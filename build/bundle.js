(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/**
 * "Agent" is the central component of a payment channel. An agent has all the
 * information about one of the sides of a payment channel.  To use the Agent
 * class:
 *
 * let Agent = require('yours-channels').Agent
 */
var lib = {};
lib.Agent = require('./lib/agent.js');
lib.Channel = require('./lib/channel.js');
lib.Consts = require('./lib/consts.js');
lib.Output = require('./lib/output.js');
lib.Wallet = require('./lib/wallet.js');

module.exports = lib;

},{"./lib/agent.js":4,"./lib/channel.js":5,"./lib/consts.js":6,"./lib/output.js":10,"./lib/wallet.js":18}],2:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Struct = require('yours-bitcoin/lib/struct');
var asink = require('asink');

var Address = require('yours-bitcoin/lib/address');
var KeyPair = require('yours-bitcoin/lib/key-pair');

var KeyPairAddress = function (_Struct) {
  _inherits(KeyPairAddress, _Struct);

  function KeyPairAddress(privKey, keyPair, address) {
    _classCallCheck(this, KeyPairAddress);

    var _this = _possibleConstructorReturn(this, (KeyPairAddress.__proto__ || Object.getPrototypeOf(KeyPairAddress)).call(this));

    _this.fromObject({ privKey: privKey, keyPair: keyPair, address: address });
    return _this;
  }

  _createClass(KeyPairAddress, [{
    key: 'asyncInitialize',
    value: function asyncInitialize(privKey) {
      return asink(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(!privKey || privKey.constructor.name !== 'PrivKey')) {
                  _context.next = 2;
                  break;
                }

                throw new Error('this.privKey must be set before multisigAddress can be initialized');

              case 2:
                _context.next = 4;
                return KeyPair.asyncFromPrivKey(privKey);

              case 4:
                this.keyPair = _context.sent;
                _context.next = 7;
                return Address.asyncFromPubKey(this.keyPair.pubKey);

              case 7:
                this.address = _context.sent;


                this.initialized = true;

              case 9:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      this.keyPair = json.keyPair ? KeyPair.fromJSON(json.keyPair) : undefined;
      this.address = json.address ? Address.fromJSON(json.address) : undefined;
      this.initialized = json.initialized;
      return this;
    }
  }, {
    key: 'toPublic',
    value: function toPublic() {
      var keyPairAddress = new KeyPairAddress();
      keyPairAddress.keyPair = this.keyPair ? this.keyPair.toPublic() : undefined;
      keyPairAddress.address = this.address;
      keyPairAddress.initialized = this.initialized;
      return keyPairAddress;
    }
  }]);

  return KeyPairAddress;
}(Struct);

module.exports = KeyPairAddress;

},{"asink":19,"yours-bitcoin/lib/address":324,"yours-bitcoin/lib/key-pair":334,"yours-bitcoin/lib/struct":342}],3:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Struct = require('yours-bitcoin/lib/struct');
var asink = require('asink');
var Script = require('yours-bitcoin/lib/script');
var PrivKey = require('yours-bitcoin/lib/priv-key');
var PubKey = require('yours-bitcoin/lib/pub-key');
var Address = require('yours-bitcoin/lib/address');
var KeyPair = require('yours-bitcoin/lib/key-pair');

var Multisig = function (_Struct) {
  _inherits(Multisig, _Struct);

  function Multisig(privKey, pubKey, otherPubKey, pubKeys, script, address, keyPair, initialized) {
    _classCallCheck(this, Multisig);

    var _this = _possibleConstructorReturn(this, (Multisig.__proto__ || Object.getPrototypeOf(Multisig)).call(this));

    _this.fromObject({ privKey: privKey,
      pubKey: pubKey,
      otherPubKey: otherPubKey,
      pubKeys: pubKeys,
      script: script,
      address: address,
      keyPair: keyPair,
      initialized: initialized
    });
    return _this;
  }

  _createClass(Multisig, [{
    key: 'initializePrivKey',
    value: function initializePrivKey(privKey) {
      return asink(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.privKey = privKey;
                _context.next = 3;
                return PubKey.asyncFromPrivKey(privKey);

              case 3:
                this.pubKey = _context.sent;

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }
  }, {
    key: 'asyncInitialize',
    value: function asyncInitialize(otherPubKey) {
      return asink(regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(!this.privKey || this.privKey.constructor.name !== 'PrivKey')) {
                  _context2.next = 2;
                  break;
                }

                throw new Error('this.privKey must be set before multisigAddress can be initialized');

              case 2:
                if (!(!otherPubKey || otherPubKey.constructor.name !== 'PubKey')) {
                  _context2.next = 4;
                  break;
                }

                throw new Error('otherPubKey required to build a multisigAddress');

              case 4:
                this.otherPubKey = otherPubKey;
                _context2.next = 7;
                return PubKey.asyncFromPrivKey(this.privKey);

              case 7:
                this.pubKey = _context2.sent;


                this.pubKeys = [this.pubKey, this.otherPubKey];
                this.script = Script.fromPubKeys(2, this.pubKeys);
                _context2.next = 12;
                return Address.asyncFromRedeemScript(this.script);

              case 12:
                this.address = _context2.sent;
                _context2.next = 15;
                return KeyPair.asyncFromPrivKey(this.privKey);

              case 15:
                this.keyPair = _context2.sent;


                this.initialized = true;

              case 17:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }), this);
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      var _this2 = this;

      this.privKey = json.privKey ? PrivKey.fromHex(json.privKey) : undefined;
      this.pubKey = json.pubKey ? PubKey.fromFastHex(json.pubKey) : undefined;
      this.otherPubKey = json.otherPubKey ? PubKey.fromFastHex(json.otherPubKey) : undefined;
      this.script = json.script ? Script.fromHex(json.script) : undefined;
      this.address = json.address ? Address.fromJSON(json.address) : undefined;
      this.keyPair = json.keyPair ? KeyPair.fromJSON(json.keyPair) : undefined;
      this.initialized = json.initialized;
      if (json.pubKeys) {
        (function () {
          var pubKeys = [];
          json.pubKeys.forEach(function (pubKey) {
            pubKeys.push(PubKey.fromFastHex(pubKey));
          });
          _this2.pubKeys = pubKeys;
        })();
      }
      return this;
    }
  }, {
    key: 'toPublic',
    value: function toPublic() {
      var multisigAddress = new Multisig().fromObject(this);
      multisigAddress.privKey = undefined;
      multisigAddress.keyPair = this.keyPair ? this.keyPair.toPublic() : undefined;
      return multisigAddress;
    }
  }]);

  return Multisig;
}(Struct);

module.exports = Multisig;

},{"asink":19,"yours-bitcoin/lib/address":324,"yours-bitcoin/lib/key-pair":334,"yours-bitcoin/lib/priv-key":337,"yours-bitcoin/lib/pub-key":338,"yours-bitcoin/lib/script":340,"yours-bitcoin/lib/struct":342}],4:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var babel = require('babel-polyfill');
var Struct = require('yours-bitcoin/lib/struct');
var asink = require('asink');
var Bn = require('yours-bitcoin/lib/bn');
var Multisig = require('./addrs/multisig');
var KeyPairAddress = require('./addrs/key-pair-address');
var HtlcSecret = require('./scrts/htlc-secret');
var RevSecret = require('./scrts/rev-secret');
var Funding = require('./txs/funding');
var Commitment = require('./txs/commitment');
var Wallet = require('./wallet');

var Agent = function (_Struct) {
  _inherits(Agent, _Struct);

  function Agent(id, sourceAddress, // the address that the funding transaction is funded from
  multisigAddress, // the shared multisigAddress address
  destinationAddress, // the address that the spending transactions spend to
  funding, // an object storing information about the funding tx
  commitments, // a list of objects storing information about previous commitment txs
  wallet, // the wallet (dummy for now)
  initialized, // boolean, set to true once local initialization is complete
  funder, // boolean, set to true if agent funds the channel
  sender, // boolean, set to true if agent has sent the last payment
  other, // public information about the other agent and all commitment txs that he stores
  remoteAgent // used temporarily to communicate with the other agent (will go away once we integrate msgs)
  ) {
    _classCallCheck(this, Agent);

    var _this = _possibleConstructorReturn(this, (Agent.__proto__ || Object.getPrototypeOf(Agent)).call(this));

    _this.fromObject({ id: id,
      sourceAddress: sourceAddress,
      multisigAddress: multisigAddress,
      destinationAddress: destinationAddress,
      funding: funding,
      commitments: commitments,
      wallet: wallet,
      initialized: initialized,
      funder: funder,
      sender: sender,
      other: other,
      remoteAgent: remoteAgent
    });
    return _this;
  }

  /* ---- INITIALIZATION ---- */

  /*
   * Initializes an agent locally. In particular, the sourceAddress address, the multisigAddress
   * address, the destinationAddress address are initialized. The list of commitment txouts
   * is initialized with secrets for the next payment.
   */


  _createClass(Agent, [{
    key: 'asyncInitialize',
    value: function asyncInitialize(sourcePrivKey, multisigPrivKey, destinationPrivKey) {
      return asink(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(!sourcePrivKey || !multisigPrivKey || !destinationPrivKey || sourcePrivKey.constructor.name !== 'PrivKey' || multisigPrivKey.constructor.name !== 'PrivKey' || destinationPrivKey.constructor.name !== 'PrivKey')) {
                  _context.next = 2;
                  break;
                }

                throw new Error('sourcePrivKey, multisigPrivKey, destinationPrivKey must be PrivKeys and are required in asyncInitialize');

              case 2:

                // the address that's the input to the sourceAddress trasnaction
                this.sourceAddress = new KeyPairAddress();
                _context.next = 5;
                return this.sourceAddress.asyncInitialize(sourcePrivKey);

              case 5:

                // the shared multisigAddress address
                this.multisigAddress = new Multisig();
                _context.next = 8;
                return this.multisigAddress.initializePrivKey(multisigPrivKey);

              case 8:

                // the address that's the output to a commitment trasnaction
                this.destinationAddress = new KeyPairAddress();
                _context.next = 11;
                return this.destinationAddress.asyncInitialize(destinationPrivKey);

              case 11:

                // initialize first commitment
                this.commitments = [];
                // yield this.asyncInitializeCommitment()

                // the wallet
                this.wallet = new Wallet();

                this.initialized = true;

              case 14:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }

    /* ---- PROTOCOL ---- */

    /*
     * This is the first point of communication between the two agents. Arguments are
     * the amount to fund the channel with and the public projection of the other agent.
     * Stores the public information about the other agent and initializes the multisigAddress
     * address. The funder of the channel will build the funding transaction and send
     * it's hash to the other party.
     */

  }, {
    key: 'asyncOpenChannel',
    value: function asyncOpenChannel(amount, publicOther) {
      return asink(regeneratorRuntime.mark(function _callee2() {
        var fee, output;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // initialize information about other agent
                this.other = publicOther;

                // initialize multisigAddress
                _context2.next = 3;
                return this.multisigAddress.asyncInitialize(this.other.multisigAddress.pubKey);

              case 3:
                if (this.funder) {
                  _context2.next = 13;
                  break;
                }

                _context2.t0 = this.remoteAgent;
                _context2.t1 = amount;
                _context2.next = 8;
                return this.asyncToPublic();

              case 8:
                _context2.t2 = _context2.sent;
                _context2.next = 11;
                return _context2.t0.asyncOpenChannel.call(_context2.t0, _context2.t1, _context2.t2);

              case 11:
                _context2.next = 22;
                break;

              case 13:
                // the funder will build the sourceAddress transaction and cache it's hashbuf and txout
                fee = Bn(20000);
                output = this.wallet.getUnspentOutput(amount.add(fee), this.sourceAddress.keyPair.pubKey);


                this.funding = new Funding();
                this.funding.asyncInitialize(amount, this.sourceAddress, this.multisigAddress, output.txhashbuf, output.txoutnum, output.txout, output.pubKey);

                // send the sourceAddress tx hash to the other agent
                _context2.t3 = this.remoteAgent;
                _context2.next = 20;
                return this.funding.asyncToPublic();

              case 20:
                _context2.t4 = _context2.sent;

                _context2.t3.setFunding.call(_context2.t3, _context2.t4);

              case 22:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }), this);
    }
  }, {
    key: 'asyncSendOutputs',
    value: function asyncSendOutputs(outputs, changeOutput) {
      return asink(regeneratorRuntime.mark(function _callee3() {
        var _this2 = this;

        var commitment;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(!this.multisigAddress || !this.funding)) {
                  _context3.next = 2;
                  break;
                }

                throw new Error('Agent not sufficiently initialized in asyncSendOutputs');

              case 2:

                // create new commitment and add all info that is not realted to builder vs owner
                commitment = new Commitment();

                commitment.revSecret = new RevSecret();
                _context3.next = 6;
                return commitment.revSecret.asyncInitialize();

              case 6:
                commitment.multisigAddress = this.multisigAddress;
                commitment.funding = this.funding;
                commitment.outputs = outputs.map(function (output) {
                  return _this2.completeOutput(output, commitment.revSecret);
                });
                commitment.changeOutput = this.completeOutput(changeOutput, commitment.revSecret);
                this.commitments.push(commitment);
                this.other.commitments.push(commitment);

                if (this.sender) {
                  _context3.next = 17;
                  break;
                }

                _context3.next = 15;
                return this.remoteAgent.asyncSendOutputs(outputs, changeOutput);

              case 15:
                _context3.next = 19;
                break;

              case 17:
                _context3.next = 19;
                return this.remoteAgent.asyncBuildCommitment();

              case 19:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }), this);
    }
  }, {
    key: 'asyncBuildCommitment',
    value: function asyncBuildCommitment() {
      return asink(regeneratorRuntime.mark(function _callee4() {
        var otherCommitment;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                otherCommitment = this.other.commitments.pop();

                otherCommitment.builderId = this.id;
                otherCommitment.builderDestinationAddress = this.destinationAddress;
                otherCommitment.ownerId = this.other.id;
                otherCommitment.ownerDestinationAddress = this.other.destinationAddress;
                _context4.next = 7;
                return otherCommitment.asyncBuild();

              case 7:
                this.other.commitments.push(otherCommitment);

                if (this.sender) {
                  _context4.next = 13;
                  break;
                }

                _context4.next = 11;
                return this.remoteAgent.asyncBuildCommitment();

              case 11:
                _context4.next = 15;
                break;

              case 13:
                _context4.next = 15;
                return this.remoteAgent.sendCommitment(otherCommitment);

              case 15:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }), this);
    }
  }, {
    key: 'sendCommitment',
    value: function sendCommitment(newCommitment) {
      return asink(regeneratorRuntime.mark(function _callee5() {
        var storedCommitment, otherCommitment, revSecret;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                storedCommitment = this.commitments[this.commitments.length - 1];

                if (!this.checkCommitment(storedCommitment, newCommitment)) {
                  _context5.next = 6;
                  break;
                }

                _context5.next = 4;
                return newCommitment.txb.asyncSign(0, this.multisigAddress.keyPair, this.funding.txb.tx.txOuts[0]);

              case 4:

                this.commitments.pop();
                this.commitments.push(newCommitment);

              case 6:
                if (this.sender) {
                  _context5.next = 12;
                  break;
                }

                otherCommitment = this.other.commitments[this.other.commitments.length - 1];
                _context5.next = 10;
                return this.remoteAgent.sendCommitment(otherCommitment);

              case 10:
                _context5.next = 16;
                break;

              case 12:
                revSecret = this.getRevSecret();

                if (!revSecret) {
                  _context5.next = 16;
                  break;
                }

                _context5.next = 16;
                return this.remoteAgent.sendRevSecret(revSecret);

              case 16:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }), this);
    }
  }, {
    key: 'sendRevSecret',
    value: function sendRevSecret(revSecret) {
      return asink(regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }), this);
    }

    /* ---- SETTERS ---- */

  }, {
    key: 'setFunding',
    value: function setFunding(txo) {
      this.funding = txo;
    }
  }, {
    key: 'setCommitment',
    value: function setCommitment(txo) {
      this.commitments[this.commitments.length - 1] = txo;
    }
  }, {
    key: 'setOtherCommitment',
    value: function setOtherCommitment(txo) {
      this.other.commitments[this.other.commitments.length - 1] = txo;
    }

    /* ---- GETTERS ---- */

  }, {
    key: 'getRevSecret',
    value: function getRevSecret() {
      // if there is a transaction to revoke, return it's rev secret
      if (this.commitments.length > 1) {
        return this.commitments[this.commitments.length - 2].revSecret;
      } else {
        return false;
      }
    }

    /* ---- HELPERS ---- */

  }, {
    key: 'completeOutput',
    value: function completeOutput(output, revSecret) {
      if (output.intermediateDestId === this.id) {
        output.revSecret = revSecret;
      }
      return output;
    }
  }, {
    key: 'checkCommitment',
    value: function checkCommitment(storedCommitment, newCommitment) {
      // TODO
      return true;
    }

    // We have to delete other and remoteAgent and restore after constructing json.
    // Ideallt we'd call super.toJSON after that, but that's not possible due to
    // some stupid error (TODO)

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var other = this.other;
      var remoteAgent = this.remoteAgent;
      var that = this;
      that.other = undefined;
      that.remoteAgent = undefined;
      var json = {};
      for (var val in this) {
        if (this[val] instanceof Array) {
          var arr = [];
          for (var i in this[val]) {
            arr.push(this[val][i].toJSON());
          }
          json[val] = arr;
        } else if (_typeof(this[val]) === 'object') {
          json[val] = this[val].toJSON();
        } else if (typeof this[val] !== 'undefined') {
          json[val] = this[val];
        }
      }
      this.other = other;
      this.remoteAgent = remoteAgent;
      return json;
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      var _this3 = this;

      this.name = json.name;
      this.sourceAddress = json.sourceAddress ? new KeyPairAddress().fromJSON(json.sourceAddress) : undefined;
      this.multisigAddress = json.multisigAddress ? new Multisig().fromJSON(json.multisigAddress) : undefined;
      this.destinationAddress = json.destinationAddress ? new KeyPairAddress().fromJSON(json.destinationAddress) : undefined;
      this.htlcSecret = json.htlcSecret ? new HtlcSecret().fromJSON(json.htlcSecret) : undefined;
      this.nextRevSecret = json.nextRevSecret ? new RevSecret().fromJSON(json.nextRevSecret) : undefined;
      this.funder = json.funder;
      this.wallet = json.wallet ? new Wallet().fromJSON(json.wallet) : undefined;
      this.initialized = json.initialized;
      this.sender = json.sender;
      this.funding = json.funding ? new Funding().fromJSON(json.funding) : undefined;
      if (json.commitments) {
        (function () {
          var commitments = [];
          json.commitments.forEach(function (tx) {
            commitments.push(new Commitment().fromJSON(tx));
          });
          _this3.commitments = commitments;
        })();
      }
      return this;
    }
  }, {
    key: 'asyncToPublic',
    value: function asyncToPublic() {
      return asink(regeneratorRuntime.mark(function _callee7() {
        var _this4 = this;

        var agent;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                agent = new Agent();

                agent.id = this.id;
                agent.sourceAddress = this.sourceAddress ? this.sourceAddress.toPublic() : undefined;
                agent.multisigAddress = this.multisigAddress ? this.multisigAddress.toPublic() : undefined;
                agent.destinationAddress = this.destinationAddress ? this.destinationAddress.toPublic() : undefined;

                if (!this.funding) {
                  _context7.next = 11;
                  break;
                }

                _context7.next = 8;
                return this.funding.asyncToPublic();

              case 8:
                _context7.t0 = _context7.sent;
                _context7.next = 12;
                break;

              case 11:
                _context7.t0 = undefined;

              case 12:
                agent.funding = _context7.t0;

                if (this.commitments) {
                  (function () {
                    var commitments = [];
                    _this4.commitments.forEach(function (txo) {
                      commitments.push(txo.toPublic());
                    });
                    agent.commitments = commitments;
                  })();
                }
                agent.wallet = this.wallet ? this.wallet.toPublic() : undefined;
                agent.initialized = this.initialized;
                agent.funder = this.funder;
                agent.sender = this.sender;
                return _context7.abrupt('return', agent);

              case 19:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }), this);
    }
  }]);

  return Agent;
}(Struct);

module.exports = Agent;
/**

Protocols
---------

We now describe the protocol that the parties use to construct the transactions
shown above.

### Local initialization (asyncInitialize)

**1. Local initialization .** Both agents initialize the following
- their local addresses (source, destination)
- a htlc and revocation secret to be used in the first payment
- the shared multisig object is initialized, but the address has not been
  generated yet.

### Opening the channel (asyncOpenChannel)

As there are inherent malleability problems if two parties fund a payment
channel. To avoid this problem we use a version where only Alice funds the
channel.

**1. Alice and Bob exchange their public projections (initializeOther).** This
allows them to build a shared multisig address and to know the public versions
of the other agents htlc and revocation secret. After this step the following
is initialized

**2. Alice and Bob build the shared multisig (asyncInitializeMultisig).** Now
that they have exchanged public keys for the multisig address, they can both
build it.

**3. The funder (Alice) builds a funding transaction.** The agent that funds
the channel creates the funding transaction that spends to the shared multisig
address. She does not broadcast it yet. She then sends the funding amount and
funding transaction hash to Bob.

**4. Bob builds and signs a refund transaction, sends it to Alice.** Alice and
Bob go through the protocol described below for creating a payment, in the case
where Bob sends a payment to Alice. The payment spends all funds from the
funding transaction to Alice.

**5. Alice broadcasts the funding transaction.** When the refund transaction is
created and distributed between the two parties, Alice broadcasts the funding
transaction. The channel is open when the funding transaction is confirmed into
the blockchain.

At the end of the channel opening process, both agents store the following
information:

- three addresses (source, destination, multisig)
- a list of commitment transactions objects. The list has one entry that
  contains the secrets used for the first payment
- the public information about the other client; this also contains a list of
  commitment transaction objects with one entry containing the public
  projections (hahes) of two secrets.

### Creating the payment (asyncSend)

We describe a payment from Alice to Bob. Note that if this is not the first
payment, Alice has the hash of Bob's last revocation secret, and the hash of
Bob's last HTLC secret. If this is the first payment, revoking isn't necessary
and these secrets are not needed.

**1. Alice builds a commitment transaction for Bob, stores it, and asks him to
do the same (asyncSend).** Alice builds the transaction labeled "known only to
Bob" above. She then asks Bob to build one for her.<!--She uses the public
versions of the secrets obtained from Bob in step 2 and her own secrets
generated in Step 1. She signs the transaction and sends it to Bob.-->

**2. Bob builds a commitment transaction for Alice, stores it, and sends it to
Alice (asyncSend).**

**3. Alice checks the new commitment transaction, stores it, and sends the
transaction built in step 1 to Bob (asyncSendTxb).**

**4. Bob checks the new commitment transaction, stores it, and revokes the old
commitment transaction (asyncSendTxb).**

**5. Alice checks the revocation secret, stores it, generates new secrets, and
revokes the old commitment transaction (asyncPrepareNextPayment).**

**6. Bob checks the revocation secret, stores it, generates new secrets for the
next payment.**

<!--
**4. Alice checks the transaction, builds one for Alice and sends it to her.**
Bob checks that the transaction spends from the shared multisig address, spends
to his destination address, that the secrets used are the ones he generated in
Step 2, and that the spending amounts are as expected. If the test passes, he
builds the transaction labelled "known only to Alice" and sends it to her (this
is symmetric to case 3.).

**5. Alice checks the transaction obtained from Bob, and revokes her last
payment if the check passes.** To revoke the previous payment, Alice sends her
revocation secret from the last commitment transaction to Bob.

**6. Bob revokes.** Symmetrically, Bob sends Alice his revocation secret from
the last commitment transaction.

**1. Alice generates new secrets and sends them to Bob.** She locally creates a
revocation secret and a htlc secret for use on the next transaction. She then
sends the public versions (hashes) of these secrets to Bob.

**2. Bob generates a new secrets and sends them to Alice.** This is symmetric
to the case above
-->
### Closing the channel

Either party can broadcast their most recent commitment transaction to the
blockchain. In this case both parties go through the following protocol

**1. Find the most recent HTLC secret.**

**2. Build a spending transaction.**

**3. Broadcast spending transaction and the most recent commitment
transaction.**

The party that broadcasts the commitment transaction must wait for a day to do
that, the other party can do so as soon as possible.

### Enforcing the HTLC

In case one party fails to spend an output by providing the HTLC secret, the
other party can spend the HTLC output after 2 days.

**1. Build spending transaction using spending key.**

**3. Broadcast spending transaction and the most recent commitment
transaction.**

### React to other agent broadcasting an old commitment transaction

In that case one party broadcasts an old commitment transaction,
the other party goes trough the following:

**1. Find the corresponding HTLC secret.**

**2. Create an output script that spends the HTLC output.**

**3. Find the corresponding revocation secret.**

**4. Create an output script that spends the revocation output.**

**5. Build a transaction that spends both outputs.**

This has to happen within one day, in order to make sure that the revocation
output can be spent.

**/

},{"./addrs/key-pair-address":2,"./addrs/multisig":3,"./scrts/htlc-secret":11,"./scrts/rev-secret":12,"./txs/commitment":14,"./txs/funding":15,"./wallet":18,"asink":19,"babel-polyfill":20,"yours-bitcoin/lib/bn":327,"yours-bitcoin/lib/struct":342}],5:[function(require,module,exports){
// TODO: All channel properties need to be saved in a database, not in memory,
// so that the state is consistent across tabs and can be synced across
// devices.
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Struct = require('yours-bitcoin/lib/struct');
var MsgUpdate = require('./msgs/msg-update');
var Secret = require('./scrts/secret');
var Random = require('yours-bitcoin/lib/random');
var Script = require('yours-bitcoin/lib/script');
var Address = require('yours-bitcoin/lib/address');
var KeyPair = require('yours-bitcoin/lib/key-pair');
var Bn = require('yours-bitcoin/lib/bn');
var Output = require('../lib/output');
var Spending = require('../lib/txs/spending.js');
var Commitment = require('../lib/txs/commitment');
var TxOut = require('yours-bitcoin/lib/tx-out');
var MsgSecrets = require('./msgs/msg-secrets');
var asink = require('asink');

var Channel = function (_Struct) {
  _inherits(Channel, _Struct);

  function Channel(fundingAmount, myXPrv, theirXPub, chanPath, myChanXPrv, theirChanXPub, myId, theirId) {
    var state = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Channel.STATE_INITIAL;
    var multiSigScript = arguments[9];
    var multiSigAddr = arguments[10];
    var id = arguments[11];
    var secretMap = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : new Map();
    var funder = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : false;
    var fundingTx = arguments[14];
    var fundingTxHash = arguments[15];
    var funded = arguments.length > 16 && arguments[16] !== undefined ? arguments[16] : false;
    var myCommitments = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : [];
    var theirCommitments = arguments.length > 18 && arguments[18] !== undefined ? arguments[18] : [];
    var errStr = arguments.length > 19 && arguments[19] !== undefined ? arguments[19] : '';

    _classCallCheck(this, Channel);

    return _possibleConstructorReturn(this, (Channel.__proto__ || Object.getPrototypeOf(Channel)).call(this, {
      fundingAmount: fundingAmount,
      myXPrv: myXPrv,
      theirXPub: theirXPub,
      chanPath: chanPath,
      myChanXPrv: myChanXPrv,
      theirChanXPub: theirChanXPub,
      myId: myId,
      theirId: theirId,
      state: state,
      multiSigScript: multiSigScript,
      multiSigAddr: multiSigAddr,
      id: id,
      secretMap: secretMap,
      funder: funder,
      fundingTx: fundingTx,
      fundingTxHash: fundingTxHash,
      funded: funded,
      myCommitments: myCommitments,
      theirCommitments: theirCommitments,
      errStr: errStr
    }));
  }

  /**
   * Initializes the channel by deriving the channel keys and id's and by
   * building and storing the multisig address
   */


  _createClass(Channel, [{
    key: 'asyncInitialize',
    value: function asyncInitialize() {
      return asink(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.chanPath) {
                  this.randomChanPath();
                }
                _context.next = 3;
                return this.myXPrv.asyncDerive(this.chanPath);

              case 3:
                this.myChanXPrv = _context.sent;
                _context.next = 6;
                return this.theirXPub.asyncDerive(this.chanPath);

              case 6:
                this.theirChanXPub = _context.sent;
                _context.next = 9;
                return this.myXPrv.toPublic().asyncToString();

              case 9:
                this.myId = _context.sent;
                _context.next = 12;
                return this.theirXPub.asyncToString();

              case 12:
                this.theirId = _context.sent;
                return _context.abrupt('return', this.asyncBuildMultiSigAddr());

              case 14:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }

    /**
     * Returns a random number between 0 and 0x7fffffff
     */

  }, {
    key: 'randomChanPath',


    /**
     * Initializes the channel path to a random one
     */
    value: function randomChanPath() {
      this.chanPath = Channel.randomChanPath();
      return this;
    }

    /**
     * Builds the multisig address from the agents public keys
     */

  }, {
    key: 'asyncBuildMultiSigAddr',
    value: function asyncBuildMultiSigAddr() {
      return asink(regeneratorRuntime.mark(function _callee2() {
        var pubKey1, pubKey2, script;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                pubKey1 = this.myChanXPrv.pubKey;
                pubKey2 = this.theirChanXPub.pubKey;
                script = Script.fromPubKeys(2, [pubKey1, pubKey2]);

                this.multiSigScript = script;
                _context2.next = 6;
                return Address.asyncFromRedeemScript(this.multiSigScript);

              case 6:
                this.multiSigAddr = _context2.sent;
                _context2.next = 9;
                return this.multiSigAddr.asyncToString();

              case 9:
                this.id = _context2.sent;
                return _context2.abrupt('return', this);

              case 11:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }), this);
    }

    /**
     * Returns the channel id, which is the multisig address
     */

  }, {
    key: 'asyncGetId',
    value: function asyncGetId() {
      return this.multiSigAddr.asyncToString();
    }

    /**
     * Generates a new secret and stores it in this.secretMap
     */

  }, {
    key: 'asyncNewSecret',
    value: function asyncNewSecret() {
      return asink(regeneratorRuntime.mark(function _callee3() {
        var secret;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                secret = new Secret();
                _context3.next = 3;
                return secret.asyncInitialize();

              case 3:
                this.secretMap.set(secret.hash.toString('hex'), secret.buf);
                return _context3.abrupt('return', secret);

              case 5:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }), this);
    }

    /**
     * Returns the pre-image of a stored secret
     */

  }, {
    key: 'getSecret',
    value: function getSecret(hash) {
      return this.secretMap.get(hash.toString('hex'));
    }

    /**
     * Opens a channel. Sets the funding tx and returns the "update" message
     * for the refund tx.
     */

  }, {
    key: 'asyncOpen',
    value: function asyncOpen(fundingTx) {
      var channelSourceIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Channel.randomIndex();
      var channelDestIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Channel.randomIndex();

      return asink(regeneratorRuntime.mark(function _callee4() {
        var revSecret, output, outputs;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.funder = true;
                this.fundingTx = fundingTx; // TODO: Validate that funding tx spends to multisig
                _context4.next = 4;
                return fundingTx.asyncHash();

              case 4:
                this.fundingTxHash = _context4.sent;
                _context4.next = 7;
                return this.asyncNewSecret();

              case 7:
                revSecret = _context4.sent;
                output = new Output().fromObject({
                  kind: 'pubKey',
                  networkSourceId: this.theirId,
                  channelSourceId: this.theirId,
                  channelDestId: this.myId,
                  networkDestId: this.myId,
                  channelSourcePath: 'm/0/' + channelSourceIndex,
                  channelDestPath: 'm/0/' + channelDestIndex,
                  // htlcSecret, // Not used in refund tx
                  revSecret: revSecret.toPublic()
                  // amount // Left undefined because this is the change output
                });
                outputs = [output];
                return _context4.abrupt('return', this.asyncUpdate(outputs));

              case 11:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }), this);
    }

    /**
     * When the funding transaction is confirmed on the blockchain, call this
     * method.
     */

  }, {
    key: 'asyncConfirmFundingTx',
    value: function asyncConfirmFundingTx(fundingTx) {
      return asink(regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.fundingTx = fundingTx;
                _context5.next = 3;
                return fundingTx.asyncHash();

              case 3:
                this.fundingTxHash = _context5.sent;

                this.funded = true;

              case 5:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }), this);
    }

    /**
     * Returns a new commitment transaction for a given output description list
     */

  }, {
    key: 'asyncBuildCommitment',
    value: function asyncBuildCommitment(outputs, fundingTxHash, fundingTxOut) {
      return asink(regeneratorRuntime.mark(function _callee6() {
        var _xPubs;

        var commitment, xPubs, keyPair;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                commitment = new Commitment();

                commitment.outputs = outputs;
                xPubs = (_xPubs = {}, _defineProperty(_xPubs, this.myId, this.myChanXPrv.toPublic()), _defineProperty(_xPubs, this.theirId, this.theirChanXPub), _xPubs);
                keyPair = new KeyPair(this.myChanXPrv.privKey, this.myChanXPrv.pubKey);
                // TODO: can this be a default parameter?

                if (!(fundingTxHash === undefined)) {
                  _context6.next = 8;
                  break;
                }

                _context6.next = 7;
                return this.fundingTx.asyncHash();

              case 7:
                fundingTxHash = _context6.sent;

              case 8:
                fundingTxOut = fundingTxOut || this.fundingTx.txOuts[0];

                return _context6.abrupt('return', commitment.asyncBuild(fundingTxHash, fundingTxOut, { script: this.multiSigScript, keyPair: keyPair }, this.myId, xPubs));

              case 10:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }), this);
    }
  }, {
    key: 'asyncBuildSpending',
    value: function asyncBuildSpending(address, commitment, commitmentTxDepth) {
      return asink(regeneratorRuntime.mark(function _callee7() {
        var spending;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                spending = new Spending();
                _context7.next = 3;
                return spending.asyncBuild(address, commitment, this.myChanXPrv, this.myId, commitmentTxDepth, this.secretMap);

              case 3:
                return _context7.abrupt('return', spending);

              case 4:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }), this);
    }

    /**
     * Convenience method to add an additional output to the output description list
     * Returns a message of type "update" with an commitment tx for the list.
     * HtlcSecret is optional.
     */

  }, {
    key: 'asyncPay',
    value: function asyncPay(amount, htlcSecret) {
      var pathIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Channel.randomIndex();

      return asink(regeneratorRuntime.mark(function _callee8() {
        var outputs, revSecret, output;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                outputs = this.myCommitments[this.myCommitments.length - 1].outputs;

                outputs = outputs.map(function (output) {
                  return output.clone();
                });
                // TODO: Validate that last output spends to me and is change, i.e.
                // TODO: check sufficient balance
                _context8.next = 4;
                return this.asyncNewSecret();

              case 4:
                revSecret = _context8.sent;
                output = new Output().fromObject({
                  kind: htlcSecret ? 'htlc' : 'pubKey',
                  networkSourceId: this.myId,
                  channelSourceId: this.myId,
                  channelDestId: this.theirId,
                  networkDestId: this.theirId,
                  channelSourcePath: 'm/0/' + pathIndex,
                  channelDestPath: 'm/0/' + pathIndex,
                  htlcSecret: htlcSecret ? htlcSecret.toPublic() : undefined,
                  revSecret: revSecret.toPublic(),
                  amount: amount
                });
                _context8.next = 8;
                return this.asyncAddOutput(output, outputs);

              case 8:
                outputs = _context8.sent;

                outputs = this.reduceOutputs(outputs);
                return _context8.abrupt('return', this.asyncUpdate(outputs));

              case 11:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }), this);
    }

    /**
     * Add output description to outputlist immediately before the change output
     */

  }, {
    key: 'asyncAddOutput',
    value: function asyncAddOutput(output, outputs) {
      outputs = outputs.map(function (output) {
        return output.clone();
      });
      var change = outputs.pop();
      outputs.push(output);
      outputs.push(change);
      return outputs;
    }

    /**
     * Merges outputs whenever possible
     */

  }, {
    key: 'reduceOutputs',
    value: function reduceOutputs(outputs) {
      return outputs;
      // TODO: call asyncReduceHtlcOutput and reducePubKeyOutputs here
    }

    /*
     * Preliminary version of reducePubKeyOutputs, returns an array where the last
     * element is a change output (with an amount)
     * TODO: skip htlc outputs
     */

  }, {
    key: 'reducePubKeyOutputs',
    value: function reducePubKeyOutputs(outputs) {
      // outputs will be grouped together if they have the same key def below
      // outputs in the same group will be merged further down below
      // not exactly sure when exactly two outputs can be merged, we'll have to adapt this
      var grouped = {};
      outputs.forEach(function (output) {
        var key = output.kind + ':' + output.channelSourceId + ':' + output.channelDestId;
        if (key in grouped === false) {
          grouped[key] = [];
        }
        grouped[key].push(output);
      });

      var amounts = void 0,
          output = void 0;
      var reduced = [];
      for (var key in grouped) {
        // sum up the amounts for each group
        amounts = grouped[key].map(function (el) {
          return el.amount ? el.amount : 'bottom';
        });
        output = grouped[key][0];
        output.amount = amounts.reduce(function (acc, cur) {
          return acc !== 'bottom' && cur !== 'bottom' ? acc.add(cur) : 'bottom';
        }, Bn(0));
        reduced.push(output);
      }

      // sort reduced so that the last output is the change output
      reduced.sort(function (a, b) {
        // conceptualy we consider "bottom" to be the bigger than all values in Bn.
        // this way the change output will always be last
        if (a.amount === 'bottom' && b.amount !== 'bottom') {
          return 1;
        } else if (a.amount !== 'bottom' && b.amount === 'bottom') {
          return -1;
        } else {
          return 0;
        }
      });

      // delete "amount: 'bottom'" from the last output
      delete reduced[reduced.length - 1].amount;
      return reduced;
    }

    /*
     * Preliminary version of asyncReduceHtlcOutput. Changes the kind of an htlc
     * output to pubKey if it corresponds to the given htlcSecret.
     * TODO: either call reducePubKeyOutputs at the end or make sure that it is
     * always called after asyncReduceHtlcOutput (eg in reduceOutputs)
     */

  }, {
    key: 'asyncReduceHtlcOutput',
    value: function asyncReduceHtlcOutput(outputs, htlcSecret) {
      return asink(regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return htlcSecret.asyncSuperCheck();

              case 2:
                if (!_context9.sent) {
                  _context9.next = 4;
                  break;
                }

                return _context9.abrupt('return', outputs.map(function (output) {
                  if (output.kind === 'htlc' && output.htlcSecret.buf === htlcSecret.buf) {
                    output.kind = 'pubKey';
                  }
                  return output;
                }));

              case 4:
              case 'end':
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }), this);
    }

    /**
     * Generates a new "update" message for a given output description list.
     * This method is used to activate the protocol for a new payment.
     * TODO: check that channel is funded.
     */

  }, {
    key: 'asyncUpdate',
    value: function asyncUpdate(outputs) {
      return asink(regeneratorRuntime.mark(function _callee10() {
        var commitment, msg;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (!(this.state !== Channel.STATE_INITIAL)) {
                  _context10.next = 2;
                  break;
                }

                throw new Error('Cannot update during ' + this.state + ' state');

              case 2:
                _context10.next = 4;
                return this.asyncBuildCommitment(outputs);

              case 4:
                commitment = _context10.sent;

                this.theirCommitments.push(commitment);

                msg = new MsgUpdate().setChanId(this.id).setChanPath(this.chanPath).setCommitment(commitment).setFundingAmount(this.fundingAmount);

                this.state = Channel.STATE_BUILT;
                return _context10.abrupt('return', msg);

              case 9:
              case 'end':
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }), this);
    }

    /**
     * Called when a new message of type "update" is received. Signs the tx in the
     * message, stores it in myCommitments. Then builds a commitment tx for the
     * other agent, packs it into a message of type "update" and returns this message
     */

  }, {
    key: 'asyncHandleMsgUpdate',
    value: function asyncHandleMsgUpdate(msgUpdate) {
      return asink(regeneratorRuntime.mark(function _callee11() {
        var myCommitment, keyPair, script, txOut, outputs, fundingTxOut, theirCommitment, msg;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(this.state === Channel.STATE_INITIAL)) {
                  _context11.next = 20;
                  break;
                }

                // TODO: Check validity
                this.state = Channel.STATE_BUILT_AND_STORED;
                myCommitment = msgUpdate.getCommitment();
                keyPair = new KeyPair(this.myChanXPrv.privKey, this.myChanXPrv.pubKey);
                script = this.multiSigAddr.toScript();
                txOut = TxOut.fromProperties(this.fundingAmount, script);
                _context11.next = 8;
                return myCommitment.txb.asyncSign(0, keyPair, txOut);

              case 8:
                this.myCommitments.push(myCommitment);

                outputs = myCommitment.outputs.map(function (output) {
                  return Output.fromJSON(output.toJSON());
                });

                this.fundingTxHash = myCommitment.txb.tx.txIns[0].txHashBuf;
                fundingTxOut = TxOut.fromProperties(this.fundingAmount, this.multiSigAddr.toScript());
                _context11.next = 14;
                return this.asyncBuildCommitment(outputs, this.fundingTxHash, fundingTxOut);

              case 14:
                theirCommitment = _context11.sent;

                this.theirCommitments.push(theirCommitment);

                msg = new MsgUpdate().setChanId(this.id).setChanPath(this.chanPath).setCommitment(theirCommitment).setFundingAmount(this.fundingAmount);
                return _context11.abrupt('return', msg);

              case 20:
                if (!(this.state === Channel.STATE_BUILT)) {
                  _context11.next = 26;
                  break;
                }

                // TODO: Check validity
                this.state = Channel.STATE_STORED;
                this.myCommitments.push(msgUpdate.getCommitment());
                return _context11.abrupt('return', this.asyncGetMsgSecrets());

              case 26:
                return _context11.abrupt('return', this.asyncError('Cannot receive msgUpdate in ' + this.state + ' state'));

              case 27:
              case 'end':
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }), this);
    }

    /**
     * Generates a new message of type "secret" containing the revocation secret
     */

  }, {
    key: 'asyncGetMsgSecrets',
    value: function asyncGetMsgSecrets() {
      return asink(regeneratorRuntime.mark(function _callee12() {
        var msg, commitment, outputs, revSecrets, index, secret, buf;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                // Suppose you have 10 commitment txs.
                // You don't want to revoke the 10th one, but you want to revoke the 9th one.
                // Get revocation hash from 9th commitment tx output description list.
                msg = new MsgSecrets().setChanId(this.id).setChanPath(this.chanPath);

                if (this.myCommitments.length > 1) {
                  commitment = this.myCommitments[this.myCommitments.length - 2];
                  outputs = commitment.outputs;
                  revSecrets = [];

                  for (index in outputs) {
                    secret = outputs[index].revSecret;
                    buf = this.getSecret(secret.hash);

                    if (buf) {
                      secret.buf = buf;
                    }
                    revSecrets.push(secret);
                  }
                  msg.setSecrets(revSecrets);
                }
                return _context12.abrupt('return', msg);

              case 3:
              case 'end':
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }), this);
    }

    /**
     * Called when a new message of type "secret" is received
     */

  }, {
    key: 'asyncHandleMsgSecrets',
    value: function asyncHandleMsgSecrets(msgSecrets) {
      var _this2 = this;

      if (this.state === Channel.STATE_BUILT_AND_STORED) {
        var _ret = function () {
          // TODO: Check validity
          _this2.state = Channel.STATE_INITIAL;
          var secrets = msgSecrets.getSecrets();
          if (_this2.myCommitments.length > 1) {
            // set secrets on commitment
            var commitment = _this2.myCommitments[_this2.myCommitments.length - 2];
            commitment.outputs = commitment.outputs.map(function (output, index) {
              output.revSecret.buf = output.revSecret.buf || secrets[index].buf;
              return output;
            });
          }
          return {
            v: _this2.asyncGetMsgSecrets()
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      } else if (this.state === Channel.STATE_STORED) {
        // TODO: Check validity
        this.state = Channel.STATE_INITIAL;
        return null;
      } else {
        return this.asyncError('Cannot receive msgSecret in ' + this.state + ' state');
      }
    }
  }, {
    key: 'asyncError',
    value: function asyncError(errStr) {
      this.state = Channel.STATE_ERROR;
      this.errStr = errStr;
      // TODO: What now? Close channel?
    }
  }], [{
    key: 'randomIndex',
    value: function randomIndex() {
      // non-hardened bip 32 path indices can be any 31 bit integer. (the 32nd
      // bit is used to specify the hardening, which is not used here).
      return Random.getRandomBuffer(4).readInt32BE(0) & 0x7fffffff;
    }

    /**
     * Return a random channel path
     */

  }, {
    key: 'randomChanPath',
    value: function randomChanPath() {
      var x = Channel.randomIndex();
      var y = Channel.randomIndex();
      return 'm/' + x + '/' + y;
    }
  }]);

  return Channel;
}(Struct);

Channel.STATE_INITIAL = 'initial';
Channel.STATE_ERROR = 'error';
Channel.STATE_BUILT_AND_STORED = 'built-and-stored';
Channel.STATE_BUILT = 'built';
Channel.STATE_STORED = 'stored';
Channel.STATE_CLOSED = 'closed';

module.exports = Channel;

},{"../lib/output":10,"../lib/txs/commitment":14,"../lib/txs/spending.js":16,"./msgs/msg-secrets":7,"./msgs/msg-update":8,"./scrts/secret":13,"asink":19,"yours-bitcoin/lib/address":324,"yours-bitcoin/lib/bn":327,"yours-bitcoin/lib/key-pair":334,"yours-bitcoin/lib/random":339,"yours-bitcoin/lib/script":340,"yours-bitcoin/lib/struct":342,"yours-bitcoin/lib/tx-out":346}],6:[function(require,module,exports){
'use strict';

var Bn = require('yours-bitcoin/lib/bn');

// see here for explanation: http://stackoverflow.com/questions/8595509/how-do-you-share-constants-in-nodejs-modules
function define(name, value) {
  Object.defineProperty(exports, name, {
    value: value,
    enumerable: true
  });
}

define('CSV_DELAY', Bn(100));

},{"yours-bitcoin/lib/bn":327}],7:[function(require,module,exports){
/**
 * MsgSecrets
 * ==========
 *
 * When an agent needs to reveal the secret for a particular hash. This works
 * either for an HTLC secret or a revocation secret.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Secret = require('../scrts/secret');
var Msg = require('./msg');

var MsgSecrets = function (_Msg) {
  _inherits(MsgSecrets, _Msg);

  function MsgSecrets() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { secrets: [] };
    var chanId = arguments[1];

    _classCallCheck(this, MsgSecrets);

    var cmd = 'secret';
    return _possibleConstructorReturn(this, (MsgSecrets.__proto__ || Object.getPrototypeOf(MsgSecrets)).call(this, cmd, args, chanId));
  }

  _createClass(MsgSecrets, [{
    key: 'setSecrets',
    value: function setSecrets(secrets) {
      this.args.secrets = secrets.map(function (secret) {
        return secret.toJSON();
      });
    }
  }, {
    key: 'getSecrets',
    value: function getSecrets() {
      return this.args.secrets.map(function (secret) {
        return new Secret().fromJSON(secret);
      });
    }
  }]);

  return MsgSecrets;
}(Msg);

module.exports = MsgSecrets;

},{"../scrts/secret":13,"./msg":9}],8:[function(require,module,exports){
/**
 * MsgUpdate
 * =========
 *
 * Message to update the commitment transaction. When an agent wishes to make a
 * payment or to update the commitment transaction for any other reason, such
 * as reducing the output list or changing the fee amount, they send an
 * 'update' message.  When an agent sends an update message with a new
 * commitment tx, they expect the other party to also send an update message
 * with a new commitment tx. Then both parties should revoke any old outputs.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Msg = require('./msg');
var Commitment = require('../../lib/txs/commitment');
var Bn = require('yours-bitcoin/lib/bn');

var MsgUpdate = function (_Msg) {
  _inherits(MsgUpdate, _Msg);

  function MsgUpdate(args, chanId) {
    _classCallCheck(this, MsgUpdate);

    var cmd = 'update';
    return _possibleConstructorReturn(this, (MsgUpdate.__proto__ || Object.getPrototypeOf(MsgUpdate)).call(this, cmd, args, chanId));
  }

  _createClass(MsgUpdate, [{
    key: 'setCommitment',
    value: function setCommitment(commitment) {
      this.args.commitment = commitment.toPublic().toJSON();
      return this;
    }
  }, {
    key: 'getCommitment',
    value: function getCommitment() {
      return Commitment.fromJSON(this.args.commitment);
    }
  }, {
    key: 'setFundingAmount',
    value: function setFundingAmount(fundingAmount) {
      this.args.fundingAmount = fundingAmount.toString();
      return this;
    }
  }, {
    key: 'getFundingAmount',
    value: function getFundingAmount() {
      return Bn(this.args.fundingAmount);
    }
  }]);

  return MsgUpdate;
}(Msg);

module.exports = MsgUpdate;

},{"../../lib/txs/commitment":14,"./msg":9,"yours-bitcoin/lib/bn":327}],9:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Protocol Message
 * ================
 *
 * - cmd: A short string specifying the command name, like 'open-channel'
 * - args: A json stringifiable object
 * - chanId: The id of the channel, which is the string form of the multiSig
 * address for the funding transaction of this channel.
 * - convId: The id of the conversation - often, a long series of messages need
 * to be exchanged in a particular order. Each sequence needs to share the same
 * 'conversation id' or 'convId'.
 */
var Struct = require('yours-bitcoin/lib/struct');
var Random = require('yours-bitcoin/lib/random');

var Msg = function (_Struct) {
  _inherits(Msg, _Struct);

  function Msg(cmd) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var chanId = arguments[2];
    var convId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Random.getRandomBuffer(16).toString('hex');
    var chanPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'm';

    _classCallCheck(this, Msg);

    var _this = _possibleConstructorReturn(this, (Msg.__proto__ || Object.getPrototypeOf(Msg)).call(this));

    _this.fromObject({
      cmd: cmd,
      args: args,
      chanId: chanId,
      convId: convId,
      chanPath: chanPath
    });
    return _this;
  }

  _createClass(Msg, [{
    key: 'setChanId',
    value: function setChanId(chanId) {
      this.chanId = chanId;
      return this;
    }
  }, {
    key: 'getChanId',
    value: function getChanId() {
      return this.chanId;
    }
  }, {
    key: 'setChanPath',
    value: function setChanPath(chanPath) {
      this.chanPath = chanPath;
      return this;
    }
  }, {
    key: 'getChanPath',
    value: function getChanPath() {
      return this.chanPath;
    }
  }, {
    key: 'setConvId',
    value: function setConvId(convId) {
      this.convId = convId;
      return this;
    }
  }, {
    key: 'getConvId',
    value: function getConvId() {
      return this.convId;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        cmd: this.cmd,
        args: this.args,
        chainId: this.chanId
      };
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      this.cmd = json.cmd;
      this.args = json.args;
      this.chainId = json.chanId;
      return this;
    }
  }, {
    key: 'isValid',
    value: function isValid() {
      // TODO: Check validity of chanPath
      if (typeof this.cmd !== 'string' || this.cmd.length > 30 || this.cmd.length < 1) {
        return false;
      }
      if (_typeof(this.args) !== 'object') {
        // this.args CAN be an array
        return false;
      }
      if (typeof this.chanId !== 'string' || !(this.chanId.startsWith('3') || // mainnet
      this.chanId.startsWith('2') // testnet
      )) {
        return false;
      }
      if (typeof this.convId !== 'string') {
        return false;
      }
      return true;
    }
  }]);

  return Msg;
}(Struct);

module.exports = Msg;

},{"yours-bitcoin/lib/random":339,"yours-bitcoin/lib/struct":342}],10:[function(require,module,exports){
// just a dummy at this point
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Struct = require('yours-bitcoin/lib/struct');
var Bn = require('yours-bitcoin/lib/bn');
var Script = require('yours-bitcoin/lib/script');
var HtlcSecret = require('./scrts/htlc-secret');
var RevSecret = require('./scrts/rev-secret');

var Output = function (_Struct) {
  _inherits(Output, _Struct);

  function Output(kind, networkSourceId, channelSourceId, channelDestId, networkDestId, channelSourcePath, channelDestPath, htlcSecret, revSecret, amount, revocable, redeemScript, scriptPubkey) {
    _classCallCheck(this, Output);

    var _this = _possibleConstructorReturn(this, (Output.__proto__ || Object.getPrototypeOf(Output)).call(this));

    _this.fromObject({
      kind: kind,
      networkSourceId: networkSourceId,
      channelSourceId: channelSourceId,
      channelDestId: channelDestId,
      networkDestId: networkDestId,
      channelSourcePath: channelSourcePath,
      channelDestPath: channelDestPath,
      htlcSecret: htlcSecret,
      revSecret: revSecret,
      amount: amount,
      revocable: revocable,
      redeemScript: redeemScript,
      scriptPubkey: scriptPubkey
    });
    return _this;
  }

  _createClass(Output, [{
    key: 'fromJSON',
    value: function fromJSON(json) {
      this.channelSourcePath = json.channelSourcePath;
      this.channelDestPath = json.channelDestPath;
      this.networkSourceId = json.networkSourceId;
      this.channelSourceId = json.channelSourceId;
      this.channelDestId = json.channelDestId;
      this.networkDestId = json.networkDestId;
      this.kind = json.kind;
      this.htlcSecret = json.htlcSecret ? new HtlcSecret().fromJSON(json.htlcSecret) : undefined;
      this.revSecret = json.revSecret ? new RevSecret().fromJSON(json.revSecret) : undefined;
      this.amount = json.amount ? new Bn().fromJSON(json.amount) : undefined;
      this.revocable = json.revocable;
      this.redeemScript = json.redeemScript ? Script.fromJSON(json.redeemScript) : undefined;
      this.scriptPubkey = json.scriptPubkey ? Script.fromJSON(json.scriptPubkey) : undefined;
      return this;
    }
  }, {
    key: 'toPublic',
    value: function toPublic() {
      var outputDesc = new Output();
      outputDesc.channelSourcePath = this.channelSourcePath;
      outputDesc.channelDestPath = this.channelDestPath;
      outputDesc.networkSourceId = this.networkSourceId;
      outputDesc.channelSourceId = this.channelSourceId;
      outputDesc.channelDestId = this.channelDestId;
      outputDesc.networkDestId = this.networkDestId;
      outputDesc.kind = this.kind;
      outputDesc.htlcSecret = this.htlcSecret ? this.htlcSecret.toPublic() : undefined;
      outputDesc.revSecret = this.revSecret ? this.revSecret.toPublic() : undefined;
      outputDesc.amount = this.amount;
      outputDesc.revocable = this.revocable;
      outputDesc.redeemScript = this.redeemScript ? this.redeemScript.toJSON() : undefined;
      outputDesc.scriptPubkey = this.scriptPubkey ? this.scriptPubkey.toJSON() : undefined;
      return outputDesc;
    }
  }]);

  return Output;
}(Struct);

module.exports = Output;

},{"./scrts/htlc-secret":11,"./scrts/rev-secret":12,"yours-bitcoin/lib/bn":327,"yours-bitcoin/lib/script":340,"yours-bitcoin/lib/struct":342}],11:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Secret = require('./secret');
var asink = require('asink');

var HtlcSecret = function (_Secret) {
  _inherits(HtlcSecret, _Secret);

  function HtlcSecret() {
    _classCallCheck(this, HtlcSecret);

    var _this = _possibleConstructorReturn(this, (HtlcSecret.__proto__ || Object.getPrototypeOf(HtlcSecret)).call(this));

    _this.fromObject({});
    return _this;
  }

  _createClass(HtlcSecret, [{
    key: 'asyncCheck',
    value: function asyncCheck(otherSecret) {
      return asink(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.asyncSuperCheck();

              case 2:
                return _context.abrupt('return', _context.sent);

              case 3:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }
  }, {
    key: 'toPublic',
    value: function toPublic() {
      var secret = new HtlcSecret();
      secret.hash = this.hash;
      return secret;
    }
  }]);

  return HtlcSecret;
}(Secret);

module.exports = HtlcSecret;

},{"./secret":13,"asink":19}],12:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Secret = require('./secret');
var asink = require('asink');

var RevocationSecret = function (_Secret) {
  _inherits(RevocationSecret, _Secret);

  function RevocationSecret() {
    _classCallCheck(this, RevocationSecret);

    var _this = _possibleConstructorReturn(this, (RevocationSecret.__proto__ || Object.getPrototypeOf(RevocationSecret)).call(this));

    _this.fromObject({});
    return _this;
  }

  _createClass(RevocationSecret, [{
    key: 'asyncCheck',
    value: function asyncCheck(otherSecret) {
      return asink(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!otherSecret) {
                  _context.next = 3;
                  break;
                }

                if (!(!otherSecret.hash || otherSecret.hash.toString('hex') !== this.hash.toString('hex'))) {
                  _context.next = 3;
                  break;
                }

                throw new Error('Provided secret does not match local secret');

              case 3:
                _context.next = 5;
                return this.asyncSuperCheck();

              case 5:
                return _context.abrupt('return', _context.sent);

              case 6:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }
  }, {
    key: 'toPublic',
    value: function toPublic() {
      var secret = new RevocationSecret();
      secret.hash = this.hash;
      return secret;
    }
  }]);

  return RevocationSecret;
}(Secret);

module.exports = RevocationSecret;

},{"./secret":13,"asink":19}],13:[function(require,module,exports){
(function (Buffer){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Struct = require('yours-bitcoin/lib/struct');
var asink = require('asink');
var Hash = require('yours-bitcoin/lib/hash');
var Random = require('yours-bitcoin/lib/random');

var Secret = function (_Struct) {
  _inherits(Secret, _Struct);

  function Secret(buf, hash) {
    _classCallCheck(this, Secret);

    var _this = _possibleConstructorReturn(this, (Secret.__proto__ || Object.getPrototypeOf(Secret)).call(this));

    _this.fromObject({ buf: buf, hash: hash });
    return _this;
  }

  _createClass(Secret, [{
    key: 'asyncInitialize',
    value: function asyncInitialize() {
      return asink(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.generateBuf();
                _context.next = 3;
                return this.asyncGenerateHash();

              case 3:
                return _context.abrupt('return', this);

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }
  }, {
    key: 'generateBuf',
    value: function generateBuf() {
      this.buf = Random.getRandomBuffer(32);
    }
  }, {
    key: 'asyncGenerateHash',
    value: function asyncGenerateHash() {
      return asink(regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.buf) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt('return', new Error('buffer must be generated before hash can be'));

              case 2:
                _context2.next = 4;
                return Hash.asyncSha256Ripemd160(this.buf);

              case 4:
                this.hash = _context2.sent;

              case 5:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }), this);
    }
  }, {
    key: 'asyncSuperCheck',
    value: function asyncSuperCheck() {
      return asink(regeneratorRuntime.mark(function _callee3() {
        var hashedBuf;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.buf) {
                  _context3.next = 2;
                  break;
                }

                throw new Error('secret.buf is not set');

              case 2:
                if (this.hash) {
                  _context3.next = 4;
                  break;
                }

                throw new Error('secret.hash is not set');

              case 4:
                _context3.next = 6;
                return Hash.asyncSha256Ripemd160(this.buf);

              case 6:
                hashedBuf = _context3.sent;
                return _context3.abrupt('return', hashedBuf.equals(this.hash));

              case 8:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }), this);
    }

    /*
     * returns a new secret with the buffer toPublic
     */

  }, {
    key: 'toPublic',
    value: function toPublic() {
      var secret = new Secret().fromObject(this);
      secret.buf = undefined;
      return secret;
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var json = {};
      json.buf = this.buf ? this.buf.toString('hex') : undefined;
      json.hash = this.hash ? this.hash.toString('hex') : undefined;
      return json;
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      this.buf = json.buf ? new Buffer(json.buf, 'hex') : undefined;
      this.hash = json.hash ? new Buffer(json.hash, 'hex') : undefined;
      return this;
    }
  }]);

  return Secret;
}(Struct);

module.exports = Secret;

}).call(this,require("buffer").Buffer)

},{"asink":19,"buffer":23,"yours-bitcoin/lib/hash":333,"yours-bitcoin/lib/random":339,"yours-bitcoin/lib/struct":342}],14:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var asink = require('asink');
var Tx = require('./tx');
var Output = require('../output');
var TxBuilder = require('yours-bitcoin/lib/tx-builder');
var Script = require('yours-bitcoin/lib/script');
var OpCode = require('yours-bitcoin/lib/op-code');
var Address = require('yours-bitcoin/lib/address');
var Bn = require('yours-bitcoin/lib/bn');
var Consts = require('../consts.js');

var Commitment = function (_Tx) {
  _inherits(Commitment, _Tx);

  function Commitment(outputs, txb) {
    _classCallCheck(this, Commitment);

    return _possibleConstructorReturn(this, (Commitment.__proto__ || Object.getPrototypeOf(Commitment)).call(this, { outputs: outputs, txb: txb }));
  }

  _createClass(Commitment, [{
    key: 'asyncBuild',
    value: function asyncBuild(fundingTxHash, fundingTxOut, multisigAddress, builderId, xPubs) {
      return asink(regeneratorRuntime.mark(function _callee() {
        var i;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.outputs) {
                  _context.next = 2;
                  break;
                }

                throw new Error('Commitment not sufficiently initialized');

              case 2:

                this.txb = new TxBuilder();
                this.txb.inputFromScriptHashMultiSig(fundingTxHash, 0, fundingTxOut, multisigAddress.script);
                for (i = 0; i < this.outputs.length; i++) {
                  // build output scripts
                  this.outputs[i].revocable = this.outputs[i].channelDestId !== builderId;
                  this.outputs[i].redeemScript = this.buildRedeemScript(this.outputs[i], builderId, xPubs);
                  this.outputs[i].scriptPubkey = Address.fromRedeemScript(this.outputs[i].redeemScript).toScript();

                  if (i < this.outputs.length - 1) {
                    this.txb.outputToScript(this.outputs[i].amount, this.outputs[i].scriptPubkey);
                  } else {
                    this.txb.setChangeScript(this.outputs[i].scriptPubkey);
                  }
                }

                this.txb.build();
                _context.next = 8;
                return this.txb.asyncSign(0, multisigAddress.keyPair, fundingTxOut);

              case 8:
                return _context.abrupt('return', this);

              case 9:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }
  }, {
    key: 'buildRedeemScript',
    value: function buildRedeemScript(outputObject, builderId, xPubs) {
      if (outputObject.kind === undefined) {
        throw new Error('Insufficient arguments for buildRedeemScript');
      }

      var sourcePath = outputObject.channelSourcePath;
      var sourceBip = xPubs[outputObject.channelSourceId];
      var sourcePubKey = sourceBip.derive(sourcePath).pubKey; // TODO: asyncDerive

      var destPath = outputObject.channelDestPath;
      var destBip = xPubs[outputObject.channelDestId];
      var destPubKey = destBip.derive(destPath).pubKey; // TODO: asyncDerive

      if (outputObject.kind === 'pubKey' && outputObject.channelDestId === builderId) {
        // build an spend to pubkey script
        return this.pubKeyRedeemScript(destPubKey);
      } else if (outputObject.kind === 'pubKey' && outputObject.channelDestId !== builderId) {
        // build a revocable spend to pubkey script
        return this.revPubKeyRedeemScript(destPubKey, sourcePubKey, outputObject);
      } else if (outputObject.kind === 'htlc' && outputObject.channelDestId === builderId) {
        // build an HTLC script
        return this.htlcRedeemScript(destPubKey, sourcePubKey, outputObject);
      }if (outputObject.kind === 'htlc' && outputObject.channelDestId !== builderId) {
        // build a revocable HTLC sctipt
        return this.revHtlcRedeemScript(destPubKey, sourcePubKey, outputObject);
      } else {
        throw new Error('invalid kind in Commitment.asyncBuild');
      }
    }
  }, {
    key: 'pubKeyRedeemScript',
    value: function pubKeyRedeemScript(destPubKey) {
      // output to channel dest
      return new Script().writeBuffer(destPubKey.toBuffer()).writeOpCode(OpCode.OP_CHECKSIG);
    }

    // all checks but the last should be ...VERIFY

  }, {
    key: 'revPubKeyRedeemScript',
    value: function revPubKeyRedeemScript(destPubKey, sourcePubKey, outputObject) {
      return new Script().writeOpCode(OpCode.OP_IF)
      // output to channel dest
      // encumbered by a CSV_DELAY CSV time lock
      // time lock is needed to allow channel source to spend via branch 2
      // should the tx be revoked
      .writeBuffer(destPubKey.toBuffer()).writeOpCode(OpCode.OP_CHECKSIG).writeBn(outputObject.csvDelay || Consts.CSV_DELAY).writeOpCode(OpCode.OP_CHECKSEQUENCEVERIFY).writeOpCode(OpCode.OP_DROP).writeOpCode(OpCode.OP_ELSE)
      // output to channel source
      // sourcePubKey & owner's revocation secret needed to spend
      // this branch is used if a revoked commitment tx has been broadcast
      .writeBuffer(sourcePubKey.toBuffer()).writeOpCode(OpCode.OP_CHECKSIGVERIFY).writeOpCode(OpCode.OP_HASH160).writeBuffer(outputObject.revSecret.hash).writeOpCode(OpCode.OP_EQUAL).writeOpCode(OpCode.OP_ENDIF);
    }
  }, {
    key: 'htlcRedeemScript',
    value: function htlcRedeemScript(destPubKey, sourcePubKey, outputObject) {
      var script = new Script().writeOpCode(OpCode.OP_IF)
      // output to channel dest
      // channel dest's sig & and network dest's HTLC secret needed to spend
      // this branch can be spent if chanel dest has the htlc secret
      .writeBuffer(destPubKey.toBuffer()) // push the agent's pubKey
      .writeOpCode(OpCode.OP_CHECKSIGVERIFY) // check sig against redeem script
      .writeOpCode(OpCode.OP_HASH160) // hash htlc secret from redeem script
      .writeBuffer(outputObject.htlcSecret.hash) // push htlc secret hash of the htlc secret
      .writeOpCode(OpCode.OP_EQUAL) // check equality
      .writeOpCode(OpCode.OP_ELSE)
      // output to channel source
      // channel source's sig needed to spend, subject to SVC lock
      // this branch can be spent if channel dest does not reveil the htlc secret in time
      .writeBuffer(sourcePubKey.toBuffer()).writeOpCode(OpCode.OP_CHECKSIG).writeBn(outputObject.csvDelay || Consts.CSV_DELAY).writeOpCode(OpCode.OP_CHECKSEQUENCEVERIFY).writeOpCode(OpCode.OP_DROP).writeOpCode(OpCode.OP_ENDIF);
      return script;
    }
  }, {
    key: 'revHtlcRedeemScript',
    value: function revHtlcRedeemScript(destPubKey, sourcePubKey, outputObject) {
      var longDelay = outputObject.csvDelay || Consts.CSV_DELAY;
      var shortDelay = longDelay.div(Bn(2));
      return new Script().writeOpCode(OpCode.OP_IF)
      // output to channel dest
      // channel dest's sig & and network dest's HTLC secret needed to spend
      // this branch can be spent if chanel dest has the htlc secret
      // corresponds to the first branch of the htlc script
      // must be encumbered by a time lock to allow channel source to spend if tx was revoked
      .writeBuffer(destPubKey.toBuffer()) // check pubkey
      .writeOpCode(OpCode.OP_CHECKSIGVERIFY).writeOpCode(OpCode.OP_HASH160) // check htlc secret
      .writeBuffer(outputObject.htlcSecret.hash).writeOpCode(OpCode.OP_EQUALVERIFY).writeBn(shortDelay) // check time lock
      .writeOpCode(OpCode.OP_CHECKSEQUENCEVERIFY).writeOpCode(OpCode.OP_ELSE).writeOpCode(OpCode.OP_IF)
      // output to channel source
      // channel source's sig needed to spend, subject to SVC lock
      // this branch can be spent if channel dest does not reveil the htlc secret in time
      // corresponds to second branch of htlc script
      .writeBuffer(sourcePubKey.toBuffer()).writeOpCode(OpCode.OP_CHECKSIG).writeBn(longDelay).writeOpCode(OpCode.OP_CHECKSEQUENCEVERIFY).writeOpCode(OpCode.OP_DROP).writeOpCode(OpCode.OP_ELSE)
      // output to channel source
      // sourcePubKey & owner's revocation secret needed to spend
      // this branch is used if a revoked commitment tx has been broadcast
      // this corresponds to second branch of rev pubKey script
      .writeBuffer(sourcePubKey.toBuffer()).writeOpCode(OpCode.OP_CHECKSIGVERIFY).writeOpCode(OpCode.OP_HASH160).writeBuffer(outputObject.revSecret.hash).writeOpCode(OpCode.OP_EQUAL).writeOpCode(OpCode.OP_ENDIF).writeOpCode(OpCode.OP_ENDIF);
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      if (json.outputs) {
        this.outputs = [];
        for (var i in json.outputs) {
          this.outputs.push(new Output().fromJSON(json.outputs[i]));
        }
      }
      this.txb = json.txb ? new TxBuilder().fromJSON(json.txb) : undefined;
      return this;
    }
  }, {
    key: 'toPublic',
    value: function toPublic() {
      var commitment = new Commitment().fromObject();
      if (this.outputs) {
        commitment.outputs = [];
        for (var i in this.outputs) {
          commitment.outputs.push(this.outputs[i].toPublic());
        }
      }
      commitment.txb = this.txb;
      return commitment;
    }
  }]);

  return Commitment;
}(Tx);

module.exports = Commitment;

},{"../consts.js":6,"../output":10,"./tx":17,"asink":19,"yours-bitcoin/lib/address":324,"yours-bitcoin/lib/bn":327,"yours-bitcoin/lib/op-code":335,"yours-bitcoin/lib/script":340,"yours-bitcoin/lib/tx-builder":343}],15:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var asink = require('asink');
var TxBuilder = require('yours-bitcoin/lib/tx-builder');
var Tx = require('./tx');

var Funding = function (_Tx) {
  _inherits(Funding, _Tx);

  function Funding() {
    _classCallCheck(this, Funding);

    var _this = _possibleConstructorReturn(this, (Funding.__proto__ || Object.getPrototypeOf(Funding)).call(this));

    _this.fromObject({});
    return _this;
  }

  _createClass(Funding, [{
    key: 'asyncInitialize',
    value: function asyncInitialize(amount, sourceAddress, multisigAddress, inputTxHashbuf, inputTxoutnum, inputTxout, pubKey) {
      return asink(regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(!amount || !sourceAddress || !multisigAddress || !inputTxHashbuf || typeof inputTxoutnum !== 'number' || !inputTxout || !pubKey)) {
                  _context.next = 2;
                  break;
                }

                throw new Error('Insufficient arguments for Funding.asyncInitialize');

              case 2:

                this.amount = amount;
                this.txb = new TxBuilder();
                this.txb.inputFromPubKeyHash(inputTxHashbuf, inputTxoutnum, inputTxout, pubKey);
                this.txb.setChangeAddress(sourceAddress.address);
                this.txb.outputToAddress(amount, multisigAddress.address);
                this.txb.build();
                this.txb.sign(0, sourceAddress.keyPair, inputTxout);

              case 9:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      this.fromObject({
        amount: json.amount,
        txb: new TxBuilder().fromJSON(json.txb)
      });
      return this;
    }
  }, {
    key: 'asyncToPublic',
    value: function asyncToPublic() {
      return asink(regeneratorRuntime.mark(function _callee2() {
        var funding, hash;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                funding = new Funding();
                _context2.next = 3;
                return this.txb.tx.asyncHash();

              case 3:
                hash = _context2.sent;

                funding.amount = this.amount;
                funding.txb = new TxBuilder();
                funding.txb.tx.txOuts = this.txb.tx.txOuts;
                funding.txb.tx.hash = function () {
                  return hash;
                };
                return _context2.abrupt('return', funding);

              case 9:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }), this);
    }
  }]);

  return Funding;
}(Tx);

module.exports = Funding;

},{"./tx":17,"asink":19,"yours-bitcoin/lib/tx-builder":343}],16:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var asink = require('asink');
var Tx = require('./tx');
var TxBuilder = require('yours-bitcoin/lib/tx-builder');
var Script = require('yours-bitcoin/lib/script');
var Sig = require('yours-bitcoin/lib/sig');
var OpCode = require('yours-bitcoin/lib/op-code');
var Hash = require('yours-bitcoin/lib/hash');
var KeyPair = require('yours-bitcoin/lib/key-pair');
var Bn = require('yours-bitcoin/lib/bn');
var Consts = require('../consts.js');

var Spending = function (_Tx) {
  _inherits(Spending, _Tx);

  function Spending(txb) {
    _classCallCheck(this, Spending);

    return _possibleConstructorReturn(this, (Spending.__proto__ || Object.getPrototypeOf(Spending)).call(this, { txb: txb }));
  }

  /*
  * Used to build destination transactions in which spend from non-standard outputs
  * like htlc or rhtlc. Conveniance function that all destination transactions call
  */


  _createClass(Spending, [{
    key: 'asyncBuild',
    value: function asyncBuild(address, commitment, xPrv, myId, commitmentTxDepth, secretMap) {
      return asink(regeneratorRuntime.mark(function _callee() {
        var i, scriptSig, nIn, _i, path, keyPair, sig;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.txb = new TxBuilder();
                this.txb.setVersion(2);

                // build input scripts form outputs
                for (i in commitment.outputs) {
                  i = parseInt(i);
                  Object.assign(commitment.outputs[i], this.buildInputScript(commitment.outputs[i], myId, commitmentTxDepth, secretMap));

                  if (commitment.outputs[i].partialScriptSig) {
                    scriptSig = this.toP2shInput(commitment.outputs[i].partialScriptSig, commitment.outputs[i].redeemScript);

                    this.txb.inputFromScript(commitment.txb.tx.hash(), i, commitment.txb.tx.txOuts[i], scriptSig, commitment.outputs[i].csvDelay || Consts.CSV_DELAY);
                  }
                }

                if (this.txb.txIns.length) {
                  _context.next = 5;
                  break;
                }

                throw new Error('no spendable outputs found');

              case 5:

                this.txb.setChangeAddress(address);
                this.txb.build(true);

                // sign the input scripts
                nIn = 0;
                _context.t0 = regeneratorRuntime.keys(commitment.outputs);

              case 9:
                if ((_context.t1 = _context.t0()).done) {
                  _context.next = 28;
                  break;
                }

                _i = _context.t1.value;

                _i = parseInt(_i);

                if (!commitment.outputs[_i].partialScriptSig) {
                  _context.next = 26;
                  break;
                }

                path = commitment.outputs[_i].channelDestPath;
                _context.t2 = KeyPair;
                _context.next = 17;
                return xPrv.asyncDerive(path);

              case 17:
                _context.t3 = _context.sent.privKey;
                _context.next = 20;
                return xPrv.asyncDerive(path);

              case 20:
                _context.t4 = _context.sent.pubKey;
                keyPair = new _context.t2(_context.t3, _context.t4);
                sig = this.txb.getSig(keyPair, Sig.SIGHASH_ALL, nIn, commitment.outputs[_i].redeemScript);

                commitment.outputs[_i].partialScriptSig.setChunkBuffer(commitment.outputs[_i].sigPos, sig.toTxFormat());
                this.txb.tx.txIns[nIn].setScript(commitment.outputs[_i].partialScriptSig);
                nIn++;

              case 26:
                _context.next = 9;
                break;

              case 28:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }
  }, {
    key: 'buildInputScript',
    value: function buildInputScript(outputObject, myId, commitmentTxDepth, secretMap) {
      if (outputObject.kind === 'pubKey' && !outputObject.revocable) {
        return this.pubKeyInputScript(outputObject, myId);
      } else if (outputObject.kind === 'pubKey' && outputObject.revocable) {
        return this.revPubKeyInputScript(outputObject, myId, commitmentTxDepth, secretMap);
      } else if (outputObject.kind === 'htlc' && !outputObject.revocable) {
        return this.htlcInputScript(outputObject, myId, commitmentTxDepth, secretMap);
      } else if (outputObject.kind === 'htlc' && outputObject.revocable) {
        return this.revHtlcInputScript(outputObject, myId, commitmentTxDepth, secretMap);
      }
    }

    /* spending from pubkey script */

  }, {
    key: 'pubKeyInputScript',
    value: function pubKeyInputScript(outputObject, myId) {
      if (myId === outputObject.channelDestId) {
        return {
          partialScriptSig: new Script().writeOpCode(OpCode.OP_TRUE), // signature will go here
          sigPos: 0
        };
      } else {
        return {};
      }
    }

    /* spending from revocable pubkey script */

  }, {
    key: 'revPubKeyInputScript',
    value: function revPubKeyInputScript(outputObject, myId, commitmentTxDepth, secretMap) {
      var csvDelay = outputObject.csvDelay || Consts.CSV_DELAY;
      if (myId === outputObject.channelDestId && parseInt(commitmentTxDepth) >= parseInt(csvDelay)) {
        return {
          partialScriptSig: new Script().writeOpCode(OpCode.OP_TRUE) // signature will go here
          .writeOpCode(OpCode.OP_TRUE),
          sigPos: 0
        };
      } else if (myId !== outputObject.channelDestId && outputObject.revSecret.buf) {
        var revSecretBuf = secretMap.get(outputObject.revSecret.hash.toString('hex'));
        return {
          partialScriptSig: new Script().writeBuffer(revSecretBuf).writeOpCode(OpCode.OP_TRUE) // signature will go here
          .writeOpCode(OpCode.OP_FALSE),
          sigPos: 1
        };
      } else {
        return {};
      }
    }

    /* spending from htlc script */

  }, {
    key: 'htlcInputScript',
    value: function htlcInputScript(outputObject, myId, commitmentTxDepth, secretMap) {
      var csvDelay = outputObject.csvDelay || Consts.CSV_DELAY;
      var htlcSecretBuf = secretMap.get(outputObject.htlcSecret.hash.toString('hex'));

      if (myId === outputObject.channelDestId && htlcSecretBuf) {
        // spends from branch 1 of htlc
        return {
          partialScriptSig: new Script().writeBuffer(htlcSecretBuf).writeOpCode(OpCode.OP_TRUE) // signature will go here
          .writeOpCode(OpCode.OP_TRUE),
          sigPos: 1
        };
      } else if (myId !== outputObject.channelDestId && parseInt(commitmentTxDepth) >= parseInt(csvDelay)) {
        // spends from branch 2 of htlc
        return {
          partialScriptSig: new Script().writeOpCode(OpCode.OP_TRUE) // signature will go here
          .writeOpCode(OpCode.OP_FALSE),
          sigPos: 0
        };
      } else {
        return {};
      }
    }
  }, {
    key: 'revHtlcInputScript',
    value: function revHtlcInputScript(outputObject, myId, commitmentTxDepth, secretMap) {
      var longDelay = outputObject.csvDelay || Consts.CSV_DELAY;
      var shortDelay = longDelay.div(Bn(2));
      var htlcSecretBuf = secretMap.get(outputObject.htlcSecret.hash.toString('hex'));
      var revSecretBuf = secretMap.get(outputObject.revSecret.hash.toString('hex'));

      if (myId === outputObject.channelDestId && htlcSecretBuf && parseInt(commitmentTxDepth) >= parseInt(shortDelay)) {
        // spends from branch 1 of rhtlc
        return {
          partialScriptSig: new Script().writeBuffer(htlcSecretBuf).writeOpCode(OpCode.OP_TRUE) // signature will go here
          .writeOpCode(OpCode.OP_TRUE),
          sigPos: 1
        };
      } else if (myId !== outputObject.channelDestId && parseInt(commitmentTxDepth) >= parseInt(longDelay)) {
        // check CSV constraint here
        // spends from branch 2 of rhtlc
        return {
          partialScriptSig: new Script().writeOpCode(OpCode.OP_TRUE) // signature will go here
          .writeOpCode(OpCode.OP_TRUE).writeOpCode(OpCode.OP_FALSE),
          sigPos: 0
        };
      } else if (myId !== outputObject.channelDestId && revSecretBuf) {
        // spends from branch 3 of rhtlc
        return {
          partialScriptSig: new Script().writeBuffer(revSecretBuf).writeOpCode(OpCode.OP_TRUE) // signature will go here
          .writeOpCode(OpCode.OP_FALSE).writeOpCode(OpCode.OP_FALSE),
          sigPos: 1
        };
      } else {
        return {};
      }
    }
  }, {
    key: 'toP2shInput',
    value: function toP2shInput(script, redeemScript) {
      if (!script || !redeemScript) {
        throw new Error('Insufficient parameters for toP2shInput');
      }
      return script.writeBuffer(redeemScript.toBuffer());
    }
  }, {
    key: 'asyncToP2shOutput',
    value: function asyncToP2shOutput(script) {
      return asink(regeneratorRuntime.mark(function _callee2() {
        var scriptHash;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (script) {
                  _context2.next = 2;
                  break;
                }

                throw new Error('Insufficient parameters for asyncToP2shOutput');

              case 2:
                _context2.next = 4;
                return Hash.asyncSha256Ripemd160(script.toBuffer());

              case 4:
                scriptHash = _context2.sent;
                return _context2.abrupt('return', new Script().writeOpCode(OpCode.OP_HASH160).writeBuffer(scriptHash).writeOpCode(OpCode.OP_EQUAL));

              case 6:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }), this);
    }
  }]);

  return Spending;
}(Tx);

module.exports = Spending;

},{"../consts.js":6,"./tx":17,"asink":19,"yours-bitcoin/lib/bn":327,"yours-bitcoin/lib/hash":333,"yours-bitcoin/lib/key-pair":334,"yours-bitcoin/lib/op-code":335,"yours-bitcoin/lib/script":340,"yours-bitcoin/lib/sig":341,"yours-bitcoin/lib/tx-builder":343}],17:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var asink = require('asink');
var Hash = require('yours-bitcoin/lib/hash');
var Struct = require('yours-bitcoin/lib/struct');
var Script = require('yours-bitcoin/lib/script');
var OpCode = require('yours-bitcoin/lib/op-code');

var Tx = function (_Struct) {
  _inherits(Tx, _Struct);

  function Tx() {
    _classCallCheck(this, Tx);

    var _this = _possibleConstructorReturn(this, (Tx.__proto__ || Object.getPrototypeOf(Tx)).call(this));

    _this.fromObject({});
    return _this;
  }

  _createClass(Tx, [{
    key: 'toP2shInput',
    value: function toP2shInput(script, redeemScript) {
      if (!script || !redeemScript) {
        throw new Error('Insufficient parameters for toP2shInput');
      }
      var newScript = Script.fromBuffer(script.toBuffer()); // copy
      newScript.writeBuffer(redeemScript.toBuffer());
      return newScript;
    }
  }, {
    key: 'asyncToP2shOutput',
    value: function asyncToP2shOutput(script) {
      return asink(regeneratorRuntime.mark(function _callee() {
        var scriptHash;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (script) {
                  _context.next = 2;
                  break;
                }

                throw new Error('Insufficient parameters for asyncToP2shOutput');

              case 2:
                _context.next = 4;
                return Hash.asyncSha256Ripemd160(script.toBuffer());

              case 4:
                scriptHash = _context.sent;
                return _context.abrupt('return', new Script().writeOpCode(OpCode.OP_HASH160).writeBuffer(scriptHash).writeOpCode(OpCode.OP_EQUAL));

              case 6:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }), this);
    }
  }]);

  return Tx;
}(Struct);

module.exports = Tx;

},{"asink":19,"yours-bitcoin/lib/hash":333,"yours-bitcoin/lib/op-code":335,"yours-bitcoin/lib/script":340,"yours-bitcoin/lib/struct":342}],18:[function(require,module,exports){
(function (Buffer){
// just a dummy at this point
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Struct = require('yours-bitcoin/lib/struct');
var Txout = require('yours-bitcoin/lib/tx-out');
var Address = require('yours-bitcoin/lib/address');

var Wallet = function (_Struct) {
  _inherits(Wallet, _Struct);

  function Wallet() {
    _classCallCheck(this, Wallet);

    var _this = _possibleConstructorReturn(this, (Wallet.__proto__ || Object.getPrototypeOf(Wallet)).call(this));

    _this.fromObject({});
    return _this;
  }

  /*
   * just a mockup at this point
   */


  _createClass(Wallet, [{
    key: 'getUnspentOutput',
    value: function getUnspentOutput(amount, pubkey) {
      // from line 444 scritp-examples
      var inputTxAddress = Address.fromPubKey(pubkey);
      var scriptPubkey = inputTxAddress.toScript();
      var inputTxHashbuf = new Buffer(32);
      inputTxHashbuf.fill(0); // a fake, non-existent input transaction
      var inputTxoutnum = 0;
      var inputTxout = new Txout(amount).setScript(scriptPubkey);

      return {
        inputTxout: new Txout(amount).setScript(inputTxAddress.toScript()),
        txhashbuf: inputTxHashbuf,
        txoutnum: inputTxoutnum,
        txout: inputTxout,
        pubKey: pubkey
      };
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      this.fromObject({});
      return this;
    }
  }, {
    key: 'toPublic',
    value: function toPublic() {
      return this;
    }
  }]);

  return Wallet;
}(Struct);

module.exports = Wallet;

}).call(this,require("buffer").Buffer)

},{"buffer":23,"yours-bitcoin/lib/address":324,"yours-bitcoin/lib/struct":342,"yours-bitcoin/lib/tx-out":346}],19:[function(require,module,exports){
/**
 * asink
 * =====
 *
 * asink is the same thing as, or a rename of, spawn. spawn in turn is a tool
 * for repeatedly calling the .thens of promises yielded by a generator.
 * Basically, this makes it possible to write asynchronous, promisified code
 * with normal try/catches that look just like synchronous code. It creates
 * shorter and easier to understand code. Hypothetically, there will be a
 * feature in the next version of javascript, ES7, called "async functions",
 * which do exactly what asink does. When/if that happens and we can access it
 * in node, we can simply remove all calls to asink and our code should behave
 * in the same way.
 *
 * See:
 * http://tc39.github.io/ecmascript-asyncawait/
 * https://github.com/tc39/ecmascript-asyncawait
 * https://gist.github.com/jakearchibald/31b89cba627924972ad6
 * http://www.html5rocks.com/en/tutorials/es6/promises/
 * https://blogs.windows.com/msedgedev/2015/09/30/asynchronous-code-gets-easier-with-es2016-async-function-support-in-chakra-and-microsoft-edge/
 */
'use strict';

function spawn(genF, self) {
  return new Promise(function (resolve, reject) {
    var gen = genF.call(self);
    function step(nextF) {
      var next;
      try {
        next = nextF();
      } catch (e) {
        // finished with failure, reject the promise
        reject(e);
        return;
      }
      if (next.done) {
        // finished with success, resolve the promise
        resolve(next.value);
        return;
      }
      // not finished, chain off the yielded promise and `step` again
      Promise.resolve(next.value).then(function (v) {
        step(function () {
          return gen.next(v);
        });
      }, function (e) {
        step(function () {
          return gen.throw(e);
        });
      });
    }
    step(function () {
      return gen.next(undefined);
    });
  });
}
module.exports = spawn;

},{}],20:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/fn/regexp/escape":24,"core-js/shim":317,"regenerator-runtime/runtime":323}],21:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],22:[function(require,module,exports){

},{}],23:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":21,"ieee754":318,"isarray":320}],24:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;
},{"../../modules/_core":45,"../../modules/core.regexp.escape":141}],25:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],26:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function(it, msg){
  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
  return +it;
};
},{"./_cof":40}],27:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};
},{"./_hide":62,"./_wks":139}],28:[function(require,module,exports){
module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};
},{}],29:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":71}],30:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object')
  , toIndex  = require('./_to-index')
  , toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
  var O     = toObject(this)
    , len   = toLength(O.length)
    , to    = toIndex(target, len)
    , from  = toIndex(start, len)
    , end   = arguments.length > 2 ? arguments[2] : undefined
    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
    , inc   = 1;
  if(from < to && to < from + count){
    inc  = -1;
    from += count - 1;
    to   += count - 1;
  }
  while(count-- > 0){
    if(from in O)O[to] = O[from];
    else delete O[to];
    to   += inc;
    from += inc;
  } return O;
};
},{"./_to-index":127,"./_to-length":130,"./_to-object":131}],31:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object')
  , toIndex  = require('./_to-index')
  , toLength = require('./_to-length');
module.exports = function fill(value /*, start = 0, end = @length */){
  var O      = toObject(this)
    , length = toLength(O.length)
    , aLen   = arguments.length
    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
    , end    = aLen > 2 ? arguments[2] : undefined
    , endPos = end === undefined ? length : toIndex(end, length);
  while(endPos > index)O[index++] = value;
  return O;
};
},{"./_to-index":127,"./_to-length":130,"./_to-object":131}],32:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":59}],33:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":127,"./_to-iobject":129,"./_to-length":130}],34:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":37,"./_ctx":47,"./_iobject":67,"./_to-length":130,"./_to-object":131}],35:[function(require,module,exports){
var aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , IObject   = require('./_iobject')
  , toLength  = require('./_to-length');

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};
},{"./_a-function":25,"./_iobject":67,"./_to-length":130,"./_to-object":131}],36:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":69,"./_is-object":71,"./_wks":139}],37:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":36}],38:[function(require,module,exports){
'use strict';
var aFunction  = require('./_a-function')
  , isObject   = require('./_is-object')
  , invoke     = require('./_invoke')
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};
},{"./_a-function":25,"./_invoke":66,"./_is-object":71}],39:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof')
  , TAG = require('./_wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./_cof":40,"./_wks":139}],40:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],41:[function(require,module,exports){
'use strict';
var dP          = require('./_object-dp').f
  , create      = require('./_object-create')
  , redefineAll = require('./_redefine-all')
  , ctx         = require('./_ctx')
  , anInstance  = require('./_an-instance')
  , defined     = require('./_defined')
  , forOf       = require('./_for-of')
  , $iterDefine = require('./_iter-define')
  , step        = require('./_iter-step')
  , setSpecies  = require('./_set-species')
  , DESCRIPTORS = require('./_descriptors')
  , fastKey     = require('./_meta').fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./_an-instance":28,"./_ctx":47,"./_defined":49,"./_descriptors":50,"./_for-of":59,"./_iter-define":75,"./_iter-step":77,"./_meta":84,"./_object-create":88,"./_object-dp":89,"./_redefine-all":108,"./_set-species":113}],42:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof')
  , from    = require('./_array-from-iterable');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};
},{"./_array-from-iterable":32,"./_classof":39}],43:[function(require,module,exports){
'use strict';
var redefineAll       = require('./_redefine-all')
  , getWeak           = require('./_meta').getWeak
  , anObject          = require('./_an-object')
  , isObject          = require('./_is-object')
  , anInstance        = require('./_an-instance')
  , forOf             = require('./_for-of')
  , createArrayMethod = require('./_array-methods')
  , $has              = require('./_has')
  , arrayFind         = createArrayMethod(5)
  , arrayFindIndex    = createArrayMethod(6)
  , id                = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(that){
  return that._l || (that._l = new UncaughtFrozenStore);
};
var UncaughtFrozenStore = function(){
  this.a = [];
};
var findUncaughtFrozen = function(store, key){
  return arrayFind(store.a, function(it){
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key){
    var entry = findUncaughtFrozen(this, key);
    if(entry)return entry[1];
  },
  has: function(key){
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value){
    var entry = findUncaughtFrozen(this, key);
    if(entry)entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function(key){
    var index = arrayFindIndex(this.a, function(it){
      return it[0] === key;
    });
    if(~index)this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var data = getWeak(anObject(key), true);
    if(data === true)uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};
},{"./_an-instance":28,"./_an-object":29,"./_array-methods":34,"./_for-of":59,"./_has":61,"./_is-object":71,"./_meta":84,"./_redefine-all":108}],44:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , $export           = require('./_export')
  , redefine          = require('./_redefine')
  , redefineAll       = require('./_redefine-all')
  , meta              = require('./_meta')
  , forOf             = require('./_for-of')
  , anInstance        = require('./_an-instance')
  , isObject          = require('./_is-object')
  , fails             = require('./_fails')
  , $iterDetect       = require('./_iter-detect')
  , setToStringTag    = require('./_set-to-string-tag')
  , inheritIfRequired = require('./_inherit-if-required');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  var fixMethod = function(KEY){
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a){
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance             = new C
      // early implementations not supports chaining
      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same
      , BUGGY_ZERO = !IS_WEAK && fails(function(){
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C()
          , index     = 5;
        while(index--)$instance[ADDER](index, index);
        return !$instance.has(-0);
      });
    if(!ACCEPT_ITERABLES){ 
      C = wrapper(function(target, iterable){
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base, target, C);
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
    // weak collections should not contains .clear method
    if(IS_WEAK && proto.clear)delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./_an-instance":28,"./_export":54,"./_fails":56,"./_for-of":59,"./_global":60,"./_inherit-if-required":65,"./_is-object":71,"./_iter-detect":76,"./_meta":84,"./_redefine":109,"./_redefine-all":108,"./_set-to-string-tag":114}],45:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],46:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp')
  , createDesc      = require('./_property-desc');

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};
},{"./_object-dp":89,"./_property-desc":107}],47:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":25}],48:[function(require,module,exports){
'use strict';
var anObject    = require('./_an-object')
  , toPrimitive = require('./_to-primitive')
  , NUMBER      = 'number';

module.exports = function(hint){
  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};
},{"./_an-object":29,"./_to-primitive":132}],49:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],50:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":56}],51:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":60,"./_is-object":71}],52:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],53:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys')
  , gOPS    = require('./_object-gops')
  , pIE     = require('./_object-pie');
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};
},{"./_object-gops":95,"./_object-keys":98,"./_object-pie":99}],54:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , hide      = require('./_hide')
  , redefine  = require('./_redefine')
  , ctx       = require('./_ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":45,"./_ctx":47,"./_global":60,"./_hide":62,"./_redefine":109}],55:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function(KEY){
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch(e){
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch(f){ /* empty */ }
  } return true;
};
},{"./_wks":139}],56:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],57:[function(require,module,exports){
'use strict';
var hide     = require('./_hide')
  , redefine = require('./_redefine')
  , fails    = require('./_fails')
  , defined  = require('./_defined')
  , wks      = require('./_wks');

module.exports = function(KEY, length, exec){
  var SYMBOL   = wks(KEY)
    , fns      = exec(defined, SYMBOL, ''[KEY])
    , strfn    = fns[0]
    , rxfn     = fns[1];
  if(fails(function(){
    var O = {};
    O[SYMBOL] = function(){ return 7; };
    return ''[KEY](O) != 7;
  })){
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function(string, arg){ return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function(string){ return rxfn.call(string, this); }
    );
  }
};
},{"./_defined":49,"./_fails":56,"./_hide":62,"./_redefine":109,"./_wks":139}],58:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function(){
  var that   = anObject(this)
    , result = '';
  if(that.global)     result += 'g';
  if(that.ignoreCase) result += 'i';
  if(that.multiline)  result += 'm';
  if(that.unicode)    result += 'u';
  if(that.sticky)     result += 'y';
  return result;
};
},{"./_an-object":29}],59:[function(require,module,exports){
var ctx         = require('./_ctx')
  , call        = require('./_iter-call')
  , isArrayIter = require('./_is-array-iter')
  , anObject    = require('./_an-object')
  , toLength    = require('./_to-length')
  , getIterFn   = require('./core.get-iterator-method')
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;
},{"./_an-object":29,"./_ctx":47,"./_is-array-iter":68,"./_iter-call":73,"./_to-length":130,"./core.get-iterator-method":140}],60:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],61:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],62:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":50,"./_object-dp":89,"./_property-desc":107}],63:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":60}],64:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":50,"./_dom-create":51,"./_fails":56}],65:[function(require,module,exports){
var isObject       = require('./_is-object')
  , setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};
},{"./_is-object":71,"./_set-proto":112}],66:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],67:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":40}],68:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./_iterators')
  , ITERATOR   = require('./_wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./_iterators":78,"./_wks":139}],69:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":40}],70:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object')
  , floor    = Math.floor;
module.exports = function isInteger(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
};
},{"./_is-object":71}],71:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],72:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object')
  , cof      = require('./_cof')
  , MATCH    = require('./_wks')('match');
module.exports = function(it){
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};
},{"./_cof":40,"./_is-object":71,"./_wks":139}],73:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./_an-object":29}],74:[function(require,module,exports){
'use strict';
var create         = require('./_object-create')
  , descriptor     = require('./_property-desc')
  , setToStringTag = require('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":62,"./_object-create":88,"./_property-desc":107,"./_set-to-string-tag":114,"./_wks":139}],75:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./_library')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , hide           = require('./_hide')
  , has            = require('./_has')
  , Iterators      = require('./_iterators')
  , $iterCreate    = require('./_iter-create')
  , setToStringTag = require('./_set-to-string-tag')
  , getPrototypeOf = require('./_object-gpo')
  , ITERATOR       = require('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":54,"./_has":61,"./_hide":62,"./_iter-create":74,"./_iterators":78,"./_library":80,"./_object-gpo":96,"./_redefine":109,"./_set-to-string-tag":114,"./_wks":139}],76:[function(require,module,exports){
var ITERATOR     = require('./_wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./_wks":139}],77:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],78:[function(require,module,exports){
module.exports = {};
},{}],79:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./_object-keys":98,"./_to-iobject":129}],80:[function(require,module,exports){
module.exports = false;
},{}],81:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;
},{}],82:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x){
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};
},{}],83:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
},{}],84:[function(require,module,exports){
var META     = require('./_uid')('meta')
  , isObject = require('./_is-object')
  , has      = require('./_has')
  , setDesc  = require('./_object-dp').f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !require('./_fails')(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
},{"./_fails":56,"./_has":61,"./_is-object":71,"./_object-dp":89,"./_uid":136}],85:[function(require,module,exports){
var Map     = require('./es6.map')
  , $export = require('./_export')
  , shared  = require('./_shared')('metadata')
  , store   = shared.store || (shared.store = new (require('./es6.weak-map')));

var getOrCreateMetadataMap = function(target, targetKey, create){
  var targetMetadata = store.get(target);
  if(!targetMetadata){
    if(!create)return undefined;
    store.set(target, targetMetadata = new Map);
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if(!keyMetadata){
    if(!create)return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map);
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function(target, targetKey){
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
    , keys        = [];
  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
  return keys;
};
var toMetaKey = function(it){
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function(O){
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};
},{"./_export":54,"./_shared":116,"./es6.map":171,"./es6.weak-map":277}],86:[function(require,module,exports){
var global    = require('./_global')
  , macrotask = require('./_task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = require('./_cof')(process) == 'process';

module.exports = function(){
  var head, last, notify;

  var flush = function(){
    var parent, fn;
    if(isNode && (parent = process.domain))parent.exit();
    while(head){
      fn   = head.fn;
      head = head.next;
      try {
        fn();
      } catch(e){
        if(head)notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if(parent)parent.enter();
  };

  // Node.js
  if(isNode){
    notify = function(){
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if(Observer){
    var toggle = true
      , node   = document.createTextNode('');
    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
    notify = function(){
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if(Promise && Promise.resolve){
    var promise = Promise.resolve();
    notify = function(){
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function(){
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function(fn){
    var task = {fn: fn, next: undefined};
    if(last)last.next = task;
    if(!head){
      head = task;
      notify();
    } last = task;
  };
};
},{"./_cof":40,"./_global":60,"./_task":126}],87:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":56,"./_iobject":67,"./_object-gops":95,"./_object-keys":98,"./_object-pie":99,"./_to-object":131}],88:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":29,"./_dom-create":51,"./_enum-bug-keys":52,"./_html":63,"./_object-dps":90,"./_shared-key":115}],89:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":29,"./_descriptors":50,"./_ie8-dom-define":64,"./_to-primitive":132}],90:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":29,"./_descriptors":50,"./_object-dp":89,"./_object-keys":98}],91:[function(require,module,exports){
// Forced replacement prototype accessors methods
module.exports = require('./_library')|| !require('./_fails')(function(){
  var K = Math.random();
  // In FF throws only define methods
  __defineSetter__.call(null, K, function(){ /* empty */});
  delete require('./_global')[K];
});
},{"./_fails":56,"./_global":60,"./_library":80}],92:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":50,"./_has":61,"./_ie8-dom-define":64,"./_object-pie":99,"./_property-desc":107,"./_to-iobject":129,"./_to-primitive":132}],93:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject')
  , gOPN      = require('./_object-gopn').f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":94,"./_to-iobject":129}],94:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":52,"./_object-keys-internal":97}],95:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],96:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = require('./_has')
  , toObject    = require('./_to-object')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":61,"./_shared-key":115,"./_to-object":131}],97:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":33,"./_has":61,"./_shared-key":115,"./_to-iobject":129}],98:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":52,"./_object-keys-internal":97}],99:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],100:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":45,"./_export":54,"./_fails":56}],101:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject')
  , isEnum    = require('./_object-pie').f;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};
},{"./_object-keys":98,"./_object-pie":99,"./_to-iobject":129}],102:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN     = require('./_object-gopn')
  , gOPS     = require('./_object-gops')
  , anObject = require('./_an-object')
  , Reflect  = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
  var keys       = gOPN.f(anObject(it))
    , getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
},{"./_an-object":29,"./_global":60,"./_object-gopn":94,"./_object-gops":95}],103:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat
  , $trim       = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str){
  var string = $trim(String(str), 3)
    , result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;
},{"./_global":60,"./_string-trim":124,"./_string-ws":125}],104:[function(require,module,exports){
var $parseInt = require('./_global').parseInt
  , $trim     = require('./_string-trim').trim
  , ws        = require('./_string-ws')
  , hex       = /^[\-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;
},{"./_global":60,"./_string-trim":124,"./_string-ws":125}],105:[function(require,module,exports){
'use strict';
var path      = require('./_path')
  , invoke    = require('./_invoke')
  , aFunction = require('./_a-function');
module.exports = function(/* ...pargs */){
  var fn     = aFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that = this
      , aLen = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !aLen)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(aLen > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
},{"./_a-function":25,"./_invoke":66,"./_path":106}],106:[function(require,module,exports){
module.exports = require('./_global');
},{"./_global":60}],107:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],108:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function(target, src, safe){
  for(var key in src)redefine(target, key, src[key], safe);
  return target;
};
},{"./_redefine":109}],109:[function(require,module,exports){
var global    = require('./_global')
  , hide      = require('./_hide')
  , has       = require('./_has')
  , SRC       = require('./_uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./_core":45,"./_global":60,"./_has":61,"./_hide":62,"./_uid":136}],110:[function(require,module,exports){
module.exports = function(regExp, replace){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(it).replace(regExp, replacer);
  };
};
},{}],111:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],112:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":29,"./_ctx":47,"./_is-object":71,"./_object-gopd":92}],113:[function(require,module,exports){
'use strict';
var global      = require('./_global')
  , dP          = require('./_object-dp')
  , DESCRIPTORS = require('./_descriptors')
  , SPECIES     = require('./_wks')('species');

module.exports = function(KEY){
  var C = global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./_descriptors":50,"./_global":60,"./_object-dp":89,"./_wks":139}],114:[function(require,module,exports){
var def = require('./_object-dp').f
  , has = require('./_has')
  , TAG = require('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":61,"./_object-dp":89,"./_wks":139}],115:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":116,"./_uid":136}],116:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":60}],117:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./_an-object')
  , aFunction = require('./_a-function')
  , SPECIES   = require('./_wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./_a-function":25,"./_an-object":29,"./_wks":139}],118:[function(require,module,exports){
var fails = require('./_fails');

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};
},{"./_fails":56}],119:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":49,"./_to-integer":128}],120:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp')
  , defined  = require('./_defined');

module.exports = function(that, searchString, NAME){
  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};
},{"./_defined":49,"./_is-regexp":72}],121:[function(require,module,exports){
var $export = require('./_export')
  , fails   = require('./_fails')
  , defined = require('./_defined')
  , quot    = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function(string, tag, attribute, value) {
  var S  = String(defined(string))
    , p1 = '<' + tag;
  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function(NAME, exec){
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function(){
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};
},{"./_defined":49,"./_export":54,"./_fails":56}],122:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length')
  , repeat   = require('./_string-repeat')
  , defined  = require('./_defined');

module.exports = function(that, maxLength, fillString, left){
  var S            = String(defined(that))
    , stringLength = S.length
    , fillStr      = fillString === undefined ? ' ' : String(fillString)
    , intMaxLength = toLength(maxLength);
  if(intMaxLength <= stringLength || fillStr == '')return S;
  var fillLen = intMaxLength - stringLength
    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":49,"./_string-repeat":123,"./_to-length":130}],123:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');

module.exports = function repeat(count){
  var str = String(defined(this))
    , res = ''
    , n   = toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
},{"./_defined":49,"./_to-integer":128}],124:[function(require,module,exports){
var $export = require('./_export')
  , defined = require('./_defined')
  , fails   = require('./_fails')
  , spaces  = require('./_string-ws')
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
},{"./_defined":49,"./_export":54,"./_fails":56,"./_string-ws":125}],125:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
},{}],126:[function(require,module,exports){
var ctx                = require('./_ctx')
  , invoke             = require('./_invoke')
  , html               = require('./_html')
  , cel                = require('./_dom-create')
  , global             = require('./_global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./_cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./_cof":40,"./_ctx":47,"./_dom-create":51,"./_global":60,"./_html":63,"./_invoke":66}],127:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":128}],128:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],129:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":49,"./_iobject":67}],130:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":128}],131:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":49}],132:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":71}],133:[function(require,module,exports){
'use strict';
if(require('./_descriptors')){
  var LIBRARY             = require('./_library')
    , global              = require('./_global')
    , fails               = require('./_fails')
    , $export             = require('./_export')
    , $typed              = require('./_typed')
    , $buffer             = require('./_typed-buffer')
    , ctx                 = require('./_ctx')
    , anInstance          = require('./_an-instance')
    , propertyDesc        = require('./_property-desc')
    , hide                = require('./_hide')
    , redefineAll         = require('./_redefine-all')
    , toInteger           = require('./_to-integer')
    , toLength            = require('./_to-length')
    , toIndex             = require('./_to-index')
    , toPrimitive         = require('./_to-primitive')
    , has                 = require('./_has')
    , same                = require('./_same-value')
    , classof             = require('./_classof')
    , isObject            = require('./_is-object')
    , toObject            = require('./_to-object')
    , isArrayIter         = require('./_is-array-iter')
    , create              = require('./_object-create')
    , getPrototypeOf      = require('./_object-gpo')
    , gOPN                = require('./_object-gopn').f
    , getIterFn           = require('./core.get-iterator-method')
    , uid                 = require('./_uid')
    , wks                 = require('./_wks')
    , createArrayMethod   = require('./_array-methods')
    , createArrayIncludes = require('./_array-includes')
    , speciesConstructor  = require('./_species-constructor')
    , ArrayIterators      = require('./es6.array.iterator')
    , Iterators           = require('./_iterators')
    , $iterDetect         = require('./_iter-detect')
    , setSpecies          = require('./_set-species')
    , arrayFill           = require('./_array-fill')
    , arrayCopyWithin     = require('./_array-copy-within')
    , $DP                 = require('./_object-dp')
    , $GOPD               = require('./_object-gopd')
    , dP                  = $DP.f
    , gOPD                = $GOPD.f
    , RangeError          = global.RangeError
    , TypeError           = global.TypeError
    , Uint8Array          = global.Uint8Array
    , ARRAY_BUFFER        = 'ArrayBuffer'
    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
    , PROTOTYPE           = 'prototype'
    , ArrayProto          = Array[PROTOTYPE]
    , $ArrayBuffer        = $buffer.ArrayBuffer
    , $DataView           = $buffer.DataView
    , arrayForEach        = createArrayMethod(0)
    , arrayFilter         = createArrayMethod(2)
    , arraySome           = createArrayMethod(3)
    , arrayEvery          = createArrayMethod(4)
    , arrayFind           = createArrayMethod(5)
    , arrayFindIndex      = createArrayMethod(6)
    , arrayIncludes       = createArrayIncludes(true)
    , arrayIndexOf        = createArrayIncludes(false)
    , arrayValues         = ArrayIterators.values
    , arrayKeys           = ArrayIterators.keys
    , arrayEntries        = ArrayIterators.entries
    , arrayLastIndexOf    = ArrayProto.lastIndexOf
    , arrayReduce         = ArrayProto.reduce
    , arrayReduceRight    = ArrayProto.reduceRight
    , arrayJoin           = ArrayProto.join
    , arraySort           = ArrayProto.sort
    , arraySlice          = ArrayProto.slice
    , arrayToString       = ArrayProto.toString
    , arrayToLocaleString = ArrayProto.toLocaleString
    , ITERATOR            = wks('iterator')
    , TAG                 = wks('toStringTag')
    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
    , DEF_CONSTRUCTOR     = uid('def_constructor')
    , ALL_CONSTRUCTORS    = $typed.CONSTR
    , TYPED_ARRAY         = $typed.TYPED
    , VIEW                = $typed.VIEW
    , WRONG_LENGTH        = 'Wrong length!';

  var $map = createArrayMethod(1, function(O, length){
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function(){
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
    new Uint8Array(1).set({});
  });

  var strictToLength = function(it, SAME){
    if(it === undefined)throw TypeError(WRONG_LENGTH);
    var number = +it
      , length = toLength(it);
    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
    return length;
  };

  var toOffset = function(it, BYTES){
    var offset = toInteger(it);
    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function(it){
    if(isObject(it) && TYPED_ARRAY in it)return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function(C, length){
    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function(O, list){
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function(C, list){
    var index  = 0
      , length = list.length
      , result = allocate(C, length);
    while(length > index)result[index] = list[index++];
    return result;
  };

  var addGetter = function(it, key, internal){
    dP(it, key, {get: function(){ return this._d[internal]; }});
  };

  var $from = function from(source /*, mapfn, thisArg */){
    var O       = toObject(source)
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , iterFn  = getIterFn(O)
      , i, length, values, result, step, iterator;
    if(iterFn != undefined && !isArrayIter(iterFn)){
      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
        values.push(step.value);
      } O = values;
    }
    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/*...items*/){
    var index  = 0
      , length = arguments.length
      , result = allocate(this, length);
    while(length > index)result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString(){
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /*, end */){
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /*, thisArg */){
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /*, thisArg */){
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /*, thisArg */){
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /*, thisArg */){
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /*, thisArg */){
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /*, fromIndex */){
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /*, fromIndex */){
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator){ // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /*, thisArg */){
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse(){
      var that   = this
        , length = validate(that).length
        , middle = Math.floor(length / 2)
        , index  = 0
        , value;
      while(index < middle){
        value         = that[index];
        that[index++] = that[--length];
        that[length]  = value;
      } return that;
    },
    some: function some(callbackfn /*, thisArg */){
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn){
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end){
      var O      = validate(this)
        , length = O.length
        , $begin = toIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end){
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /*, offset */){
    validate(this);
    var offset = toOffset(arguments[1], 1)
      , length = this.length
      , src    = toObject(arrayLike)
      , len    = toLength(src.length)
      , index  = 0;
    if(len + offset > length)throw RangeError(WRONG_LENGTH);
    while(index < len)this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries(){
      return arrayEntries.call(validate(this));
    },
    keys: function keys(){
      return arrayKeys.call(validate(this));
    },
    values: function values(){
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function(target, key){
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key){
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc){
    if(isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ){
      target[key] = desc.value;
      return target;
    } else return dP(target, key, desc);
  };

  if(!ALL_CONSTRUCTORS){
    $GOPD.f = $getDesc;
    $DP.f   = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty:           $setDesc
  });

  if(fails(function(){ arrayToString.call({}); })){
    arrayToString = arrayToLocaleString = function toString(){
      return arrayJoin.call(this);
    }
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice:          $slice,
    set:            $set,
    constructor:    function(){ /* noop */ },
    toString:       arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function(){ return this[TYPED_ARRAY]; }
  });

  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
    CLAMPED = !!CLAMPED;
    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
      , ISNT_UINT8 = NAME != 'Uint8Array'
      , GETTER     = 'get' + KEY
      , SETTER     = 'set' + KEY
      , TypedArray = global[NAME]
      , Base       = TypedArray || {}
      , TAC        = TypedArray && getPrototypeOf(TypedArray)
      , FORCED     = !TypedArray || !$typed.ABV
      , O          = {}
      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function(that, index){
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function(that, index, value){
      var data = that._d;
      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function(that, index){
      dP(that, index, {
        get: function(){
          return getter(this, index);
        },
        set: function(value){
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if(FORCED){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME, '_d');
        var index  = 0
          , offset = 0
          , buffer, byteLength, length, klass;
        if(!isObject(data)){
          length     = strictToLength(data, true)
          byteLength = length * BYTES;
          buffer     = new $ArrayBuffer(byteLength);
        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if($length === undefined){
            if($len % BYTES)throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if(TYPED_ARRAY in data){
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while(index < length)addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if(!$iterDetect(function(iter){
      // V8 works with iterators, but fails in many other cases
      // https://code.google.com/p/v8/issues/detail?id=4552
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
      , $iterator         = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
      dP(TypedArrayPrototype, TAG, {
        get: function(){ return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES,
      from: $from,
      of: $of
    });

    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});

    $export($export.P + $export.F * fails(function(){
      new TypedArray(1).slice();
    }), NAME, {slice: $slice});

    $export($export.P + $export.F * (fails(function(){
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
    }) || !fails(function(){
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {toLocaleString: $toLocaleString});

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function(){ /* empty */ };
},{"./_an-instance":28,"./_array-copy-within":30,"./_array-fill":31,"./_array-includes":33,"./_array-methods":34,"./_classof":39,"./_ctx":47,"./_descriptors":50,"./_export":54,"./_fails":56,"./_global":60,"./_has":61,"./_hide":62,"./_is-array-iter":68,"./_is-object":71,"./_iter-detect":76,"./_iterators":78,"./_library":80,"./_object-create":88,"./_object-dp":89,"./_object-gopd":92,"./_object-gopn":94,"./_object-gpo":96,"./_property-desc":107,"./_redefine-all":108,"./_same-value":111,"./_set-species":113,"./_species-constructor":117,"./_to-index":127,"./_to-integer":128,"./_to-length":130,"./_to-object":131,"./_to-primitive":132,"./_typed":135,"./_typed-buffer":134,"./_uid":136,"./_wks":139,"./core.get-iterator-method":140,"./es6.array.iterator":152}],134:[function(require,module,exports){
'use strict';
var global         = require('./_global')
  , DESCRIPTORS    = require('./_descriptors')
  , LIBRARY        = require('./_library')
  , $typed         = require('./_typed')
  , hide           = require('./_hide')
  , redefineAll    = require('./_redefine-all')
  , fails          = require('./_fails')
  , anInstance     = require('./_an-instance')
  , toInteger      = require('./_to-integer')
  , toLength       = require('./_to-length')
  , gOPN           = require('./_object-gopn').f
  , dP             = require('./_object-dp').f
  , arrayFill      = require('./_array-fill')
  , setToStringTag = require('./_set-to-string-tag')
  , ARRAY_BUFFER   = 'ArrayBuffer'
  , DATA_VIEW      = 'DataView'
  , PROTOTYPE      = 'prototype'
  , WRONG_LENGTH   = 'Wrong length!'
  , WRONG_INDEX    = 'Wrong index!'
  , $ArrayBuffer   = global[ARRAY_BUFFER]
  , $DataView      = global[DATA_VIEW]
  , Math           = global.Math
  , RangeError     = global.RangeError
  , Infinity       = global.Infinity
  , BaseBuffer     = $ArrayBuffer
  , abs            = Math.abs
  , pow            = Math.pow
  , floor          = Math.floor
  , log            = Math.log
  , LN2            = Math.LN2
  , BUFFER         = 'buffer'
  , BYTE_LENGTH    = 'byteLength'
  , BYTE_OFFSET    = 'byteOffset'
  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function(value, mLen, nBytes){
  var buffer = Array(nBytes)
    , eLen   = nBytes * 8 - mLen - 1
    , eMax   = (1 << eLen) - 1
    , eBias  = eMax >> 1
    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
    , i      = 0
    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
    , e, m, c;
  value = abs(value)
  if(value != value || value === Infinity){
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if(value * (c = pow(2, -e)) < 1){
      e--;
      c *= 2;
    }
    if(e + eBias >= 1){
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if(value * c >= 2){
      e++;
      c /= 2;
    }
    if(e + eBias >= eMax){
      m = 0;
      e = eMax;
    } else if(e + eBias >= 1){
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
};
var unpackIEEE754 = function(buffer, mLen, nBytes){
  var eLen  = nBytes * 8 - mLen - 1
    , eMax  = (1 << eLen) - 1
    , eBias = eMax >> 1
    , nBits = eLen - 7
    , i     = nBytes - 1
    , s     = buffer[i--]
    , e     = s & 127
    , m;
  s >>= 7;
  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if(e === 0){
    e = 1 - eBias;
  } else if(e === eMax){
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
};

var unpackI32 = function(bytes){
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
};
var packI8 = function(it){
  return [it & 0xff];
};
var packI16 = function(it){
  return [it & 0xff, it >> 8 & 0xff];
};
var packI32 = function(it){
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
};
var packF64 = function(it){
  return packIEEE754(it, 52, 8);
};
var packF32 = function(it){
  return packIEEE754(it, 23, 4);
};

var addGetter = function(C, key, internal){
  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
};

var get = function(view, bytes, index, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
};
var set = function(view, bytes, index, conversion, value, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = conversion(+value);
  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
};

var validateArrayBufferArguments = function(that, length){
  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
  var numberLength = +length
    , byteLength   = toLength(numberLength);
  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
  return byteLength;
};

if(!$typed.ABV){
  $ArrayBuffer = function ArrayBuffer(length){
    var byteLength = validateArrayBufferArguments(this, length);
    this._b       = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength){
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH]
      , offset       = toInteger(byteOffset);
    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if(DESCRIPTORS){
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset){
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset){
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if(!fails(function(){
    new $ArrayBuffer;     // eslint-disable-line no-new
  }) || !fails(function(){
    new $ArrayBuffer(.5); // eslint-disable-line no-new
  })){
    $ArrayBuffer = function ArrayBuffer(length){
      return new BaseBuffer(validateArrayBufferArguments(this, length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
    };
    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2))
    , $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;
},{"./_an-instance":28,"./_array-fill":31,"./_descriptors":50,"./_fails":56,"./_global":60,"./_hide":62,"./_library":80,"./_object-dp":89,"./_object-gopn":94,"./_redefine-all":108,"./_set-to-string-tag":114,"./_to-integer":128,"./_to-length":130,"./_typed":135}],135:[function(require,module,exports){
var global = require('./_global')
  , hide   = require('./_hide')
  , uid    = require('./_uid')
  , TYPED  = uid('typed_array')
  , VIEW   = uid('view')
  , ABV    = !!(global.ArrayBuffer && global.DataView)
  , CONSTR = ABV
  , i = 0, l = 9, Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while(i < l){
  if(Typed = global[TypedArrayConstructors[i++]]){
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV:    ABV,
  CONSTR: CONSTR,
  TYPED:  TYPED,
  VIEW:   VIEW
};
},{"./_global":60,"./_hide":62,"./_uid":136}],136:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],137:[function(require,module,exports){
var global         = require('./_global')
  , core           = require('./_core')
  , LIBRARY        = require('./_library')
  , wksExt         = require('./_wks-ext')
  , defineProperty = require('./_object-dp').f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};
},{"./_core":45,"./_global":60,"./_library":80,"./_object-dp":89,"./_wks-ext":138}],138:[function(require,module,exports){
exports.f = require('./_wks');
},{"./_wks":139}],139:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":60,"./_shared":116,"./_uid":136}],140:[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./_classof":39,"./_core":45,"./_iterators":78,"./_wks":139}],141:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export')
  , $re     = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});

},{"./_export":54,"./_replacer":110}],142:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', {copyWithin: require('./_array-copy-within')});

require('./_add-to-unscopables')('copyWithin');
},{"./_add-to-unscopables":27,"./_array-copy-within":30,"./_export":54}],143:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $every  = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */){
    return $every(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":34,"./_export":54,"./_strict-method":118}],144:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', {fill: require('./_array-fill')});

require('./_add-to-unscopables')('fill');
},{"./_add-to-unscopables":27,"./_array-fill":31,"./_export":54}],145:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */){
    return $filter(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":34,"./_export":54,"./_strict-method":118}],146:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(6)
  , KEY     = 'findIndex'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":27,"./_array-methods":34,"./_export":54}],147:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":27,"./_array-methods":34,"./_export":54}],148:[function(require,module,exports){
'use strict';
var $export  = require('./_export')
  , $forEach = require('./_array-methods')(0)
  , STRICT   = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":34,"./_export":54,"./_strict-method":118}],149:[function(require,module,exports){
'use strict';
var ctx            = require('./_ctx')
  , $export        = require('./_export')
  , toObject       = require('./_to-object')
  , call           = require('./_iter-call')
  , isArrayIter    = require('./_is-array-iter')
  , toLength       = require('./_to-length')
  , createProperty = require('./_create-property')
  , getIterFn      = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":46,"./_ctx":47,"./_export":54,"./_is-array-iter":68,"./_iter-call":73,"./_iter-detect":76,"./_to-length":130,"./_to-object":131,"./core.get-iterator-method":140}],150:[function(require,module,exports){
'use strict';
var $export       = require('./_export')
  , $indexOf      = require('./_array-includes')(false)
  , $native       = [].indexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});
},{"./_array-includes":33,"./_export":54,"./_strict-method":118}],151:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', {isArray: require('./_is-array')});
},{"./_export":54,"./_is-array":69}],152:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables')
  , step             = require('./_iter-step')
  , Iterators        = require('./_iterators')
  , toIObject        = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./_add-to-unscopables":27,"./_iter-define":75,"./_iter-step":77,"./_iterators":78,"./_to-iobject":129}],153:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export   = require('./_export')
  , toIObject = require('./_to-iobject')
  , arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator){
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});
},{"./_export":54,"./_iobject":67,"./_strict-method":118,"./_to-iobject":129}],154:[function(require,module,exports){
'use strict';
var $export       = require('./_export')
  , toIObject     = require('./_to-iobject')
  , toInteger     = require('./_to-integer')
  , toLength      = require('./_to-length')
  , $native       = [].lastIndexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
    // convert -0 to +0
    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
    var O      = toIObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
    if(index < 0)index = length + index;
    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
    return -1;
  }
});
},{"./_export":54,"./_strict-method":118,"./_to-integer":128,"./_to-iobject":129,"./_to-length":130}],155:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $map    = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */){
    return $map(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":34,"./_export":54,"./_strict-method":118}],156:[function(require,module,exports){
'use strict';
var $export        = require('./_export')
  , createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function(){
  function F(){}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , aLen   = arguments.length
      , result = new (typeof this == 'function' ? this : Array)(aLen);
    while(aLen > index)createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});
},{"./_create-property":46,"./_export":54,"./_fails":56}],157:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});
},{"./_array-reduce":35,"./_export":54,"./_strict-method":118}],158:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
},{"./_array-reduce":35,"./_export":54,"./_strict-method":118}],159:[function(require,module,exports){
'use strict';
var $export    = require('./_export')
  , html       = require('./_html')
  , cof        = require('./_cof')
  , toIndex    = require('./_to-index')
  , toLength   = require('./_to-length')
  , arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function(){
  if(html)arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return arraySlice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});
},{"./_cof":40,"./_export":54,"./_fails":56,"./_html":63,"./_to-index":127,"./_to-length":130}],160:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $some   = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */){
    return $some(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":34,"./_export":54,"./_strict-method":118}],161:[function(require,module,exports){
'use strict';
var $export   = require('./_export')
  , aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , fails     = require('./_fails')
  , $sort     = [].sort
  , test      = [1, 2, 3];

$export($export.P + $export.F * (fails(function(){
  // IE8-
  test.sort(undefined);
}) || !fails(function(){
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn){
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});
},{"./_a-function":25,"./_export":54,"./_fails":56,"./_strict-method":118,"./_to-object":131}],162:[function(require,module,exports){
require('./_set-species')('Array');
},{"./_set-species":113}],163:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});
},{"./_export":54}],164:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export')
  , fails   = require('./_fails')
  , getTime = Date.prototype.getTime;

var lz = function(num){
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (fails(function(){
  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
}) || !fails(function(){
  new Date(NaN).toISOString();
})), 'Date', {
  toISOString: function toISOString(){
    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
    var d = this
      , y = d.getUTCFullYear()
      , m = d.getUTCMilliseconds()
      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
  }
});
},{"./_export":54,"./_fails":56}],165:[function(require,module,exports){
'use strict';
var $export     = require('./_export')
  , toObject    = require('./_to-object')
  , toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function(){
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
}), 'Date', {
  toJSON: function toJSON(key){
    var O  = toObject(this)
      , pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});
},{"./_export":54,"./_fails":56,"./_to-object":131,"./_to-primitive":132}],166:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive')
  , proto        = Date.prototype;

if(!(TO_PRIMITIVE in proto))require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));
},{"./_date-to-primitive":48,"./_hide":62,"./_wks":139}],167:[function(require,module,exports){
var DateProto    = Date.prototype
  , INVALID_DATE = 'Invalid Date'
  , TO_STRING    = 'toString'
  , $toString    = DateProto[TO_STRING]
  , getTime      = DateProto.getTime;
if(new Date(NaN) + '' != INVALID_DATE){
  require('./_redefine')(DateProto, TO_STRING, function toString(){
    var value = getTime.call(this);
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}
},{"./_redefine":109}],168:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', {bind: require('./_bind')});
},{"./_bind":38,"./_export":54}],169:[function(require,module,exports){
'use strict';
var isObject       = require('./_is-object')
  , getPrototypeOf = require('./_object-gpo')
  , HAS_INSTANCE   = require('./_wks')('hasInstance')
  , FunctionProto  = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))require('./_object-dp').f(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(typeof this != 'function' || !isObject(O))return false;
  if(!isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
  return false;
}});
},{"./_is-object":71,"./_object-dp":89,"./_object-gpo":96,"./_wks":139}],170:[function(require,module,exports){
var dP         = require('./_object-dp').f
  , createDesc = require('./_property-desc')
  , has        = require('./_has')
  , FProto     = Function.prototype
  , nameRE     = /^\s*function ([^ (]*)/
  , NAME       = 'name';

var isExtensible = Object.isExtensible || function(){
  return true;
};

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function(){
    try {
      var that = this
        , name = ('' + that).match(nameRE)[1];
      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
      return name;
    } catch(e){
      return '';
    }
  }
});
},{"./_descriptors":50,"./_has":61,"./_object-dp":89,"./_property-desc":107}],171:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.1 Map Objects
module.exports = require('./_collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./_collection":44,"./_collection-strong":41}],172:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export')
  , log1p   = require('./_math-log1p')
  , sqrt    = Math.sqrt
  , $acosh  = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});
},{"./_export":54,"./_math-log1p":82}],173:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export')
  , $asinh  = Math.asinh;

function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0 
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});
},{"./_export":54}],174:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export')
  , $atanh  = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0 
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});
},{"./_export":54}],175:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export')
  , sign    = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x){
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});
},{"./_export":54,"./_math-sign":83}],176:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});
},{"./_export":54}],177:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export')
  , exp     = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  }
});
},{"./_export":54}],178:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export')
  , $expm1  = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});
},{"./_export":54,"./_math-expm1":81}],179:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export   = require('./_export')
  , sign      = require('./_math-sign')
  , pow       = Math.pow
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);

var roundTiesToEven = function(n){
  return n + 1 / EPSILON - 1 / EPSILON;
};


$export($export.S, 'Math', {
  fround: function fround(x){
    var $abs  = Math.abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  }
});
},{"./_export":54,"./_math-sign":83}],180:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = require('./_export')
  , abs     = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , aLen = arguments.length
      , larg = 0
      , arg, div;
    while(i < aLen){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});
},{"./_export":54}],181:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export')
  , $imul   = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function(){
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y){
    var UINT16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UINT16 & xn
      , yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});
},{"./_export":54,"./_fails":56}],182:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});
},{"./_export":54}],183:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', {log1p: require('./_math-log1p')});
},{"./_export":54,"./_math-log1p":82}],184:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});
},{"./_export":54}],185:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', {sign: require('./_math-sign')});
},{"./_export":54,"./_math-sign":83}],186:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export')
  , expm1   = require('./_math-expm1')
  , exp     = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function(){
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x){
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});
},{"./_export":54,"./_fails":56,"./_math-expm1":81}],187:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export')
  , expm1   = require('./_math-expm1')
  , exp     = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});
},{"./_export":54,"./_math-expm1":81}],188:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it){
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});
},{"./_export":54}],189:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , has               = require('./_has')
  , cof               = require('./_cof')
  , inheritIfRequired = require('./_inherit-if-required')
  , toPrimitive       = require('./_to-primitive')
  , fails             = require('./_fails')
  , gOPN              = require('./_object-gopn').f
  , gOPD              = require('./_object-gopd').f
  , dP                = require('./_object-dp').f
  , $trim             = require('./_string-trim').trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}
},{"./_cof":40,"./_descriptors":50,"./_fails":56,"./_global":60,"./_has":61,"./_inherit-if-required":65,"./_object-create":88,"./_object-dp":89,"./_object-gopd":92,"./_object-gopn":94,"./_redefine":109,"./_string-trim":124,"./_to-primitive":132}],190:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});
},{"./_export":54}],191:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export   = require('./_export')
  , _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  }
});
},{"./_export":54,"./_global":60}],192:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', {isInteger: require('./_is-integer')});
},{"./_export":54,"./_is-integer":70}],193:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number){
    return number != number;
  }
});
},{"./_export":54}],194:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export   = require('./_export')
  , isInteger = require('./_is-integer')
  , abs       = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});
},{"./_export":54,"./_is-integer":70}],195:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
},{"./_export":54}],196:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
},{"./_export":54}],197:[function(require,module,exports){
var $export     = require('./_export')
  , $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});
},{"./_export":54,"./_parse-float":103}],198:[function(require,module,exports){
var $export   = require('./_export')
  , $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});
},{"./_export":54,"./_parse-int":104}],199:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , toInteger    = require('./_to-integer')
  , aNumberValue = require('./_a-number-value')
  , repeat       = require('./_string-repeat')
  , $toFixed     = 1..toFixed
  , floor        = Math.floor
  , data         = [0, 0, 0, 0, 0, 0]
  , ERROR        = 'Number.toFixed: incorrect invocation!'
  , ZERO         = '0';

var multiply = function(n, c){
  var i  = -1
    , c2 = c;
  while(++i < 6){
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function(n){
  var i = 6
    , c = 0;
  while(--i >= 0){
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function(){
  var i = 6
    , s = '';
  while(--i >= 0){
    if(s !== '' || i === 0 || data[i] !== 0){
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function(x, n, acc){
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x){
  var n  = 0
    , x2 = x;
  while(x2 >= 4096){
    n += 12;
    x2 /= 4096;
  }
  while(x2 >= 2){
    n  += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128..toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function(){
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits){
    var x = aNumberValue(this, ERROR)
      , f = toInteger(fractionDigits)
      , s = ''
      , m = ZERO
      , e, z, j, k;
    if(f < 0 || f > 20)throw RangeError(ERROR);
    if(x != x)return 'NaN';
    if(x <= -1e21 || x >= 1e21)return String(x);
    if(x < 0){
      s = '-';
      x = -x;
    }
    if(x > 1e-21){
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if(e > 0){
        multiply(0, z);
        j = f;
        while(j >= 7){
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while(j >= 23){
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if(f > 0){
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});
},{"./_a-number-value":26,"./_export":54,"./_fails":56,"./_string-repeat":123,"./_to-integer":128}],200:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , $fails       = require('./_fails')
  , aNumberValue = require('./_a-number-value')
  , $toPrecision = 1..toPrecision;

$export($export.P + $export.F * ($fails(function(){
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function(){
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision){
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
  }
});
},{"./_a-number-value":26,"./_export":54,"./_fails":56}],201:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":54,"./_object-assign":87}],202:[function(require,module,exports){
var $export = require('./_export')
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: require('./_object-create')});
},{"./_export":54,"./_object-create":88}],203:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperties: require('./_object-dps')});
},{"./_descriptors":50,"./_export":54,"./_object-dps":90}],204:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":50,"./_export":54,"./_object-dp":89}],205:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});
},{"./_is-object":71,"./_meta":84,"./_object-sap":100}],206:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = require('./_to-iobject')
  , $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./_object-gopd":92,"./_object-sap":100,"./_to-iobject":129}],207:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function(){
  return require('./_object-gopn-ext').f;
});
},{"./_object-gopn-ext":93,"./_object-sap":100}],208:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = require('./_to-object')
  , $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});
},{"./_object-gpo":96,"./_object-sap":100,"./_to-object":131}],209:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function($isExtensible){
  return function isExtensible(it){
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});
},{"./_is-object":71,"./_object-sap":100}],210:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function($isFrozen){
  return function isFrozen(it){
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});
},{"./_is-object":71,"./_object-sap":100}],211:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function($isSealed){
  return function isSealed(it){
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});
},{"./_is-object":71,"./_object-sap":100}],212:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', {is: require('./_same-value')});
},{"./_export":54,"./_same-value":111}],213:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":98,"./_object-sap":100,"./_to-object":131}],214:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function($preventExtensions){
  return function preventExtensions(it){
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});
},{"./_is-object":71,"./_meta":84,"./_object-sap":100}],215:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('seal', function($seal){
  return function seal(it){
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});
},{"./_is-object":71,"./_meta":84,"./_object-sap":100}],216:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});
},{"./_export":54,"./_set-proto":112}],217:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof')
  , test    = {};
test[require('./_wks')('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  require('./_redefine')(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}
},{"./_classof":39,"./_redefine":109,"./_wks":139}],218:[function(require,module,exports){
var $export     = require('./_export')
  , $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});
},{"./_export":54,"./_parse-float":103}],219:[function(require,module,exports){
var $export   = require('./_export')
  , $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});
},{"./_export":54,"./_parse-int":104}],220:[function(require,module,exports){
'use strict';
var LIBRARY            = require('./_library')
  , global             = require('./_global')
  , ctx                = require('./_ctx')
  , classof            = require('./_classof')
  , $export            = require('./_export')
  , isObject           = require('./_is-object')
  , aFunction          = require('./_a-function')
  , anInstance         = require('./_an-instance')
  , forOf              = require('./_for-of')
  , speciesConstructor = require('./_species-constructor')
  , task               = require('./_task').set
  , microtask          = require('./_microtask')()
  , PROMISE            = 'Promise'
  , TypeError          = global.TypeError
  , process            = global.process
  , $Promise           = global[PROMISE]
  , process            = global.process
  , isNode             = classof(process) == 'process'
  , empty              = function(){ /* empty */ }
  , Internal, GenericPromiseCapability, Wrapper;

var USE_NATIVE = !!function(){
  try {
    // correct subclassing with @@species support
    var promise     = $Promise.resolve(1)
      , FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec){ exec(empty, empty); };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch(e){ /* empty */ }
}();

// helpers
var sameConstructor = function(a, b){
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var newPromiseCapability = function(C){
  return sameConstructor($Promise, C)
    ? new PromiseCapability(C)
    : new GenericPromiseCapability(C);
};
var PromiseCapability = GenericPromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject  = aFunction(reject);
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(promise, isReject){
  if(promise._n)return;
  promise._n = true;
  var chain = promise._c;
  microtask(function(){
    var value = promise._v
      , ok    = promise._s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , domain  = reaction.domain
        , result, then;
      try {
        if(handler){
          if(!ok){
            if(promise._h == 2)onHandleUnhandled(promise);
            promise._h = 1;
          }
          if(handler === true)result = value;
          else {
            if(domain)domain.enter();
            result = handler(value);
            if(domain)domain.exit();
          }
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if(isReject && !promise._h)onUnhandled(promise);
  });
};
var onUnhandled = function(promise){
  task.call(global, function(){
    var value = promise._v
      , abrupt, handler, console;
    if(isUnhandled(promise)){
      abrupt = perform(function(){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if(abrupt)throw abrupt.error;
  });
};
var isUnhandled = function(promise){
  if(promise._h == 1)return false;
  var chain = promise._a || promise._c
    , i     = 0
    , reaction;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var onHandleUnhandled = function(promise){
  task.call(global, function(){
    var handler;
    if(isNode){
      process.emit('rejectionHandled', promise);
    } else if(handler = global.onrejectionhandled){
      handler({promise: promise, reason: promise._v});
    }
  });
};
var $reject = function(value){
  var promise = this;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if(!promise._a)promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function(value){
  var promise = this
    , then;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if(promise === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      microtask(function(){
        var wrapper = {_w: promise, _d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch(e){
    $reject.call({_w: promise, _d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor){
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch(err){
      $reject.call(this, err);
    }
  };
  Internal = function Promise(executor){
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail   = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if(this._a)this._a.push(reaction);
      if(this._s)notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
  PromiseCapability = function(){
    var promise  = new Internal;
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject  = ctx($reject, promise, 1);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = newPromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
    var capability = newPromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter){
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject;
    var abrupt = perform(function(){
      var values    = []
        , index     = 0
        , remaining = 1;
      forOf(iterable, false, function(promise){
        var $index        = index++
          , alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled  = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./_a-function":25,"./_an-instance":28,"./_classof":39,"./_core":45,"./_ctx":47,"./_export":54,"./_for-of":59,"./_global":60,"./_is-object":71,"./_iter-detect":76,"./_library":80,"./_microtask":86,"./_redefine-all":108,"./_set-species":113,"./_set-to-string-tag":114,"./_species-constructor":117,"./_task":126,"./_wks":139}],221:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export   = require('./_export')
  , aFunction = require('./_a-function')
  , anObject  = require('./_an-object')
  , rApply    = (require('./_global').Reflect || {}).apply
  , fApply    = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function(){
  rApply(function(){});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList){
    var T = aFunction(target)
      , L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});
},{"./_a-function":25,"./_an-object":29,"./_export":54,"./_fails":56,"./_global":60}],222:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export    = require('./_export')
  , create     = require('./_object-create')
  , aFunction  = require('./_a-function')
  , anObject   = require('./_an-object')
  , isObject   = require('./_is-object')
  , fails      = require('./_fails')
  , bind       = require('./_bind')
  , rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function(){
  function F(){}
  return !(rConstruct(function(){}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function(){
  rConstruct(function(){});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /*, newTarget*/){
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
    if(Target == newTarget){
      // w/o altered newTarget, optimization for 0-4 arguments
      switch(args.length){
        case 0: return new Target;
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args));
    }
    // with altered newTarget, not support built-in constructors
    var proto    = newTarget.prototype
      , instance = create(isObject(proto) ? proto : Object.prototype)
      , result   = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});
},{"./_a-function":25,"./_an-object":29,"./_bind":38,"./_export":54,"./_fails":56,"./_global":60,"./_is-object":71,"./_object-create":88}],223:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP          = require('./_object-dp')
  , $export     = require('./_export')
  , anObject    = require('./_an-object')
  , toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function(){
  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes){
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_an-object":29,"./_export":54,"./_fails":56,"./_object-dp":89,"./_to-primitive":132}],224:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export  = require('./_export')
  , gOPD     = require('./_object-gopd').f
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});
},{"./_an-object":29,"./_export":54,"./_object-gopd":92}],225:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export  = require('./_export')
  , anObject = require('./_an-object');
var Enumerate = function(iterated){
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = []       // keys
    , key;
  for(key in iterated)keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function(){
  var that = this
    , keys = that._k
    , key;
  do {
    if(that._i >= keys.length)return {value: undefined, done: true};
  } while(!((key = keys[that._i++]) in that._t));
  return {value: key, done: false};
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target){
    return new Enumerate(target);
  }
});
},{"./_an-object":29,"./_export":54,"./_iter-create":74}],226:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD     = require('./_object-gopd')
  , $export  = require('./_export')
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return gOPD.f(anObject(target), propertyKey);
  }
});
},{"./_an-object":29,"./_export":54,"./_object-gopd":92}],227:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export  = require('./_export')
  , getProto = require('./_object-gpo')
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(anObject(target));
  }
});
},{"./_an-object":29,"./_export":54,"./_object-gpo":96}],228:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD           = require('./_object-gopd')
  , getPrototypeOf = require('./_object-gpo')
  , has            = require('./_has')
  , $export        = require('./_export')
  , isObject       = require('./_is-object')
  , anObject       = require('./_an-object');

function get(target, propertyKey/*, receiver*/){
  var receiver = arguments.length < 3 ? target : arguments[2]
    , desc, proto;
  if(anObject(target) === receiver)return target[propertyKey];
  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {get: get});
},{"./_an-object":29,"./_export":54,"./_has":61,"./_is-object":71,"./_object-gopd":92,"./_object-gpo":96}],229:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey){
    return propertyKey in target;
  }
});
},{"./_export":54}],230:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export       = require('./_export')
  , anObject      = require('./_an-object')
  , $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target){
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});
},{"./_an-object":29,"./_export":54}],231:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', {ownKeys: require('./_own-keys')});
},{"./_export":54,"./_own-keys":102}],232:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export            = require('./_export')
  , anObject           = require('./_an-object')
  , $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target){
    anObject(target);
    try {
      if($preventExtensions)$preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_an-object":29,"./_export":54}],233:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export  = require('./_export')
  , setProto = require('./_set-proto');

if(setProto)$export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto){
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_export":54,"./_set-proto":112}],234:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP             = require('./_object-dp')
  , gOPD           = require('./_object-gopd')
  , getPrototypeOf = require('./_object-gpo')
  , has            = require('./_has')
  , $export        = require('./_export')
  , createDesc     = require('./_property-desc')
  , anObject       = require('./_an-object')
  , isObject       = require('./_is-object');

function set(target, propertyKey, V/*, receiver*/){
  var receiver = arguments.length < 4 ? target : arguments[3]
    , ownDesc  = gOPD.f(anObject(target), propertyKey)
    , existingDescriptor, proto;
  if(!ownDesc){
    if(isObject(proto = getPrototypeOf(target))){
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if(has(ownDesc, 'value')){
    if(ownDesc.writable === false || !isObject(receiver))return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {set: set});
},{"./_an-object":29,"./_export":54,"./_has":61,"./_is-object":71,"./_object-dp":89,"./_object-gopd":92,"./_object-gpo":96,"./_property-desc":107}],235:[function(require,module,exports){
var global            = require('./_global')
  , inheritIfRequired = require('./_inherit-if-required')
  , dP                = require('./_object-dp').f
  , gOPN              = require('./_object-gopn').f
  , isRegExp          = require('./_is-regexp')
  , $flags            = require('./_flags')
  , $RegExp           = global.RegExp
  , Base              = $RegExp
  , proto             = $RegExp.prototype
  , re1               = /a/g
  , re2               = /a/g
  // "new" creates a new object, old webkit buggy here
  , CORRECT_NEW       = new $RegExp(re1) !== re1;

if(require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function(){
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))){
  $RegExp = function RegExp(p, f){
    var tiRE = this instanceof $RegExp
      , piRE = isRegExp(p)
      , fiU  = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function(key){
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function(){ return Base[key]; },
      set: function(it){ Base[key] = it; }
    });
  };
  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');
},{"./_descriptors":50,"./_fails":56,"./_flags":58,"./_global":60,"./_inherit-if-required":65,"./_is-regexp":72,"./_object-dp":89,"./_object-gopn":94,"./_redefine":109,"./_set-species":113,"./_wks":139}],236:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if(require('./_descriptors') && /./g.flags != 'g')require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});
},{"./_descriptors":50,"./_flags":58,"./_object-dp":89}],237:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function(defined, MATCH, $match){
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});
},{"./_fix-re-wks":57}],238:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function(defined, REPLACE, $replace){
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue){
    'use strict';
    var O  = defined(this)
      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});
},{"./_fix-re-wks":57}],239:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function(defined, SEARCH, $search){
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});
},{"./_fix-re-wks":57}],240:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function(defined, SPLIT, $split){
  'use strict';
  var isRegExp   = require('./_is-regexp')
    , _split     = $split
    , $push      = [].push
    , $SPLIT     = 'split'
    , LENGTH     = 'length'
    , LAST_INDEX = 'lastIndex';
  if(
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ){
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function(separator, limit){
      var string = String(this);
      if(separator === undefined && limit === 0)return [];
      // If `separator` is not a regex, use native split
      if(!isRegExp(separator))return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while(match = separatorCopy.exec(string)){
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if(lastIndex > lastLastIndex){
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
          });
          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if(output[LENGTH] >= splitLimit)break;
        }
        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if(lastLastIndex === string[LENGTH]){
        if(lastLength || !separatorCopy.test(''))output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
    $split = function(separator, limit){
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit){
    var O  = defined(this)
      , fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});
},{"./_fix-re-wks":57,"./_is-regexp":72}],241:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject    = require('./_an-object')
  , $flags      = require('./_flags')
  , DESCRIPTORS = require('./_descriptors')
  , TO_STRING   = 'toString'
  , $toString   = /./[TO_STRING];

var define = function(fn){
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if(require('./_fails')(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
  define(function toString(){
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if($toString.name != TO_STRING){
  define(function toString(){
    return $toString.call(this);
  });
}
},{"./_an-object":29,"./_descriptors":50,"./_fails":56,"./_flags":58,"./_redefine":109,"./es6.regexp.flags":236}],242:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.2 Set Objects
module.exports = require('./_collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./_collection":44,"./_collection-strong":41}],243:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function(createHTML){
  return function anchor(name){
    return createHTML(this, 'a', 'name', name);
  }
});
},{"./_string-html":121}],244:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function(createHTML){
  return function big(){
    return createHTML(this, 'big', '', '');
  }
});
},{"./_string-html":121}],245:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function(createHTML){
  return function blink(){
    return createHTML(this, 'blink', '', '');
  }
});
},{"./_string-html":121}],246:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function(createHTML){
  return function bold(){
    return createHTML(this, 'b', '', '');
  }
});
},{"./_string-html":121}],247:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $at     = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
},{"./_export":54,"./_string-at":119}],248:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export   = require('./_export')
  , toLength  = require('./_to-length')
  , context   = require('./_string-context')
  , ENDS_WITH = 'endsWith'
  , $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    var that = context(this, searchString, ENDS_WITH)
      , endPosition = arguments.length > 1 ? arguments[1] : undefined
      , len    = toLength(that.length)
      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
      , search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});
},{"./_export":54,"./_fails-is-regexp":55,"./_string-context":120,"./_to-length":130}],249:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function(createHTML){
  return function fixed(){
    return createHTML(this, 'tt', '', '');
  }
});
},{"./_string-html":121}],250:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function(createHTML){
  return function fontcolor(color){
    return createHTML(this, 'font', 'color', color);
  }
});
},{"./_string-html":121}],251:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function(createHTML){
  return function fontsize(size){
    return createHTML(this, 'font', 'size', size);
  }
});
},{"./_string-html":121}],252:[function(require,module,exports){
var $export        = require('./_export')
  , toIndex        = require('./_to-index')
  , fromCharCode   = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res  = []
      , aLen = arguments.length
      , i    = 0
      , code;
    while(aLen > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
},{"./_export":54,"./_to-index":127}],253:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export  = require('./_export')
  , context  = require('./_string-context')
  , INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /*, position = 0 */){
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});
},{"./_export":54,"./_fails-is-regexp":55,"./_string-context":120}],254:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function(createHTML){
  return function italics(){
    return createHTML(this, 'i', '', '');
  }
});
},{"./_string-html":121}],255:[function(require,module,exports){
'use strict';
var $at  = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":75,"./_string-at":119}],256:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function(createHTML){
  return function link(url){
    return createHTML(this, 'a', 'href', url);
  }
});
},{"./_string-html":121}],257:[function(require,module,exports){
var $export   = require('./_export')
  , toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl  = toIObject(callSite.raw)
      , len  = toLength(tpl.length)
      , aLen = arguments.length
      , res  = []
      , i    = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < aLen)res.push(String(arguments[i]));
    } return res.join('');
  }
});
},{"./_export":54,"./_to-iobject":129,"./_to-length":130}],258:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});
},{"./_export":54,"./_string-repeat":123}],259:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function(createHTML){
  return function small(){
    return createHTML(this, 'small', '', '');
  }
});
},{"./_string-html":121}],260:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export     = require('./_export')
  , toLength    = require('./_to-length')
  , context     = require('./_string-context')
  , STARTS_WITH = 'startsWith'
  , $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /*, position = 0 */){
    var that   = context(this, searchString, STARTS_WITH)
      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
      , search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});
},{"./_export":54,"./_fails-is-regexp":55,"./_string-context":120,"./_to-length":130}],261:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function(createHTML){
  return function strike(){
    return createHTML(this, 'strike', '', '');
  }
});
},{"./_string-html":121}],262:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function(createHTML){
  return function sub(){
    return createHTML(this, 'sub', '', '');
  }
});
},{"./_string-html":121}],263:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function(createHTML){
  return function sup(){
    return createHTML(this, 'sup', '', '');
  }
});
},{"./_string-html":121}],264:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function($trim){
  return function trim(){
    return $trim(this, 3);
  };
});
},{"./_string-trim":124}],265:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global         = require('./_global')
  , has            = require('./_has')
  , DESCRIPTORS    = require('./_descriptors')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , META           = require('./_meta').KEY
  , $fails         = require('./_fails')
  , shared         = require('./_shared')
  , setToStringTag = require('./_set-to-string-tag')
  , uid            = require('./_uid')
  , wks            = require('./_wks')
  , wksExt         = require('./_wks-ext')
  , wksDefine      = require('./_wks-define')
  , keyOf          = require('./_keyof')
  , enumKeys       = require('./_enum-keys')
  , isArray        = require('./_is-array')
  , anObject       = require('./_an-object')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , createDesc     = require('./_property-desc')
  , _create        = require('./_object-create')
  , gOPNExt        = require('./_object-gopn-ext')
  , $GOPD          = require('./_object-gopd')
  , $DP            = require('./_object-dp')
  , $keys          = require('./_object-keys')
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f  = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./_library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./_an-object":29,"./_descriptors":50,"./_enum-keys":53,"./_export":54,"./_fails":56,"./_global":60,"./_has":61,"./_hide":62,"./_is-array":69,"./_keyof":79,"./_library":80,"./_meta":84,"./_object-create":88,"./_object-dp":89,"./_object-gopd":92,"./_object-gopn":94,"./_object-gopn-ext":93,"./_object-gops":95,"./_object-keys":98,"./_object-pie":99,"./_property-desc":107,"./_redefine":109,"./_set-to-string-tag":114,"./_shared":116,"./_to-iobject":129,"./_to-primitive":132,"./_uid":136,"./_wks":139,"./_wks-define":137,"./_wks-ext":138}],266:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , $typed       = require('./_typed')
  , buffer       = require('./_typed-buffer')
  , anObject     = require('./_an-object')
  , toIndex      = require('./_to-index')
  , toLength     = require('./_to-length')
  , isObject     = require('./_is-object')
  , ArrayBuffer  = require('./_global').ArrayBuffer
  , speciesConstructor = require('./_species-constructor')
  , $ArrayBuffer = buffer.ArrayBuffer
  , $DataView    = buffer.DataView
  , $isView      = $typed.ABV && ArrayBuffer.isView
  , $slice       = $ArrayBuffer.prototype.slice
  , VIEW         = $typed.VIEW
  , ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it){
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function(){
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end){
    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
    var len    = anObject(this).byteLength
      , first  = toIndex(start, len)
      , final  = toIndex(end === undefined ? len : end, len)
      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
      , viewS  = new $DataView(this)
      , viewT  = new $DataView(result)
      , index  = 0;
    while(first < final){
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);
},{"./_an-object":29,"./_export":54,"./_fails":56,"./_global":60,"./_is-object":71,"./_set-species":113,"./_species-constructor":117,"./_to-index":127,"./_to-length":130,"./_typed":135,"./_typed-buffer":134}],267:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});
},{"./_export":54,"./_typed":135,"./_typed-buffer":134}],268:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function(init){
  return function Float32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":133}],269:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function(init){
  return function Float64Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":133}],270:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function(init){
  return function Int16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":133}],271:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function(init){
  return function Int32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":133}],272:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function(init){
  return function Int8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":133}],273:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function(init){
  return function Uint16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":133}],274:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function(init){
  return function Uint32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":133}],275:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function(init){
  return function Uint8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":133}],276:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function(init){
  return function Uint8ClampedArray(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
}, true);
},{"./_typed-array":133}],277:[function(require,module,exports){
'use strict';
var each         = require('./_array-methods')(0)
  , redefine     = require('./_redefine')
  , meta         = require('./_meta')
  , assign       = require('./_object-assign')
  , weak         = require('./_collection-weak')
  , isObject     = require('./_is-object')
  , getWeak      = meta.getWeak
  , isExtensible = Object.isExtensible
  , uncaughtFrozenStore = weak.ufstore
  , tmp          = {}
  , InternalMap;

var wrapper = function(get){
  return function WeakMap(){
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      var data = getWeak(key);
      if(data === true)return uncaughtFrozenStore(this).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')('WeakMap', wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  InternalMap = weak.getConstructor(wrapper);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    redefine(proto, key, function(a, b){
      // store frozen objects on internal weakmap shim
      if(isObject(a) && !isExtensible(a)){
        if(!this._f)this._f = new InternalMap;
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
},{"./_array-methods":34,"./_collection":44,"./_collection-weak":43,"./_is-object":71,"./_meta":84,"./_object-assign":87,"./_redefine":109}],278:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');

// 23.4 WeakSet Objects
require('./_collection')('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
},{"./_collection":44,"./_collection-weak":43}],279:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export   = require('./_export')
  , $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');
},{"./_add-to-unscopables":27,"./_array-includes":33,"./_export":54}],280:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export   = require('./_export')
  , microtask = require('./_microtask')()
  , process   = require('./_global').process
  , isNode    = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn){
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});
},{"./_cof":40,"./_export":54,"./_global":60,"./_microtask":86}],281:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export')
  , cof     = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it){
    return cof(it) === 'Error';
  }
});
},{"./_cof":40,"./_export":54}],282:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Map', {toJSON: require('./_collection-to-json')('Map')});
},{"./_collection-to-json":42,"./_export":54}],283:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});
},{"./_export":54}],284:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >> 16
      , v1 = $v >> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});
},{"./_export":54}],285:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});
},{"./_export":54}],286:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >>> 16
      , v1 = $v >>> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});
},{"./_export":54}],287:[function(require,module,exports){
'use strict';
var $export         = require('./_export')
  , toObject        = require('./_to-object')
  , aFunction       = require('./_a-function')
  , $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter){
    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
  }
});
},{"./_a-function":25,"./_descriptors":50,"./_export":54,"./_object-dp":89,"./_object-forced-pam":91,"./_to-object":131}],288:[function(require,module,exports){
'use strict';
var $export         = require('./_export')
  , toObject        = require('./_to-object')
  , aFunction       = require('./_a-function')
  , $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter){
    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
  }
});
},{"./_a-function":25,"./_descriptors":50,"./_export":54,"./_object-dp":89,"./_object-forced-pam":91,"./_to-object":131}],289:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export  = require('./_export')
  , $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./_export":54,"./_object-to-array":101}],290:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export        = require('./_export')
  , ownKeys        = require('./_own-keys')
  , toIObject      = require('./_to-iobject')
  , gOPD           = require('./_object-gopd')
  , createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O       = toIObject(object)
      , getDesc = gOPD.f
      , keys    = ownKeys(O)
      , result  = {}
      , i       = 0
      , key;
    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
    return result;
  }
});
},{"./_create-property":46,"./_export":54,"./_object-gopd":92,"./_own-keys":102,"./_to-iobject":129}],291:[function(require,module,exports){
'use strict';
var $export                  = require('./_export')
  , toObject                 = require('./_to-object')
  , toPrimitive              = require('./_to-primitive')
  , getPrototypeOf           = require('./_object-gpo')
  , getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.get;
    } while(O = getPrototypeOf(O));
  }
});
},{"./_descriptors":50,"./_export":54,"./_object-forced-pam":91,"./_object-gopd":92,"./_object-gpo":96,"./_to-object":131,"./_to-primitive":132}],292:[function(require,module,exports){
'use strict';
var $export                  = require('./_export')
  , toObject                 = require('./_to-object')
  , toPrimitive              = require('./_to-primitive')
  , getPrototypeOf           = require('./_object-gpo')
  , getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.set;
    } while(O = getPrototypeOf(O));
  }
});
},{"./_descriptors":50,"./_export":54,"./_object-forced-pam":91,"./_object-gopd":92,"./_object-gpo":96,"./_to-object":131,"./_to-primitive":132}],293:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export')
  , $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});
},{"./_export":54,"./_object-to-array":101}],294:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export     = require('./_export')
  , global      = require('./_global')
  , core        = require('./_core')
  , microtask   = require('./_microtask')()
  , OBSERVABLE  = require('./_wks')('observable')
  , aFunction   = require('./_a-function')
  , anObject    = require('./_an-object')
  , anInstance  = require('./_an-instance')
  , redefineAll = require('./_redefine-all')
  , hide        = require('./_hide')
  , forOf       = require('./_for-of')
  , RETURN      = forOf.RETURN;

var getMethod = function(fn){
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function(subscription){
  var cleanup = subscription._c;
  if(cleanup){
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function(subscription){
  return subscription._o === undefined;
};

var closeSubscription = function(subscription){
  if(!subscriptionClosed(subscription)){
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function(observer, subscriber){
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup      = subscriber(observer)
      , subscription = cleanup;
    if(cleanup != null){
      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch(e){
    observer.error(e);
    return;
  } if(subscriptionClosed(this))cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe(){ closeSubscription(this); }
});

var SubscriptionObserver = function(subscription){
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if(m)return m.call(observer, value);
      } catch(e){
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value){
    var subscription = this._s;
    if(subscriptionClosed(subscription))throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if(!m)throw value;
      value = m.call(observer, value);
    } catch(e){
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch(e){
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber){
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer){
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn){
    var that = this;
    return new (core.Promise || global.Promise)(function(resolve, reject){
      aFunction(fn);
      var subscription = that.subscribe({
        next : function(value){
          try {
            return fn(value);
          } catch(e){
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x){
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if(method){
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function(observer){
        return observable.subscribe(observer);
      });
    }
    return new C(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          try {
            if(forOf(x, false, function(it){
              observer.next(it);
              if(done)return RETURN;
            }) === RETURN)return;
          } catch(e){
            if(done)throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  },
  of: function of(){
    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          for(var i = 0; i < items.length; ++i){
            observer.next(items[i]);
            if(done)return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function(){ return this; });

$export($export.G, {Observable: $Observable});

require('./_set-species')('Observable');
},{"./_a-function":25,"./_an-instance":28,"./_an-object":29,"./_core":45,"./_export":54,"./_for-of":59,"./_global":60,"./_hide":62,"./_microtask":86,"./_redefine-all":108,"./_set-species":113,"./_wks":139}],295:[function(require,module,exports){
var metadata                  = require('./_metadata')
  , anObject                  = require('./_an-object')
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
}});
},{"./_an-object":29,"./_metadata":85}],296:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , toMetaKey              = metadata.key
  , getOrCreateMetadataMap = metadata.map
  , store                  = metadata.store;

metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
  if(metadataMap.size)return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
}});
},{"./_an-object":29,"./_metadata":85}],297:[function(require,module,exports){
var Set                     = require('./es6.set')
  , from                    = require('./_array-from-iterable')
  , metadata                = require('./_metadata')
  , anObject                = require('./_an-object')
  , getPrototypeOf          = require('./_object-gpo')
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

var ordinaryMetadataKeys = function(O, P){
  var oKeys  = ordinaryOwnMetadataKeys(O, P)
    , parent = getPrototypeOf(O);
  if(parent === null)return oKeys;
  var pKeys  = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});
},{"./_an-object":29,"./_array-from-iterable":32,"./_metadata":85,"./_object-gpo":96,"./es6.set":242}],298:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , getPrototypeOf         = require('./_object-gpo')
  , ordinaryHasOwnMetadata = metadata.has
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

var ordinaryGetMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":29,"./_metadata":85,"./_object-gpo":96}],299:[function(require,module,exports){
var metadata                = require('./_metadata')
  , anObject                = require('./_an-object')
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});
},{"./_an-object":29,"./_metadata":85}],300:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":29,"./_metadata":85}],301:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , getPrototypeOf         = require('./_object-gpo')
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

var ordinaryHasMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":29,"./_metadata":85,"./_object-gpo":96}],302:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":29,"./_metadata":85}],303:[function(require,module,exports){
var metadata                  = require('./_metadata')
  , anObject                  = require('./_an-object')
  , aFunction                 = require('./_a-function')
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({metadata: function metadata(metadataKey, metadataValue){
  return function decorator(target, targetKey){
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
}});
},{"./_a-function":25,"./_an-object":29,"./_metadata":85}],304:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Set', {toJSON: require('./_collection-to-json')('Set')});
},{"./_collection-to-json":42,"./_export":54}],305:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export')
  , $at     = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
},{"./_export":54,"./_string-at":119}],306:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export     = require('./_export')
  , defined     = require('./_defined')
  , toLength    = require('./_to-length')
  , isRegExp    = require('./_is-regexp')
  , getFlags    = require('./_flags')
  , RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function(regexp, string){
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next(){
  var match = this._r.exec(this._s);
  return {value: match, done: match === null};
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp){
    defined(this);
    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
    var S     = String(this)
      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});
},{"./_defined":49,"./_export":54,"./_flags":58,"./_is-regexp":72,"./_iter-create":74,"./_to-length":130}],307:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export')
  , $pad    = require('./_string-pad');

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});
},{"./_export":54,"./_string-pad":122}],308:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export')
  , $pad    = require('./_string-pad');

$export($export.P, 'String', {
  padStart: function padStart(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});
},{"./_export":54,"./_string-pad":122}],309:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function($trim){
  return function trimLeft(){
    return $trim(this, 1);
  };
}, 'trimStart');
},{"./_string-trim":124}],310:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function($trim){
  return function trimRight(){
    return $trim(this, 2);
  };
}, 'trimEnd');
},{"./_string-trim":124}],311:[function(require,module,exports){
require('./_wks-define')('asyncIterator');
},{"./_wks-define":137}],312:[function(require,module,exports){
require('./_wks-define')('observable');
},{"./_wks-define":137}],313:[function(require,module,exports){
// https://github.com/ljharb/proposal-global
var $export = require('./_export');

$export($export.S, 'System', {global: require('./_global')});
},{"./_export":54,"./_global":60}],314:[function(require,module,exports){
var $iterators    = require('./es6.array.iterator')
  , redefine      = require('./_redefine')
  , global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , wks           = require('./_wks')
  , ITERATOR      = wks('iterator')
  , TO_STRING_TAG = wks('toStringTag')
  , ArrayValues   = Iterators.Array;

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype
    , key;
  if(proto){
    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
  }
}
},{"./_global":60,"./_hide":62,"./_iterators":78,"./_redefine":109,"./_wks":139,"./es6.array.iterator":152}],315:[function(require,module,exports){
var $export = require('./_export')
  , $task   = require('./_task');
$export($export.G + $export.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
},{"./_export":54,"./_task":126}],316:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global     = require('./_global')
  , $export    = require('./_export')
  , invoke     = require('./_invoke')
  , partial    = require('./_partial')
  , navigator  = global.navigator
  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      typeof fn == 'function' ? fn : Function(fn)
    ), time);
  } : set;
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout:  wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});
},{"./_export":54,"./_global":60,"./_invoke":66,"./_partial":105}],317:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.umulh');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');
},{"./modules/_core":45,"./modules/es6.array.copy-within":142,"./modules/es6.array.every":143,"./modules/es6.array.fill":144,"./modules/es6.array.filter":145,"./modules/es6.array.find":147,"./modules/es6.array.find-index":146,"./modules/es6.array.for-each":148,"./modules/es6.array.from":149,"./modules/es6.array.index-of":150,"./modules/es6.array.is-array":151,"./modules/es6.array.iterator":152,"./modules/es6.array.join":153,"./modules/es6.array.last-index-of":154,"./modules/es6.array.map":155,"./modules/es6.array.of":156,"./modules/es6.array.reduce":158,"./modules/es6.array.reduce-right":157,"./modules/es6.array.slice":159,"./modules/es6.array.some":160,"./modules/es6.array.sort":161,"./modules/es6.array.species":162,"./modules/es6.date.now":163,"./modules/es6.date.to-iso-string":164,"./modules/es6.date.to-json":165,"./modules/es6.date.to-primitive":166,"./modules/es6.date.to-string":167,"./modules/es6.function.bind":168,"./modules/es6.function.has-instance":169,"./modules/es6.function.name":170,"./modules/es6.map":171,"./modules/es6.math.acosh":172,"./modules/es6.math.asinh":173,"./modules/es6.math.atanh":174,"./modules/es6.math.cbrt":175,"./modules/es6.math.clz32":176,"./modules/es6.math.cosh":177,"./modules/es6.math.expm1":178,"./modules/es6.math.fround":179,"./modules/es6.math.hypot":180,"./modules/es6.math.imul":181,"./modules/es6.math.log10":182,"./modules/es6.math.log1p":183,"./modules/es6.math.log2":184,"./modules/es6.math.sign":185,"./modules/es6.math.sinh":186,"./modules/es6.math.tanh":187,"./modules/es6.math.trunc":188,"./modules/es6.number.constructor":189,"./modules/es6.number.epsilon":190,"./modules/es6.number.is-finite":191,"./modules/es6.number.is-integer":192,"./modules/es6.number.is-nan":193,"./modules/es6.number.is-safe-integer":194,"./modules/es6.number.max-safe-integer":195,"./modules/es6.number.min-safe-integer":196,"./modules/es6.number.parse-float":197,"./modules/es6.number.parse-int":198,"./modules/es6.number.to-fixed":199,"./modules/es6.number.to-precision":200,"./modules/es6.object.assign":201,"./modules/es6.object.create":202,"./modules/es6.object.define-properties":203,"./modules/es6.object.define-property":204,"./modules/es6.object.freeze":205,"./modules/es6.object.get-own-property-descriptor":206,"./modules/es6.object.get-own-property-names":207,"./modules/es6.object.get-prototype-of":208,"./modules/es6.object.is":212,"./modules/es6.object.is-extensible":209,"./modules/es6.object.is-frozen":210,"./modules/es6.object.is-sealed":211,"./modules/es6.object.keys":213,"./modules/es6.object.prevent-extensions":214,"./modules/es6.object.seal":215,"./modules/es6.object.set-prototype-of":216,"./modules/es6.object.to-string":217,"./modules/es6.parse-float":218,"./modules/es6.parse-int":219,"./modules/es6.promise":220,"./modules/es6.reflect.apply":221,"./modules/es6.reflect.construct":222,"./modules/es6.reflect.define-property":223,"./modules/es6.reflect.delete-property":224,"./modules/es6.reflect.enumerate":225,"./modules/es6.reflect.get":228,"./modules/es6.reflect.get-own-property-descriptor":226,"./modules/es6.reflect.get-prototype-of":227,"./modules/es6.reflect.has":229,"./modules/es6.reflect.is-extensible":230,"./modules/es6.reflect.own-keys":231,"./modules/es6.reflect.prevent-extensions":232,"./modules/es6.reflect.set":234,"./modules/es6.reflect.set-prototype-of":233,"./modules/es6.regexp.constructor":235,"./modules/es6.regexp.flags":236,"./modules/es6.regexp.match":237,"./modules/es6.regexp.replace":238,"./modules/es6.regexp.search":239,"./modules/es6.regexp.split":240,"./modules/es6.regexp.to-string":241,"./modules/es6.set":242,"./modules/es6.string.anchor":243,"./modules/es6.string.big":244,"./modules/es6.string.blink":245,"./modules/es6.string.bold":246,"./modules/es6.string.code-point-at":247,"./modules/es6.string.ends-with":248,"./modules/es6.string.fixed":249,"./modules/es6.string.fontcolor":250,"./modules/es6.string.fontsize":251,"./modules/es6.string.from-code-point":252,"./modules/es6.string.includes":253,"./modules/es6.string.italics":254,"./modules/es6.string.iterator":255,"./modules/es6.string.link":256,"./modules/es6.string.raw":257,"./modules/es6.string.repeat":258,"./modules/es6.string.small":259,"./modules/es6.string.starts-with":260,"./modules/es6.string.strike":261,"./modules/es6.string.sub":262,"./modules/es6.string.sup":263,"./modules/es6.string.trim":264,"./modules/es6.symbol":265,"./modules/es6.typed.array-buffer":266,"./modules/es6.typed.data-view":267,"./modules/es6.typed.float32-array":268,"./modules/es6.typed.float64-array":269,"./modules/es6.typed.int16-array":270,"./modules/es6.typed.int32-array":271,"./modules/es6.typed.int8-array":272,"./modules/es6.typed.uint16-array":273,"./modules/es6.typed.uint32-array":274,"./modules/es6.typed.uint8-array":275,"./modules/es6.typed.uint8-clamped-array":276,"./modules/es6.weak-map":277,"./modules/es6.weak-set":278,"./modules/es7.array.includes":279,"./modules/es7.asap":280,"./modules/es7.error.is-error":281,"./modules/es7.map.to-json":282,"./modules/es7.math.iaddh":283,"./modules/es7.math.imulh":284,"./modules/es7.math.isubh":285,"./modules/es7.math.umulh":286,"./modules/es7.object.define-getter":287,"./modules/es7.object.define-setter":288,"./modules/es7.object.entries":289,"./modules/es7.object.get-own-property-descriptors":290,"./modules/es7.object.lookup-getter":291,"./modules/es7.object.lookup-setter":292,"./modules/es7.object.values":293,"./modules/es7.observable":294,"./modules/es7.reflect.define-metadata":295,"./modules/es7.reflect.delete-metadata":296,"./modules/es7.reflect.get-metadata":298,"./modules/es7.reflect.get-metadata-keys":297,"./modules/es7.reflect.get-own-metadata":300,"./modules/es7.reflect.get-own-metadata-keys":299,"./modules/es7.reflect.has-metadata":301,"./modules/es7.reflect.has-own-metadata":302,"./modules/es7.reflect.metadata":303,"./modules/es7.set.to-json":304,"./modules/es7.string.at":305,"./modules/es7.string.match-all":306,"./modules/es7.string.pad-end":307,"./modules/es7.string.pad-start":308,"./modules/es7.string.trim-left":309,"./modules/es7.string.trim-right":310,"./modules/es7.symbol.async-iterator":311,"./modules/es7.symbol.observable":312,"./modules/es7.system.global":313,"./modules/web.dom.iterable":314,"./modules/web.immediate":315,"./modules/web.timers":316}],318:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],319:[function(require,module,exports){
'use strict';

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],320:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],321:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":322}],322:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],323:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = arg;

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":322}],324:[function(require,module,exports){
(function (Buffer){
/**
 * Bitcoin Address
 * ===============
 *
 * A bitcoin address. Normal use cases:
 * let address = new Address().fromPubKey(pubKey)
 * let address = new Address().fromRedeemScript(script)
 * let address = new Address().fromString(string)
 * let string = address.toString()
 * let script = address.toScript()
 * let isValid = Address.isValid(string)
 *
 * Can also do testnet:
 * let address = Address.Testnet()
 *
 * Note that an Address and an Addr are two completely different things. An
 * Address is what you send bitcoin to. An Addr is an ip address and port that
 * you connect to over the internet.
 */
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Base58Check: require('./base-58-check'),
  Constants: require('./constants').Default.Address,
  Hash: require('./hash'),
  OpCode: require('./op-code'),
  PubKey: require('./pub-key'),
  Script: require('./script'),
  Struct: require('./struct'),
  Workers: require('./workers'),
  asink: require('asink')
};

var inject = function inject(deps) {
  var Base58Check = deps.Base58Check;
  var Constants = deps.Constants;
  var Hash = deps.Hash;
  var OpCode = deps.OpCode;
  var PubKey = deps.PubKey;
  var Script = deps.Script;
  var Struct = deps.Struct;
  var Workers = deps.Workers;
  var asink = deps.asink;

  var Address = function (_Struct) {
    _inherits(Address, _Struct);

    function Address(versionByteNum, hashBuf) {
      _classCallCheck(this, Address);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Address).call(this, { versionByteNum: versionByteNum, hashBuf: hashBuf }));
    }

    _createClass(Address, [{
      key: 'fromBuffer',
      value: function fromBuffer(buf) {
        if (buf.length !== 1 + 20) {
          throw new Error('address buffers must be exactly 21 bytes');
        }
        if (buf[0] !== Constants.pubKeyHash && buf[0] !== Constants.scriptHash) {
          throw new Error('address: invalid versionByteNum byte');
        }
        this.versionByteNum = buf[0];
        this.hashBuf = buf.slice(1);
        return this;
      }
    }, {
      key: 'fromPubKeyHashBuf',
      value: function fromPubKeyHashBuf(hashBuf) {
        this.hashBuf = hashBuf;
        this.versionByteNum = Constants['pubKeyHash'];
        return this;
      }
    }, {
      key: 'fromPubKey',
      value: function fromPubKey(pubKey) {
        var hashBuf = Hash.sha256Ripemd160(pubKey.toBuffer());
        return this.fromPubKeyHashBuf(hashBuf);
      }
    }, {
      key: 'asyncFromPubKey',
      value: function asyncFromPubKey(pubKey) {
        return asink(regeneratorRuntime.mark(function _callee() {
          var args, workersResult;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  args = [pubKey];
                  _context.next = 3;
                  return Workers.asyncObjectMethod(this, 'fromPubKey', args);

                case 3:
                  workersResult = _context.sent;
                  return _context.abrupt('return', this.fromFastBuffer(workersResult.resbuf));

                case 5:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }), this);
      }
    }, {
      key: 'fromPrivKey',
      value: function fromPrivKey(privKey) {
        var pubKey = new PubKey().fromPrivKey(privKey);
        var hashBuf = Hash.sha256Ripemd160(pubKey.toBuffer());
        return this.fromPubKeyHashBuf(hashBuf);
      }
    }, {
      key: 'asyncFromPrivKey',
      value: function asyncFromPrivKey(privKey) {
        return asink(regeneratorRuntime.mark(function _callee2() {
          var args, workersResult;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  args = [privKey];
                  _context2.next = 3;
                  return Workers.asyncObjectMethod(this, 'fromPrivKey', args);

                case 3:
                  workersResult = _context2.sent;
                  return _context2.abrupt('return', this.fromFastBuffer(workersResult.resbuf));

                case 5:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }), this);
      }
    }, {
      key: 'fromRedeemScriptHashBuf',
      value: function fromRedeemScriptHashBuf(hashBuf) {
        this.hashBuf = hashBuf;
        var typeStr = 'scriptHash';
        this.versionByteNum = Constants[typeStr];
        return this;
      }
    }, {
      key: 'fromRedeemScript',
      value: function fromRedeemScript(script) {
        var hashBuf = Hash.sha256Ripemd160(script.toBuffer());
        return this.fromRedeemScriptHashBuf(hashBuf);
      }
    }, {
      key: 'asyncFromRedeemScript',
      value: function asyncFromRedeemScript(script) {
        return asink(regeneratorRuntime.mark(function _callee3() {
          var args, workersResult;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  args = [script];
                  _context3.next = 3;
                  return Workers.asyncObjectMethod(this, 'fromRedeemScript', args);

                case 3:
                  workersResult = _context3.sent;
                  return _context3.abrupt('return', this.fromFastBuffer(workersResult.resbuf));

                case 5:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }), this);
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        var buf = Base58Check.decode(str);
        return this.fromBuffer(buf);
      }
    }, {
      key: 'asyncFromString',
      value: function asyncFromString(str) {
        return asink(regeneratorRuntime.mark(function _callee4() {
          var args, workersResult;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  args = [str];
                  _context4.next = 3;
                  return Workers.asyncObjectMethod(this, 'fromString', args);

                case 3:
                  workersResult = _context4.sent;
                  return _context4.abrupt('return', this.fromFastBuffer(workersResult.resbuf));

                case 5:
                case 'end':
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }), this);
      }
    }, {
      key: 'isValid',
      value: function isValid() {
        try {
          this.validate();
          return true;
        } catch (e) {
          return false;
        }
      }
    }, {
      key: 'type',
      value: function type() {
        if (this.versionByteNum === Constants['pubKeyHash']) {
          return 'pubKeyHash';
        } else if (this.versionByteNum === Constants['scriptHash']) {
          return 'scriptHash';
        } else {
          return 'unknown';
        }
      }
    }, {
      key: 'toScript',
      value: function toScript() {
        var type = this.type();
        var script = void 0;
        if (type === 'pubKeyHash') {
          script = new Script();
          script.writeOpCode(OpCode.OP_DUP);
          script.writeOpCode(OpCode.OP_HASH160);
          script.writeBuffer(this.hashBuf);
          script.writeOpCode(OpCode.OP_EQUALVERIFY);
          script.writeOpCode(OpCode.OP_CHECKSIG);
        } else if (type === 'scriptHash') {
          script = new Script();
          script.writeOpCode(OpCode.OP_HASH160);
          script.writeBuffer(this.hashBuf);
          script.writeOpCode(OpCode.OP_EQUAL);
        } else {
          throw new Error('script must be either pubKeyHash or scriptHash');
        }
        return script;
      }
    }, {
      key: 'toBuffer',
      value: function toBuffer() {
        var versionByteBuf = new Buffer([this.versionByteNum]);
        var buf = Buffer.concat([versionByteBuf, this.hashBuf]);
        return buf;
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        var json = {};
        if (this.hashBuf) {
          json.hashBuf = this.hashBuf.toString('hex');
        }
        if (_typeof(this.versionByteNum) !== undefined) {
          json.versionByteNum = this.versionByteNum;
        }
        return json;
      }
    }, {
      key: 'fromJSON',
      value: function fromJSON(json) {
        if (json.hashBuf) {
          this.hashBuf = new Buffer(json.hashBuf, 'hex');
        }
        if (_typeof(json.versionByteNum) !== undefined) {
          this.versionByteNum = json.versionByteNum;
        }
        return this;
      }
    }, {
      key: 'toString',
      value: function toString() {
        return Base58Check.encode(this.toBuffer());
      }
    }, {
      key: 'asyncToString',
      value: function asyncToString() {
        return asink(regeneratorRuntime.mark(function _callee5() {
          var args, workersResult;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  args = [];
                  _context5.next = 3;
                  return Workers.asyncObjectMethod(this, 'toString', args);

                case 3:
                  workersResult = _context5.sent;
                  return _context5.abrupt('return', JSON.parse(workersResult.resbuf.toString()));

                case 5:
                case 'end':
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }), this);
      }
    }, {
      key: 'validate',
      value: function validate() {
        if (!Buffer.isBuffer(this.hashBuf) || this.hashBuf.length !== 20) {
          throw new Error('hashBuf must be a buffer of 20 bytes');
        }
        if (this.versionByteNum !== Constants['pubKeyHash'] && this.versionByteNum !== Constants['scriptHash']) {
          throw new Error('invalid versionByteNum');
        }
        return this;
      }
    }], [{
      key: 'fromPubKeyHashBuf',
      value: function fromPubKeyHashBuf(hashBuf) {
        return new this().fromPubKeyHashBuf(hashBuf);
      }
    }, {
      key: 'fromPubKey',
      value: function fromPubKey(pubKey) {
        return new this().fromPubKey(pubKey);
      }
    }, {
      key: 'asyncFromPubKey',
      value: function asyncFromPubKey(pubKey) {
        return new this().asyncFromPubKey(pubKey);
      }
    }, {
      key: 'fromPrivKey',
      value: function fromPrivKey(privKey) {
        return new this().fromPrivKey(privKey);
      }
    }, {
      key: 'asyncFromPrivKey',
      value: function asyncFromPrivKey(privKey) {
        return new this().fromPrivKey(privKey);
      }
    }, {
      key: 'fromRedeemScriptHashBuf',
      value: function fromRedeemScriptHashBuf(hashBuf) {
        return new this().fromRedeemScriptHashBuf(hashBuf);
      }
    }, {
      key: 'fromRedeemScript',
      value: function fromRedeemScript(script) {
        return new this().fromRedeemScript(script);
      }
    }, {
      key: 'asyncFromRedeemScript',
      value: function asyncFromRedeemScript(script) {
        return new this().asyncFromRedeemScript(script);
      }
    }, {
      key: 'asyncFromString',
      value: function asyncFromString(str) {
        return new this().asyncFromString(str);
      }
    }, {
      key: 'isValid',
      value: function isValid(addrstr) {
        var address = void 0;
        try {
          address = new Address().fromString(addrstr);
        } catch (e) {
          return false;
        }
        return address.isValid();
      }
    }]);

    return Address;
  }(Struct);

  return Address;
};

inject = require('injecter')(inject, dependencies);
var Address = inject();
Address.Mainnet = inject({
  Constants: require('./constants').Mainnet.Address
});
Address.Testnet = inject({
  Constants: require('./constants').Testnet.Address
});
module.exports = Address;

}).call(this,require("buffer").Buffer)

},{"./base-58-check":325,"./constants":331,"./hash":333,"./op-code":335,"./pub-key":338,"./script":340,"./struct":342,"./workers":351,"asink":352,"buffer":23,"injecter":381}],325:[function(require,module,exports){
(function (Buffer){
/**
 * Base58 Check Encoding
 * =====================
 *
 * Base58 check encoding. The usual way to use it is
 * new Base58Check(buf).toString() or new Base58Check(str).toBuffer().
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Base58: require('./base-58'),
  cmp: require('./cmp'),
  Hash: require('./hash'),
  Struct: require('./struct')
};

var inject = function inject(deps) {
  var Base58 = deps.Base58;
  var cmp = deps.cmp;
  var Hash = deps.Hash;
  var Struct = deps.Struct;

  var Base58Check = function (_Struct) {
    _inherits(Base58Check, _Struct);

    function Base58Check(buf) {
      _classCallCheck(this, Base58Check);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Base58Check).call(this, { buf: buf }));
    }

    _createClass(Base58Check, [{
      key: 'fromHex',
      value: function fromHex(hex) {
        return this.fromBuffer(new Buffer(hex, 'hex'));
      }
    }, {
      key: 'toHex',
      value: function toHex() {
        return this.toBuffer().toString('hex');
      }
    }, {
      key: 'fromBuffer',
      value: function fromBuffer(buf) {
        this.buf = buf;
        return this;
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        var buf = Base58Check.decode(str);
        this.buf = buf;
        return this;
      }
    }, {
      key: 'toBuffer',
      value: function toBuffer() {
        return this.buf;
      }
    }, {
      key: 'toString',
      value: function toString() {
        return Base58Check.encode(this.buf);
      }
    }], [{
      key: 'decode',
      value: function decode(s) {
        if (typeof s !== 'string') {
          throw new Error('Input must be a string');
        }

        var buf = Base58.decode(s);

        if (buf.length < 4) {
          throw new Error('Input string too short');
        }

        var data = buf.slice(0, -4);
        var csum = buf.slice(-4);

        var hash = Hash.sha256Sha256(data);
        var hash4 = hash.slice(0, 4);

        if (!cmp(csum, hash4)) {
          throw new Error('Checksum mismatch');
        }

        return data;
      }
    }, {
      key: 'encode',
      value: function encode(buf) {
        if (!Buffer.isBuffer(buf)) {
          throw new Error('Input must be a buffer');
        }
        var checkedBuf = new Buffer(buf.length + 4);
        var hash = Hash.sha256Sha256(buf);
        buf.copy(checkedBuf);
        hash.copy(checkedBuf, buf.length);
        return Base58.encode(checkedBuf);
      }
    }]);

    return Base58Check;
  }(Struct);

  return Base58Check;
};

inject = require('injecter')(inject, dependencies);
var Base58Check = inject();
module.exports = Base58Check;

}).call(this,require("buffer").Buffer)

},{"./base-58":326,"./cmp":330,"./hash":333,"./struct":342,"buffer":23,"injecter":381}],326:[function(require,module,exports){
(function (Buffer){
/**
 * Base58 Encoding
 * ===============
 *
 * Base58 (no check)
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  bs58: require('bs58'),
  Struct: require('./struct')
};

var inject = function inject(deps) {
  var bs58 = deps.bs58;
  var Struct = deps.Struct;

  var Base58 = function (_Struct) {
    _inherits(Base58, _Struct);

    function Base58(buf) {
      _classCallCheck(this, Base58);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Base58).call(this, { buf: buf }));
    }

    _createClass(Base58, [{
      key: 'fromHex',
      value: function fromHex(hex) {
        return this.fromBuffer(new Buffer(hex, 'hex'));
      }
    }, {
      key: 'toHex',
      value: function toHex() {
        return this.toBuffer().toString('hex');
      }
    }, {
      key: 'fromBuffer',
      value: function fromBuffer(buf) {
        this.buf = buf;
        return this;
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        var buf = Base58.decode(str);
        this.buf = buf;
        return this;
      }
    }, {
      key: 'toBuffer',
      value: function toBuffer() {
        return this.buf;
      }
    }, {
      key: 'toString',
      value: function toString() {
        return Base58.encode(this.buf);
      }
    }], [{
      key: 'encode',
      value: function encode(buf) {
        if (!Buffer.isBuffer(buf)) {
          throw new Error('Input should be a buffer');
        }
        return bs58.encode(buf);
      }
    }, {
      key: 'decode',
      value: function decode(str) {
        if (typeof str !== 'string') {
          throw new Error('Input should be a string');
        }
        return new Buffer(bs58.decode(str));
      }
    }]);

    return Base58;
  }(Struct);

  return Base58;
};

inject = require('injecter')(inject, dependencies);
var Base58 = inject();
module.exports = Base58;

}).call(this,require("buffer").Buffer)

},{"./struct":342,"bs58":356,"buffer":23,"injecter":381}],327:[function(require,module,exports){
(function (Buffer){
/**
 * Big Number
 * ==========
 *
 * Since javascript numbers are only precise up to 53 bits, and bitcoin is
 * based on cryptography that uses 256 bit numbers, we must use a big number
 * library. The library we use at the moment is Fedor Indutny's bn.js library.
 * Since big numbers are extremely useful, we provide some very basic wrappers
 * for his big number class and expose it. The wrappers merely allow you to do,
 * say, bn.cmp(num) instead of just bn.cmp(bn), which is nice. The primary way
 * to use this is:
 * let bn = BN(str) // str is base 10
 * let bn = BN(num)
 * let bn = BN().fromBuffer(buf)
 * let bn = BN().fromSm(buf); // sign+magnitude format, first bit is sign
 *
 * For little endian, pass in an options value:
 * let bn = BN().fromBuffer(buf, {endian: 'little'})
 * let bn = BN().fromSm(buf, {endian: 'little'})
 *
 * Getting output:
 * let str = BN().toString() // produces base 10 string
 * let buf = BN().toBuffer() // produces buffer representation
 * let buf = BN().toBuffer({size: 32}) //produced 32 byte buffer
 */
'use strict';

var dependencies = {
  _BN: require('bn.js')
};

var inject = function inject(deps) {
  var _BN = deps._BN;

  function BN(n, base) {
    for (var _len = arguments.length, rest = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      rest[_key - 2] = arguments[_key];
    }

    if (!(this instanceof BN)) {
      return new (Function.prototype.bind.apply(BN, [null].concat([n, base], rest)))();
    }
    _BN.call.apply(_BN, [this, n, base].concat(rest));
  }

  Object.keys(_BN).forEach(function (key) {
    BN[key] = _BN[key];
  });
  BN.prototype = Object.create(_BN.prototype);
  BN.prototype.constructor = BN;

  function reverseBuf(buf) {
    var buf2 = new Buffer(buf.length);
    for (var i = 0; i < buf.length; i++) {
      buf2[i] = buf[buf.length - 1 - i];
    }
    return buf2;
  }

  BN.prototype.fromHex = function (hex, opts) {
    return this.fromBuffer(new Buffer(hex, 'hex'), opts);
  };

  BN.prototype.toHex = function (opts) {
    return this.toBuffer(opts).toString('hex');
  };

  BN.prototype.toJSON = function () {
    return this.toString();
  };

  BN.prototype.fromJSON = function (str) {
    var bn = BN(str);
    bn.copy(this);
    return this;
  };

  BN.prototype.fromNumber = function (n) {
    var bn = BN(n);
    bn.copy(this);
    return this;
  };

  BN.prototype.toNumber = function () {
    return parseInt(this['toString'](10), 10);
  };

  BN.prototype.fromString = function (str, base) {
    var bn = BN(str, base);
    bn.copy(this);
    return this;
  };

  BN.fromBuffer = function (buf) {
    var opts = arguments.length <= 1 || arguments[1] === undefined ? { endian: 'big' } : arguments[1];

    if (opts.endian === 'little') {
      buf = reverseBuf(buf);
    }
    var hex = buf.toString('hex');
    var bn = new BN(hex, 16);
    return bn;
  };

  BN.prototype.fromBuffer = function (buf, opts) {
    var bn = BN.fromBuffer(buf, opts);
    bn.copy(this);

    return this;
  };

  BN.prototype.toBuffer = function () {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? { size: undefined, endian: 'big' } : arguments[0];

    var buf = void 0;
    if (opts.size) {
      var hex = this.toString(16, 2);
      var natlen = hex.length / 2;
      buf = new Buffer(hex, 'hex');

      if (natlen === opts.size) {
        // pass
      } else if (natlen > opts.size) {
        buf = buf.slice(natlen - buf.length, buf.length);
      } else if (natlen < opts.size) {
        var rbuf = new Buffer(opts.size);
        for (var i = 0; i < buf.length; i++) {
          rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];
        }
        for (var _i = 0; _i < opts.size - natlen; _i++) {
          rbuf[_i] = 0;
        }
        buf = rbuf;
      }
    } else {
      var _hex = this.toString(16, 2);
      buf = new Buffer(_hex, 'hex');
    }

    if (opts.endian === 'little') {
      buf = reverseBuf(buf);
    }
    var longzero = new Buffer([0]);
    if (Buffer.compare(buf, longzero) === 0) {
      return new Buffer([]);
    }
    return buf;
  };

  /**
   * Signed magnitude buffer. Most significant bit represents sign (0 = positive,
   * 1 = negative).
   */
  BN.prototype.fromSm = function (buf) {
    var opts = arguments.length <= 1 || arguments[1] === undefined ? { endian: 'big' } : arguments[1];

    if (buf.length === 0) {
      this.fromBuffer(new Buffer([0]));
    }

    var endian = opts.endian;
    if (endian === 'little') {
      buf = reverseBuf(buf);
    }

    if (buf[0] & 0x80) {
      buf[0] = buf[0] & 0x7f;
      this.fromBuffer(buf);
      this.neg().copy(this);
    } else {
      this.fromBuffer(buf);
    }
    return this;
  };

  BN.prototype.toSm = function () {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? { endian: 'big' } : arguments[0];

    var endian = opts.endian;

    var buf = void 0;
    if (this.cmp(0) === -1) {
      buf = this.neg().toBuffer();
      if (buf[0] & 0x80) {
        buf = Buffer.concat([new Buffer([0x80]), buf]);
      } else {
        buf[0] = buf[0] | 0x80;
      }
    } else {
      buf = this.toBuffer();
      if (buf[0] & 0x80) {
        buf = Buffer.concat([new Buffer([0x00]), buf]);
      }
    }

    if (buf.length === 1 & buf[0] === 0) {
      buf = new Buffer([]);
    }

    if (endian === 'little') {
      buf = reverseBuf(buf);
    }

    return buf;
  };

  /**
   * Produce a BN from the "bits" value in a blockheader. Analagous to Bitcoin
   * Core's uint256 SetCompact method. bits is assumed to be UInt32.
   */
  BN.prototype.fromBits = function (bits) {
    var opts = arguments.length <= 1 || arguments[1] === undefined ? { strict: false } : arguments[1];

    // To performed bitwise operations in javascript, we need to convert to a
    // signed 32 bit value.
    var buf = new Buffer(4);
    buf.writeUInt32BE(bits, 0);
    bits = buf.readInt32BE(0);
    if (opts.strict && bits & 0x00800000) {
      throw new Error('negative bit set');
    }
    var nsize = bits >> 24;
    var nword = bits & 0x007fffff;
    buf = new Buffer(4);
    buf.writeInt32BE(nword);
    if (nsize <= 3) {
      buf = buf.slice(1, nsize + 1);
    } else {
      var fill = new Buffer(nsize - 3);
      fill.fill(0);
      buf = Buffer.concat([buf, fill]);
    }
    this.fromBuffer(buf);
    if (bits & 0x00800000) {
      BN(0).sub(this).copy(this);
    }
    return this;
  };

  /**
   * Convert BN to the "bits" value in a blockheader. Analagous to Bitcoin
   * Core's uint256 GetCompact method. bits is a UInt32.
   */
  BN.prototype.toBits = function () {
    var buf = void 0;
    if (this.lt(0)) {
      buf = this.neg().toBuffer();
    } else {
      buf = this.toBuffer();
    }
    var nsize = buf.length;
    var nword = void 0;
    if (nsize > 3) {
      nword = Buffer.concat([new Buffer([0]), buf.slice(0, 3)]).readUInt32BE(0);
    } else if (nsize <= 3) {
      var blank = new Buffer(3 - nsize + 1);
      blank.fill(0);
      nword = Buffer.concat([blank, buf.slice(0, nsize)]).readUInt32BE(0);
    }
    if (nword & 0x00800000) {
      // The most significant bit denotes sign. Do not want unless number is
      // actually negative.
      nword >>= 8;
      nsize++;
    }
    if (this.lt(0)) {
      nword |= 0x00800000;
    }
    var bits = nsize << 24 | nword;
    // convert bits to UInt32 before returnIng
    buf = new Buffer(4);
    buf.writeInt32BE(bits, 0);
    return buf.readUInt32BE(0);
  };

  // This is analogous to the constructor for CScriptNum in bitcoind. Many ops
  // in bitcoind's script interpreter use CScriptNum, which is not really a
  // proper bignum. Instead, an error is thrown if trying to input a number
  // bigger than 4 bytes. We copy that behavior here. There is one exception -
  // in CHECKLOCKTIMEVERIFY, the numbers are allowed to be up to 5 bytes long.
  // We allow for setting that variable here for use in CHECKLOCKTIMEVERIFY.
  BN.prototype.fromScriptNumBuffer = function (buf, fRequireMinimal, nMaxNumSize) {
    if (nMaxNumSize === undefined) {
      nMaxNumSize = 4;
    }
    if (buf.length > nMaxNumSize) {
      throw new Error('script number overflow');
    }
    if (fRequireMinimal && buf.length > 0) {
      // Check that the number is encoded with the minimum possible
      // number of bytes.
      //
      // If the most-significant-byte - excluding the sign bit - is zero
      // then we're not minimal. Note how this test also rejects the
      // negative-zero encoding, 0x80.
      if ((buf[buf.length - 1] & 0x7f) === 0) {
        // One exception: if there's more than one byte and the most
        // significant bit of the second-most-significant-byte is set
        // it would conflict with the sign bit. An example of this case
        // is +-255, which encode to 0xff00 and 0xff80 respectively.
        // (big-endian).
        if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {
          throw new Error('non-minimally encoded script number');
        }
      }
    }
    return this.fromSm(buf, { endian: 'little' });
  };

  // The corollary to the above, with the notable exception that we do not throw
  // an error if the output is larger than four bytes. (Which can happen if
  // performing a numerical operation that results in an overflow to more than 4
  // bytes).
  BN.prototype.toScriptNumBuffer = function (buf) {
    return this.toSm({ endian: 'little' });
  };

  BN.prototype.neg = function () {
    var _neg = _BN.prototype.neg.call(this);
    var neg = Object.create(BN.prototype);
    _neg.copy(neg);
    return neg;
  };

  BN.prototype.add = function (bn) {
    var _bn = _BN.prototype.add.call(this, bn);
    bn = Object.create(BN.prototype);
    _bn.copy(bn);
    return bn;
  };

  BN.prototype.sub = function (bn) {
    var _bn = _BN.prototype.sub.call(this, bn);
    bn = Object.create(BN.prototype);
    _bn.copy(bn);
    return bn;
  };

  BN.prototype.mul = function (bn) {
    var _bn = _BN.prototype.mul.call(this, bn);
    bn = Object.create(BN.prototype);
    _bn.copy(bn);
    return bn;
  };

  /**
   * to be used if this is positive.
   */
  BN.prototype.mod = function (bn) {
    var _bn = _BN.prototype.mod.call(this, bn);
    bn = Object.create(BN.prototype);
    _bn.copy(bn);
    return bn;
  };

  /**
   * to be used if this is negative.
   */
  BN.prototype.umod = function (bn) {
    var _bn = _BN.prototype.umod.call(this, bn);
    bn = Object.create(BN.prototype);
    _bn.copy(bn);
    return bn;
  };

  BN.prototype.invm = function (bn) {
    var _bn = _BN.prototype.invm.call(this, bn);
    bn = Object.create(BN.prototype);
    _bn.copy(bn);
    return bn;
  };

  BN.prototype.div = function (bn) {
    var _bn = _BN.prototype.div.call(this, bn);
    bn = Object.create(BN.prototype);
    _bn.copy(bn);
    return bn;
  };

  BN.prototype.cmp = function (bn) {
    return _BN.prototype.cmp.call(this, bn);
  };

  /**
   * All the standard big number operations operate on other big numbers. e.g.,
   * bn1.add(bn2). But it is frequenly valuble to add numbers or strings, e.g.
   * bn.add(5) or bn.add('5'). The decorator wraps all methods where this would
   * be convenient and makes that possible.
   */
  function decorate(name) {
    BN.prototype['_' + name] = BN.prototype[name];
    var f = function f(b) {
      if (typeof b === 'string') {
        b = new BN(b);
      } else if (typeof b === 'number') {
        b = new BN(b.toString());
      }
      return this['_' + name](b);
    };
    BN.prototype[name] = f;
  }

  BN.prototype.eq = function (b) {
    return this.cmp(b) === 0;
  };

  BN.prototype.neq = function (b) {
    return this.cmp(b) !== 0;
  };

  BN.prototype.gt = function (b) {
    return this.cmp(b) > 0;
  };

  BN.prototype.geq = function (b) {
    return this.cmp(b) >= 0;
  };

  BN.prototype.lt = function (b) {
    return this.cmp(b) < 0;
  };

  BN.prototype.leq = function (b) {
    return this.cmp(b) <= 0;
  };

  decorate('add');
  decorate('sub');
  decorate('mul');
  decorate('mod');
  decorate('invm');
  decorate('div');
  decorate('cmp');
  decorate('gt');
  decorate('geq');
  decorate('lt');
  decorate('leq');

  return BN;
};

inject = require('injecter')(inject, dependencies);
var BN = inject();
module.exports = BN;

}).call(this,require("buffer").Buffer)

},{"bn.js":354,"buffer":23,"injecter":381}],328:[function(require,module,exports){
(function (Buffer){
/**
 * Buffer Reader
 * =============
 *
 * This is a convenience class for reading VarInts and other basic types from a
 * buffer. This class is most useful for reading VarInts, and also for signed
 * or unsigned integers of various types. It can also read a buffer in reverse
 * order, which is useful in bitcoin which uses little endian numbers a lot so
 * you find that you must reverse things. You probably want to use it like:
 * varInt = new Br(buf).readnew VarInt()
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var dependencies = {
  Bn: require('./bn')
};

var inject = function inject(deps) {
  var Bn = deps.Bn;

  var Br = function () {
    function Br(buf) {
      _classCallCheck(this, Br);

      this.fromObject({ buf: buf });
    }

    _createClass(Br, [{
      key: 'fromObject',
      value: function fromObject(obj) {
        this.buf = obj.buf || this.buf || undefined;
        this.pos = obj.pos || this.pos || 0;
        return this;
      }
    }, {
      key: 'eof',
      value: function eof() {
        return this.pos >= this.buf.length;
      }
    }, {
      key: 'read',
      value: function read() {
        var len = arguments.length <= 0 || arguments[0] === undefined ? this.buf.length : arguments[0];

        var buf = this.buf.slice(this.pos, this.pos + len);
        this.pos = this.pos + len;
        return buf;
      }
    }, {
      key: 'readReverse',
      value: function readReverse() {
        var len = arguments.length <= 0 || arguments[0] === undefined ? this.buf.length : arguments[0];

        var buf = this.buf.slice(this.pos, this.pos + len);
        this.pos = this.pos + len;
        var buf2 = new Buffer(buf.length);
        for (var i = 0; i < buf2.length; i++) {
          buf2[i] = buf[buf.length - 1 - i];
        }
        return buf2;
      }
    }, {
      key: 'readUInt8',
      value: function readUInt8() {
        var val = this.buf.readUInt8(this.pos);
        this.pos = this.pos + 1;
        return val;
      }
    }, {
      key: 'readInt8',
      value: function readInt8() {
        var val = this.buf.readInt8(this.pos);
        this.pos = this.pos + 1;
        return val;
      }
    }, {
      key: 'readUInt16BE',
      value: function readUInt16BE() {
        var val = this.buf.readUInt16BE(this.pos);
        this.pos = this.pos + 2;
        return val;
      }
    }, {
      key: 'readInt16BE',
      value: function readInt16BE() {
        var val = this.buf.readInt16BE(this.pos);
        this.pos = this.pos + 2;
        return val;
      }
    }, {
      key: 'readUInt16LE',
      value: function readUInt16LE() {
        var val = this.buf.readUInt16LE(this.pos);
        this.pos = this.pos + 2;
        return val;
      }
    }, {
      key: 'readInt16LE',
      value: function readInt16LE() {
        var val = this.buf.readInt16LE(this.pos);
        this.pos = this.pos + 2;
        return val;
      }
    }, {
      key: 'readUInt32BE',
      value: function readUInt32BE() {
        var val = this.buf.readUInt32BE(this.pos);
        this.pos = this.pos + 4;
        return val;
      }
    }, {
      key: 'readInt32BE',
      value: function readInt32BE() {
        var val = this.buf.readInt32BE(this.pos);
        this.pos = this.pos + 4;
        return val;
      }
    }, {
      key: 'readUInt32LE',
      value: function readUInt32LE() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos = this.pos + 4;
        return val;
      }
    }, {
      key: 'readInt32LE',
      value: function readInt32LE() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos = this.pos + 4;
        return val;
      }
    }, {
      key: 'readUInt64BEBn',
      value: function readUInt64BEBn() {
        var buf = this.buf.slice(this.pos, this.pos + 8);
        var bn = new Bn().fromBuffer(buf);
        this.pos = this.pos + 8;
        return bn;
      }
    }, {
      key: 'readUInt64LEBn',
      value: function readUInt64LEBn() {
        var buf = this.readReverse(8);
        var bn = new Bn().fromBuffer(buf);
        return bn;
      }
    }, {
      key: 'readVarIntNum',
      value: function readVarIntNum() {
        var first = this.readUInt8();
        var bn = void 0,
            n = void 0;
        switch (first) {
          case 0xFD:
            return this.readUInt16LE();
          case 0xFE:
            return this.readUInt32LE();
          case 0xFF:
            bn = this.readUInt64LEBn();
            n = bn.toNumber();
            if (n <= Math.pow(2, 53)) {
              return n;
            } else {
              throw new Error('number too large to retain precision - use readVarIntBn');
            }
          default:
            return first;
        }
      }
    }, {
      key: 'readVarIntBuf',
      value: function readVarIntBuf() {
        var first = this.buf.readUInt8(this.pos);
        switch (first) {
          case 0xFD:
            return this.read(1 + 2);
          case 0xFE:
            return this.read(1 + 4);
          case 0xFF:
            return this.read(1 + 8);
          default:
            return this.read(1);
        }
      }
    }, {
      key: 'readVarIntBn',
      value: function readVarIntBn() {
        var first = this.readUInt8();
        switch (first) {
          case 0xFD:
            return new Bn(this.readUInt16LE());
          case 0xFE:
            return new Bn(this.readUInt32LE());
          case 0xFF:
            return this.readUInt64LEBn();
          default:
            return new Bn(first);
        }
      }
    }]);

    return Br;
  }();

  return Br;
};

inject = require('injecter')(inject, dependencies);
var Br = inject();
module.exports = Br;

}).call(this,require("buffer").Buffer)

},{"./bn":327,"buffer":23,"injecter":381}],329:[function(require,module,exports){
(function (Buffer){
/**
 * Buffer Writer
 * =============
 *
 * This is the writing complement of the Br. You can easily write
 * VarInts and other basic number types. The way to use it is: buf =
 * new Bw().write(buf1).write(buf2).toBuffer()
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var dependencies = {};

var inject = function inject(deps) {
  var Bw = function () {
    function Bw(bufs) {
      _classCallCheck(this, Bw);

      this.fromObject({ bufs: bufs });
    }

    _createClass(Bw, [{
      key: 'fromObject',
      value: function fromObject(obj) {
        this.bufs = obj.bufs || this.bufs || [];
        return this;
      }
    }, {
      key: 'getLength',
      value: function getLength() {
        var len = 0;
        for (var i in this.bufs) {
          var buf = this.bufs[i];
          len = len + buf.length;
        }
        return len;
      }
    }, {
      key: 'toBuffer',
      value: function toBuffer() {
        return Buffer.concat(this.bufs);
      }
    }, {
      key: 'write',
      value: function write(buf) {
        this.bufs.push(buf);
        return this;
      }
    }, {
      key: 'writeReverse',
      value: function writeReverse(buf) {
        var buf2 = new Buffer(buf.length);
        for (var i = 0; i < buf2.length; i++) {
          buf2[i] = buf[buf.length - 1 - i];
        }
        this.bufs.push(buf2);
        return this;
      }
    }, {
      key: 'writeUInt8',
      value: function writeUInt8(n) {
        var buf = new Buffer(1);
        buf.writeUInt8(n, 0);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeInt8',
      value: function writeInt8(n) {
        var buf = new Buffer(1);
        buf.writeInt8(n, 0);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeUInt16BE',
      value: function writeUInt16BE(n) {
        var buf = new Buffer(2);
        buf.writeUInt16BE(n, 0);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeInt16BE',
      value: function writeInt16BE(n) {
        var buf = new Buffer(2);
        buf.writeInt16BE(n, 0);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeUInt16LE',
      value: function writeUInt16LE(n) {
        var buf = new Buffer(2);
        buf.writeUInt16LE(n, 0);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeInt16LE',
      value: function writeInt16LE(n) {
        var buf = new Buffer(2);
        buf.writeInt16LE(n, 0);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeUInt32BE',
      value: function writeUInt32BE(n) {
        var buf = new Buffer(4);
        buf.writeUInt32BE(n, 0);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeInt32BE',
      value: function writeInt32BE(n) {
        var buf = new Buffer(4);
        buf.writeInt32BE(n, 0);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeUInt32LE',
      value: function writeUInt32LE(n) {
        var buf = new Buffer(4);
        buf.writeUInt32LE(n, 0);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeInt32LE',
      value: function writeInt32LE(n) {
        var buf = new Buffer(4);
        buf.writeInt32LE(n, 0);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeUInt64BEBn',
      value: function writeUInt64BEBn(bn) {
        var buf = bn.toBuffer({ size: 8 });
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeUInt64LEBn',
      value: function writeUInt64LEBn(bn) {
        var buf = bn.toBuffer({ size: 8 });
        this.writeReverse(buf);
        return this;
      }
    }, {
      key: 'writeVarIntNum',
      value: function writeVarIntNum(n) {
        var buf = Bw.varIntBufNum(n);
        this.write(buf);
        return this;
      }
    }, {
      key: 'writeVarIntBn',
      value: function writeVarIntBn(bn) {
        var buf = Bw.varIntBufBn(bn);
        this.write(buf);
        return this;
      }
    }], [{
      key: 'varIntBufNum',
      value: function varIntBufNum(n) {
        var buf = void 0;
        if (n < 253) {
          buf = new Buffer(1);
          buf.writeUInt8(n, 0);
        } else if (n < 0x10000) {
          buf = new Buffer(1 + 2);
          buf.writeUInt8(253, 0);
          buf.writeUInt16LE(n, 1);
        } else if (n < 0x100000000) {
          buf = new Buffer(1 + 4);
          buf.writeUInt8(254, 0);
          buf.writeUInt32LE(n, 1);
        } else {
          buf = new Buffer(1 + 8);
          buf.writeUInt8(255, 0);
          buf.writeInt32LE(n & -1, 1);
          buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);
        }
        return buf;
      }
    }, {
      key: 'varIntBufBn',
      value: function varIntBufBn(bn) {
        var buf = void 0;
        var n = bn.toNumber();
        if (n < 253) {
          buf = new Buffer(1);
          buf.writeUInt8(n, 0);
        } else if (n < 0x10000) {
          buf = new Buffer(1 + 2);
          buf.writeUInt8(253, 0);
          buf.writeUInt16LE(n, 1);
        } else if (n < 0x100000000) {
          buf = new Buffer(1 + 4);
          buf.writeUInt8(254, 0);
          buf.writeUInt32LE(n, 1);
        } else {
          var bw = new Bw();
          bw.writeUInt8(255);
          bw.writeUInt64LEBn(bn);
          buf = bw.toBuffer();
        }
        return buf;
      }
    }]);

    return Bw;
  }();

  return Bw;
};

inject = require('injecter')(inject, dependencies);
var Bw = inject();
module.exports = Bw;

}).call(this,require("buffer").Buffer)

},{"buffer":23,"injecter":381}],330:[function(require,module,exports){
(function (Buffer){
/**
 * Constant-Time Buffer Compare
 * ============================
 *
 * A constant-time comparison function. This should be used in any security
 * sensitive code where leaking timing information may lead to lessened
 * security. Note that if the buffers are not equal in length, this function
 * loops for the longest buffer, which may not be necessary. Usually this
 * function should be used for buffers that would otherwise be equal length,
 * such as a hash, particularly Hmacs.
 *
 * The algorithm here, which is XORs each byte (or, if undefined, 0) with the
 * corresponding other byte, and then ORs that with a running total (d), is
 * adapted from here:
 *
 * https://groups.google.com/forum/#!topic/keyczar-discuss/VXHsoJSLKhM
 */
'use strict';

module.exports = function cmp(buf1, buf2) {
  if (!Buffer.isBuffer(buf1) || !Buffer.isBuffer(buf2)) {
    throw new Error('buf1 and buf2 must be buffers');
  }
  if (buf1.length !== buf2.length) {
    return false;
  }

  var d = 0;
  for (var i = 0; i < buf1.length; i++) {
    var x = buf1[i];
    var y = buf2[i];
    d |= x ^ y;
  }

  return d === 0;
};

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":319}],331:[function(require,module,exports){
(function (process){
/**
 * Constants
 * =========
 *
 * Constants used to distinguish mainnet from testnet.
 */
'use strict';

var Constants = module.exports;

Constants.Mainnet = {
  maxsize: 0x02000000, // MAX_SIZE
  Address: {
    pubKeyHash: 0x00,
    scriptHash: 0x05
  },
  Bip32: {
    pubKey: 0x0488b21e,
    privKey: 0x0488ade4
  },
  Block: {
    maxNBits: 0x1d00ffff,
    magicNum: 0xf9beb4d9
  },
  Msg: {
    magicNum: 0xf9beb4d9,
    versionBytesNum: 70012 // as of Bitcoin Core v0.12.0
  },
  PrivKey: {
    versionByteNum: 0x80
  },
  StealthAddress: {
    versionByteNum: 42
  },
  TxBuilder: {
    feePerKbNum: 0.0001e8,
    dustNum: 546
  }
};

Constants.Testnet = Object.assign({}, Constants.Mainnet, {
  Address: {
    pubKeyHash: 0x6f,
    scriptHash: 0xc4
  },
  Bip32: {
    pubKey: 0x043587cf,
    privKey: 0x04358394
  },
  Block: {
    maxNBits: 0x1d00ffff,
    magicNum: 0x0b110907
  },
  Msg: {
    magicNum: 0x0b110907,
    versionBytesNum: 70012 // as of Bitcoin Core v0.12.0
  },
  Network: {
    maxconnections: 20,
    minconnections: 8,
    port: 8333,
    rendezvous: {
      host: 'localhost',
      port: 3000,
      path: '/'
    }
  },
  PrivKey: {
    versionByteNum: 0xef
  },
  StealthAddress: {
    versionByteNum: 43
  }
});

Constants.Regtest = Object.assign({}, Constants.Mainnet, {
  Network: {
    maxconnections: 20,
    minconnections: 8,
    port: 18444,
    rendezvous: {
      host: 'localhost',
      port: 3000,
      path: '/'
    }
  }
});

/**
 * Yours Bitcoin can be globally configured to mainnet, testnet, or regtest. Via the
 * inject pattern, you always have access to the other networks at any time.
 * However, it is very convenient to be able to change the default
 * configuration. The default is mainnet, which can be changed to testnet or
 * regtest.
 */
if (process.env.YOURS_BITCOIN_NETWORK === 'testnet') {
  Constants.Default = Object.assign({}, Constants.Testnet);
} else if (process.env.YOURS_BITCOIN_NETWORK === 'regtest') {
  Constants.Default = Object.assign({}, Constants.Regtest);
} else {
  process.env.YOURS_BITCOIN_NETWORK = 'mainnet';
  Constants.Default = Object.assign({}, Constants.Mainnet);
}

}).call(this,require('_process'))

},{"_process":322}],332:[function(require,module,exports){
(function (Buffer){
/**
 * Ecdsa
 * =====
 *
 * Ecdsa is the signature algorithm used by bitcoin. The way you probably want
 * to use this is with the static Ecdsa.sign( ... ) and Ecdsa.verify( ... )
 * functions. Note that in bitcoin, the hashBuf is little endian, so if you are
 * signIng or verifying something that has to do with a transaction, you should
 * explicitly plug in that it is little endian as an option to the sign and
 * verify functions.
 *
 * This implementation of Ecdsa uses deterministic signatures as defined in RFC
 * 6979 as the default, which has become a defacto standard in bitcoin wallets
 * due to recurring security issues around using a value of k pulled from a
 * possibly faulty entropy pool. If you use the same value of k twice, someone
 * can derive your private key. Deterministic k prevents this without needing
 * an entropy pool.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Bn: require('./bn'),
  Hash: require('./hash'),
  KeyPair: require('./key-pair'),
  Point: require('./point'),
  PubKey: require('./pub-key'),
  Random: require('./random'),
  Sig: require('./sig'),
  Struct: require('./struct'),
  Workers: require('./workers'),
  asink: require('asink')
};

var inject = function inject(deps) {
  var Bn = deps.Bn;
  var Hash = deps.Hash;
  var KeyPair = deps.KeyPair;
  var Point = deps.Point;
  var PubKey = deps.PubKey;
  var Random = deps.Random;
  var Sig = deps.Sig;
  var Struct = deps.Struct;
  var Workers = deps.Workers;
  var asink = deps.asink;

  var Ecdsa = function (_Struct) {
    _inherits(Ecdsa, _Struct);

    function Ecdsa(sig, keyPair, hashBuf, k, endian, verified) {
      _classCallCheck(this, Ecdsa);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Ecdsa).call(this, { sig: sig, keyPair: keyPair, hashBuf: hashBuf, k: k, endian: endian, verified: verified }));
    }

    _createClass(Ecdsa, [{
      key: 'toJSON',
      value: function toJSON() {
        return {
          sig: this.sig ? this.sig.toString() : undefined,
          keyPair: this.keyPair ? this.keyPair.toBuffer().toString('hex') : undefined,
          hashBuf: this.hashBuf ? this.hashBuf.toString('hex') : undefined,
          k: this.k ? this.k.toString() : undefined,
          endian: this.endian,
          verified: this.verified
        };
      }
    }, {
      key: 'fromJSON',
      value: function fromJSON(json) {
        this.sig = json.sig ? new Sig().fromString(json.sig) : undefined;
        this.keyPair = json.keyPair ? new KeyPair().fromBuffer(new Buffer(json.keyPair, 'hex')) : undefined;
        this.hashBuf = json.hashBuf ? new Buffer(json.hashBuf, 'hex') : undefined;
        this.k = json.k ? new Bn().fromString(json.k) : undefined;
        this.endian = json.endian;
        this.verified = json.verified;
        return this;
      }
    }, {
      key: 'toBuffer',
      value: function toBuffer() {
        var str = JSON.stringify(this.toJSON());
        return new Buffer(str);
      }
    }, {
      key: 'fromBuffer',
      value: function fromBuffer(buf) {
        var json = JSON.parse(buf.toString());
        return this.fromJSON(json);
      }
    }, {
      key: 'calcrecovery',
      value: function calcrecovery() {
        for (var recovery = 0; recovery < 4; recovery++) {
          var Qprime = void 0;
          this.sig.recovery = recovery;
          try {
            Qprime = this.sig2PubKey();
          } catch (e) {
            continue;
          }

          if (Qprime.point.eq(this.keyPair.pubKey.point)) {
            var compressed = this.keyPair.pubKey.compressed;
            this.sig.compressed = this.keyPair.pubKey.compressed === undefined ? true : compressed;
            return this;
          }
        }

        this.sig.recovery = undefined;
        throw new Error('Unable to find valid recovery factor');
      }
    }, {
      key: 'asyncCalcrecovery',
      value: function asyncCalcrecovery() {
        return asink(regeneratorRuntime.mark(function _callee() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Workers.asyncObjectMethod(this, 'calcrecovery', []);

                case 2:
                  workersResult = _context.sent;
                  return _context.abrupt('return', this.fromFastBuffer(workersResult.resbuf));

                case 4:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }), this);
      }

      /**
       * Calculates the recovery factor, and mutates sig so that it now contains
       * the recovery factor and the "compressed" variable. Throws an exception on
       * failure.
       */

    }, {
      key: 'fromString',
      value: function fromString(str) {
        var obj = JSON.parse(str);
        if (obj.hashBuf) {
          this.hashBuf = new Buffer(obj.hashBuf, 'hex');
        }
        if (obj.keyPair) {
          this.keyPair = new KeyPair().fromString(obj.keyPair);
        }
        if (obj.sig) {
          this.sig = new Sig().fromString(obj.sig);
        }
        if (obj.k) {
          this.k = new Bn(obj.k, 10);
        }
        return this;
      }
    }, {
      key: 'randomK',
      value: function randomK() {
        var N = Point.getN();
        var k = void 0;
        do {
          k = new Bn().fromBuffer(Random.getRandomBuffer(32));
        } while (!(k.lt(N) && k.gt(0)));
        this.k = k;
        return this;
      }

      /**
       * The traditional Ecdsa algorithm uses a purely random value of k. This has
       * the negative that when signIng, your entropy must be good, or the private
       * key can be recovered if two signatures use the same value of k. It turns out
       * that k does not have to be purely random. It can be deterministic, so long
       * as an attacker can't guess it. RFC 6979 specifies how to do this using a
       * combination of the private key and the hash of the thing to be signed. It is
       * best practice to use this value, which can be tested for byte-for-byte
       * accuracy, and is resistant to a broken RNG. Note that it is actually the
       * case that bitcoin private keys have been compromised through that attack.
       * Deterministic k is a best practice.
       *
       * https://tools.ietf.org/html/rfc6979#section-3.2
       */

    }, {
      key: 'deterministicK',
      value: function deterministicK(badrs) {
        var v = new Buffer(32);
        v.fill(0x01);
        var k = new Buffer(32);
        k.fill(0x00);
        var x = this.keyPair.privKey.bn.toBuffer({ size: 32 });
        k = Hash.sha256Hmac(Buffer.concat([v, new Buffer([0x00]), x, this.hashBuf]), k);
        v = Hash.sha256Hmac(v, k);
        k = Hash.sha256Hmac(Buffer.concat([v, new Buffer([0x01]), x, this.hashBuf]), k);
        v = Hash.sha256Hmac(v, k);
        v = Hash.sha256Hmac(v, k);
        var T = new Bn().fromBuffer(v);
        var N = Point.getN();

        // if r or s were invalid when this function was used in signIng,
        // we do not want to actually compute r, s here for efficiency, so,
        // we can increment badrs. explained at end of RFC 6979 section 3.2
        if (badrs === undefined) {
          badrs = 0;
        }
        // also explained in 3.2, we must ensure T is in the proper range (0, N)
        for (var i = 0; i < badrs || !(T.lt(N) && T.gt(0)); i++) {
          k = Hash.sha256Hmac(Buffer.concat([v, new Buffer([0x00])]), k);
          v = Hash.sha256Hmac(v, k);
          v = Hash.sha256Hmac(v, k);
          T = new Bn().fromBuffer(v);
        }

        this.k = T;
        return this;
      }

      /**
       * Information about public key recovery:
       * https://bitcointalk.org/index.php?topic=6430.0
       * http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k
       * This code was originally taken from BitcoinJS
       */

    }, {
      key: 'sig2PubKey',
      value: function sig2PubKey() {
        var recovery = this.sig.recovery;
        if (!(recovery === 0 || recovery === 1 || recovery === 2 || recovery === 3)) {
          throw new Error('i must be equal to 0, 1, 2, or 3');
        }

        var e = new Bn().fromBuffer(this.hashBuf);
        var r = this.sig.r;
        var s = this.sig.s;

        // A set LSB signifies that the y-coordinate is odd
        var isYOdd = recovery & 1;

        // The more significant bit specifies whether we should use the
        // first or second candidate key.
        var isSecondKey = recovery >> 1;

        var n = Point.getN();
        var G = Point.getG();

        // 1.1 LEt x = r + jn
        var x = isSecondKey ? r.add(n) : r;
        var R = Point.fromX(isYOdd, x);

        // 1.4 Check that nR is at infinity
        var nR = R.mul(n);

        if (!nR.isInfinity()) {
          throw new Error('nR is not a valid curve point');
        }

        // Compute -e from e
        var eNeg = e.neg().umod(n);

        // 1.6.1 Compute Q = r^-1 (sR - eG)
        // Q = r^-1 (sR + -eG)
        var rInv = r.invm(n);

        // let Q = R.multiplyTwo(s, G, eNeg).mul(rInv)
        var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);

        var pubKey = new PubKey(Q);
        pubKey.compressed = this.sig.compressed;
        pubKey.validate();

        return pubKey;
      }
    }, {
      key: 'asyncSig2PubKey',
      value: function asyncSig2PubKey() {
        return asink(regeneratorRuntime.mark(function _callee2() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return Workers.asyncObjectMethod(this, 'sig2PubKey', []);

                case 2:
                  workersResult = _context2.sent;
                  return _context2.abrupt('return', PubKey.fromFastBuffer(workersResult.resbuf));

                case 4:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }), this);
      }
    }, {
      key: 'verifyStr',
      value: function verifyStr() {
        if (!Buffer.isBuffer(this.hashBuf) || this.hashBuf.length !== 32) {
          return 'hashBuf must be a 32 byte buffer';
        }

        try {
          this.keyPair.pubKey.validate();
        } catch (e) {
          return 'Invalid pubKey: ' + e;
        }

        var r = this.sig.r;
        var s = this.sig.s;
        if (!(r.gt(0) && r.lt(Point.getN())) || !(s.gt(0) && s.lt(Point.getN()))) {
          return 'r and s not in range';
        }

        var e = new Bn().fromBuffer(this.hashBuf, this.endian ? { endian: this.endian } : undefined);
        var n = Point.getN();
        var sinv = s.invm(n);
        var u1 = sinv.mul(e).mod(n);
        var u2 = sinv.mul(r).mod(n);

        var p = Point.getG().mulAdd(u1, this.keyPair.pubKey.point, u2);
        // let p = Point.getG().mulAdd(u1, this.keyPair.pubKey.point, u2)
        if (p.isInfinity()) {
          return 'p is infinity';
        }

        if (!(p.getX().mod(n).cmp(r) === 0)) {
          return 'Invalid signature';
        } else {
          return false;
        }
      }
    }, {
      key: 'sign',
      value: function sign() {
        var hashBuf = this.hashBuf;
        var privKey = this.keyPair.privKey;

        var d = privKey.bn;

        if (!hashBuf || !privKey || !d) {
          throw new Error('invalid parameters');
        }

        if (!Buffer.isBuffer(hashBuf) || hashBuf.length !== 32) {
          throw new Error('hashBuf must be a 32 byte buffer');
        }

        var N = Point.getN();
        var G = Point.getG();
        var e = new Bn().fromBuffer(hashBuf, this.endian ? { endian: this.endian } : undefined);

        // try different values of k until r, s are valid
        var badrs = 0;
        var k = void 0,
            Q = void 0,
            r = void 0,
            s = void 0;
        do {
          if (!this.k || badrs > 0) {
            this.deterministicK(badrs);
          }
          badrs++;
          k = this.k;
          Q = G.mul(k);
          r = Q.getX().mod(N);
          s = k.invm(N).mul(e.add(d.mul(r))).mod(N);
        } while (r.cmp(0) <= 0 || s.cmp(0) <= 0);

        // enforce low s
        // see Bip 62, "low S values in signatures"
        if (s.gt(new Bn().fromBuffer(new Buffer('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {
          s = Point.getN().sub(s);
        }
        this.sig = Sig.fromObject({ r: r, s: s, compressed: this.keyPair.pubKey.compressed });
        return this;
      }
    }, {
      key: 'asyncSign',
      value: function asyncSign() {
        return asink(regeneratorRuntime.mark(function _callee3() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return Workers.asyncObjectMethod(this, 'sign', []);

                case 2:
                  workersResult = _context3.sent;
                  return _context3.abrupt('return', this.fromFastBuffer(workersResult.resbuf));

                case 4:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }), this);
      }
    }, {
      key: 'signRandomK',
      value: function signRandomK() {
        this.randomK();
        return this.sign();
      }
    }, {
      key: 'toString',
      value: function toString() {
        var obj = {};
        if (this.hashBuf) {
          obj.hashBuf = this.hashBuf.toString('hex');
        }
        if (this.keyPair) {
          obj.keyPair = this.keyPair.toString();
        }
        if (this.sig) {
          obj.sig = this.sig.toString();
        }
        if (this.k) {
          obj.k = this.k.toString();
        }
        return JSON.stringify(obj);
      }
    }, {
      key: 'verify',
      value: function verify() {
        if (!this.verifyStr()) {
          this.verified = true;
        } else {
          this.verified = false;
        }
        return this;
      }
    }, {
      key: 'asyncVerify',
      value: function asyncVerify() {
        return asink(regeneratorRuntime.mark(function _callee4() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return Workers.asyncObjectMethod(this, 'verify', []);

                case 2:
                  workersResult = _context4.sent;
                  return _context4.abrupt('return', this.fromFastBuffer(workersResult.resbuf));

                case 4:
                case 'end':
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }), this);
      }
    }], [{
      key: 'calcrecovery',
      value: function calcrecovery(sig, pubKey, hashBuf) {
        var ecdsa = new Ecdsa().fromObject({
          sig: sig,
          keyPair: new KeyPair().fromObject({ pubKey: pubKey }),
          hashBuf: hashBuf
        });
        return ecdsa.calcrecovery().sig;
      }
    }, {
      key: 'asyncCalcrecovery',
      value: function asyncCalcrecovery(sig, pubKey, hashBuf) {
        return asink(regeneratorRuntime.mark(function _callee5() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return Workers.asyncClassMethod('Ecdsa', 'calcrecovery', [sig, pubKey, hashBuf]);

                case 2:
                  workersResult = _context5.sent;
                  return _context5.abrupt('return', new Sig().fromFastBuffer(workersResult.resbuf));

                case 4:
                case 'end':
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }), this);
      }
    }, {
      key: 'sig2PubKey',
      value: function sig2PubKey(sig, hashBuf) {
        var ecdsa = new Ecdsa().fromObject({
          sig: sig,
          hashBuf: hashBuf
        });
        return ecdsa.sig2PubKey();
      }
    }, {
      key: 'asyncSig2PubKey',
      value: function asyncSig2PubKey(sig, hashBuf) {
        return asink(regeneratorRuntime.mark(function _callee6() {
          var ecdsa, pubKey;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  ecdsa = new Ecdsa().fromObject({
                    sig: sig,
                    hashBuf: hashBuf
                  });
                  _context6.next = 3;
                  return ecdsa.asyncSig2PubKey();

                case 3:
                  pubKey = _context6.sent;
                  return _context6.abrupt('return', pubKey);

                case 5:
                case 'end':
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }), this);
      }
    }, {
      key: 'sign',
      value: function sign(hashBuf, keyPair, endian) {
        return new Ecdsa().fromObject({
          hashBuf: hashBuf,
          endian: endian,
          keyPair: keyPair
        }).sign().sig;
      }
    }, {
      key: 'asyncSign',
      value: function asyncSign(hashBuf, keyPair, endian) {
        return asink(regeneratorRuntime.mark(function _callee7() {
          var ecdsa;
          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  ecdsa = new Ecdsa().fromObject({
                    hashBuf: hashBuf,
                    endian: endian,
                    keyPair: keyPair
                  });
                  _context7.next = 3;
                  return ecdsa.asyncSign();

                case 3:
                  return _context7.abrupt('return', ecdsa.sig);

                case 4:
                case 'end':
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }), this);
      }
    }, {
      key: 'verify',
      value: function verify(hashBuf, sig, pubKey, endian) {
        return new Ecdsa().fromObject({
          hashBuf: hashBuf,
          endian: endian,
          sig: sig,
          keyPair: new KeyPair().fromObject({ pubKey: pubKey })
        }).verify().verified;
      }
    }, {
      key: 'asyncVerify',
      value: function asyncVerify(hashBuf, sig, pubKey, endian) {
        return asink(regeneratorRuntime.mark(function _callee8() {
          var ecdsa;
          return regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  ecdsa = new Ecdsa().fromObject({
                    hashBuf: hashBuf,
                    endian: endian,
                    sig: sig,
                    keyPair: new KeyPair().fromObject({ pubKey: pubKey })
                  });
                  _context8.next = 3;
                  return ecdsa.asyncVerify();

                case 3:
                  return _context8.abrupt('return', ecdsa.verified);

                case 4:
                case 'end':
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }), this);
      }
    }]);

    return Ecdsa;
  }(Struct);

  return Ecdsa;
};

inject = require('injecter')(inject, dependencies);
var Ecdsa = inject();
Ecdsa.Mainnet = inject({
  KeyPair: require('./key-pair').Mainnet
});
Ecdsa.Testnet = inject({
  KeyPair: require('./key-pair').Testnet
});
module.exports = Ecdsa;

}).call(this,require("buffer").Buffer)

},{"./bn":327,"./hash":333,"./key-pair":334,"./point":336,"./pub-key":338,"./random":339,"./sig":341,"./struct":342,"./workers":351,"asink":352,"buffer":23,"injecter":381}],333:[function(require,module,exports){
(function (Buffer){
/**
 * Hash
 * ====
 *
 * Some hash functions are used through out bitcoin. We expose them here as a
 * convenience.
 */
'use strict';

var dependencies = {
  Workers: require('./workers'),
  asink: require('asink'),
  hashjs: require('hash.js')
};

var inject = function inject(deps) {
  var Workers = deps.Workers;
  var asink = deps.asink;
  var hashjs = deps.hashjs;

  var Hash = {};

  Hash.sha1 = function (buf) {
    if (!Buffer.isBuffer(buf)) {
      throw new Error('sha1 hash must be of a buffer');
    }
    var Sha1 = hashjs.sha1;
    var hash = new Sha1().update(buf).digest();
    return new Buffer(hash);
  };

  Hash.sha1.blockSize = 512;

  Hash.asyncSha1 = function (buf) {
    return asink(regeneratorRuntime.mark(function _callee() {
      var args, workersResult;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              args = [buf];
              _context.next = 3;
              return Workers.asyncClassMethod('Hash', 'sha1', args);

            case 3:
              workersResult = _context.sent;
              return _context.abrupt('return', workersResult.resbuf);

            case 5:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }), this);
  };

  Hash.sha256 = function (buf) {
    if (!Buffer.isBuffer(buf)) {
      throw new Error('sha256 hash must be of a buffer');
    }
    var Sha256 = hashjs.sha256;
    var hash = new Sha256().update(buf).digest();
    return new Buffer(hash);
  };

  Hash.sha256.blockSize = 512;

  Hash.asyncSha256 = function (buf) {
    return asink(regeneratorRuntime.mark(function _callee2() {
      var args, workersResult;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              args = [buf];
              _context2.next = 3;
              return Workers.asyncClassMethod('Hash', 'sha256', args);

            case 3:
              workersResult = _context2.sent;
              return _context2.abrupt('return', workersResult.resbuf);

            case 5:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }), this);
  };

  Hash.sha256Sha256 = function (buf) {
    try {
      return Hash.sha256(Hash.sha256(buf));
    } catch (e) {
      throw new Error('sha256Sha256 hash must be of a buffer: ' + e);
    }
  };

  Hash.asyncSha256Sha256 = function (buf) {
    return asink(regeneratorRuntime.mark(function _callee3() {
      var args, workersResult;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              args = [buf];
              _context3.next = 3;
              return Workers.asyncClassMethod('Hash', 'sha256Sha256', args);

            case 3:
              workersResult = _context3.sent;
              return _context3.abrupt('return', workersResult.resbuf);

            case 5:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }), this);
  };

  Hash.ripemd160 = function (buf) {
    if (!Buffer.isBuffer(buf)) {
      throw new Error('ripemd160 hash must be of a buffer');
    }
    var Ripemd160 = hashjs.ripemd160;
    var hash = new Ripemd160().update(buf).digest();
    return new Buffer(hash);
  };

  Hash.asyncRipemd160 = function (buf) {
    return asink(regeneratorRuntime.mark(function _callee4() {
      var args, workersResult;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              args = [buf];
              _context4.next = 3;
              return Workers.asyncClassMethod('Hash', 'ripemd160', args);

            case 3:
              workersResult = _context4.sent;
              return _context4.abrupt('return', workersResult.resbuf);

            case 5:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }), this);
  };

  Hash.sha256Ripemd160 = function (buf) {
    try {
      return Hash.ripemd160(Hash.sha256(buf));
    } catch (e) {
      throw new Error('sha256Ripemd160 hash must be of a buffer: ' + e);
    }
  };

  Hash.asyncSha256Ripemd160 = function (buf) {
    return asink(regeneratorRuntime.mark(function _callee5() {
      var args, workersResult;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              args = [buf];
              _context5.next = 3;
              return Workers.asyncClassMethod('Hash', 'sha256Ripemd160', args);

            case 3:
              workersResult = _context5.sent;
              return _context5.abrupt('return', workersResult.resbuf);

            case 5:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }), this);
  };

  Hash.sha512 = function (buf) {
    if (!Buffer.isBuffer(buf)) {
      throw new Error('sha512 hash must be of a buffer');
    }
    var Sha512 = hashjs.sha512;
    var hash = new Sha512().update(buf).digest();
    return new Buffer(hash);
  };

  Hash.asyncSha512 = function (buf) {
    return asink(regeneratorRuntime.mark(function _callee6() {
      var args, workersResult;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              args = [buf];
              _context6.next = 3;
              return Workers.asyncClassMethod('Hash', 'sha512', args);

            case 3:
              workersResult = _context6.sent;
              return _context6.abrupt('return', workersResult.resbuf);

            case 5:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }), this);
  };

  Hash.sha512.blockSize = 1024;

  Hash.hmac = function (hashFStr, data, key) {
    if (hashFStr !== 'sha1' && hashFStr !== 'sha256' && hashFStr !== 'sha512') {
      throw new Error('invalid choice of hash function');
    }

    var hashf = Hash[hashFStr];

    if (!Buffer.isBuffer(data) || !Buffer.isBuffer(key)) {
      throw new Error('data and key must be buffers');
    }

    // http://en.wikipedia.org/wiki/Hash-based_message_authentication_code
    // http://tools.ietf.org/html/rfc4868#section-2
    var blockSize = hashf.blockSize / 8;

    if (key.length > blockSize) {
      key = hashf(key);
    }

    if (key.length < blockSize) {
      var fill = new Buffer(blockSize);
      fill.fill(0, key.length);
      key.copy(fill);
      key = fill;
    }

    var oKeyPad = new Buffer(blockSize);
    var iKeyPad = new Buffer(blockSize);
    for (var i = 0; i < blockSize; i++) {
      oKeyPad[i] = 0x5c ^ key[i];
      iKeyPad[i] = 0x36 ^ key[i];
    }

    return hashf(Buffer.concat([oKeyPad, hashf(Buffer.concat([iKeyPad, data]))]));
  };

  Hash.sha1Hmac = function (data, key) {
    return Hash.hmac('sha1', data, key);
  };

  Hash.asyncSha1Hmac = function (data, key) {
    return asink(regeneratorRuntime.mark(function _callee7() {
      var args, workersResult;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              args = [data, key];
              _context7.next = 3;
              return Workers.asyncClassMethod('Hash', 'sha1Hmac', args);

            case 3:
              workersResult = _context7.sent;
              return _context7.abrupt('return', workersResult.resbuf);

            case 5:
            case 'end':
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }), this);
  };

  Hash.sha1Hmac.bitsize = 160;

  Hash.sha256Hmac = function (data, key) {
    return Hash.hmac('sha256', data, key);
  };

  Hash.asyncSha256Hmac = function (data, key) {
    return asink(regeneratorRuntime.mark(function _callee8() {
      var args, workersResult;
      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              args = [data, key];
              _context8.next = 3;
              return Workers.asyncClassMethod('Hash', 'sha256Hmac', args);

            case 3:
              workersResult = _context8.sent;
              return _context8.abrupt('return', workersResult.resbuf);

            case 5:
            case 'end':
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }), this);
  };

  Hash.sha256Hmac.bitsize = 256;

  Hash.sha512Hmac = function (data, key) {
    return Hash.hmac('sha512', data, key);
  };

  Hash.asyncSha512Hmac = function (data, key) {
    return asink(regeneratorRuntime.mark(function _callee9() {
      var args, workersResult;
      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              args = [data, key];
              _context9.next = 3;
              return Workers.asyncClassMethod('Hash', 'sha512Hmac', args);

            case 3:
              workersResult = _context9.sent;
              return _context9.abrupt('return', workersResult.resbuf);

            case 5:
            case 'end':
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }), this);
  };

  Hash.sha512Hmac.bitsize = 512;

  return Hash;
};

inject = require('injecter')(inject, dependencies);
var Hash = inject();
module.exports = Hash;

}).call(this,require("buffer").Buffer)

},{"./workers":351,"asink":352,"buffer":23,"hash.js":374,"injecter":381}],334:[function(require,module,exports){
/**
 * KeyPair
 * =======
 *
 * A keyPair is a collection of a private key and a public key.
 * let keyPair = new KeyPair().fromRandom()
 * let keyPair = new KeyPair().fromPrivKey(privKey)
 * let privKey = keyPair.privKey
 * let pubKey = keyPair.pubKey
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  PrivKey: require('./priv-key'),
  PubKey: require('./pub-key'),
  Struct: require('./struct'),
  Bw: require('./bw'),
  asink: require('asink')
};

var inject = function inject(deps) {
  var PrivKey = deps.PrivKey;
  var PubKey = deps.PubKey;
  var Struct = deps.Struct;
  var Bw = deps.Bw;
  var asink = deps.asink;

  var KeyPair = function (_Struct) {
    _inherits(KeyPair, _Struct);

    function KeyPair(privKey, pubKey) {
      _classCallCheck(this, KeyPair);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(KeyPair).call(this, { privKey: privKey, pubKey: pubKey }));
    }

    _createClass(KeyPair, [{
      key: 'fromJSON',
      value: function fromJSON(json) {
        if (json.privKey) {
          this.privKey = PrivKey.fromJSON(json.privKey);
        }
        if (json.pubKey) {
          this.pubKey = PubKey.fromJSON(json.pubKey);
        }
        return this;
      }
      /*
          toJSON () {
            let json = {}
            if (this.privKey && this.privKey !== undefined) {
              json.privKey = this.privKey.toJSON()
            }
            if (this.pubKey && this.pubKey !== undefined) {
              json.pubKey = this.pubKey.toJSON()
            }
            return json
          }
      */

    }, {
      key: 'fromBr',
      value: function fromBr(br) {
        var buflen1 = br.readUInt8();
        if (buflen1 > 0) {
          this.privKey = new PrivKey().fromFastBuffer(br.read(buflen1));
        }
        var buflen2 = br.readUInt8();
        if (buflen2 > 0) {
          this.pubKey = new PubKey().fromFastBuffer(br.read(buflen2));
        }
        return this;
      }
    }, {
      key: 'toBw',
      value: function toBw(bw) {
        if (!bw) {
          bw = new Bw();
        }
        if (this.privKey) {
          var privKeybuf = this.privKey.toFastBuffer();
          bw.writeUInt8(privKeybuf.length);
          bw.write(privKeybuf);
        } else {
          bw.writeUInt8(0);
        }
        if (this.pubKey) {
          var pubKeybuf = this.pubKey.toFastBuffer();
          bw.writeUInt8(pubKeybuf.length);
          bw.write(pubKeybuf);
        } else {
          bw.writeUInt8(0);
        }
        return bw;
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        return this.fromJSON(JSON.parse(str));
      }
    }, {
      key: 'toString',
      value: function toString() {
        return JSON.stringify(this.toJSON());
      }
    }, {
      key: 'toPublic',
      value: function toPublic() {
        var keyPair = new KeyPair().fromObject(this);
        keyPair.privKey = undefined;
        return keyPair;
      }
    }, {
      key: 'fromPrivKey',
      value: function fromPrivKey(privKey) {
        this.privKey = privKey;
        this.pubKey = new PubKey().fromPrivKey(privKey);
        return this;
      }
    }, {
      key: 'asyncFromPrivKey',
      value: function asyncFromPrivKey(privKey) {
        return asink(regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.privKey = privKey;
                  _context.next = 3;
                  return new PubKey().asyncFromPrivKey(privKey);

                case 3:
                  this.pubKey = _context.sent;
                  return _context.abrupt('return', this);

                case 5:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }), this);
      }
    }, {
      key: 'fromRandom',
      value: function fromRandom() {
        this.privKey = new PrivKey().fromRandom();
        this.pubKey = new PubKey().fromPrivKey(this.privKey);
        return this;
      }
    }, {
      key: 'asyncFromRandom',
      value: function asyncFromRandom() {
        return asink(regeneratorRuntime.mark(function _callee2() {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  this.privKey = new PrivKey().fromRandom();
                  return _context2.abrupt('return', this.asyncFromPrivKey(this.privKey));

                case 2:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }), this);
      }
    }], [{
      key: 'fromPrivKey',
      value: function fromPrivKey(privKey) {
        return new this().fromPrivKey(privKey);
      }
    }, {
      key: 'asyncFromPrivKey',
      value: function asyncFromPrivKey(privKey) {
        return new this().asyncFromPrivKey(privKey);
      }
    }, {
      key: 'fromRandom',
      value: function fromRandom() {
        return new this().fromRandom();
      }
    }, {
      key: 'asyncFromRandom',
      value: function asyncFromRandom() {
        return new this().asyncFromRandom();
      }
    }]);

    return KeyPair;
  }(Struct);

  return KeyPair;
};

inject = require('injecter')(inject, dependencies);
var KeyPair = inject();
KeyPair.Mainnet = inject({
  PrivKey: require('./priv-key').Mainnet
});
KeyPair.Testnet = inject({
  PrivKey: require('./priv-key').Testnet
});
module.exports = KeyPair;

},{"./bw":329,"./priv-key":337,"./pub-key":338,"./struct":342,"asink":352,"injecter":381}],335:[function(require,module,exports){
/*
 * OpCode
 * ======
 *
 * An opCode is one of the operations in the bitcoin scripting language. Each
 * operation is just a number from 0-255, and it has a corresponding string,
 * e.g. "OP_RETURN", which comes from the name of that constant in the bitcoind
 * source code. The way you probably want to use this is with
 * new OpCode(str).toNumber() or new OpCode(num).toString()
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Struct: require('./struct')
};

var inject = function inject(deps) {
  var Struct = deps.Struct;
  var map = void 0;

  var OpCode = function (_Struct) {
    _inherits(OpCode, _Struct);

    function OpCode(num) {
      _classCallCheck(this, OpCode);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(OpCode).call(this, { num: num }));
    }

    _createClass(OpCode, [{
      key: 'fromNumber',
      value: function fromNumber(num) {
        this.num = num;
        return this;
      }
    }, {
      key: 'toNumber',
      value: function toNumber() {
        return this.num;
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        var num = map[str];
        if (num === undefined) {
          throw new Error('Invalid opCodeStr');
        }
        this.num = num;
        return this;
      }
    }, {
      key: 'toString',
      value: function toString() {
        var str = OpCode.str[this.num];
        if (str === undefined) {
          if (this.num > 0 && this.num < OpCode.OP_PUSHDATA1) {
            return this.num.toString();
          }
          throw new Error('OpCode does not have a string representation');
        }
        return str;
      }
    }], [{
      key: 'fromNumber',
      value: function fromNumber(num) {
        return new this().fromNumber(num);
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        return new this().fromString(str);
      }
    }]);

    return OpCode;
  }(Struct);

  map = {
    // push value
    OP_FALSE: 0x00,
    OP_0: 0x00,
    OP_PUSHDATA1: 0x4c,
    OP_PUSHDATA2: 0x4d,
    OP_PUSHDATA4: 0x4e,
    OP_1NEGATE: 0x4f,
    OP_RESERVED: 0x50,
    OP_TRUE: 0x51,
    OP_1: 0x51,
    OP_2: 0x52,
    OP_3: 0x53,
    OP_4: 0x54,
    OP_5: 0x55,
    OP_6: 0x56,
    OP_7: 0x57,
    OP_8: 0x58,
    OP_9: 0x59,
    OP_10: 0x5a,
    OP_11: 0x5b,
    OP_12: 0x5c,
    OP_13: 0x5d,
    OP_14: 0x5e,
    OP_15: 0x5f,
    OP_16: 0x60,

    // control
    OP_NOP: 0x61,
    OP_VER: 0x62,
    OP_IF: 0x63,
    OP_NOTIF: 0x64,
    OP_VERIF: 0x65,
    OP_VERNOTIF: 0x66,
    OP_ELSE: 0x67,
    OP_ENDIF: 0x68,
    OP_VERIFY: 0x69,
    OP_RETURN: 0x6a,

    // stack ops
    OP_TOALTSTACK: 0x6b,
    OP_FROMALTSTACK: 0x6c,
    OP_2DROP: 0x6d,
    OP_2DUP: 0x6e,
    OP_3DUP: 0x6f,
    OP_2OVER: 0x70,
    OP_2ROT: 0x71,
    OP_2SWAP: 0x72,
    OP_IFDUP: 0x73,
    OP_DEPTH: 0x74,
    OP_DROP: 0x75,
    OP_DUP: 0x76,
    OP_NIP: 0x77,
    OP_OVER: 0x78,
    OP_PICK: 0x79,
    OP_ROLL: 0x7a,
    OP_ROT: 0x7b,
    OP_SWAP: 0x7c,
    OP_TUCK: 0x7d,

    // splice ops
    OP_CAT: 0x7e,
    OP_SUBSTR: 0x7f,
    OP_LEFT: 0x80,
    OP_RIGHT: 0x81,
    OP_SIZE: 0x82,

    // bit logic
    OP_INVERT: 0x83,
    OP_AND: 0x84,
    OP_OR: 0x85,
    OP_XOR: 0x86,
    OP_EQUAL: 0x87,
    OP_EQUALVERIFY: 0x88,
    OP_RESERVED1: 0x89,
    OP_RESERVED2: 0x8a,

    // numeric
    OP_1ADD: 0x8b,
    OP_1SUB: 0x8c,
    OP_2MUL: 0x8d,
    OP_2DIV: 0x8e,
    OP_NEGATE: 0x8f,
    OP_ABS: 0x90,
    OP_NOT: 0x91,
    OP_0NOTEQUAL: 0x92,

    OP_ADD: 0x93,
    OP_SUB: 0x94,
    OP_MUL: 0x95,
    OP_DIV: 0x96,
    OP_MOD: 0x97,
    OP_LSHIFT: 0x98,
    OP_RSHIFT: 0x99,

    OP_BOOLAND: 0x9a,
    OP_BOOLOR: 0x9b,
    OP_NUMEQUAL: 0x9c,
    OP_NUMEQUALVERIFY: 0x9d,
    OP_NUMNOTEQUAL: 0x9e,
    OP_LESSTHAN: 0x9f,
    OP_GREATERTHAN: 0xa0,
    OP_LESSTHANOREQUAL: 0xa1,
    OP_GREATERTHANOREQUAL: 0xa2,
    OP_MIN: 0xa3,
    OP_MAX: 0xa4,

    OP_WITHIN: 0xa5,

    // crypto
    OP_RIPEMD160: 0xa6,
    OP_SHA1: 0xa7,
    OP_SHA256: 0xa8,
    OP_HASH160: 0xa9,
    OP_HASH256: 0xaa,
    OP_CODESEPARATOR: 0xab,
    OP_CHECKSIG: 0xac,
    OP_CHECKSIGVERIFY: 0xad,
    OP_CHECKMULTISIG: 0xae,
    OP_CHECKMULTISIGVERIFY: 0xaf,

    // expansion
    OP_NOP1: 0xb0,
    OP_NOP2: 0xb1,
    OP_CHECKLOCKTIMEVERIFY: 0xb1,
    OP_NOP3: 0xb2,
    OP_CHECKSEQUENCEVERIFY: 0xb2,
    OP_NOP4: 0xb3,
    OP_NOP5: 0xb4,
    OP_NOP6: 0xb5,
    OP_NOP7: 0xb6,
    OP_NOP8: 0xb7,
    OP_NOP9: 0xb8,
    OP_NOP10: 0xb9,

    // template matching params
    OP_SMALLDATA: 0xf9,
    OP_SMALLINTEGER: 0xfa,
    OP_PUBKEYS: 0xfb,
    OP_PUBKEYHASH: 0xfd,
    OP_PUBKEY: 0xfe,

    OP_INVALIDOPCODE: 0xff
  };

  OpCode.str = {};

  for (var k in map) {
    OpCode[k] = map[k];
    if (map.hasOwnProperty(k)) {
      OpCode.str[map[k]] = k;
    }
  }

  return OpCode;
};

inject = require('injecter')(inject, dependencies);
var OpCode = inject();
module.exports = OpCode;

},{"./struct":342,"injecter":381}],336:[function(require,module,exports){
/**
 * Point (on secp256k1)
 * ====================
 *
 * A point is a point on the secp256k1 curve which is the elliptic curve used
 * by bitcoin. This code is a wrapper for Fedor Indutny's Point class from his
 * elliptic library. This code adds a few minor conveniences, but is mostly the
 * same. Since Fedor's code returns points and big numbers that are instances
 * of his point and big number classes, we have to wrap all the methods such as
 * getX() to return the Yours Bitcoin point and big number types.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Bn: require('./bn'),
  elliptic: require('elliptic')
};

var inject = function inject(deps) {
  var Bn = deps.Bn;
  var elliptic = deps.elliptic;

  var ec = elliptic.curves.secp256k1;
  var _point = ec.curve.point();
  var _Point = _point.constructor;

  var Point = function (_Point2) {
    _inherits(Point, _Point2);

    function Point(x, y, isRed) {
      _classCallCheck(this, Point);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Point).call(this, ec.curve, x, y, isRed));
    }

    _createClass(Point, [{
      key: 'copyFrom',
      value: function copyFrom(point) {
        if (!(point instanceof _Point)) {
          throw new Error('point should be an external point');
        }
        Object.keys(point).forEach(function (key) {
          this[key] = point[key];
        }.bind(this));
        return this;
      }
    }, {
      key: 'add',
      value: function add(p) {
        p = _Point.prototype.add.call(this, p);
        var point = Object.create(Point.prototype);
        return point.copyFrom(p);
      }
    }, {
      key: 'mul',
      value: function mul(bn) {
        var p = _Point.prototype.mul.call(this, bn);
        var point = Object.create(Point.prototype);
        return point.copyFrom(p);
      }
    }, {
      key: 'mulAdd',
      value: function mulAdd(bn1, point, bn2) {
        var p = _Point.prototype.mulAdd.call(this, bn1, point, bn2);
        point = Object.create(Point.prototype);
        return point.copyFrom(p);
      }
    }, {
      key: 'getX',
      value: function getX() {
        var _x = _Point.prototype.getX.call(this);
        var x = Object.create(Bn.prototype);
        _x.copy(x);
        return x;
      }
    }, {
      key: 'getY',
      value: function getY() {
        var _y = _Point.prototype.getY.call(this);
        var y = Object.create(Bn.prototype);
        _y.copy(y);
        return y;
      }
    }, {
      key: 'fromX',
      value: function fromX(isOdd, x) {
        var point = Point.fromX(isOdd, x);
        return this.copyFrom(point);
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        return {
          x: this.getX().toString(),
          y: this.getY().toString()
        };
      }
    }, {
      key: 'fromJSON',
      value: function fromJSON(json) {
        var x = new Bn().fromString(json.x);
        var y = new Bn().fromString(json.y);
        var point = new Point(x, y);
        return this.copyFrom(point);
      }
    }, {
      key: 'toString',
      value: function toString() {
        return JSON.stringify(this.toJSON());
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        var json = JSON.parse(str);
        var p = new Point().fromJSON(json);
        return this.copyFrom(p);
      }
    }, {
      key: 'validate',


      // https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf
      value: function validate() {
        var p2 = Point.fromX(this.getY().isOdd(), this.getX());
        if (!(p2.getY().cmp(this.getY()) === 0)) {
          throw new Error('Invalid y value of public key');
        }
        if (!(this.getX().gt(-1) && this.getX().lt(Point.getN())) || !(this.getY().gt(-1) && this.getY().lt(Point.getN()))) {
          throw new Error('Point does not lie on the curve');
        }
        if (!this.mul(Point.getN()).isInfinity()) {
          throw new Error('Point times N must be infinity');
        }
        return this;
      }
    }], [{
      key: 'fromX',
      value: function fromX(isOdd, x) {
        var _point = ec.curve.pointFromX(x, isOdd);
        var point = Object.create(Point.prototype);
        return point.copyFrom(_point);
      }
    }, {
      key: 'getG',
      value: function getG() {
        var _g = ec.curve.g;
        var g = Object.create(Point.prototype);
        return g.copyFrom(_g);
      }
    }, {
      key: 'getN',
      value: function getN() {
        return new Bn(ec.curve.n.toArray());
      }
    }]);

    return Point;
  }(_Point);

  return Point;
};

inject = require('injecter')(inject, dependencies);
var Point = inject();
module.exports = Point;

},{"./bn":327,"elliptic":357,"injecter":381}],337:[function(require,module,exports){
(function (Buffer){
/**
 * Private Key
 * ===========
 *
 * A private key is used for signIng transactions (or messages). The primary
 * way to use this is new PrivKey().fromRandom(), or new PrivKey().fromBuffer(buf).
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Bn: require('./bn'),
  Point: require('./point'),
  Constants: require('./constants').Default.PrivKey,
  Base58Check: require('./base-58-check'),
  Random: require('./random'),
  Struct: require('./struct')
};

var inject = function inject(deps) {
  var Bn = deps.Bn;
  var Point = deps.Point;
  var Constants = deps.Constants;
  var Base58Check = deps.Base58Check;
  var Random = deps.Random;
  var Struct = deps.Struct;

  var PrivKey = function (_Struct) {
    _inherits(PrivKey, _Struct);

    function PrivKey(bn, compressed) {
      _classCallCheck(this, PrivKey);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(PrivKey).call(this, { bn: bn, compressed: compressed }));
    }

    _createClass(PrivKey, [{
      key: 'fromJSON',
      value: function fromJSON(json) {
        this.fromHex(json);
        return this;
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        return this.toHex();
      }
    }, {
      key: 'fromRandom',
      value: function fromRandom() {
        var privBuf = void 0,
            bn = void 0,
            condition = void 0;

        do {
          privBuf = Random.getRandomBuffer(32);
          bn = new Bn().fromBuffer(privBuf);
          condition = bn.lt(Point.getN());
        } while (!condition);

        this.fromObject({
          bn: bn,
          compressed: true
        });
        return this;
      }
    }, {
      key: 'toBuffer',
      value: function toBuffer() {
        var compressed = this.compressed;

        if (compressed === undefined) {
          compressed = true;
        }

        var privBuf = this.bn.toBuffer({ size: 32 });
        var buf = void 0;
        if (compressed) {
          buf = Buffer.concat([new Buffer([Constants.versionByteNum]), privBuf, new Buffer([0x01])]);
        } else {
          buf = Buffer.concat([new Buffer([Constants.versionByteNum]), privBuf]);
        }

        return buf;
      }
    }, {
      key: 'fromBuffer',
      value: function fromBuffer(buf) {
        if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {
          this.compressed = true;
        } else if (buf.length === 1 + 32) {
          this.compressed = false;
        } else {
          throw new Error('LEngth of privKey buffer must be 33 (uncompressed pubKey) or 34 (compressed pubKey)');
        }

        if (buf[0] !== Constants.versionByteNum) {
          throw new Error('Invalid versionByteNum byte');
        }

        return this.fromBn(new Bn().fromBuffer(buf.slice(1, 1 + 32)));
      }
    }, {
      key: 'toBn',
      value: function toBn() {
        return this.bn;
      }
    }, {
      key: 'fromBn',
      value: function fromBn(bn) {
        this.bn = bn;
        return this;
      }
    }, {
      key: 'validate',
      value: function validate() {
        if (!this.bn.lt(Point.getN())) {
          throw new Error('Number must be less than N');
        }
        if (typeof this.compressed !== 'boolean') {
          throw new Error('Must specify whether the corresponding public key is compressed or not (true or false)');
        }
        return this;
      }

      /**
       * Output the private key a Wallet Import Format (Wif) string.
       */

    }, {
      key: 'toWif',
      value: function toWif() {
        return Base58Check.encode(this.toBuffer());
      }

      /**
       * Input the private key from a Wallet Import Format (Wif) string.
       */

    }, {
      key: 'fromWif',
      value: function fromWif(str) {
        return this.fromBuffer(Base58Check.decode(str));
      }
    }, {
      key: 'toString',
      value: function toString() {
        return this.toWif();
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        return this.fromWif(str);
      }
    }], [{
      key: 'fromRandom',
      value: function fromRandom() {
        return new this().fromRandom();
      }
    }, {
      key: 'fromBn',
      value: function fromBn(bn) {
        return new this().fromBn(bn);
      }
    }, {
      key: 'fromWif',
      value: function fromWif(str) {
        return new this().fromWif(str);
      }
    }]);

    return PrivKey;
  }(Struct);

  return PrivKey;
};

inject = require('injecter')(inject, dependencies);
var PrivKey = inject();
PrivKey.Mainnet = inject({
  Constants: require('./constants').Mainnet.PrivKey
});
PrivKey.Testnet = inject({
  Constants: require('./constants').Testnet.PrivKey
});
module.exports = PrivKey;

}).call(this,require("buffer").Buffer)

},{"./base-58-check":325,"./bn":327,"./constants":331,"./point":336,"./random":339,"./struct":342,"buffer":23,"injecter":381}],338:[function(require,module,exports){
(function (Buffer){
/**
 * Public Key
 * ==========
 *
 * A public key corresponds to a private key. If you have a private key, you
 * can find the corresponding public key with new PubKey().fromPrivKey(privKey).
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Point: require('./point'),
  Bn: require('./bn'),
  Bw: require('./bw'),
  Struct: require('./struct'),
  Workers: require('./workers'),
  asink: require('asink')
};

var inject = function inject(deps) {
  var Point = deps.Point;
  var Bn = deps.Bn;
  var Bw = deps.Bw;
  var Struct = deps.Struct;
  var Workers = deps.Workers;
  var asink = deps.asink;

  var PubKey = function (_Struct) {
    _inherits(PubKey, _Struct);

    function PubKey(point) {
      _classCallCheck(this, PubKey);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(PubKey).call(this, { point: point }));
    }

    _createClass(PubKey, [{
      key: 'fromJSON',
      value: function fromJSON(json) {
        this.fromFastHex(json);
        return this;
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        return this.toFastHex();
      }
    }, {
      key: 'fromPrivKey',
      value: function fromPrivKey(privKey) {
        this.fromObject({
          point: Point.getG().mul(privKey.bn),
          compressed: privKey.compressed
        });
        return this;
      }
    }, {
      key: 'asyncFromPrivKey',
      value: function asyncFromPrivKey(privKey) {
        return asink(regeneratorRuntime.mark(function _callee() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Workers.asyncObjectMethod(this, 'fromPrivKey', [privKey]);

                case 2:
                  workersResult = _context.sent;
                  return _context.abrupt('return', this.fromFastBuffer(workersResult.resbuf));

                case 4:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }), this);
      }
    }, {
      key: 'fromBuffer',
      value: function fromBuffer(buf, strict) {
        return this.fromDer(buf, strict);
      }
    }, {
      key: 'asyncFromBuffer',
      value: function asyncFromBuffer(buf, strict) {
        return asink(regeneratorRuntime.mark(function _callee2() {
          var args, workersResult;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  args = [buf, strict];
                  _context2.next = 3;
                  return Workers.asyncObjectMethod(this, 'fromBuffer', args);

                case 3:
                  workersResult = _context2.sent;
                  return _context2.abrupt('return', this.fromFastBuffer(workersResult.resbuf));

                case 5:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }), this);
      }
    }, {
      key: 'fromFastBuffer',
      value: function fromFastBuffer(buf) {
        if (buf.length === 0) {
          return this;
        }
        var compressed = Boolean(buf[0]);
        buf = buf.slice(1);
        this.fromDer(buf);
        this.compressed = compressed;
        return this;
      }

      /**
       * In order to mimic the non-strict style of OpenSSL, set strict = false. For
       * information and what prefixes 0x06 and 0x07 mean, in addition to the normal
       * compressed and uncompressed public keys, see the message by Peter Wuille
       * where he discovered these "hybrid pubKeys" on the mailing list:
       * http://sourceforge.net/p/bitcoin/mailman/message/29416133/
       */

    }, {
      key: 'fromDer',
      value: function fromDer(buf, strict) {
        if (strict === undefined) {
          strict = true;
        } else {
          strict = false;
        }
        if (buf[0] === 0x04 || !strict && (buf[0] === 0x06 || buf[0] === 0x07)) {
          var xbuf = buf.slice(1, 33);
          var ybuf = buf.slice(33, 65);
          if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {
            throw new Error('LEngth of x and y must be 32 bytes');
          }
          var x = new Bn(xbuf);
          var y = new Bn(ybuf);
          this.point = new Point(x, y);
          this.compressed = false;
        } else if (buf[0] === 0x03) {
          var _xbuf = buf.slice(1);
          var _x = new Bn(_xbuf);
          this.fromX(true, _x);
          this.compressed = true;
        } else if (buf[0] === 0x02) {
          var _xbuf2 = buf.slice(1);
          var _x2 = new Bn(_xbuf2);
          this.fromX(false, _x2);
          this.compressed = true;
        } else {
          throw new Error('Invalid DER format pubKey');
        }
        return this;
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        this.fromDer(new Buffer(str, 'hex'));
        return this;
      }
    }, {
      key: 'fromX',
      value: function fromX(odd, x) {
        if (typeof odd !== 'boolean') {
          throw new Error('Must specify whether y is odd or not (true or false)');
        }
        this.point = Point.fromX(odd, x);
        return this;
      }
    }, {
      key: 'toBuffer',
      value: function toBuffer() {
        var compressed = this.compressed === undefined ? true : this.compressed;
        return this.toDer(compressed);
      }
    }, {
      key: 'toFastBuffer',
      value: function toFastBuffer() {
        if (!this.point) {
          return new Buffer(0);
        }
        var bw = new Bw();
        var compressed = this.compressed === undefined ? true : Boolean(this.compressed);
        bw.writeUInt8(Number(compressed));
        bw.write(this.toDer(false));
        return bw.toBuffer();
      }
    }, {
      key: 'toDer',
      value: function toDer(compressed) {
        compressed = compressed === undefined ? this.compressed : compressed;
        if (typeof compressed !== 'boolean') {
          throw new Error('Must specify whether the public key is compressed or not (true or false)');
        }

        var x = this.point.getX();
        var y = this.point.getY();

        var xbuf = x.toBuffer({ size: 32 });
        var ybuf = y.toBuffer({ size: 32 });

        var prefix = void 0;
        if (!compressed) {
          prefix = new Buffer([0x04]);
          return Buffer.concat([prefix, xbuf, ybuf]);
        } else {
          var odd = ybuf[ybuf.length - 1] % 2;
          if (odd) {
            prefix = new Buffer([0x03]);
          } else {
            prefix = new Buffer([0x02]);
          }
          return Buffer.concat([prefix, xbuf]);
        }
      }
    }, {
      key: 'toString',
      value: function toString() {
        var compressed = this.compressed === undefined ? true : this.compressed;
        return this.toDer(compressed).toString('hex');
      }

      /**
       * Translated from bitcoind's IsCompressedOrUncompressedPubKey
       */

    }, {
      key: 'validate',


      // https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf
      value: function validate() {
        if (this.point.isInfinity()) {
          throw new Error('point: Point cannot be equal to Infinity');
        }
        if (this.point.eq(new Point(new Bn(0), new Bn(0)))) {
          throw new Error('point: Point cannot be equal to 0, 0');
        }
        this.point.validate();
        return this;
      }
    }], [{
      key: 'fromPrivKey',
      value: function fromPrivKey(privKey) {
        return new this().fromPrivKey(privKey);
      }
    }, {
      key: 'asyncFromPrivKey',
      value: function asyncFromPrivKey(privKey) {
        return new this().asyncFromPrivKey(privKey);
      }
    }, {
      key: 'fromDer',
      value: function fromDer(buf, strict) {
        return new this().fromDer(buf, strict);
      }
    }, {
      key: 'fromX',
      value: function fromX(odd, x) {
        return new this().fromX(odd, x);
      }
    }, {
      key: 'isCompressedOrUncompressed',
      value: function isCompressedOrUncompressed(buf) {
        if (buf.length < 33) {
          //  Non-canonical public key: too short
          return false;
        }
        if (buf[0] === 0x04) {
          if (buf.length !== 65) {
            //  Non-canonical public key: invalid length for uncompressed key
            return false;
          }
        } else if (buf[0] === 0x02 || buf[0] === 0x03) {
          if (buf.length !== 33) {
            //  Non-canonical public key: invalid length for compressed key
            return false;
          }
        } else {
          //  Non-canonical public key: neither compressed nor uncompressed
          return false;
        }
        return true;
      }
    }]);

    return PubKey;
  }(Struct);

  return PubKey;
};

inject = require('injecter')(inject, dependencies);
var PubKey = inject();
module.exports = PubKey;

}).call(this,require("buffer").Buffer)

},{"./bn":327,"./bw":329,"./point":336,"./struct":342,"./workers":351,"asink":352,"buffer":23,"injecter":381}],339:[function(require,module,exports){
/**
 * Random Number Generator
 * =======================
 *
 * Random numbers are important in bitcoin primarily for generating private
 * keys. It is also important for creating signatures if you are using a random
 * value of k, but Yours Bitcoin defaults to using deterministic k. That means
 * computing a random private key, or a random seed for use in Bip39 or Bip32,
 * is the primary use of the random number generator.  Note that the simplicity
 * of this class is extremely carefully considered. It is easy to audit that
 * this code runs node's randomBytes function. It is also easy to audit that
 * the randomBytes method is correctly interpreted as
 * window.crypto.getRandomValues when this code is browserified by browserify,
 * and thus also works correctly in the browser. We deliberately do not do
 * anything else to this random number in order to minimize possible errors in
 * this absolutely critical code.
 */
'use strict';

var dependencies = {
  randomBytes: require('randombytes')
};

var inject = function inject(deps) {
  var randomBytes = deps.randomBytes;

  var Random = {};

  Random.getRandomBuffer = function (size) {
    return randomBytes(size);
  };

  return Random;
};

inject = require('injecter')(inject, dependencies);
var Random = inject();
module.exports = Random;

},{"injecter":381,"randombytes":382}],340:[function(require,module,exports){
(function (Buffer){
/*
 * Script
 * ======
 *
 * Script is the scripting language built into bitcoin. The Script class lets
 * you create an instance of a script, e.g. for a scriptSig or a scriptPubKey.
 * It understands both the binary format, as well as two different string
 * formats. The default string format, to/fromString, is a custom format only
 * used by Yours Bitcoin because it is isomorphic to the binary format (or as
 * isomorphic as it can be ... since OP_0 and OP_FALSE have the same byte
 * value, and so do OP_1 and OP_TRUE). The bitcoind string format is also
 * support, but that format is not isomorphic (i.e., if you pull in a string
 * and then write it again, you are likely to get back a different string, even
 * if you don't use OP_0, OP_FALSE, OP_1, or OP_TRUE).
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Bn: require('./bn'),
  Br: require('./br'),
  Bw: require('./bw'),
  cmp: require('./cmp'),
  OpCode: require('./op-code'),
  PubKey: require('./pub-key'),
  Sig: require('./sig'),
  Struct: require('./struct')
};

var inject = function inject(deps) {
  var Bn = deps.Bn;
  var Br = deps.Br;
  var Bw = deps.Bw;
  var cmp = deps.cmp;
  var OpCode = deps.OpCode;
  var PubKey = deps.PubKey;
  var Sig = deps.Sig;
  var Struct = deps.Struct;

  var Script = function (_Struct) {
    _inherits(Script, _Struct);

    function Script() {
      var chunks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

      _classCallCheck(this, Script);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Script).call(this, { chunks: chunks }));
    }

    _createClass(Script, [{
      key: 'fromJSON',
      value: function fromJSON(json) {
        return this.fromString(json);
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        return this.toString();
      }
    }, {
      key: 'fromBuffer',
      value: function fromBuffer(buf) {
        this.chunks = [];

        var br = new Br(buf);
        while (!br.eof()) {
          var opCodeNum = br.readUInt8();

          var len = void 0,
              _buf = void 0;
          if (opCodeNum > 0 && opCodeNum < OpCode.OP_PUSHDATA1) {
            len = opCodeNum;
            this.chunks.push({
              buf: br.read(len),
              len: len,
              opCodeNum: opCodeNum
            });
          } else if (opCodeNum === OpCode.OP_PUSHDATA1) {
            len = br.readUInt8();
            var _buf2 = br.read(len);
            this.chunks.push({
              buf: _buf2,
              len: len,
              opCodeNum: opCodeNum
            });
          } else if (opCodeNum === OpCode.OP_PUSHDATA2) {
            len = br.readUInt16LE();
            _buf = br.read(len);
            this.chunks.push({
              buf: _buf,
              len: len,
              opCodeNum: opCodeNum
            });
          } else if (opCodeNum === OpCode.OP_PUSHDATA4) {
            len = br.readUInt32LE();
            _buf = br.read(len);
            this.chunks.push({
              buf: _buf,
              len: len,
              opCodeNum: opCodeNum
            });
          } else {
            this.chunks.push({
              opCodeNum: opCodeNum
            });
          }
        }

        return this;
      }
    }, {
      key: 'toBuffer',
      value: function toBuffer() {
        var bw = new Bw();

        for (var i = 0; i < this.chunks.length; i++) {
          var chunk = this.chunks[i];
          var opCodeNum = chunk.opCodeNum;
          bw.writeUInt8(opCodeNum);
          if (chunk.buf) {
            if (opCodeNum < OpCode.OP_PUSHDATA1) {
              bw.write(chunk.buf);
            } else if (opCodeNum === OpCode.OP_PUSHDATA1) {
              bw.writeUInt8(chunk.len);
              bw.write(chunk.buf);
            } else if (opCodeNum === OpCode.OP_PUSHDATA2) {
              bw.writeUInt16LE(chunk.len);
              bw.write(chunk.buf);
            } else if (opCodeNum === OpCode.OP_PUSHDATA4) {
              bw.writeUInt32LE(chunk.len);
              bw.write(chunk.buf);
            }
          }
        }

        return bw.toBuffer();
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        this.chunks = [];
        if (str === '' || str === undefined) {
          return this;
        }

        var tokens = str.split(' ');
        var i = 0;
        while (i < tokens.length) {
          var token = tokens[i];
          var opCodeNum = void 0;
          try {
            var opCode = new OpCode().fromString(token);
            opCodeNum = opCode.toNumber();
          } catch (err) {}

          if (opCodeNum === undefined) {
            opCodeNum = parseInt(token, 10);
            if (opCodeNum > 0 && opCodeNum < OpCode.OP_PUSHDATA1) {
              this.chunks.push({
                buf: new Buffer(tokens[i + 1].slice(2), 'hex'),
                len: opCodeNum,
                opCodeNum: opCodeNum
              });
              i = i + 2;
            } else if (opCodeNum === 0) {
              this.chunks.push({
                opCodeNum: 0
              });
              i = i + 1;
            } else {
              throw new Error('Invalid script');
            }
          } else if (opCodeNum === OpCode.OP_PUSHDATA1 || opCodeNum === OpCode.OP_PUSHDATA2 || opCodeNum === OpCode.OP_PUSHDATA4) {
            if (tokens[i + 2].slice(0, 2) !== '0x') {
              throw new Error('Pushdata data must start with 0x');
            }
            this.chunks.push({
              buf: new Buffer(tokens[i + 2].slice(2), 'hex'),
              len: parseInt(tokens[i + 1], 10),
              opCodeNum: opCodeNum
            });
            i = i + 3;
          } else {
            this.chunks.push({
              opCodeNum: opCodeNum
            });
            i = i + 1;
          }
        }
        return this;
      }
    }, {
      key: 'toString',
      value: function toString() {
        var str = '';

        for (var i = 0; i < this.chunks.length; i++) {
          var chunk = this.chunks[i];
          var opCodeNum = chunk.opCodeNum;
          if (!chunk.buf) {
            if (OpCode.str[opCodeNum] !== undefined) {
              str = str + ' ' + new OpCode(opCodeNum).toString();
            } else {
              str = str + ' ' + '0x' + opCodeNum.toString(16);
            }
          } else {
            if (opCodeNum === OpCode.OP_PUSHDATA1 || opCodeNum === OpCode.OP_PUSHDATA2 || opCodeNum === OpCode.OP_PUSHDATA4) {
              str = str + ' ' + new OpCode(opCodeNum).toString();
            }
            str = str + ' ' + chunk.len;
            str = str + ' ' + '0x' + chunk.buf.toString('hex');
          }
        }

        return str.substr(1);
      }

      /**
       * Input the script from the script string format used in bitcoind data tests
       */

    }, {
      key: 'fromBitcoindString',
      value: function fromBitcoindString(str) {
        var bw = new Bw();
        var tokens = str.split(' ');
        var i = void 0;
        for (i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          if (token === '') {
            continue;
          }
          if (token[0] === '0' && token[1] === 'x') {
            var hex = token.slice(2);
            bw.write(new Buffer(hex, 'hex'));
          } else if (token[0] === "'") {
            var tstr = token.slice(1, token.length - 1);
            var cbuf = new Buffer(tstr);
            var tbuf = new Script().writeBuffer(cbuf).toBuffer();
            bw.write(tbuf);
          } else if (OpCode['OP_' + token] !== undefined) {
            var opstr = 'OP_' + token;
            var opCodeNum = OpCode[opstr];
            bw.writeUInt8(opCodeNum);
          } else if (typeof OpCode[token] === 'number') {
            var _opstr = token;
            var _opCodeNum = OpCode[_opstr];
            bw.writeUInt8(_opCodeNum);
          } else if (!isNaN(parseInt(token, 10))) {
            var bn = new Bn(token);
            var script = new Script().writeBn(bn);
            var _tbuf = script.toBuffer();
            bw.write(_tbuf);
          } else {
            throw new Error('Could not determine type of script value');
          }
        }
        var buf = bw.toBuffer();
        return this.fromBuffer(buf);
      }
    }, {
      key: 'toBitcoindString',


      /**
       * Output the script to the script string format used in bitcoind data tests.
       */
      value: function toBitcoindString() {
        var str = '';
        for (var i = 0; i < this.chunks.length; i++) {
          var chunk = this.chunks[i];
          if (chunk.buf) {
            var buf = new Script([chunk]).toBuffer();
            var hex = buf.toString('hex');
            str = str + ' ' + '0x' + hex;
          } else if (OpCode.str[chunk.opCodeNum] !== undefined) {
            var ostr = new OpCode(chunk.opCodeNum).toString();
            str = str + ' ' + ostr.slice(3); // remove OP_
          } else {
            str = str + ' ' + '0x' + chunk.opCodeNum.toString(16);
          }
        }
        return str.substr(1);
      }

      /**
       * Turn script into a standard pubKeyHash output script
       */

    }, {
      key: 'fromPubKeyHash',
      value: function fromPubKeyHash(hashBuf) {
        if (hashBuf.length !== 20) {
          throw new Error('hashBuf must be a 20 byte buffer');
        }
        this.writeOpCode(OpCode.OP_DUP);
        this.writeOpCode(OpCode.OP_HASH160);
        this.writeBuffer(hashBuf);
        this.writeOpCode(OpCode.OP_EQUALVERIFY);
        this.writeOpCode(OpCode.OP_CHECKSIG);
        return this;
      }
    }, {
      key: 'fromScriptHash',


      /**
       * Turn script into a standard scriptHash (p2sh) output script
       */
      value: function fromScriptHash(hashBuf) {
        if (hashBuf.length !== 20) {
          throw new Error('hashBuf must be a 20 byte buffer');
        }
        this.writeOpCode(OpCode.OP_HASH160);
        this.writeBuffer(hashBuf);
        this.writeOpCode(OpCode.OP_EQUAL);
        return this;
      }
    }, {
      key: 'fromPubKeys',


      /**
       * Generate a multisig output script from a list of public keys. sort
       * defaults to true. If sort is true, the pubKeys are sorted
       * lexicographically.
      */
      value: function fromPubKeys(m, pubKeys) {
        var sort = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

        if (typeof m !== 'number') {
          throw new Error('m must be a number');
        }
        if (sort === true) {
          pubKeys = Script.sortPubKeys(pubKeys);
        }
        this.writeOpCode(m + OpCode.OP_1 - 1);
        for (var i in pubKeys) {
          this.writeBuffer(pubKeys[i].toBuffer());
        }
        this.writeOpCode(pubKeys.length + OpCode.OP_1 - 1);
        this.writeOpCode(OpCode.OP_CHECKMULTISIG);
        return this;
      }
    }, {
      key: 'removeCodeseparators',
      value: function removeCodeseparators() {
        var chunks = [];
        for (var i = 0; i < this.chunks.length; i++) {
          if (this.chunks[i].opCodeNum !== OpCode.OP_CODESEPARATOR) {
            chunks.push(this.chunks[i]);
          }
        }
        this.chunks = chunks;
        return this;
      }
    }, {
      key: 'isPushOnly',
      value: function isPushOnly() {
        for (var i = 0; i < this.chunks.length; i++) {
          var chunk = this.chunks[i];
          var opCodeNum = chunk.opCodeNum;
          if (opCodeNum > OpCode.OP_16) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: 'isOpReturn',
      value: function isOpReturn() {
        if (this.chunks[0].opCodeNum === OpCode.OP_RETURN && (this.chunks.length === 1 || this.chunks.length === 2 && this.chunks[1].buf && this.chunks[1].buf.length <= 40 && this.chunks[1].length === this.chunks.len)) {
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: 'isPubKeyHashOut',
      value: function isPubKeyHashOut() {
        if (this.chunks[0] && this.chunks[0].opCodeNum === OpCode.OP_DUP && this.chunks[1] && this.chunks[1].opCodeNum === OpCode.OP_HASH160 && this.chunks[2].buf && this.chunks[3] && this.chunks[3].opCodeNum === OpCode.OP_EQUALVERIFY && this.chunks[4] && this.chunks[4].opCodeNum === OpCode.OP_CHECKSIG) {
          return true;
        } else {
          return false;
        }
      }

      /**
       * A pubKeyHash input should consist of two push operations. The first push
       * operation may be OP_0, which means the signature is missing, which is true
       * for some partially signed (and invalid) transactions.
       */

    }, {
      key: 'isPubKeyHashIn',
      value: function isPubKeyHashIn() {
        if (this.chunks.length === 2 && (this.chunks[0].buf || this.chunks[0].opCodeNum === OpCode.OP_0) && this.chunks[1].buf) {
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: 'isScriptHashOut',
      value: function isScriptHashOut() {
        var buf = this.toBuffer();
        return buf.length === 23 && buf[0] === OpCode.OP_HASH160 && buf[1] === 0x14 && buf[22] === OpCode.OP_EQUAL;
      }

      /**
       * Note that these are frequently indistinguishable from pubKeyHashin
       */

    }, {
      key: 'isScriptHashIn',
      value: function isScriptHashIn() {
        if (!this.isPushOnly()) {
          return false;
        }
        try {
          new Script().fromBuffer(this.chunks[this.chunks.length - 1].buf);
        } catch (err) {
          return false;
        }
        return true;
      }

      /**
       * Convenience method to check if a script is both scriptHash (p2sh) and if
       * the redeemScript inside is a multisig output. This is the standard format
       * for inputs of most multisig transactions.
       */

    }, {
      key: 'isScriptHashMultiSigIn',
      value: function isScriptHashMultiSigIn() {
        if (!this.isScriptHashIn()) {
          return false;
        }
        var redeemScript = void 0;
        try {
          redeemScript = new Script().fromBuffer(this.chunks[this.chunks.length - 1].buf);
        } catch (err) {
          return false;
        }
        return redeemScript.isMultiSigOut();
      }
    }, {
      key: 'isMultiSigOut',
      value: function isMultiSigOut() {
        var m = this.chunks[0].opCodeNum - OpCode.OP_1 + 1;
        if (!(m >= 1 && m <= 16)) {
          return false;
        }
        var pubKeychunks = this.chunks.slice(1, this.chunks.length - 2);
        if (!pubKeychunks.every(function (chunk) {
          try {
            var buf = chunk.buf;
            var pubKey = new PubKey().fromDer(buf);
            pubKey.validate();
            return true;
          } catch (err) {
            return false;
          }
        })) {
          return false;
        }
        var n = this.chunks[this.chunks.length - 2].opCodeNum - OpCode.OP_1 + 1;
        if (!(n >= m && n <= 16)) {
          return false;
        }
        if (this.chunks[1 + n + 1].opCodeNum !== OpCode.OP_CHECKMULTISIG) {
          return false;
        }
        return true;
      }
    }, {
      key: 'isMultiSigIn',
      value: function isMultiSigIn() {
        if (this.chunks[0].opCodeNum !== OpCode.OP_0) {
          return false;
        }
        var remainIng = this.chunks.slice(1);
        if (remainIng.length < 1) {
          return false;
        }
        return remainIng.every(function (chunk) {
          return Buffer.isBuffer(chunk.buf) && Sig.IsTxDer(chunk.buf);
        });
      }

      /**
       * Analagous to bitcoind's FindAndDelete. Find and delete equivalent chunks,
       * typically used with push data chunks.  Note that this will find and delete
       * not just the same data, but the same data with the same push data op as
       * produced by default. i.e., if a pushdata in a tx does not use the minimal
       * pushdata op, then when you try to remove the data it is pushing, it will not
       * be removed, because they do not use the same pushdata op.
       */

    }, {
      key: 'findAndDelete',
      value: function findAndDelete(script) {
        var buf = script.toBuffer();
        for (var i = 0; i < this.chunks.length; i++) {
          var script2 = new Script([this.chunks[i]]);
          var buf2 = script2.toBuffer();
          if (cmp(buf, buf2)) {
            this.chunks.splice(i, 1);
          }
        }
        return this;
      }
    }, {
      key: 'writeScript',
      value: function writeScript(script) {
        this.chunks = this.chunks.concat(script.chunks);
        return this;
      }
    }, {
      key: 'writeString',
      value: function writeString(str) {
        var script = new Script().fromString(str);
        this.chunks = this.chunks.concat(script.chunks);
        return this;
      }
    }, {
      key: 'writeOpCode',
      value: function writeOpCode(opCodeNum) {
        this.chunks.push({ opCodeNum: opCodeNum });
        return this;
      }
    }, {
      key: 'setChunkOpCode',
      value: function setChunkOpCode(i, opCodeNum) {
        this.chunks[i] = { opCodeNum: opCodeNum };
        return this;
      }

      // write a big number in the minimal way

    }, {
      key: 'writeBn',
      value: function writeBn(bn) {
        if (bn.cmp(0) === OpCode.OP_0) {
          this.chunks.push({
            opCodeNum: OpCode.OP_0
          });
        } else if (bn.cmp(-1) === 0) {
          this.chunks.push({
            opCodeNum: OpCode.OP_1NEGATE
          });
        } else if (bn.cmp(1) >= 0 && bn.cmp(16) <= 0) {
          // see OP_1 - OP_16
          this.chunks.push({
            opCodeNum: bn.toNumber() + OpCode.OP_1 - 1
          });
        } else {
          var buf = bn.toSm({ endian: 'little' });
          this.writeBuffer(buf);
        }
        return this;
      }
    }, {
      key: 'setChunkBn',
      value: function setChunkBn(i, bn) {
        this.chunks[i] = new Script().writeBn(bn).chunks[0];
        return this;
      }

      // note: this does not necessarily write buffers in the minimal way
      // to write numbers in the minimal way, see writeBn

    }, {
      key: 'writeBuffer',
      value: function writeBuffer(buf) {
        var opCodeNum = void 0;
        var len = buf.length;
        if (buf.length > 0 && buf.length < OpCode.OP_PUSHDATA1) {
          opCodeNum = buf.length;
        } else if (buf.length === 0) {
          opCodeNum = OpCode.OP_0;
        } else if (buf.length < Math.pow(2, 8)) {
          opCodeNum = OpCode.OP_PUSHDATA1;
        } else if (buf.length < Math.pow(2, 16)) {
          opCodeNum = OpCode.OP_PUSHDATA2;
        } else if (buf.length < Math.pow(2, 32)) {
          opCodeNum = OpCode.OP_PUSHDATA4;
        } else {
          throw new Error("You can't push that much data");
        }
        this.chunks.push({
          buf: buf,
          len: len,
          opCodeNum: opCodeNum
        });
        return this;
      }
    }, {
      key: 'setChunkBuffer',
      value: function setChunkBuffer(i, buf) {
        this.chunks[i] = new Script().writeBuffer(buf).chunks[0];
        return this;
      }

      // make sure a push is the smallest way to push that particular data
      // comes from bitcoind's script interpreter CheckMinimalPush function

    }, {
      key: 'checkMinimalPush',
      value: function checkMinimalPush(i) {
        var chunk = this.chunks[i];
        var buf = chunk.buf;
        var opCodeNum = chunk.opCodeNum;
        if (!buf) {
          return true;
        }
        if (buf.length === 0) {
          // Could have used OP_0.
          return opCodeNum === OpCode.OP_0;
        } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {
          // Could have used OP_1 .. OP_16.
          return opCodeNum === OpCode.OP_1 + (buf[0] - 1);
        } else if (buf.length === 1 && buf[0] === 0x81) {
          // Could have used OP_1NEGATE.
          return opCodeNum === OpCode.OP_1NEGATE;
        } else if (buf.length <= 75) {
          // Could have used a direct push (opCode indicating number of bytes pushed + those bytes).
          return opCodeNum === buf.length;
        } else if (buf.length <= 255) {
          // Could have used OP_PUSHDATA.
          return opCodeNum === OpCode.OP_PUSHDATA1;
        } else if (buf.length <= 65535) {
          // Could have used OP_PUSHDATA2.
          return opCodeNum === OpCode.OP_PUSHDATA2;
        }
        return true;
      }
    }], [{
      key: 'fromBitcoindString',
      value: function fromBitcoindString(str) {
        return new this().fromBitcoindString(str);
      }
    }, {
      key: 'fromPubKeyHash',
      value: function fromPubKeyHash(hashBuf) {
        return new this().fromPubKeyHash(hashBuf);
      }
    }, {
      key: 'fromScriptHash',
      value: function fromScriptHash(hashBuf) {
        return new this().fromScriptHash(hashBuf);
      }
    }, {
      key: 'sortPubKeys',
      value: function sortPubKeys(pubKeys) {
        return pubKeys.slice().sort(function (pubKey1, pubKey2) {
          var buf1 = pubKey1.toBuffer();
          var buf2 = pubKey2.toBuffer();
          var len = buf1.length > buf1.length ? buf1.length : buf2.length;
          for (var i = 0; i <= len; i++) {
            if (buf1[i] === undefined) {
              return -1; // shorter strings come first
            }
            if (buf2[i] === undefined) {
              return 1;
            }
            if (buf1[i] < buf2[i]) {
              return -1;
            }
            if (buf1[i] > buf2[i]) {
              return 1;
            } else {
              continue;
            }
          }
        });
      }
    }, {
      key: 'fromPubKeys',
      value: function fromPubKeys(m, pubKeys, sort) {
        return new this().fromPubKeys(m, pubKeys, sort);
      }
    }, {
      key: 'writeScript',
      value: function writeScript(script) {
        return new this().writeScript(script);
      }
    }, {
      key: 'writeString',
      value: function writeString(str) {
        return new this().writeString(str);
      }
    }, {
      key: 'writeOpCode',
      value: function writeOpCode(opCodeNum) {
        return new this().writeOpCode(opCodeNum);
      }
    }, {
      key: 'writeBn',
      value: function writeBn(bn) {
        return new this().writeBn(bn);
      }
    }, {
      key: 'writeBuffer',
      value: function writeBuffer(buf) {
        return new this().writeBuffer(buf);
      }
    }]);

    return Script;
  }(Struct);

  return Script;
};

inject = require('injecter')(inject, dependencies);
var Script = inject();
module.exports = Script;

}).call(this,require("buffer").Buffer)

},{"./bn":327,"./br":328,"./bw":329,"./cmp":330,"./op-code":335,"./pub-key":338,"./sig":341,"./struct":342,"buffer":23,"injecter":381}],341:[function(require,module,exports){
(function (Buffer){
/**
 * Signature
 * =========
 *
 * A signature is the thing you make when you want to sign a transaction, or
 * the thing you want to verify if you want to ensure that someone signed a
 * transaction. It has an r and s value, which are the cryptographic big
 * numbers that define a signature. And since this is a bitcoin library, it
 * also has nHashType, which is the way to hash a transaction and is used in
 * the binary format of a signature when it is in a transaction. We also
 * support a public key recover value, recovery, allowing one to compute the
 * public key from a signature. The "compressed" value is also necessary to
 * accurately compute the public key from a signature.
 *
 * There are a few different formats of a signature in bitcoin. One is DER, the
 * other is the TxFormat which is the same as DER but with the nHashType byte
 * appended, and the final one is Compact, which is used by Bitcoin Signed
 * Message (Bsm).
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Bn: require('./bn'),
  Struct: require('./struct')
};

var inject = function inject(deps) {
  var Bn = deps.Bn;
  var Struct = deps.Struct;

  /**
   * r, s: big numbers constiting a cryptographic signature
   * nHashType: found at the end of a signature in a transaction
   * recovery: public key recovery number
   * compressed: whether the recovered pubKey is compressed
   */

  var Sig = function (_Struct) {
    _inherits(Sig, _Struct);

    function Sig(r, s, nHashType, recovery, compressed) {
      _classCallCheck(this, Sig);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Sig).call(this, { r: r, s: s, nHashType: nHashType, recovery: recovery, compressed: compressed }));
    }

    _createClass(Sig, [{
      key: 'fromBuffer',
      value: function fromBuffer(buf) {
        try {
          return this.fromDer(buf, true);
        } catch (e) {}
        try {
          return this.fromCompact(buf);
        } catch (e) {}
        return this.fromTxFormat(buf);
      }
    }, {
      key: 'toBuffer',
      value: function toBuffer() {
        if (this.nHashType !== undefined) {
          return this.toTxFormat();
        } else if (this.recovery !== undefined) {
          return this.toCompact();
        }
        return this.toDer();
      }

      // The format used by "message"

    }, {
      key: 'fromCompact',
      value: function fromCompact(buf) {
        var compressed = true;
        var recovery = buf.slice(0, 1)[0] - 27 - 4;
        if (recovery < 0) {
          compressed = false;
          recovery = recovery + 4;
        }

        var b2 = buf.slice(1, 33);
        var b3 = buf.slice(33, 65);

        if (!(recovery === 0 || recovery === 1 || recovery === 2 || recovery === 3)) {
          throw new Error('i must be 0, 1, 2, or 3');
        }
        if (b2.length !== 32) {
          throw new Error('r must be 32 bytes');
        }
        if (b3.length !== 32 || buf.length > 65) {
          throw new Error('s must be 32 bytes');
        }

        this.compressed = compressed;
        this.recovery = recovery;
        this.r = new Bn().fromBuffer(b2);
        this.s = new Bn().fromBuffer(b3);

        return this;
      }
    }, {
      key: 'fromDer',


      // The format used in a tx, except without the nHashType at the end
      value: function fromDer(buf, strict) {
        var obj = Sig.parseDer(buf, strict);
        this.r = obj.r;
        this.s = obj.s;

        return this;
      }
    }, {
      key: 'fromTxFormat',


      // The format used in a tx
      value: function fromTxFormat(buf) {
        if (buf.length === 0) {
          // allow setting a "blank" signature
          this.r = new Bn(1);
          this.s = new Bn(1);
          this.nHashType = 1;
          return this;
        }
        var nHashType = buf.readUInt8(buf.length - 1);
        var derbuf = buf.slice(0, buf.length - 1);
        this.fromDer(derbuf, false);
        this.nHashType = nHashType;
        return this;
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        return this.fromHex(str);
      }

      /**
       * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.
       */

    }, {
      key: 'hasLowS',


      /**
       * Compares to bitcoind's IsLowDERSignature
       * See also Ecdsa signature algorithm which enforces this.
       * See also Bip 62, "low S values in signatures"
       */
      value: function hasLowS() {
        if (this.s.lt(1) || this.s.gt(Bn.fromBuffer(new Buffer('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {
          return false;
        }
        return true;
      }

      /**
       * Ensures the nHashType is exactly equal to one of the standard options or combinations thereof.
       * Translated from bitcoind's IsDefinedHashtypeSignature
       */

    }, {
      key: 'hasDefinedHashType',
      value: function hasDefinedHashType() {
        if (this.nHashType < Sig.SIGHASH_ALL || this.nHashType > Sig.SIGHASH_SINGLE) {
          return false;
        }
        return true;
      }
    }, {
      key: 'toCompact',
      value: function toCompact(recovery, compressed) {
        recovery = typeof recovery === 'number' ? recovery : this.recovery;
        compressed = typeof compressed === 'boolean' ? compressed : this.compressed;

        if (!(recovery === 0 || recovery === 1 || recovery === 2 || recovery === 3)) {
          throw new Error('recovery must be equal to 0, 1, 2, or 3');
        }

        var val = recovery + 27 + 4;
        if (compressed === false) {
          val = val - 4;
        }
        var b1 = new Buffer([val]);
        var b2 = this.r.toBuffer({ size: 32 });
        var b3 = this.s.toBuffer({ size: 32 });
        return Buffer.concat([b1, b2, b3]);
      }
    }, {
      key: 'toDer',
      value: function toDer() {
        var rnbuf = this.r.toBuffer();
        var snbuf = this.s.toBuffer();

        var rneg = rnbuf[0] & 0x80;
        var sneg = snbuf[0] & 0x80;

        var rbuf = rneg ? Buffer.concat([new Buffer([0x00]), rnbuf]) : rnbuf;
        var sbuf = sneg ? Buffer.concat([new Buffer([0x00]), snbuf]) : snbuf;

        var length = 2 + rbuf.length + 2 + sbuf.length;
        var rlength = rbuf.length;
        var slength = sbuf.length;
        var rheader = 0x02;
        var sheader = 0x02;
        var header = 0x30;

        var der = Buffer.concat([new Buffer([header, length, rheader, rlength]), rbuf, new Buffer([sheader, slength]), sbuf]);
        return der;
      }
    }, {
      key: 'toTxFormat',
      value: function toTxFormat() {
        var derbuf = this.toDer();
        var buf = new Buffer(1);
        buf.writeUInt8(this.nHashType, 0);
        return Buffer.concat([derbuf, buf]);
      }
    }, {
      key: 'toString',
      value: function toString() {
        return this.toHex();
      }
    }], [{
      key: 'fromCompact',
      value: function fromCompact(buf) {
        return new this().fromCompact(buf);
      }
    }, {
      key: 'fromDer',
      value: function fromDer(buf, strict) {
        return new this().fromDer(buf, strict);
      }
    }, {
      key: 'fromTxFormat',
      value: function fromTxFormat(buf) {
        return new this().fromTxFormat(buf);
      }
    }, {
      key: 'parseDer',
      value: function parseDer(buf, strict) {
        if (strict === undefined) {
          strict = true;
        }

        if (!Buffer.isBuffer(buf)) {
          throw new Error('DER formatted signature should be a buffer');
        }

        var header = buf[0];

        if (header !== 0x30) {
          throw new Error('Header byte should be 0x30');
        }

        var length = buf[1];
        var buflength = buf.slice(2).length;
        if (strict && length !== buflength) {
          throw new Error('LEngth byte should length of what follows');
        } else {
          length = length < buflength ? length : buflength;
        }

        var rheader = buf[2 + 0];
        if (rheader !== 0x02) {
          throw new Error('Integer byte for r should be 0x02');
        }

        var rlength = buf[2 + 1];
        var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);
        var r = new Bn().fromBuffer(rbuf);
        var rneg = buf[2 + 1 + 1] === 0x00;
        if (rlength !== rbuf.length) {
          throw new Error('LEngth of r incorrect');
        }

        var sheader = buf[2 + 2 + rlength + 0];
        if (sheader !== 0x02) {
          throw new Error('Integer byte for s should be 0x02');
        }

        var slength = buf[2 + 2 + rlength + 1];
        var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);
        var s = new Bn().fromBuffer(sbuf);
        var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00;
        if (slength !== sbuf.length) {
          throw new Error('LEngth of s incorrect');
        }

        var sumlength = 2 + 2 + rlength + 2 + slength;
        if (length !== sumlength - 2) {
          throw new Error('LEngth of signature incorrect');
        }

        var obj = {
          header: header,
          length: length,
          rheader: rheader,
          rlength: rlength,
          rneg: rneg,
          rbuf: rbuf,
          r: r,
          sheader: sheader,
          slength: slength,
          sneg: sneg,
          sbuf: sbuf,
          s: s
        };

        return obj;
      }

      /**
       * This function is translated from bitcoind's IsDERSignature and is used in
       * the script interpreter.  This "DER" format actually includes an extra byte,
       * the nHashType, at the end. It is really the tx format, not DER format.
       *
       * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]
       * Where R and S are not negative (their first byte has its highest bit not set), and not
       * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
       * in which case a single 0 byte is necessary and even required).
       *
       * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
       */

    }, {
      key: 'IsTxDer',
      value: function IsTxDer(buf) {
        if (buf.length < 9) {
          //  Non-canonical signature: too short
          return false;
        }
        if (buf.length > 73) {
          // Non-canonical signature: too long
          return false;
        }
        if (buf[0] !== 0x30) {
          //  Non-canonical signature: wrong type
          return false;
        }
        if (buf[1] !== buf.length - 3) {
          //  Non-canonical signature: wrong length marker
          return false;
        }
        var nLEnR = buf[3];
        if (5 + nLEnR >= buf.length) {
          //  Non-canonical signature: S length misplaced
          return false;
        }
        var nLEnS = buf[5 + nLEnR];
        if (nLEnR + nLEnS + 7 !== buf.length) {
          //  Non-canonical signature: R+S length mismatch
          return false;
        }

        var R = buf.slice(4);
        if (buf[4 - 2] !== 0x02) {
          //  Non-canonical signature: R value type mismatch
          return false;
        }
        if (nLEnR === 0) {
          //  Non-canonical signature: R length is zero
          return false;
        }
        if (R[0] & 0x80) {
          //  Non-canonical signature: R value negative
          return false;
        }
        if (nLEnR > 1 && R[0] === 0x00 && !(R[1] & 0x80)) {
          //  Non-canonical signature: R value excessively padded
          return false;
        }

        var S = buf.slice(6 + nLEnR);
        if (buf[6 + nLEnR - 2] !== 0x02) {
          //  Non-canonical signature: S value type mismatch
          return false;
        }
        if (nLEnS === 0) {
          //  Non-canonical signature: S length is zero
          return false;
        }
        if (S[0] & 0x80) {
          //  Non-canonical signature: S value negative
          return false;
        }
        if (nLEnS > 1 && S[0] === 0x00 && !(S[1] & 0x80)) {
          //  Non-canonical signature: S value excessively padded
          return false;
        }
        return true;
      }
    }]);

    return Sig;
  }(Struct);

  Sig.SIGHASH_ALL = 0x00000001;
  Sig.SIGHASH_NONE = 0x00000002;
  Sig.SIGHASH_SINGLE = 0x00000003;
  Sig.SIGHASH_ANYONECANPAY = 0x00000080;

  return Sig;
};

inject = require('injecter')(inject, dependencies);
var Sig = inject();
module.exports = Sig;

}).call(this,require("buffer").Buffer)

},{"./bn":327,"./struct":342,"buffer":23,"injecter":381}],342:[function(require,module,exports){
(function (Buffer){
/**
 * Structure
 * =========
 *
 * A convenient structure to extend objects from that comes with very common
 * boiler plate instance methods:
 * - fromObject
 * - fromBr
 * - toBw
 * - fromBuffer
 * - fromFastBuffer
 * - toBuffer
 * - toFastBuffer
 * - fromHex
 * - toHex
 * - fromString
 * - toString
 * - fromJSON
 * - toJSON
 * - cloneByBuffer
 * - cloneByFastBuffer
 * - cloneByHex
 * - cloneByString
 * - cloneByJSON
 *
 * As well as static methods for:
 * - fromObject
 * - fromBr
 * - fromBuffer
 * - fromFastBuffer
 * - fromHex
 * - fromString
 * - fromJSON
 *
 * The "expect" method also facilitates deserializing a sequence of buffers
 * into an object.
 */
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var dependencies = {
  Br: require('./br'),
  Bw: require('./bw')
};

var inject = function inject(deps) {
  var Br = deps.Br;
  var Bw = deps.Bw;

  var Struct = function () {
    function Struct(obj) {
      _classCallCheck(this, Struct);

      this.fromObject(obj);
    }

    _createClass(Struct, [{
      key: 'fromObject',
      value: function fromObject(obj) {
        if (!obj) {
          return this;
        }
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = Object.keys(obj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            if (obj[key] !== undefined) {
              this[key] = obj[key];
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return this;
      }
    }, {
      key: 'fromBr',
      value: function fromBr(br) {
        if (!(br instanceof Br)) {
          throw new Error('br must be a buffer reader');
        }
        throw new Error('not implemented');
      }
    }, {
      key: 'asyncFromBr',
      value: function asyncFromBr(br) {
        if (!(br instanceof Br)) {
          throw new Error('br must be a buffer reader');
        }
        throw new Error('not implemented');
      }
    }, {
      key: 'toBw',
      value: function toBw(bw) {
        throw new Error('not implemented');
      }
    }, {
      key: 'asyncToBw',
      value: function asyncToBw(bw) {
        throw new Error('not implemented');
      }

      /**
       * It is very often the case that you want to create a bitcoin object from a
       * stream of small buffers rather than from a buffer of the correct length.
       * For instance, if streaming from the network or disk. The genFromBuffers
       * method is a generator which produces an iterator. Use .next(buf) to pass
       * in a small buffer. The iterator will end when it has received enough data
       * to produce the object. In some cases it is able to yield the number of
       * bytes it is expecting, but that is not always known.
       */

    }, {
      key: 'genFromBuffers',
      value: regeneratorRuntime.mark(function genFromBuffers() {
        return regeneratorRuntime.wrap(function genFromBuffers$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                throw new Error('not implemented');

              case 1:
              case 'end':
                return _context.stop();
            }
          }
        }, genFromBuffers, this);
      })

      /**
       * A convenience method used by from the genFromBuffers* generators.
       * Basically lets you expect a certain number of bytes (len) and keeps
       * yielding until you give it enough. It yields the expected amount
       * remainIng, and returns an object containIng a buffer of the expected
       * length, and, if any, the remainder buffer.
       */

    }, {
      key: 'expect',
      value: regeneratorRuntime.mark(function expect(len, startbuf) {
        var buf, bw, gotlen, remainderbuf, remainderlen, overlen;
        return regeneratorRuntime.wrap(function expect$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                buf = startbuf;
                bw = new Bw();
                gotlen = 0;

                if (startbuf) {
                  bw.write(startbuf);
                  gotlen += startbuf.length;
                }
                remainderbuf = void 0;

              case 5:
                if (!(gotlen < len)) {
                  _context2.next = 16;
                  break;
                }

                remainderlen = len - gotlen;
                _context2.next = 9;
                return remainderlen;

              case 9:
                buf = _context2.sent;

                if (buf) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt('continue', 5);

              case 12:
                bw.write(buf);
                gotlen += buf.length;
                _context2.next = 5;
                break;

              case 16:
                buf = bw.toBuffer();
                overlen = gotlen - len;

                remainderbuf = buf.slice(buf.length - overlen, buf.length);
                buf = buf.slice(0, buf.length - overlen);
                return _context2.abrupt('return', {
                  buf: buf,
                  remainderbuf: remainderbuf
                });

              case 21:
              case 'end':
                return _context2.stop();
            }
          }
        }, expect, this);
      })

      /**
       * Convert a buffer into an object, i.e. deserialize the object.
       */

    }, {
      key: 'fromBuffer',
      value: function fromBuffer(buf) {
        if (!Buffer.isBuffer(buf)) {
          throw new Error('buf must be a buffer');
        }
        var br = new Br(buf);

        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }

        return this.fromBr.apply(this, [br].concat(rest));
      }
    }, {
      key: 'asyncFromBuffer',
      value: function asyncFromBuffer(buf) {
        if (!Buffer.isBuffer(buf)) {
          throw new Error('buf must be a buffer');
        }
        var br = new Br(buf);

        for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          rest[_key2 - 1] = arguments[_key2];
        }

        return this.asyncFromBr.apply(this, [br].concat(rest));
      }
    }, {
      key: 'fromFastBuffer',


      /**
       * The complement of toFastBuffer - see description for toFastBuffer
       */
      value: function fromFastBuffer(buf) {
        if (buf.length === 0) {
          return this;
        } else {
          for (var _len3 = arguments.length, rest = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            rest[_key3 - 1] = arguments[_key3];
          }

          return this.fromBuffer.apply(this, [buf].concat(rest));
        }
      }
    }, {
      key: 'toBuffer',


      /**
       * Convert the object into a buffer, i.e. serialize the object. This method
       * may block the main thread.
       */
      value: function toBuffer() {
        return this.toBw.apply(this, arguments).toBuffer();
      }
    }, {
      key: 'asyncToBuffer',
      value: function asyncToBuffer() {
        return this.asyncToBw.apply(this, arguments).then(function (bw) {
          return bw.toBuffer();
        });
      }

      /**
       * Sometimes the toBuffer method has cryptography and blocks the main thread,
       * and we need a non-blocking way to serialize an object. That is what
       * toFastBuffer is. Of course it defaults to just using toBuffer if an object
       * hasn't implemented it. If your regular toBuffer method blocks, like with
       * Bip32, then you should implement this method to be non-blocking. This
       * method is used to send objects to the workers. i.e., for converting a
       * Bip32 object to a string, we need to encode it as a buffer in a
       * non-blocking manner with toFastBuffer, send it to a worker, then the
       * worker converts it to a string, which is a blocking operation.
       *
       * It is very common to want to convert a blank object to a zero length
       * buffer, so we can transport a blank object to a worker. So that behavior
       * is included by default.
       */

    }, {
      key: 'toFastBuffer',
      value: function toFastBuffer() {
        if (Object.keys(this).length === 0) {
          return new Buffer(0);
        } else {
          return this.toBuffer.apply(this, arguments);
        }
      }
    }, {
      key: 'fromHex',
      value: function fromHex(hex) {
        var buf = void 0;
        try {
          buf = new Buffer(hex, 'hex');
        } catch (e) {
          throw new Error('invalid hex string');
        }

        for (var _len4 = arguments.length, rest = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          rest[_key4 - 1] = arguments[_key4];
        }

        return this.fromBuffer.apply(this, [buf].concat(rest));
      }
    }, {
      key: 'asyncFromHex',
      value: function asyncFromHex(hex) {
        var buf = void 0;
        try {
          buf = new Buffer(hex, 'hex');
        } catch (e) {
          throw new Error('invalid hex string');
        }

        for (var _len5 = arguments.length, rest = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          rest[_key5 - 1] = arguments[_key5];
        }

        return this.asyncFromBuffer.apply(this, [buf].concat(rest));
      }
    }, {
      key: 'fromFastHex',
      value: function fromFastHex(hex) {
        var buf = void 0;
        try {
          buf = new Buffer(hex, 'hex');
        } catch (e) {
          throw new Error('invalid hex string');
        }

        for (var _len6 = arguments.length, rest = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          rest[_key6 - 1] = arguments[_key6];
        }

        return this.fromFastBuffer.apply(this, [buf].concat(rest));
      }
    }, {
      key: 'toHex',
      value: function toHex() {
        return this.toBuffer.apply(this, arguments).toString('hex');
      }
    }, {
      key: 'asyncToHex',
      value: function asyncToHex() {
        return this.asyncToBuffer.apply(this, arguments).then(function (buf) {
          return buf.toString('hex');
        });
      }
    }, {
      key: 'toFastHex',
      value: function toFastHex() {
        return this.toFastBuffer.apply(this, arguments).toString('hex');
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        if (typeof str !== 'string') {
          throw new Error('str must be a string');
        }

        for (var _len7 = arguments.length, rest = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
          rest[_key7 - 1] = arguments[_key7];
        }

        return this.fromHex.apply(this, [str].concat(rest));
      }
    }, {
      key: 'asyncFromString',
      value: function asyncFromString(str) {
        if (typeof str !== 'string') {
          throw new Error('str must be a string');
        }

        for (var _len8 = arguments.length, rest = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
          rest[_key8 - 1] = arguments[_key8];
        }

        return this.asyncFromHex.apply(this, [str].concat(rest));
      }
    }, {
      key: 'toString',
      value: function toString() {
        return this.toHex.apply(this, arguments);
      }
    }, {
      key: 'asyncToString',
      value: function asyncToString() {
        return this.asyncToHex.apply(this, arguments);
      }
    }, {
      key: 'fromJSON',
      value: function fromJSON(json) {
        throw new Error('not implemented');
      }
    }, {
      key: 'asyncFromJSON',
      value: function asyncFromJSON(json) {
        throw new Error('not implemented');
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        var json = {};
        for (var val in this) {
          // arrays
          if (this[val] instanceof Array) {
            var arr = [];
            for (var i in this[val]) {
              if (typeof this[val][i].toJSON === 'function') {
                arr.push(this[val][i].toJSON());
              } else {
                arr.push(JSON.stringify(this[val][i]));
              }
            }
            json[val] = arr;
            // objects
          } else if (_typeof(this[val]) === 'object' && typeof this[val].toJSON === 'function') {
            json[val] = this[val].toJSON();
            // booleans, numbers, and strings
          } else if (typeof this[val] === 'boolean' || typeof this[val] === 'number' || typeof this[val] === 'string') {
            json[val] = this[val];
            // throw an error for objects that do not implement toJSON
          } else if (_typeof(this[val]) === 'object') {
            throw new Error('not implemented');
          }
        }
        return json;
        // throw new Error('not implemented')
      }
    }, {
      key: 'asyncToJSON',
      value: function asyncToJSON() {
        throw new Error('not implemented');
      }
    }, {
      key: 'clone',
      value: function clone() {
        // TODO: Should this be more intelligent about picking which clone method
        // to default to?
        return this.cloneByJSON();
      }
    }, {
      key: 'cloneByBuffer',
      value: function cloneByBuffer() {
        return new this.constructor().fromBuffer(this.toBuffer());
      }
    }, {
      key: 'cloneByFastBuffer',
      value: function cloneByFastBuffer() {
        return new this.constructor().fromFastBuffer(this.toFastBuffer());
      }
    }, {
      key: 'cloneByHex',
      value: function cloneByHex() {
        return new this.constructor().fromHex(this.toHex());
      }
    }, {
      key: 'cloneByString',
      value: function cloneByString() {
        return new this.constructor().fromString(this.toString());
      }
    }, {
      key: 'cloneByJSON',
      value: function cloneByJSON() {
        return new this.constructor().fromJSON(this.toJSON());
      }
    }], [{
      key: 'fromObject',
      value: function fromObject(obj) {
        return new this().fromObject(obj);
      }
    }, {
      key: 'fromBr',
      value: function fromBr(br) {
        return new this().fromBr(br);
      }
    }, {
      key: 'asyncFromBr',
      value: function asyncFromBr(br) {
        return new this().asyncFromBr(br);
      }
    }, {
      key: 'fromBuffer',
      value: function fromBuffer() {
        var _ref;

        return (_ref = new this()).fromBuffer.apply(_ref, arguments);
      }
    }, {
      key: 'asyncFromBuffer',
      value: function asyncFromBuffer(buf) {
        var _ref2;

        for (var _len9 = arguments.length, rest = Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
          rest[_key9 - 1] = arguments[_key9];
        }

        return (_ref2 = new this()).asyncFromBuffer.apply(_ref2, [buf].concat(rest));
      }
    }, {
      key: 'fromFastBuffer',
      value: function fromFastBuffer() {
        var _ref3;

        return (_ref3 = new this()).fromFastBuffer.apply(_ref3, arguments);
      }
    }, {
      key: 'fromHex',
      value: function fromHex(hex) {
        var _ref4;

        for (var _len10 = arguments.length, rest = Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
          rest[_key10 - 1] = arguments[_key10];
        }

        return (_ref4 = new this()).fromHex.apply(_ref4, [hex].concat(rest));
      }
    }, {
      key: 'asyncFromHex',
      value: function asyncFromHex(hex) {
        var _ref5;

        for (var _len11 = arguments.length, rest = Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
          rest[_key11 - 1] = arguments[_key11];
        }

        return (_ref5 = new this()).asyncFromHex.apply(_ref5, [hex].concat(rest));
      }
    }, {
      key: 'fromFastHex',
      value: function fromFastHex(hex) {
        var _ref6;

        for (var _len12 = arguments.length, rest = Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
          rest[_key12 - 1] = arguments[_key12];
        }

        return (_ref6 = new this()).fromFastHex.apply(_ref6, [hex].concat(rest));
      }
    }, {
      key: 'fromString',
      value: function fromString(str) {
        var _ref7;

        for (var _len13 = arguments.length, rest = Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
          rest[_key13 - 1] = arguments[_key13];
        }

        return (_ref7 = new this()).fromString.apply(_ref7, [str].concat(rest));
      }
    }, {
      key: 'asyncFromString',
      value: function asyncFromString(str) {
        var _ref8;

        for (var _len14 = arguments.length, rest = Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
          rest[_key14 - 1] = arguments[_key14];
        }

        return (_ref8 = new this()).asyncFromString.apply(_ref8, [str].concat(rest));
      }
    }, {
      key: 'fromJSON',
      value: function fromJSON(json) {
        var _ref9;

        for (var _len15 = arguments.length, rest = Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
          rest[_key15 - 1] = arguments[_key15];
        }

        return (_ref9 = new this()).fromJSON.apply(_ref9, [json].concat(rest));
      }
    }, {
      key: 'asyncFromJSON',
      value: function asyncFromJSON(json) {
        var _ref10;

        for (var _len16 = arguments.length, rest = Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {
          rest[_key16 - 1] = arguments[_key16];
        }

        return (_ref10 = new this()).asyncFromJSON.apply(_ref10, [json].concat(rest));
      }
    }]);

    return Struct;
  }();

  return Struct;
};

inject = require('injecter')(inject, dependencies);
var Struct = inject();
module.exports = Struct;

}).call(this,require("buffer").Buffer)

},{"./br":328,"./bw":329,"buffer":23,"injecter":381}],343:[function(require,module,exports){
(function (Buffer){
/**
 * Transaction Builder (experimental)
 * ==================================
 *
 * Transaction Builder. This is a, yet unfinished, convenience class for
 * building pubKeyHash and p2sh transactions, and also for verifying arbitrary
 * transactions (and their inputs). You can (or will be able to) pay to
 * pubKeyHash to p2sh and can spend pubKeyHash or p2sh-pubKeyHash or
 * p2sh-multisig.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Address: require('./address'),
  Constants: require('./constants').Default.TxBuilder,
  Bn: require('./bn'),
  PubKey: require('./pub-key'),
  Script: require('./script'),
  Sig: require('./sig'),
  Struct: require('./struct'),
  Tx: require('./tx'),
  TxIn: require('./tx-in'),
  TxOut: require('./tx-out'),
  TxOutMap: require('./tx-out-map'),
  VarInt: require('./var-int'),
  asink: require('asink')
};

var inject = function inject(deps) {
  var Address = deps.Address;
  var Constants = deps.Constants;
  var Bn = deps.Bn;
  var PubKey = deps.PubKey;
  var Script = deps.Script;
  var Sig = deps.Sig;
  var Struct = deps.Struct;
  var Tx = deps.Tx;
  var TxIn = deps.TxIn;
  var TxOut = deps.TxOut;
  var TxOutMap = deps.TxOutMap;
  var VarInt = deps.VarInt;
  var asink = deps.asink;

  var TxBuilder = function (_Struct) {
    _inherits(TxBuilder, _Struct);

    function TxBuilder() {
      var tx = arguments.length <= 0 || arguments[0] === undefined ? new Tx() : arguments[0];
      var txIns = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
      var txOuts = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
      var uTxOutMap = arguments.length <= 3 || arguments[3] === undefined ? new TxOutMap() : arguments[3];
      var changeScript = arguments[4];
      var feePerKbNum = arguments.length <= 5 || arguments[5] === undefined ? Constants.feePerKbNum : arguments[5];
      var nLockTime = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];
      var versionBytesNum = arguments.length <= 7 || arguments[7] === undefined ? 1 : arguments[7];

      _classCallCheck(this, TxBuilder);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(TxBuilder).call(this, { tx: tx, txIns: txIns, txOuts: txOuts, uTxOutMap: uTxOutMap, changeScript: changeScript, feePerKbNum: feePerKbNum, nLockTime: nLockTime, versionBytesNum: versionBytesNum }));
    }

    _createClass(TxBuilder, [{
      key: 'toJSON',
      value: function toJSON() {
        var json = {};
        json.tx = this.tx.toHex();
        json.txIns = this.txIns.map(function (txIn) {
          return txIn.toHex();
        });
        json.txOuts = this.txOuts.map(function (txOut) {
          return txOut.toHex();
        });
        json.uTxOutMap = this.uTxOutMap.toJSON();
        if (this.changeScript) {
          json.changeScript = this.changeScript.toHex();
        }
        json.feePerKbNum = this.feePerKbNum;
        return json;
      }
    }, {
      key: 'fromJSON',
      value: function fromJSON(json) {
        this.tx = new Tx().fromHex(json.tx);
        this.txIns = json.txIns.map(function (txIn) {
          return TxIn.fromHex(txIn);
        });
        this.txOuts = json.txOuts.map(function (txOut) {
          return TxOut.fromHex(txOut);
        });
        this.uTxOutMap = new TxOutMap().fromJSON(json.uTxOutMap);
        if (json.changeScript) {
          this.changeScript = new Script().fromHex(json.changeScript);
        }
        this.feePerKbNum = json.feePerKbNum;
        return this;
      }
    }, {
      key: 'setFeePerKbNum',
      value: function setFeePerKbNum(feePerKbNum) {
        this.feePerKbNum = feePerKbNum;
        return this;
      }
    }, {
      key: 'setChangeAddress',
      value: function setChangeAddress(changeAddress) {
        this.changeScript = changeAddress.toScript();
        return this;
      }
    }, {
      key: 'setChangeScript',
      value: function setChangeScript(changeScript) {
        this.changeScript = changeScript;
        return this;
      }

      /**
       * nLockTime is an unsigned integer.
       */

    }, {
      key: 'setNLocktime',
      value: function setNLocktime(nLockTime) {
        this.nLockTime = nLockTime;
        return this;
      }
    }, {
      key: 'setVersion',
      value: function setVersion(versionBytesNum) {
        this.versionBytesNum = versionBytesNum;
        return this;
      }

      /**
       * Import a transaction partially signed by someone else. The only thing you
       * can do after this is sign one or more inputs. Usually used for multisig
       * transactions. uTxOutMap is optional. It is not necessary so long as you
       * pass in the txOut when you sign.
       */

    }, {
      key: 'importPartiallySignedTx',
      value: function importPartiallySignedTx(tx, uTxOutMap) {
        this.tx = tx;
        if (uTxOutMap) {
          this.uTxOutMap = uTxOutMap;
        }
        return this;
      }

      /**
       * Pay "from" a script - in other words, add an input to the transaction.
       */

    }, {
      key: 'inputFromScript',
      value: function inputFromScript(txHashBuf, txOutNum, txOut, script, nSequence) {
        if (!Buffer.isBuffer(txHashBuf) || !(typeof txOutNum === 'number') || !(txOut instanceof TxOut) || !(script instanceof Script)) {
          throw new Error('invalid one of: txHashBuf, txOutNum, txOut, script');
        }
        this.txIns.push(TxIn.fromProperties(txHashBuf, txOutNum, script, nSequence));
        this.uTxOutMap.add(txHashBuf, txOutNum, txOut);
        return this;
      }

      /**
       * Pay "from" a pubKeyHash output - in other words, add an input to the
       * transaction.
       */

    }, {
      key: 'inputFromPubKeyHash',
      value: function inputFromPubKeyHash(txHashBuf, txOutNum, txOut, pubKey, nSequence) {
        if (!Buffer.isBuffer(txHashBuf) || !(typeof txOutNum === 'number') || !(txOut instanceof TxOut) || !(pubKey instanceof PubKey)) {
          throw new Error('invalid one of: txHashBuf, txOutNum, txOut, pubKey');
        }
        this.txIns.push(new TxIn().fromObject({ nSequence: nSequence }).fromPubKeyHashTxOut(txHashBuf, txOutNum, txOut, pubKey));
        this.uTxOutMap.add(txHashBuf, txOutNum, txOut);
        return this;
      }

      /**
       * Pay "from" a scriptHash (p2sh) output - in other words, add an input to
       * the transaction.
       */

    }, {
      key: 'inputFromScriptHashMultiSig',
      value: function inputFromScriptHashMultiSig(txHashBuf, txOutNum, txOut, redeemScript, nSequence) {
        if (!Buffer.isBuffer(txHashBuf) || !(typeof txOutNum === 'number') || !(txOut instanceof TxOut) || !(redeemScript instanceof Script)) {
          throw new Error('invalid one of: txHashBuf, txOutNum, txOut, redeemScript');
        }
        this.txIns.push(new TxIn().fromObject({ nSequence: nSequence }).fromScriptHashMultiSigTxOut(txHashBuf, txOutNum, txOut, redeemScript));
        this.uTxOutMap.add(txHashBuf, txOutNum, txOut);
        return this;
      }

      /**
       * An address to send funds to, along with the amount. The amount should be
       * denominated in satoshis, not bitcoins.
       */

    }, {
      key: 'outputToAddress',
      value: function outputToAddress(valueBn, addr) {
        if (!(addr instanceof Address) || !(valueBn instanceof Bn)) {
          throw new Error('addr must be an Address, and valueBn must be a Bn');
        }
        var script = void 0;
        if (addr.type() === 'scriptHash') {
          script = new Script().fromScriptHash(addr.hashBuf);
        } else if (addr.type() === 'pubKeyHash') {
          script = new Script().fromPubKeyHash(addr.hashBuf);
        } else {
          throw new Error('invalid address type');
        }
        this.outputToScript(valueBn, script);
        return this;
      }

      /**
       * A script to send funds to, along with the amount. The amount should be
       * denominated in satoshis, not bitcoins.
       */

    }, {
      key: 'outputToScript',
      value: function outputToScript(valueBn, script) {
        if (!(script instanceof Script) || !(valueBn instanceof Bn)) {
          throw new Error('script must be a Script, and valueBn must be a Bn');
        }
        var txOut = TxOut.fromProperties(valueBn, script);
        this.txOuts.push(txOut);
        return this;
      }
    }, {
      key: 'buildOutputs',
      value: function buildOutputs() {
        var _this2 = this;

        var outamount = new Bn(0);
        this.txOuts.forEach(function (txOut) {
          outamount = outamount.add(txOut.valueBn);
          _this2.tx.addTxOut(txOut);
        });
        return outamount;
      }
    }, {
      key: 'buildInputs',
      value: function buildInputs(outamount) {
        var extraInputsNum = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

        var inamount = new Bn(0);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.txIns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var txIn = _step.value;

            var txOut = this.uTxOutMap.get(txIn.txHashBuf, txIn.txOutNum);
            inamount = inamount.add(txOut.valueBn);
            this.tx.addTxIn(txIn);
            if (inamount.geq(outamount)) {
              if (extraInputsNum <= 0) {
                break;
              }
              extraInputsNum--;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (inamount.lt(outamount)) {
          throw new Error('not enough funds for output');
        }
        return inamount;
      }

      // For now this method only supports pubKeyHash inputs. It assumes we have
      // not yet added signatures to our inputs.
      // TODO: Support it when the signatures are already on the inputs.
      // TODO: Support p2sh inputs.

    }, {
      key: 'estimateSize',
      value: function estimateSize() {
        // largest possible sig size
        var sigsize = 1 + 1 + 1 + 1 + 32 + 1 + 1 + 32 + 1;
        var size = this.tx.toBuffer().length;
        size = size + sigsize * this.tx.txIns.length;
        size = size + 1; // assume txInsVi increases by 1 byte
        return size;
      }
    }, {
      key: 'estimateFee',
      value: function estimateFee() {
        // TODO: Support calculating fees from p2sh multisig.
        var fee = Math.ceil(this.estimateSize() / 1000) * this.feePerKbNum;
        return new Bn(fee);
      }

      /**
       * Builds the transaction and adds the appropriate fee by subtracting from
       * the change output. Note that by default the TxBuilder will use as many
       * inputs as necessary to pay the output amounts and the required fee. The
       * TxBuilder will not necessarily us all the inputs. To force the TxBuilder
       * to use all the inputs (such as if you wish to spend the entire balance
       * of a wallet), set the argument useAllInputs = true.
       */

    }, {
      key: 'build',
      value: function build() {
        var useAllInputs = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

        var changeAmount = void 0,
            shouldfeebn = void 0;
        for (var extraInputsNum = useAllInputs ? this.txIns.length - 1 : 0; extraInputsNum < this.txIns.length; extraInputsNum++) {
          this.tx = new Tx();
          var outamount = this.buildOutputs();
          var changeScript = this.changeScript;
          var changeTxOut = TxOut.fromProperties(new Bn(0), changeScript);
          this.tx.addTxOut(changeTxOut);

          var inamount = this.buildInputs(outamount, extraInputsNum);

          // TODO: What if change amount is less than dust?
          // Set change amount from inamount - outamount
          changeAmount = inamount.sub(outamount);
          this.tx.txOuts[this.tx.txOuts.length - 1].valueBn = changeAmount;

          shouldfeebn = this.estimateFee();
          if (changeAmount.geq(shouldfeebn) && changeAmount.sub(shouldfeebn).gt(Constants.dustNum)) {
            break;
          }
        }
        if (changeAmount.geq(shouldfeebn)) {
          // Subtract fee from change
          // TODO: What if change is less than dust? What if change is 0?
          changeAmount = changeAmount.sub(shouldfeebn);
          this.tx.txOuts[this.tx.txOuts.length - 1].valueBn = changeAmount;

          if (changeAmount.lt(Constants.dustNum)) {
            throw new Error('unable to create change amount greater than dust');
          }

          this.tx.nLockTime = this.nLockTime;
          this.tx.versionBytesNum = this.versionBytesNum;
          return this;
        } else {
          throw new Error('unable to gather enough inputs for outputs and fee');
        }
      }

      /**
       * Check if all signatures are present in a p2sh multisig input script.
       */

    }, {
      key: 'fillPubKeyHashSig',


      /**
       * Given the signature for a transaction, fill it in the appropriate place
       * for an input that spends a pubKeyHash output.
       */
      value: function fillPubKeyHashSig(i, keyPair, sig) {
        var txIn = this.tx.txIns[i];
        txIn.script.chunks[0] = new Script().writeBuffer(sig.toTxFormat()).chunks[0];
        txIn.scriptVi = VarInt.fromNumber(txIn.script.toBuffer().length);
        return this;
      }
    }, {
      key: 'fillScriptHashMultiSigSig',
      value: function fillScriptHashMultiSigSig(i, keyPair, sig, redeemScript) {
        var txIn = this.tx.txIns[i];
        var script = txIn.script;

        // three normal opCodes, and the rest are pubKeys
        var pubKeychunks = redeemScript.chunks.slice(1, redeemScript.chunks.length - 2);

        var pubKeybufs = pubKeychunks.map(function (chunk) {
          return chunk.buf;
        });
        var pubKeybuf = keyPair.pubKey.toBuffer();

        // find which pubKey in the redeemScript is the one we are trying to sign
        var thisPubKeyIndex = void 0;
        for (thisPubKeyIndex = 0; thisPubKeyIndex < pubKeybufs.length; thisPubKeyIndex++) {
          if (Buffer.compare(pubKeybuf, pubKeybufs[thisPubKeyIndex]) === 0) {
            break;
          }
          if (thisPubKeyIndex >= pubKeybufs.length - 1) {
            throw new Error('cannot sign; pubKey not found in input ' + i);
          }
        }

        script.chunks[thisPubKeyIndex + 1] = new Script().writeBuffer(sig.toTxFormat()).chunks[0];
        var m = redeemScript.chunks[0].opCodeNum - 0x50;
        if (TxBuilder.allSigsPresent(m, script)) {
          txIn.script = TxBuilder.removeBlankSigs(script);
        }
        txIn.scriptVi = VarInt.fromNumber(txIn.script.toBuffer().length);
        return this;
      }

      /**
       * Sign an input, but do not fill the signature into the transaction. Return
       * the signature.
       *
       * For a normal transaction, subScript is usually the scriptPubKey. For a
       * p2sh transaction, subScript is usually the redeemScript. If you're not
       * normal because you're using OP_CODESEPARATORs, you know what to do.
       */

    }, {
      key: 'getSig',
      value: function getSig(keyPair, nHashType, nIn, subScript) {
        nHashType = nHashType === undefined ? Sig.SIGHASH_ALL : nHashType;
        return this.tx.sign(keyPair, nHashType, nIn, subScript);
      }

      /**
       * Asynchronously sign an input in a worker, but do not fill the signature
       * into the transaction. Return the signature.
       */

    }, {
      key: 'asyncGetSig',
      value: function asyncGetSig(keyPair, nHashType, nIn, subScript) {
        nHashType = nHashType === undefined ? Sig.SIGHASH_ALL : nHashType;
        return this.tx.asyncSign(keyPair, nHashType, nIn, subScript);
      }

      /**
       * Sign ith input with keyPair and insert the signature into the transaction.
       * This method only works for some standard transaction types. For
       * non-standard transaction types, use getSig.
       */

    }, {
      key: 'sign',
      value: function sign(i, keyPair, txOut) {
        var txIn = this.tx.txIns[i];
        var script = txIn.script;
        if (script.isPubKeyHashIn()) {
          var txHashBuf = txIn.txHashBuf;
          var txOutNum = txIn.txOutNum;
          if (!txOut) {
            txOut = this.uTxOutMap.get(txHashBuf, txOutNum);
          }
          var outScript = txOut.script;
          var subScript = outScript; // true for standard script types
          var sig = this.getSig(keyPair, Sig.SIGHASH_ALL, i, subScript);
          this.fillPubKeyHashSig(i, keyPair, sig, subScript);
        } else if (script.isScriptHashIn()) {
          var redeemScript = new Script().fromBuffer(script.chunks[script.chunks.length - 1].buf);
          var _subScript = redeemScript;
          if (!redeemScript.isMultiSigOut()) {
            throw new Error('cannot sign non-multisig scriptHash script type for input ' + i);
          }
          var _sig = this.tx.sign(keyPair, Sig.SIGHASH_ALL, i, _subScript);
          this.fillScriptHashMultiSigSig(i, keyPair, _sig, redeemScript);
        } else {
          throw new Error('cannot sign unknown script type for input ' + i);
        }
        return this;
      }

      /**
       * Asynchronously sign ith input with keyPair in a worker and insert the
       * signature into the transaction.  This method only works for some standard
       * transaction types. For non-standard transaction types, use asyncGetSig.
       */

    }, {
      key: 'asyncSign',
      value: function asyncSign(i, keyPair, txOut) {
        return asink(regeneratorRuntime.mark(function _callee() {
          var txIn, script, txHashBuf, txOutNum, outScript, subScript, sig, redeemScript, _subScript2, _sig2;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  txIn = this.tx.txIns[i];
                  script = txIn.script;

                  if (!script.isPubKeyHashIn()) {
                    _context.next = 14;
                    break;
                  }

                  txHashBuf = txIn.txHashBuf;
                  txOutNum = txIn.txOutNum;

                  if (!txOut) {
                    txOut = this.uTxOutMap.get(txHashBuf, txOutNum);
                  }
                  outScript = txOut.script;
                  subScript = outScript; // true for standard script types

                  _context.next = 10;
                  return this.asyncGetSig(keyPair, Sig.SIGHASH_ALL, i, subScript);

                case 10:
                  sig = _context.sent;

                  this.fillPubKeyHashSig(i, keyPair, sig, subScript);
                  _context.next = 26;
                  break;

                case 14:
                  if (!script.isScriptHashIn()) {
                    _context.next = 25;
                    break;
                  }

                  redeemScript = new Script().fromBuffer(script.chunks[script.chunks.length - 1].buf);
                  _subScript2 = redeemScript;

                  if (redeemScript.isMultiSigOut()) {
                    _context.next = 19;
                    break;
                  }

                  throw new Error('cannot sign non-multisig scriptHash script type for input ' + i);

                case 19:
                  _context.next = 21;
                  return this.tx.asyncSign(keyPair, Sig.SIGHASH_ALL, i, _subScript2);

                case 21:
                  _sig2 = _context.sent;

                  this.fillScriptHashMultiSigSig(i, keyPair, _sig2, redeemScript);
                  _context.next = 26;
                  break;

                case 25:
                  throw new Error('cannot sign unknown script type for input ' + i);

                case 26:
                  return _context.abrupt('return', this);

                case 27:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }), this);
      }
    }], [{
      key: 'allSigsPresent',
      value: function allSigsPresent(m, script) {
        // The first element is a Famous MultiSig Bug OP_0, and last element is the
        // redeemScript. The rest are signatures.
        var present = 0;
        for (var i = 1; i < script.chunks.length - 1; i++) {
          if (script.chunks[i].buf) {
            present++;
          }
        }
        return present === m;
      }

      /**
       * Remove blank signatures in a p2sh multisig input script.
       */

    }, {
      key: 'removeBlankSigs',
      value: function removeBlankSigs(script) {
        // The first element is a Famous MultiSig Bug OP_0, and last element is the
        // redeemScript. The rest are signatures.
        script = new Script(script.chunks.slice()); // copy the script
        for (var i = 1; i < script.chunks.length - 1; i++) {
          if (!script.chunks[i].buf) {
            script.chunks.splice(i, 1); // remove ith element
          }
        }
        return script;
      }
    }]);

    return TxBuilder;
  }(Struct);

  return TxBuilder;
};

inject = require('injecter')(inject, dependencies);
var TxBuilder = inject();
module.exports = TxBuilder;

}).call(this,require("buffer").Buffer)

},{"./address":324,"./bn":327,"./constants":331,"./pub-key":338,"./script":340,"./sig":341,"./struct":342,"./tx":347,"./tx-in":344,"./tx-out":346,"./tx-out-map":345,"./var-int":348,"asink":352,"buffer":23,"injecter":381}],344:[function(require,module,exports){
(function (Buffer){
/*
 * Transaction Input
 * =================
 *
 * An input to a transaction. The way you probably want to use this is through
 * the convenient method of new TxIn(txHashBuf, txOutNum, script, nSequence) (i.e., you
 * can leave out the scriptVi, which is computed automatically if you leave it
 * out.)
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Bw: require('./bw'),
  VarInt: require('./var-int'),
  OpCode: require('./op-code'),
  Script: require('./script'),
  Struct: require('./struct')
};

var inject = function inject(deps) {
  var Bw = deps.Bw;
  var VarInt = deps.VarInt;
  var OpCode = deps.OpCode;
  var Script = deps.Script;
  var Struct = deps.Struct;

  var TxIn = function (_Struct) {
    _inherits(TxIn, _Struct);

    function TxIn(txHashBuf, txOutNum, scriptVi, script) {
      var nSequence = arguments.length <= 4 || arguments[4] === undefined ? 0xffffffff : arguments[4];

      _classCallCheck(this, TxIn);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(TxIn).call(this, { txHashBuf: txHashBuf, txOutNum: txOutNum, scriptVi: scriptVi, script: script, nSequence: nSequence }));
    }

    _createClass(TxIn, [{
      key: 'setScript',
      value: function setScript(script) {
        this.scriptVi = VarInt.fromNumber(script.toBuffer().length);
        this.script = script;
        return this;
      }
    }, {
      key: 'fromProperties',
      value: function fromProperties(txHashBuf, txOutNum, script, nSequence) {
        this.fromObject({ txHashBuf: txHashBuf, txOutNum: txOutNum, nSequence: nSequence });
        this.setScript(script);
        return this;
      }
    }, {
      key: 'fromJSON',
      value: function fromJSON(json) {
        this.fromObject({
          txHashBuf: new Buffer(json.txHashBuf, 'hex'),
          txOutNum: json.txOutNum,
          scriptVi: VarInt.fromJSON(json.scriptVi),
          script: Script.fromJSON(json.script),
          nSequence: json.nSequence
        });
        return this;
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        return {
          txHashBuf: this.txHashBuf.toString('hex'),
          txOutNum: this.txOutNum,
          scriptVi: this.scriptVi.toJSON(),
          script: this.script.toJSON(),
          nSequence: this.nSequence
        };
      }
    }, {
      key: 'fromBr',
      value: function fromBr(br) {
        this.txHashBuf = br.read(32);
        this.txOutNum = br.readUInt32LE();
        this.scriptVi = VarInt.fromBuffer(br.readVarIntBuf());
        this.script = Script.fromBuffer(br.read(this.scriptVi.toNumber()));
        this.nSequence = br.readUInt32LE();
        return this;
      }
    }, {
      key: 'toBw',
      value: function toBw(bw) {
        if (!bw) {
          bw = new Bw();
        }
        bw.write(this.txHashBuf);
        bw.writeUInt32LE(this.txOutNum);
        bw.write(this.scriptVi.buf);
        bw.write(this.script.toBuffer());
        bw.writeUInt32LE(this.nSequence);
        return bw;
      }

      /**
       * Generate txIn with blank signatures from a txOut and its
       * txHashBuf+txOutNum. A "blank" signature is just an OP_0.
       */

    }, {
      key: 'fromPubKeyHashTxOut',
      value: function fromPubKeyHashTxOut(txHashBuf, txOutNum, txOut, pubKey) {
        var script = new Script();
        if (txOut.script.isPubKeyHashOut()) {
          script.writeOpCode(OpCode.OP_0); // blank signature
          script.writeBuffer(pubKey.toBuffer());
        } else {
          throw new Error('txOut must be of type pubKeyHash');
        }
        this.txHashBuf = txHashBuf;
        this.txOutNum = txOutNum;
        this.setScript(script);
        return this;
      }

      /**
       * Generate txIn with blank signatures from a txOut and its
       * txHashBuf+txOutNum. A "blank" signature is just an OP_0.
       *
       * TODO: Also support other types of p2sh outputs other than multisig.
       */

    }, {
      key: 'fromScriptHashMultiSigTxOut',
      value: function fromScriptHashMultiSigTxOut(txHashBuf, txOutNum, txOut, redeemScript) {
        var script = new Script();
        if (!txOut.script.isScriptHashOut()) {
          throw new Error('txOut must be of type scriptHash');
        }
        if (!redeemScript.isMultiSigOut()) {
          throw new Error('redeemScript must be multisig');
        }
        script.writeOpCode(OpCode.OP_0); // extra OP_0; famous multisig bug in bitcoin pops one too many items from the stack
        var numpubKeys = redeemScript.chunks.length - 3; // 3 normal opCodes, the rest pubKeys
        for (var i = 0; i < numpubKeys; i++) {
          script.writeOpCode(OpCode.OP_0); // one blank per pubKey (not per sig)
        }
        script.writeBuffer(redeemScript.toBuffer());
        this.fromProperties(txHashBuf, txOutNum, script);
        return this;
      }
    }, {
      key: 'hasNullInput',
      value: function hasNullInput() {
        var hex = this.txHashBuf.toString('hex');
        if (hex === '0000000000000000000000000000000000000000000000000000000000000000' && this.txOutNum === 0xffffffff) {
          return true;
        }
        return false;
      }

      /**
       * Analagous to bitcoind's SetNull in COutPoint
       */

    }, {
      key: 'setNullInput',
      value: function setNullInput() {
        this.txHashBuf = new Buffer(32);
        this.txHashBuf.fill(0);
        this.txOutNum = 0xffffffff; // -1 cast to unsigned int
      }
    }], [{
      key: 'fromProperties',
      value: function fromProperties(txHashBuf, txOutNum, script, nSequence) {
        return new this().fromProperties(txHashBuf, txOutNum, script, nSequence);
      }
    }, {
      key: 'fromScriptHashMultiSigTxOut',
      value: function fromScriptHashMultiSigTxOut(txHashBuf, txOutNum, txOut, redeemScript) {
        return new this().fromScriptHashMultiSigTxOut(txHashBuf, txOutNum, txOut, redeemScript);
      }
    }]);

    return TxIn;
  }(Struct);

  /* Interpret sequence numbers as relative lock-time constraints. */


  TxIn.LOCKTIME_VERIFY_SEQUENCE = 1 << 0;

  /* Setting nSequence to this value for every input in a transaction disables
   * nLockTime. */
  TxIn.SEQUENCE_FINAL = 0xffffffff;

  /* Below flags apply in the context of Bip 68*/
  /* If this flag set, txIn.nSequence is NOT interpreted as a relative lock-time.
   * */
  TxIn.SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 << 31;

  /* If txIn.nSequence encodes a relative lock-time and this flag is set, the
   * relative lock-time has units of 512 seconds, otherwise it specifies blocks
   * with a granularity of 1. */
  TxIn.SEQUENCE_LOCKTIME_TYPE_FLAG = 1 << 22;

  /* If txIn.nSequence encodes a relative lock-time, this mask is applied to
   * extract that lock-time from the sequence field. */
  TxIn.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;

  /* In order to use the same number of bits to encode roughly the same
   * wall-clock duration, and because blocks are naturally limited to occur
   * every 600s on average, the minimum granularity for time-based relative
   * lock-time is fixed at 512 seconds.  Converting from CTxIn::nSequence to
   * seconds is performed by multiplying by 512 = 2^9, or equivalently
   * shifting up by 9 bits. */
  TxIn.SEQUENCE_LOCKTIME_GRANULARITY = 9;

  return TxIn;
};

inject = require('injecter')(inject, dependencies);
var TxIn = inject();
module.exports = TxIn;

}).call(this,require("buffer").Buffer)

},{"./bw":329,"./op-code":335,"./script":340,"./struct":342,"./var-int":348,"buffer":23,"injecter":381}],345:[function(require,module,exports){
/**
 * Transaction Output Map
 * ======================
 *
 * A map from a transaction hash and output number to that particular output.
 * Note that the map is from the transaction *hash*, which is the value that
 * occurs in the blockchain, not the id, which is the reverse of the hash.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Struct: require('./struct'),
  TxOut: require('./tx-out')
};

var inject = function inject(deps) {
  var Struct = deps.Struct;
  var TxOut = deps.TxOut;

  var TxOutMap = function (_Struct) {
    _inherits(TxOutMap, _Struct);

    function TxOutMap() {
      var map = arguments.length <= 0 || arguments[0] === undefined ? new Map() : arguments[0];

      _classCallCheck(this, TxOutMap);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(TxOutMap).call(this, { map: map }));
    }

    _createClass(TxOutMap, [{
      key: 'toJSON',
      value: function toJSON() {
        var json = {};
        this.map.forEach(function (txOut, label) {
          json[label] = txOut.toHex();
        });
        return json;
      }
    }, {
      key: 'fromJSON',
      value: function fromJSON(json) {
        var _this2 = this;

        Object.keys(json).forEach(function (label) {
          _this2.map.set(label, TxOut.fromHex(json[label]));
        });
        return this;
      }
    }, {
      key: 'add',
      value: function add(txHashBuf, txOutNum, txOut) {
        var label = txHashBuf.toString('hex') + ':' + txOutNum;
        this.map.set(label, txOut);
        return this;
      }
    }, {
      key: 'get',
      value: function get(txHashBuf, txOutNum) {
        var label = txHashBuf.toString('hex') + ':' + txOutNum;
        return this.map.get(label);
      }
    }, {
      key: 'addTx',
      value: function addTx(tx) {
        var _this3 = this;

        var txhashhex = tx.hash().toString('hex');
        tx.txOuts.forEach(function (txOut, index) {
          var label = txhashhex + ':' + index;
          _this3.map.set(label, txOut);
        });
        return this;
      }
    }]);

    return TxOutMap;
  }(Struct);

  return TxOutMap;
};

inject = require('injecter')(inject, dependencies);
var TxOutMap = inject();
module.exports = TxOutMap;

},{"./struct":342,"./tx-out":346,"injecter":381}],346:[function(require,module,exports){
/**
 * Transaction Output
 * ==================
 *
 * An output to a transaction. The way you normally want to make one is with
 * new TxOut(valueBn, script) (i.e., just as with TxIn, you can leave out the
 * scriptVi, since it can be computed automatically.
*/
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Bn: require('./bn'),
  Bw: require('./bw'),
  Script: require('./script'),
  Struct: require('./struct'),
  VarInt: require('./var-int')
};

var inject = function inject(deps) {
  var Bn = deps.Bn;
  var Bw = deps.Bw;
  var Script = deps.Script;
  var Struct = deps.Struct;
  var VarInt = deps.VarInt;

  var TxOut = function (_Struct) {
    _inherits(TxOut, _Struct);

    function TxOut(valueBn, scriptVi, script) {
      _classCallCheck(this, TxOut);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(TxOut).call(this, { valueBn: valueBn, scriptVi: scriptVi, script: script }));
    }

    _createClass(TxOut, [{
      key: 'setScript',
      value: function setScript(script) {
        this.scriptVi = VarInt.fromNumber(script.toBuffer().length);
        this.script = script;
        return this;
      }
    }, {
      key: 'fromProperties',
      value: function fromProperties(valueBn, script) {
        this.fromObject({ valueBn: valueBn });
        this.setScript(script);
        return this;
      }
    }, {
      key: 'fromJSON',
      value: function fromJSON(json) {
        this.fromObject({
          valueBn: new Bn().fromJSON(json.valueBn),
          scriptVi: new VarInt().fromJSON(json.scriptVi),
          script: new Script().fromJSON(json.script)
        });
        return this;
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        return {
          valueBn: this.valueBn.toJSON(),
          scriptVi: this.scriptVi.toJSON(),
          script: this.script.toJSON()
        };
      }
    }, {
      key: 'fromBr',
      value: function fromBr(br) {
        this.valueBn = br.readUInt64LEBn();
        this.scriptVi = VarInt.fromNumber(br.readVarIntNum());
        this.script = new Script().fromBuffer(br.read(this.scriptVi.toNumber()));
        return this;
      }
    }, {
      key: 'toBw',
      value: function toBw(bw) {
        if (!bw) {
          bw = new Bw();
        }
        bw.writeUInt64LEBn(this.valueBn);
        bw.write(this.scriptVi.buf);
        bw.write(this.script.toBuffer());
        return bw;
      }
    }], [{
      key: 'fromProperties',
      value: function fromProperties(valueBn, script) {
        return new this().fromProperties(valueBn, script);
      }
    }]);

    return TxOut;
  }(Struct);

  return TxOut;
};

inject = require('injecter')(inject, dependencies);
var TxOut = inject();
module.exports = TxOut;

},{"./bn":327,"./bw":329,"./script":340,"./struct":342,"./var-int":348,"injecter":381}],347:[function(require,module,exports){
(function (Buffer){
/**
 * Transaction
 * ===========
 *
 * A bitcoin transaction.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Bn: require('./bn'),
  Br: require('./br'),
  Bw: require('./bw'),
  Ecdsa: require('./ecdsa'),
  Hash: require('./hash'),
  Script: require('./script'),
  Sig: require('./sig'),
  Struct: require('./struct'),
  TxIn: require('./tx-in'),
  TxOut: require('./tx-out'),
  VarInt: require('./var-int'),
  Workers: require('./workers'),
  asink: require('asink')
};

var inject = function inject(deps) {
  var Bn = deps.Bn;
  var Br = deps.Br;
  var Bw = deps.Bw;
  var Ecdsa = deps.Ecdsa;
  var Hash = deps.Hash;
  var Script = deps.Script;
  var Sig = deps.Sig;
  var Struct = deps.Struct;
  var TxIn = deps.TxIn;
  var TxOut = deps.TxOut;
  var VarInt = deps.VarInt;
  var Workers = deps.Workers;
  var asink = deps.asink;

  var Tx = function (_Struct) {
    _inherits(Tx, _Struct);

    function Tx() {
      var versionBytesNum = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
      var txInsVi = arguments.length <= 1 || arguments[1] === undefined ? VarInt.fromNumber(0) : arguments[1];
      var txIns = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
      var txOutsVi = arguments.length <= 3 || arguments[3] === undefined ? VarInt.fromNumber(0) : arguments[3];
      var txOuts = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
      var nLockTime = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];

      _classCallCheck(this, Tx);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Tx).call(this, { versionBytesNum: versionBytesNum, txInsVi: txInsVi, txIns: txIns, txOutsVi: txOutsVi, txOuts: txOuts, nLockTime: nLockTime }));
    }

    _createClass(Tx, [{
      key: 'fromJSON',
      value: function fromJSON(json) {
        var txIns = [];
        json.txIns.forEach(function (txIn) {
          txIns.push(new TxIn().fromJSON(txIn));
        });
        var txOuts = [];
        json.txOuts.forEach(function (txOut) {
          txOuts.push(new TxOut().fromJSON(txOut));
        });
        this.fromObject({
          versionBytesNum: json.versionBytesNum,
          txInsVi: new VarInt().fromJSON(json.txInsVi),
          txIns: txIns,
          txOutsVi: new VarInt().fromJSON(json.txOutsVi),
          txOuts: txOuts,
          nLockTime: json.nLockTime
        });
        return this;
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        var txIns = [];
        this.txIns.forEach(function (txIn) {
          txIns.push(txIn.toJSON());
        });
        var txOuts = [];
        this.txOuts.forEach(function (txOut) {
          txOuts.push(txOut.toJSON());
        });
        return {
          versionBytesNum: this.versionBytesNum,
          txInsVi: this.txInsVi.toJSON(),
          txIns: txIns,
          txOutsVi: this.txOutsVi.toJSON(),
          txOuts: txOuts,
          nLockTime: this.nLockTime
        };
      }
    }, {
      key: 'fromBr',
      value: function fromBr(br) {
        this.versionBytesNum = br.readUInt32LE();
        this.txInsVi = new VarInt(br.readVarIntBuf());
        var txInsNum = this.txInsVi.toNumber();
        this.txIns = [];
        for (var i = 0; i < txInsNum; i++) {
          this.txIns.push(new TxIn().fromBr(br));
        }
        this.txOutsVi = new VarInt(br.readVarIntBuf());
        var txOutsNum = this.txOutsVi.toNumber();
        this.txOuts = [];
        for (var _i = 0; _i < txOutsNum; _i++) {
          this.txOuts.push(new TxOut().fromBr(br));
        }
        this.nLockTime = br.readUInt32LE();
        return this;
      }
    }, {
      key: 'toBw',
      value: function toBw(bw) {
        if (!bw) {
          bw = new Bw();
        }
        bw.writeUInt32LE(this.versionBytesNum);
        bw.write(this.txInsVi.buf);
        for (var i = 0; i < this.txIns.length; i++) {
          this.txIns[i].toBw(bw);
        }
        bw.write(this.txOutsVi.buf);
        for (var _i2 = 0; _i2 < this.txOuts.length; _i2++) {
          this.txOuts[_i2].toBw(bw);
        }
        bw.writeUInt32LE(this.nLockTime);
        return bw;
      }

      /**
       * For a normal transaction, subScript is usually the scriptPubKey. For a
       * p2sh transaction, subScript is usually the redeemScript. If you're not
       * normal because you're using OP_CODESEPARATORs, you know what to do.
       */

    }, {
      key: 'sighash',
      value: function sighash(nHashType, nIn, subScript) {
        var txcopy = this.cloneByBuffer();

        subScript = new Script().fromBuffer(subScript.toBuffer());
        subScript.removeCodeseparators();

        for (var i = 0; i < txcopy.txIns.length; i++) {
          txcopy.txIns[i] = TxIn.fromBuffer(txcopy.txIns[i].toBuffer()).setScript(new Script());
        }

        txcopy.txIns[nIn] = TxIn.fromBuffer(txcopy.txIns[nIn].toBuffer()).setScript(subScript);

        if ((nHashType & 31) === Sig.SIGHASH_NONE) {
          txcopy.txOuts.length = 0;
          txcopy.txOutsVi = VarInt.fromNumber(0);

          for (var _i3 = 0; _i3 < txcopy.txIns.length; _i3++) {
            if (_i3 !== nIn) {
              txcopy.txIns[_i3].nSequence = 0;
            }
          }
        } else if ((nHashType & 31) === Sig.SIGHASH_SINGLE) {
          // The SIGHASH_SINGLE bug.
          // https://bitcointalk.org/index.php?topic=260595.0
          if (nIn > txcopy.txOuts.length - 1) {
            return new Buffer('0000000000000000000000000000000000000000000000000000000000000001', 'hex');
          }

          txcopy.txOuts.length = nIn + 1;
          txcopy.txOutsVi = VarInt.fromNumber(nIn + 1);

          for (var _i4 = 0; _i4 < txcopy.txOuts.length; _i4++) {
            if (_i4 < nIn) {
              txcopy.txOuts[_i4] = TxOut.fromProperties(new Bn().fromBuffer(new Buffer('ffffffffffffffff', 'hex')), new Script());
            }
          }

          for (var _i5 = 0; _i5 < txcopy.txIns.length; _i5++) {
            if (_i5 !== nIn) {
              txcopy.txIns[_i5].nSequence = 0;
            }
          }
        }
        // else, SIGHASH_ALL

        if (nHashType & Sig.SIGHASH_ANYONECANPAY) {
          txcopy.txIns[0] = txcopy.txIns[nIn];
          txcopy.txIns.length = 1;
          txcopy.txInsVi = VarInt.fromNumber(1);
        }

        var buf = new Bw().write(txcopy.toBuffer()).writeInt32LE(nHashType).toBuffer();
        return new Br(Hash.sha256Sha256(buf)).readReverse();
      }
    }, {
      key: 'asyncSighash',
      value: function asyncSighash(nHashType, nIn, subScript) {
        return asink(regeneratorRuntime.mark(function _callee() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Workers.asyncObjectMethod(this, 'sighash', [nHashType, nIn, subScript]);

                case 2:
                  workersResult = _context.sent;
                  return _context.abrupt('return', workersResult.resbuf);

                case 4:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }), this);
      }

      // This function returns a signature but does not update any inputs

    }, {
      key: 'sign',
      value: function sign(keyPair, nHashType, nIn, subScript) {
        var hashBuf = this.sighash(nHashType, nIn, subScript);
        var sig = Ecdsa.sign(hashBuf, keyPair, 'little').fromObject({ nHashType: nHashType });
        return sig;
      }
    }, {
      key: 'asyncSign',
      value: function asyncSign(keyPair, nHashType, nIn, subScript) {
        return asink(regeneratorRuntime.mark(function _callee2() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return Workers.asyncObjectMethod(this, 'sign', [keyPair, nHashType, nIn, subScript]);

                case 2:
                  workersResult = _context2.sent;
                  return _context2.abrupt('return', new Sig().fromFastBuffer(workersResult.resbuf));

                case 4:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }), this);
      }

      // This function takes a signature as input and does not parse any inputs

    }, {
      key: 'verify',
      value: function verify(sig, pubKey, nIn, subScript) {
        var hashBuf = this.sighash(sig.nHashType, nIn, subScript);
        return Ecdsa.verify(hashBuf, sig, pubKey, 'little');
      }
    }, {
      key: 'asyncVerify',
      value: function asyncVerify(sig, pubKey, nIn, subScript) {
        return asink(regeneratorRuntime.mark(function _callee3() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return Workers.asyncObjectMethod(this, 'verify', [sig, pubKey, nIn, subScript]);

                case 2:
                  workersResult = _context3.sent;
                  return _context3.abrupt('return', JSON.parse(workersResult.resbuf.toString()));

                case 4:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }), this);
      }
    }, {
      key: 'hash',
      value: function hash() {
        return Hash.sha256Sha256(this.toBuffer());
      }
    }, {
      key: 'asyncHash',
      value: function asyncHash() {
        return asink(regeneratorRuntime.mark(function _callee4() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return Workers.asyncObjectMethod(this, 'hash', []);

                case 2:
                  workersResult = _context4.sent;
                  return _context4.abrupt('return', workersResult.resbuf);

                case 4:
                case 'end':
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }), this);
      }
    }, {
      key: 'id',
      value: function id() {
        return new Br(this.hash()).readReverse();
      }
    }, {
      key: 'asyncId',
      value: function asyncId() {
        return asink(regeneratorRuntime.mark(function _callee5() {
          var workersResult;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return Workers.asyncObjectMethod(this, 'id', []);

                case 2:
                  workersResult = _context5.sent;
                  return _context5.abrupt('return', workersResult.resbuf);

                case 4:
                case 'end':
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }), this);
      }
    }, {
      key: 'addTxIn',
      value: function addTxIn(txHashBuf, txOutNum, script, nSequence) {
        var txIn = void 0;
        if (txHashBuf instanceof TxIn) {
          txIn = txHashBuf;
        } else {
          txIn = new TxIn().fromObject({ txHashBuf: txHashBuf, txOutNum: txOutNum, nSequence: nSequence }).setScript(script);
        }
        this.txIns.push(txIn);
        this.txInsVi = VarInt.fromNumber(this.txInsVi.toNumber() + 1);
        return this;
      }
    }, {
      key: 'addTxOut',
      value: function addTxOut(valueBn, script) {
        var txOut = void 0;
        if (valueBn instanceof TxOut) {
          txOut = valueBn;
        } else {
          txOut = new TxOut().fromObject({ valueBn: valueBn }).setScript(script);
        }
        this.txOuts.push(txOut);
        this.txOutsVi = VarInt.fromNumber(this.txOutsVi.toNumber() + 1);
        return this;
      }

      /**
       * Analagous to bitcoind's IsCoinBase function in transaction.h
       */

    }, {
      key: 'isCoinbase',
      value: function isCoinbase() {
        return this.txIns.length === 1 && this.txIns[0].hasNullInput();
      }
    }]);

    return Tx;
  }(Struct);

  Tx.MAX_MONEY = 21000000 * 1e8;

  return Tx;
};

inject = require('injecter')(inject, dependencies);
var Tx = inject();
module.exports = Tx;

}).call(this,require("buffer").Buffer)

},{"./bn":327,"./br":328,"./bw":329,"./ecdsa":332,"./hash":333,"./script":340,"./sig":341,"./struct":342,"./tx-in":344,"./tx-out":346,"./var-int":348,"./workers":351,"asink":352,"buffer":23,"injecter":381}],348:[function(require,module,exports){
(function (Buffer){
/**
 * VarInt (a.k.a. Compact Size)
 * ============================
 *
 * A varInt is a varible sized integer, and it is a format that is unique to
 * bitcoin, and used throughout bitcoin to represent the length of binary data
 * in a compact format that can take up as little as 1 byte or as much as 9
 * bytes.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Br: require('./br'),
  Bw: require('./bw'),
  Struct: require('./struct')
};

var inject = function inject(deps) {
  var Br = deps.Br;
  var Bw = deps.Bw;
  var Struct = deps.Struct;

  var VarInt = function (_Struct) {
    _inherits(VarInt, _Struct);

    function VarInt(buf) {
      _classCallCheck(this, VarInt);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(VarInt).call(this, { buf: buf }));
    }

    _createClass(VarInt, [{
      key: 'fromJSON',
      value: function fromJSON(json) {
        this.fromObject({
          buf: new Buffer(json, 'hex')
        });
        return this;
      }
    }, {
      key: 'toJSON',
      value: function toJSON() {
        return this.buf.toString('hex');
      }
    }, {
      key: 'fromBuffer',
      value: function fromBuffer(buf) {
        this.buf = buf;
        return this;
      }
    }, {
      key: 'fromBr',
      value: function fromBr(br) {
        this.buf = br.readVarIntBuf();
        return this;
      }
    }, {
      key: 'fromBn',
      value: function fromBn(bn) {
        this.buf = new Bw().writeVarIntBn(bn).toBuffer();
        return this;
      }
    }, {
      key: 'fromNumber',
      value: function fromNumber(num) {
        this.buf = new Bw().writeVarIntNum(num).toBuffer();
        return this;
      }
    }, {
      key: 'toBuffer',
      value: function toBuffer() {
        return this.buf;
      }
    }, {
      key: 'toBn',
      value: function toBn() {
        return new Br(this.buf).readVarIntBn();
      }
    }, {
      key: 'toNumber',
      value: function toNumber() {
        return new Br(this.buf).readVarIntNum();
      }
    }], [{
      key: 'fromBn',
      value: function fromBn(bn) {
        return new this().fromBn(bn);
      }
    }, {
      key: 'fromNumber',
      value: function fromNumber(num) {
        return new this().fromNumber(num);
      }
    }]);

    return VarInt;
  }(Struct);

  return VarInt;
};

inject = require('injecter')(inject, dependencies);
var VarInt = inject();
module.exports = VarInt;

}).call(this,require("buffer").Buffer)

},{"./br":328,"./bw":329,"./struct":342,"buffer":23,"injecter":381}],349:[function(require,module,exports){
(function (Buffer){
/**
 * WorkersCmd
 * ==========
 *
 * A command sent to a worker. The idea is that you send the worker a object,
 * and a method to perform on that object, and the arguments to that method,
 * all contained inside a WorkersCmd object. The worker will send back a
 * result, which is a WorkersResult object.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Bw: require('./bw'),
  Struct: require('./struct')
};

var inject = function inject(deps) {
  var Bw = deps.Bw;
  var Struct = deps.Struct;

  var WorkersCmd = function (_Struct) {
    _inherits(WorkersCmd, _Struct);

    function WorkersCmd(objbuf, classname, methodname, args, id) {
      _classCallCheck(this, WorkersCmd);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(WorkersCmd).call(this, { objbuf: objbuf, classname: classname, methodname: methodname, args: args, id: id }));
    }

    /**
     * The arguments to a workers command can be normal javascript objects,
     * buffers, or Yours Bitcoin objects.
     */


    _createClass(WorkersCmd, [{
      key: 'toBw',
      value: function toBw(bw) {
        if (!bw) {
          bw = new Bw();
        }
        var classNameBuf = new Buffer(this.classname);
        bw.writeUInt8(Number(this.isobj));
        bw.writeVarIntNum(classNameBuf.length);
        bw.write(classNameBuf);
        var methodNameBuf = new Buffer(this.methodname);
        bw.writeVarIntNum(methodNameBuf.length);
        bw.write(methodNameBuf);
        bw.writeVarIntNum(this.objbuf.length);
        bw.write(this.objbuf);
        WorkersCmd.argsToBw(bw, this.args);
        bw.writeVarIntNum(this.id);
        return bw;
      }
    }, {
      key: 'fromBr',
      value: function fromBr(br, classes) {
        this.isobj = Boolean(br.readUInt8());
        var classNameLEn = br.readVarIntNum();
        this.classname = br.read(classNameLEn).toString();
        var methodNameLEn = br.readVarIntNum();
        this.methodname = br.read(methodNameLEn).toString();
        var objbuflen = br.readVarIntNum();
        this.objbuf = br.read(objbuflen);
        this.args = WorkersCmd.argsFromBr(br, classes);
        this.id = br.readVarIntNum();
        return this;
      }
    }, {
      key: 'fromObjectMethod',
      value: function fromObjectMethod(obj, methodname, args, id) {
        this.isobj = true;
        this.objbuf = obj.toFastBuffer();
        this.classname = obj.constructor.name;
        this.methodname = methodname;
        this.args = args;
        this.id = id;
        return this;
      }
    }, {
      key: 'fromClassMethod',
      value: function fromClassMethod(classname, methodname, args, id) {
        this.isobj = false;
        this.objbuf = new Buffer(0);
        this.classname = classname;
        this.methodname = methodname;
        this.args = args;
        this.id = id;
        return this;
      }
    }], [{
      key: 'argsToBw',
      value: function argsToBw(bw, args) {
        bw.writeVarIntNum(args.length);
        for (var index in args) {
          var arg = args[index];
          if (Buffer.isBuffer(arg)) {
            // argument is Buffer
            bw.writeUInt8(0); // header byte
            bw.writeVarIntNum(arg.length);
            bw.write(arg);
          } else if (arg instanceof Struct) {
            // argument is Yours Bitcoin object
            bw.writeUInt8(1); // header byte
            var classname = arg.constructor.name;
            bw.writeVarIntNum(classname.length);
            bw.write(new Buffer(classname));
            var buf = arg.toFastBuffer();
            bw.writeVarIntNum(buf.length);
            bw.write(buf);
          } else if (arg === undefined) {
            bw.writeUInt8(2); // header byte
          } else {
            // assume basic javascript type
            bw.writeUInt8(3); // header byte
            var _buf = new Buffer(JSON.stringify(arg));
            bw.writeVarIntNum(_buf.length);
            bw.write(_buf);
          }
        }
        return bw;
      }

      /**
       * The arguments to a workers command can be normal javascript objects,
       * buffers, or Yours Bitcoin objects.
       */

    }, {
      key: 'argsFromBr',
      value: function argsFromBr(br, classes) {
        var argslen = br.readVarIntNum();
        var args = [];
        for (var i = 0; i < argslen; i++) {
          var header = br.readUInt8();
          if (header === 0) {
            // argument is Buffer
            var len = br.readVarIntNum();
            var buf = br.read(len);
            args.push(buf);
          } else if (header === 1) {
            // argument is Yours Bitcoin object
            var classNameLEn = br.readVarIntNum();
            var classname = br.read(classNameLEn).toString();
            var buflen = br.readVarIntNum();
            var _buf2 = br.read(buflen);
            var obj = new classes[classname]().fromFastBuffer(_buf2);
            args.push(obj);
          } else if (header === 2) {
            args.push(undefined);
          } else if (header === 3) {
            // argument is basic javascript type
            var _len = br.readVarIntNum();
            var _buf3 = br.read(_len);
            var _obj = JSON.parse(_buf3.toString());
            args.push(_obj);
          } else {
            throw new Error('invalid header byte for argument');
          }
        }
        return args;
      }
    }, {
      key: 'fromObjectMethod',
      value: function fromObjectMethod(obj, methodname, args, id) {
        return new this().fromObjectMethod(obj, methodname, args, id);
      }
    }, {
      key: 'fromClassMethod',
      value: function fromClassMethod(classname, methodname, args, id) {
        return new this().fromClassMethod(classname, methodname, args, id);
      }
    }]);

    return WorkersCmd;
  }(Struct);

  return WorkersCmd;
};

inject = require('injecter')(inject, dependencies);
var WorkersCmd = inject();
module.exports = WorkersCmd;

}).call(this,require("buffer").Buffer)

},{"./bw":329,"./struct":342,"buffer":23,"injecter":381}],350:[function(require,module,exports){
(function (Buffer){
/**
 * WorkersResult
 * =============
 *
 * A response sent back from a worker to the main thread. Contains the "result"
 * of the computation in the form of a buffer, resbuf. If the actual result is
 * an object with a .toFastBuffer method, the object is converted to a buffer
 * using that method. Otherwise it is JSON serialized into a buffer. The result
 * can also be an error, in which case the isError flag is set.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var dependencies = {
  Bw: require('./bw'),
  Struct: require('./struct')
};

var inject = function inject(deps) {
  var Bw = deps.Bw;
  var Struct = deps.Struct;

  var WorkersResult = function (_Struct) {
    _inherits(WorkersResult, _Struct);

    function WorkersResult(resbuf, isError, id) {
      _classCallCheck(this, WorkersResult);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(WorkersResult).call(this, { resbuf: resbuf, isError: isError, id: id }));
    }

    _createClass(WorkersResult, [{
      key: 'fromResult',
      value: function fromResult(result, id) {
        if (result.toFastBuffer) {
          this.resbuf = result.toFastBuffer();
        } else if (Buffer.isBuffer(result)) {
          this.resbuf = result;
        } else {
          this.resbuf = new Buffer(JSON.stringify(result));
        }
        this.isError = false;
        this.id = id;
        return this;
      }
    }, {
      key: 'fromError',
      value: function fromError(error, id) {
        this.resbuf = new Buffer(JSON.stringify(error.message));
        this.isError = true;
        this.id = id;
        return this;
      }
    }, {
      key: 'toBw',
      value: function toBw(bw) {
        if (!bw) {
          bw = new Bw();
        }
        bw.writeVarIntNum(this.resbuf.length);
        bw.write(this.resbuf);
        bw.writeUInt8(Number(this.isError));
        bw.writeVarIntNum(this.id);
        return bw;
      }
    }, {
      key: 'fromBr',
      value: function fromBr(br) {
        var resbuflen = br.readVarIntNum();
        this.resbuf = br.read(resbuflen);
        this.isError = Boolean(br.readUInt8());
        this.id = br.readVarIntNum();
        return this;
      }
    }], [{
      key: 'fromResult',
      value: function fromResult(result, id) {
        return new this().fromResult(result, id);
      }
    }]);

    return WorkersResult;
  }(Struct);

  return WorkersResult;
};

inject = require('injecter')(inject, dependencies);
var WorkersResult = inject();
module.exports = WorkersResult;

}).call(this,require("buffer").Buffer)

},{"./bw":329,"./struct":342,"buffer":23,"injecter":381}],351:[function(require,module,exports){
(function (process,Buffer,__dirname){
/* global self */
/**
 * Workers
 * =======
 *
 * Workers manages either processes (in node) or threads (in a browser). The
 * workers are intended to handle CPU-heavy tasks that block IO. This class is
 * a little unusual in that it must use different interfaces whether in node or
 * in the browser. In node, we use node's build-in child_process fork to create
 * new workers we can communicate with. In the browser, we use web workers.
 * Unfortunately, node and web browsers do not have a common interface for
 * workers. There is a node module called webworker-threads for node that
 * mimics the browser's web workers, but unfortunately it does not support
 * require(), and thus isn't very useful in our case. Therefore we fall back to
 * process forks.
 *
 * You probably don't need to use this class directly. Use Work, which will
 * automatically spawn new workers if needed.
 */
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var dependencies = {
  Worker: !process.browser ? require('child_process').spawn : undefined,
  WorkersCmd: require('./workers-cmd'),
  WorkersResult: require('./workers-result'),
  path: !process.browser ? require('path') : undefined
};

var inject = function inject(deps) {
  var Worker = deps.Worker;
  var WorkersCmd = deps.WorkersCmd;
  var WorkersResult = deps.WorkersResult;
  var path = deps.path;

  var globalWorkers = void 0;

  var Workers = function () {
    function Workers() {
      var nativeWorkers = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
      var lastid = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
      var promisemap = arguments.length <= 2 || arguments[2] === undefined ? new Map() : arguments[2];

      _classCallCheck(this, Workers);

      this.nativeWorkers = nativeWorkers;
      this.lastid = lastid;
      this.promisemap = promisemap;
    }

    _createClass(Workers, [{
      key: 'spawnBrowser',
      value: function spawnBrowser() {
        // TODO: Support more than one worker
        this.nativeWorkers[0] = new Worker(process.env.YOURS_BITCOIN_JS_BASE_URL + process.env.YOURS_BITCOIN_JS_WORKER_FILE);
        this.handleBrowser();
        return this;
      }
    }, {
      key: 'handleBrowser',
      value: function handleBrowser() {
        this.nativeWorkers[0].onerror = function (event) {
          this.onError(event.message + ': ' + event.filename + ':' + event.lineno);
        }.bind(this);
        this.nativeWorkers[0].onmessage = function (event) {
          this.onStdoutData(new Buffer(event.data));
        }.bind(this);
        return this;
      }
    }, {
      key: 'spawnNode',
      value: function spawnNode() {
        // TODO: Support more than one worker
        // TODO: {maxBuffer: 1000*1024}
        this.nativeWorkers[0] = Worker('node', [path.join(__dirname, 'worker-node.js')]);
        this.handleNode();
        return this;
      }
    }, {
      key: 'handleNode',
      value: function handleNode() {
        var _this = this;

        this.nativeWorkers[0].on('error', function (error) {
          _this.onError(error);
        });
        this.nativeWorkers[0].on('exit', function () {
          _this.onError('unexpected exit');
        });
        this.nativeWorkers[0].on('close', function () {
          _this.onError('unexpected close');
        });
        this.nativeWorkers[0].on('disconnect', function () {
          _this.onError('unexpected disconnect');
        });
        this.nativeWorkers[0].stdout.on('data', function (buf) {
          _this.onStdoutData(buf);
        });
        return this;
      }
    }, {
      key: 'onStdoutData',
      value: function onStdoutData(buf) {
        var workersResult = new WorkersResult().fromFastBuffer(buf);
        return this.onResult(workersResult);
      }
    }, {
      key: 'onResult',
      value: function onResult(workersResult) {
        if (!workersResult.isError) {
          var resolve = this.promisemap.get(workersResult.id).resolve;
          resolve(workersResult);
        } else {
          // console.log(workersResult.resbuf.toString()) // throw an error in worker to see output here
          var error = new Error(JSON.parse(workersResult.resbuf.toString()));
          var reject = this.promisemap.get(workersResult.id).reject;
          reject(error);
        }
        this.promisemap.delete(workersResult.id);
        return this;
      }
    }, {
      key: 'onError',
      value: function onError(error) {
        // eslint-disable-line
        return this;
      }
    }, {
      key: 'spawn',
      value: function spawn() {
        if (globalWorkers) {
          console.log('Warning: Spooling up non-global workers.');
        }
        if (process.browser) {
          return this.spawnBrowser();
        } else {
          return this.spawnNode();
        }
      }
    }, {
      key: 'sendBuffer',
      value: function sendBuffer(buf) {
        var buflen = new Buffer(4);
        buflen.writeUInt32BE(buf.length);
        buf = Buffer.concat([buflen, buf]);
        if (process.browser) {
          this.nativeWorkers[0].postMessage(buf);
        } else {
          this.nativeWorkers[0].stdin.write(buf);
        }
        return this;
      }
    }, {
      key: 'asyncObjectMethod',
      value: function asyncObjectMethod(obj, methodname, args, id) {
        var _this2 = this;

        if (!args) {
          throw new Error('must specify args');
        }
        id = id !== undefined ? id : ++this.lastid;
        var workersCmd = new WorkersCmd().fromObjectMethod(obj, methodname, args, id);
        var buf = workersCmd.toFastBuffer();
        return new Promise(function (resolve, reject) {
          _this2.sendBuffer(buf);
          _this2.promisemap.set(id, {
            resolve: resolve,
            reject: reject
          });
        });
      }
    }, {
      key: 'asyncClassMethod',
      value: function asyncClassMethod(classname, methodname, args, id) {
        if (!args) {
          throw new Error('must specify args');
        }
        id = id !== undefined ? id : ++this.lastid;
        var workersCmd = new WorkersCmd().fromClassMethod(classname, methodname, args, id);
        var buf = workersCmd.toFastBuffer();
        return new Promise(function (resolve, reject) {
          this.sendBuffer(buf);
          this.promisemap.set(id, {
            resolve: resolve,
            reject: reject
          });
        }.bind(this));
      }
    }], [{
      key: 'asyncObjectMethod',
      value: function asyncObjectMethod(obj, methodname, args, id) {
        if (!globalWorkers) {
          globalWorkers = new Workers().spawn();
        }
        return globalWorkers.asyncObjectMethod(obj, methodname, args, id);
      }
    }, {
      key: 'asyncClassMethod',
      value: function asyncClassMethod(obj, methodname, args, id) {
        if (!globalWorkers) {
          globalWorkers = new Workers().spawn();
        }
        return globalWorkers.asyncClassMethod(obj, methodname, args, id);
      }
    }, {
      key: 'endGlobalWorkers',
      value: function endGlobalWorkers() {
        if (globalWorkers && !process.browser) {
          // TODO: Support multiple workers.
          globalWorkers.nativeWorkers[0].kill('SIGINT');
          globalWorkers = undefined;
        }
      }
    }]);

    return Workers;
  }();

  return Workers;
};

inject = require('injecter')(inject, dependencies);
var Workers = inject();
module.exports = Workers;

}).call(this,require('_process'),require("buffer").Buffer,"/node_modules/yours-bitcoin/lib")

},{"./workers-cmd":349,"./workers-result":350,"_process":322,"buffer":23,"child_process":22,"injecter":381,"path":321}],352:[function(require,module,exports){
/**
 * asink
 * =====
 *
 * asink is the same thing as, or a rename of, spawn. spawn in turn is a tool
 * for repeatedly calling the .thens of promises yielded by a generator.
 * Basically, this makes it possible to write asynchronous, promisified code
 * with normal try/catches that look just like synchronous code. It creates
 * shorter and easier to understand code. Hypothetically, there will be a
 * feature in the next version of javascript, ES7, called "async functions",
 * which do exactly what asink does. When/if that happens and we can access it
 * in node, we can simply remove all calls to asink and our code should behave
 * in the same way.
 *
 * See:
 * http://tc39.github.io/ecmascript-asyncawait/
 * https://github.com/tc39/ecmascript-asyncawait
 * https://gist.github.com/jakearchibald/31b89cba627924972ad6
 * http://www.html5rocks.com/en/tutorials/es6/promises/
 * https://blogs.windows.com/msedgedev/2015/09/30/asynchronous-code-gets-easier-with-es2016-async-function-support-in-chakra-and-microsoft-edge/
 */
'use strict';

function spawn(genF, self) {
  return new Promise(function (resolve, reject) {
    var gen = genF.call(self);
    function step(nextF) {
      var next;
      try {
        next = nextF();
      } catch (e) {
        // finished with failure, reject the promise
        reject(e);
        return;
      }
      if (next.done) {
        // finished with success, resolve the promise
        resolve(next.value);
        return;
      }
      // not finished, chain off the yielded promise and `step` again
      Promise.resolve(next.value).then(function (v) {
        step(function () {
          return gen.next(v);
        });
      }, function (e) {
        step(function () {
          return gen.throw(e);
        });
      });
    }
    step(function () {
      return gen.next(undefined);
    });
  });
}
module.exports = spawn;

},{}],353:[function(require,module,exports){
// base-x encoding
// Forked from https://github.com/cryptocoinjs/bs58
// Originally written by Mike Hearn for BitcoinJ
// Copyright (c) 2011 Google Inc
// Ported to JavaScript by Stefan Thomas
// Merged Buffer refactorings from base58-native by Stephen Pair
// Copyright (c) 2013 BitPay Inc

module.exports = function base (ALPHABET) {
  var ALPHABET_MAP = {}
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)

  // pre-compute lookup table
  for (var i = 0; i < ALPHABET.length; i++) {
    ALPHABET_MAP[ALPHABET.charAt(i)] = i
  }

  function encode (source) {
    if (source.length === 0) return ''

    var digits = [0]
    for (var i = 0; i < source.length; ++i) {
      for (var j = 0, carry = source[i]; j < digits.length; ++j) {
        carry += digits[j] << 8
        digits[j] = carry % BASE
        carry = (carry / BASE) | 0
      }

      while (carry > 0) {
        digits.push(carry % BASE)
        carry = (carry / BASE) | 0
      }
    }

    // deal with leading zeros
    for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      digits.push(0)
    }

    // convert digits to a string
    for (var ii = 0, jj = digits.length - 1; ii <= jj; ++ii, --jj) {
      var tmp = ALPHABET[digits[ii]]
      digits[ii] = ALPHABET[digits[jj]]
      digits[jj] = tmp
    }

    return digits.join('')
  }

  function decode (string) {
    if (string.length === 0) return []

    var bytes = [0]
    for (var i = 0; i < string.length; i++) {
      var value = ALPHABET_MAP[string[i]]
      if (value === undefined) throw new Error('Non-base' + BASE + ' character')

      for (var j = 0, carry = value; j < bytes.length; ++j) {
        carry += bytes[j] * BASE
        bytes[j] = carry & 0xff
        carry >>= 8
      }

      while (carry > 0) {
        bytes.push(carry & 0xff)
        carry >>= 8
      }
    }

    // deal with leading zeros
    for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
      bytes.push(0)
    }

    return bytes.reverse()
  }

  return {
    encode: encode,
    decode: decode
  }
}

},{}],354:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = require('buf' + 'fer').Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    return num !== null && typeof num === 'object' &&
      num.constructor.name === 'BN' && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{}],355:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

if (typeof window === 'object') {
  if (window.crypto && window.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      window.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (window.msCrypto && window.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      window.msCrypto.getRandomValues(arr);
      return arr;
    };
  } else {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker
  try {
    var crypto = require('cry' + 'pto');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
    // Emulate crypto API using randy
    Rand.prototype._rand = function _rand(n) {
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
  }
}

},{}],356:[function(require,module,exports){
var basex = require('base-x')
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
var base58 = basex(ALPHABET)

module.exports = {
  encode: base58.encode,
  decode: base58.decode
}

},{"base-x":353}],357:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.hmacDRBG = require('./elliptic/hmac-drbg');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":373,"./elliptic/curve":360,"./elliptic/curves":363,"./elliptic/ec":364,"./elliptic/eddsa":367,"./elliptic/hmac-drbg":370,"./elliptic/utils":372,"brorand":355}],358:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../../elliptic":357,"bn.js":354}],359:[function(require,module,exports){
'use strict';

var curve = require('../curve');
var elliptic = require('../../elliptic');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - 1) / (d y^2 + 1)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.one);
  var rhs = y2.redMul(this.d).redAdd(this.one);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
         this.y.cmp(this.z) === 0;
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
  return false;
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../../elliptic":357,"../curve":360,"bn.js":354,"inherits":380}],360:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":358,"./edwards":359,"./mont":361,"./short":362}],361:[function(require,module,exports){
'use strict';

var curve = require('../curve');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var elliptic = require('../../elliptic');
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../../elliptic":357,"../curve":360,"bn.js":354,"inherits":380}],362:[function(require,module,exports){
'use strict';

var curve = require('../curve');
var elliptic = require('../../elliptic');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
  return false;
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../../elliptic":357,"../curve":360,"bn.js":354,"inherits":380}],363:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var elliptic = require('../elliptic');

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '0',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});

},{"../elliptic":357,"./precomputed/secp256k1":371,"hash.js":374}],364:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    pers: options.pers,
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var eNeg = n.sub(e);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  var rInv = signature.r.invm(n);
  return this.g.mulAdd(eNeg, r, s).mul(rInv);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../../elliptic":357,"./key":365,"./signature":366,"bn.js":354}],365:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"bn.js":354}],366:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../../elliptic":357,"bn.js":354}],367:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../../elliptic":357,"./key":368,"./signature":369,"hash.js":374}],368:[function(require,module,exports){
'use strict';

var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../../elliptic":357}],369:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../../elliptic":357,"bn.js":354}],370:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var elliptic = require('../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this.reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc);
  var nonce = utils.toArray(options.nonce, options.nonceEnc);
  var pers = utils.toArray(options.pers, options.persEnc);
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this.reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toBuffer(entropy, entropyEnc);
  add = utils.toBuffer(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this.reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this.reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc);
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this.reseed++;
  return utils.encode(res, enc);
};

},{"../elliptic":357,"hash.js":374}],371:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};

},{}],372:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');

utils.assert = function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
};

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (!enc) {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  } else if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":354}],373:[function(require,module,exports){
module.exports={
  "_args": [
    [
      {
        "raw": "elliptic@https://registry.npmjs.org/elliptic/-/elliptic-6.3.1.tgz",
        "scope": null,
        "escapedName": "elliptic",
        "name": "elliptic",
        "rawSpec": "https://registry.npmjs.org/elliptic/-/elliptic-6.3.1.tgz",
        "spec": "https://registry.npmjs.org/elliptic/-/elliptic-6.3.1.tgz",
        "type": "remote"
      },
      "/home/iluvpool19/Desktop/xbt/yours-channels/node_modules/yours-bitcoin"
    ]
  ],
  "_from": "elliptic@6.3.1",
  "_id": "elliptic@6.3.1",
  "_inCache": true,
  "_location": "/yours-bitcoin/elliptic",
  "_phantomChildren": {},
  "_requested": {
    "raw": "elliptic@https://registry.npmjs.org/elliptic/-/elliptic-6.3.1.tgz",
    "scope": null,
    "escapedName": "elliptic",
    "name": "elliptic",
    "rawSpec": "https://registry.npmjs.org/elliptic/-/elliptic-6.3.1.tgz",
    "spec": "https://registry.npmjs.org/elliptic/-/elliptic-6.3.1.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/yours-bitcoin",
    "/yours-bitcoin/browserify-sign",
    "/yours-bitcoin/create-ecdh"
  ],
  "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.3.1.tgz",
  "_shasum": "17781f2109ab0ec686b146bdcff5d2e8c6aeceda",
  "_shrinkwrap": null,
  "_spec": "elliptic@https://registry.npmjs.org/elliptic/-/elliptic-6.3.1.tgz",
  "_where": "/home/iluvpool19/Desktop/xbt/yours-channels/node_modules/yours-bitcoin",
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "dependencies": {
    "bn.js": "^4.4.0",
    "brorand": "^1.0.1",
    "hash.js": "^1.0.0",
    "inherits": "^2.0.1"
  },
  "description": "EC cryptography",
  "devDependencies": {
    "brfs": "^1.4.3",
    "coveralls": "^2.11.3",
    "grunt": "^0.4.5",
    "grunt-browserify": "^5.0.0",
    "grunt-contrib-connect": "^1.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^1.0.1",
    "grunt-mocha-istanbul": "^3.0.1",
    "grunt-saucelabs": "^8.6.2",
    "istanbul": "^0.4.2",
    "jscs": "^2.9.0",
    "jshint": "^2.6.0",
    "mocha": "^2.1.0"
  },
  "files": [
    "lib"
  ],
  "homepage": "https://github.com/indutny/elliptic",
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "license": "MIT",
  "main": "lib/elliptic.js",
  "name": "elliptic",
  "optionalDependencies": {},
  "readme": "# Elliptic [![Build Status](https://secure.travis-ci.org/indutny/elliptic.png)](http://travis-ci.org/indutny/elliptic) [![Coverage Status](https://coveralls.io/repos/indutny/elliptic/badge.svg?branch=master&service=github)](https://coveralls.io/github/indutny/elliptic?branch=master) [![Code Climate](https://codeclimate.com/github/indutny/elliptic/badges/gpa.svg)](https://codeclimate.com/github/indutny/elliptic)\n\n[![Saucelabs Test Status](https://saucelabs.com/browser-matrix/gh-indutny-elliptic.svg)](https://saucelabs.com/u/gh-indutny-elliptic)\n\nFast elliptic-curve cryptography in a plain javascript implementation.\n\nNOTE: Please take a look at http://safecurves.cr.yp.to/ before choosing a curve\nfor your cryptography operations.\n\n## Incentive\n\nECC is much slower than regular RSA cryptography, the JS implementations are\neven more slower.\n\n## Benchmarks\n\n```bash\n$ node benchmarks/index.js\nBenchmarking: sign\nelliptic#sign x 262 ops/sec 0.51% (177 runs sampled)\neccjs#sign x 55.91 ops/sec 0.90% (144 runs sampled)\n------------------------\nFastest is elliptic#sign\n========================\nBenchmarking: verify\nelliptic#verify x 113 ops/sec 0.50% (166 runs sampled)\neccjs#verify x 48.56 ops/sec 0.36% (125 runs sampled)\n------------------------\nFastest is elliptic#verify\n========================\nBenchmarking: gen\nelliptic#gen x 294 ops/sec 0.43% (176 runs sampled)\neccjs#gen x 62.25 ops/sec 0.63% (129 runs sampled)\n------------------------\nFastest is elliptic#gen\n========================\nBenchmarking: ecdh\nelliptic#ecdh x 136 ops/sec 0.85% (156 runs sampled)\n------------------------\nFastest is elliptic#ecdh\n========================\n```\n\n## API\n\n### ECDSA\n\n```javascript\nvar EC = require('elliptic').ec;\n\n// Create and initialize EC context\n// (better do it once and reuse it)\nvar ec = new EC('secp256k1');\n\n// Generate keys\nvar key = ec.genKeyPair();\n\n// Sign message (must be an array, or it'll be treated as a hex sequence)\nvar msg = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nvar signature = key.sign(msg);\n\n// Export DER encoded signature in Array\nvar derSign = signature.toDER();\n\n// Verify signature\nconsole.log(key.verify(msg, derSign));\n\n// CHECK WITH NO PRIVATE KEY\n\n// Public key as '04 + x + y'\nvar pub = '04bb1fa3...';\n\n// Signature MUST be either:\n// 1) hex-string of DER-encoded signature; or\n// 2) DER-encoded signature as buffer; or\n// 3) object with two hex-string properties (r and s)\n\nvar signature = 'b102ac...'; // case 1\nvar signature = new Buffer('...'); // case 2\nvar signature = { r: 'b1fc...', s: '9c42...' }; // case 3\n\n// Import public key\nvar key = ec.keyFromPublic(pub, 'hex');\n\n// Verify signature\nconsole.log(key.verify(msg, signature));\n```\n\n### EdDSA\n\n```javascript\nvar EdDSA = require('elliptic').eddsa;\n\n// Create and initialize EdDSA context\n// (better do it once and reuse it)\nvar ec = new EdDSA('ed25519');\n\n// Create key pair from secret\nvar key = ec.keyFromSecret('693e3c...'); // hex string, array or Buffer\n\n// Sign message (must be an array, or it'll be treated as a hex sequence)\nvar msg = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nvar signature = key.sign(msg).toHex();\n\n// Verify signature\nconsole.log(key.verify(msg, signature));\n\n// CHECK WITH NO PRIVATE KEY\n\n// Import public key\nvar pub = '0a1af638...';\nvar key = ec.keyFromPublic(pub, 'hex');\n\n// Verify signature\nvar signature = '70bed1...';\nconsole.log(key.verify(msg, signature));\n```\n\n### ECDH\n\n```javascript\n// Generate keys\nvar key1 = ec.genKeyPair();\nvar key2 = ec.genKeyPair();\n\nvar shared1 = key1.derive(key2.getPublic());\nvar shared2 = key2.derive(key1.getPublic());\n\nconsole.log('Both shared secrets are BN instances');\nconsole.log(shared1.toString(16));\nconsole.log(shared2.toString(16));\n```\n\nNOTE: `.derive()` returns a [BN][1] instance.\n\n## Supported curves\n\nElliptic.js support following curve types:\n\n* Short Weierstrass\n* Montgomery\n* Edwards\n* Twisted Edwards\n\nFollowing curve 'presets' are embedded into the library:\n\n* `secp256k1`\n* `p192`\n* `p224`\n* `p256`\n* `p384`\n* `p521`\n* `curve25519`\n* `ed25519`\n\nNOTE: That `curve25519` could not be used for ECDSA, use `ed25519` instead.\n\n### Implementation details\n\nECDSA is using deterministic `k` value generation as per [RFC6979][0]. Most of\nthe curve operations are performed on non-affine coordinates (either projective\nor extended), various windowing techniques are used for different cases.\n\nAll operations are performed in reduction context using [bn.js][1], hashing is\nprovided by [hash.js][2]\n\n### Related projects\n\n* [eccrypto][3]: isomorphic implementation of ECDSA, ECDH and ECIES for both\n  browserify and node (uses `elliptic` for browser and [secp256k1-node][4] for\n  node)\n\n#### LICENSE\n\nThis software is licensed under the MIT License.\n\nCopyright Fedor Indutny, 2014.\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n\n[0]: http://tools.ietf.org/html/rfc6979\n[1]: https://github.com/indutny/bn.js\n[2]: https://github.com/indutny/hash.js\n[3]: https://github.com/bitchan/eccrypto\n[4]: https://github.com/wanderer/secp256k1-node\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/indutny/elliptic.git"
  },
  "scripts": {
    "jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
    "jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
    "lint": "npm run jscs && npm run jshint",
    "test": "npm run lint && npm run unit",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "version": "grunt dist && git add dist/"
  },
  "version": "6.3.1"
}

},{}],374:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":375,"./hash/hmac":376,"./hash/ripemd":377,"./hash/sha":378,"./hash/utils":379}],375:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"../hash":374}],376:[function(require,module,exports){
var hmac = exports;

var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"../hash":374}],377:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = hash.common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"../hash":374}],378:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

var rotr32 = utils.rotr32;
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = hash.common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
exports.sha256 = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
exports.sha224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xf3bcc908,
             0xbb67ae85, 0x84caa73b,
             0x3c6ef372, 0xfe94f82b,
             0xa54ff53a, 0x5f1d36f1,
             0x510e527f, 0xade682d1,
             0x9b05688c, 0x2b3e6c1f,
             0x1f83d9ab, 0xfb41bd6b,
             0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
exports.sha512 = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(c0_hi, c0_lo,
                      c1_hi, c1_lo,
                      c2_hi, c2_lo,
                      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
                          c1_hi, c1_lo,
                          c2_hi, c2_lo,
                          c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);

    var c0_hi = s0_512_hi(ah, al);
    var c0_lo = s0_512_lo(ah, al);
    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [ 0xcbbb9d5d, 0xc1059ed8,
             0x629a292a, 0x367cd507,
             0x9159015a, 0x3070dd17,
             0x152fecd8, 0xf70e5939,
             0x67332667, 0xffc00b31,
             0x8eb44a87, 0x68581511,
             0xdb0c2e0d, 0x64f98fa7,
             0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
exports.sha384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,
             0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
exports.sha1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (var i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}

function p32(x, y, z) {
  return x ^ y ^ z;
}

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}

function ch64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../hash":374}],379:[function(require,module,exports){
var utils = exports;
var inherits = require('inherits');

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
utils.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
utils.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils.sum32_5 = sum32_5;

function assert(cond, msg) {
  if (!cond)
    throw new Error(msg || 'Assertion failed');
}
utils.assert = assert;

utils.inherits = inherits;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
};
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
};
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
};
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
};
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
};
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
};
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
};
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
};
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.shr64_lo = shr64_lo;

},{"inherits":380}],380:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],381:[function(require,module,exports){
/**
 * Injecter
 * ========
 *
 * This is a dependency injector specifically designed for use with Yours
 * Bitcoin. In order to allow injecting dependencies, Yours Bitcoin classes
 * provide an "inject" method that makes a new class with injected
 * dependencies. However, that method by itself presents a problem, because it
 * creates a new class every time it is used, leaving the burden of caching the
 * classes to the user. Thus the injector allows us to easily wrap an inject
 * method that keeps a cache of the created classes, lowing memory burden, and
 * allowing the instanceof operator to work correctly.
 */
'use strict'
let classmaps = new Map()

module.exports = function injector (inject, dependencies) {
  if (classmaps.get(inject) === undefined) {
    classmaps.set(inject, new Map())
  }

  let classmap = classmaps.get(inject)
  let meminject = function (deps) {
    let Class = classmap.get(deps)
    if (Class !== undefined) {
      return Class
    }

    Class = inject(Object.assign({}, dependencies, deps))
    classmap.set(deps, Class)

    // The "inject" and "injected" properties are non-enumerable so they don't
    // ruin any code that may enumerate properties of your classes.
    Object.defineProperty(Class, 'inject', {
      value: meminject,
      enumerable: false
    })
    Object.defineProperty(Class, 'injected', {
      value: deps,
      enumerable: false
    })
    return Class
  }

  return meminject
}

},{}],382:[function(require,module,exports){
(function (process,global,Buffer){
'use strict'

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}

var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > 65536) throw new Error('requested too many random bytes')
  // in case browserify  isn't using the Uint8Array version
  var rawBytes = new global.Uint8Array(size)

  // This will not work in older browsers.
  // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
  if (size > 0) {  // getRandomValues fails on IE if size == 0
    crypto.getRandomValues(rawBytes)
  }
  // phantomjs doesn't like a buffer being passed here
  var bytes = new Buffer(rawBytes.buffer)

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"_process":322,"buffer":23}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsImxpYi9hZGRycy9rZXktcGFpci1hZGRyZXNzLmpzIiwibGliL2FkZHJzL211bHRpc2lnLmpzIiwibGliL2FnZW50LmpzIiwibGliL2NoYW5uZWwuanMiLCJsaWIvY29uc3RzLmpzIiwibGliL21zZ3MvbXNnLXNlY3JldHMuanMiLCJsaWIvbXNncy9tc2ctdXBkYXRlLmpzIiwibGliL21zZ3MvbXNnLmpzIiwibGliL291dHB1dC5qcyIsImxpYi9zY3J0cy9odGxjLXNlY3JldC5qcyIsImxpYi9zY3J0cy9yZXYtc2VjcmV0LmpzIiwibGliL3NjcnRzL3NlY3JldC5qcyIsImxpYi90eHMvY29tbWl0bWVudC5qcyIsImxpYi90eHMvZnVuZGluZy5qcyIsImxpYi90eHMvc3BlbmRpbmcuanMiLCJsaWIvdHhzL3R4LmpzIiwibGliL3dhbGxldC5qcyIsIm5vZGVfbW9kdWxlcy9hc2luay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGF0ZS10by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtZXhwbTEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnRpYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVwbGFjZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5sYXN0LWluZGV4LW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jbHozMi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudHJ1bmMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuZXBzaWxvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5pcy1leHRlbnNpYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcubGluay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yYXcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9zaGltLmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9saWIvYWRkcmVzcy5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL2xpYi9iYXNlLTU4LWNoZWNrLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbGliL2Jhc2UtNTguanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9saWIvYm4uanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9saWIvYnIuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9saWIvYncuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9saWIvY21wLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL2xpYi9lY2RzYS5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL2xpYi9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbGliL2tleS1wYWlyLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbGliL29wLWNvZGUuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9saWIvcG9pbnQuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9saWIvcHJpdi1rZXkuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9saWIvcHViLWtleS5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL2xpYi9yYW5kb20uanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9saWIvc2NyaXB0LmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbGliL3NpZy5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL2xpYi9zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9saWIvdHgtYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL2xpYi90eC1pbi5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL2xpYi90eC1vdXQtbWFwLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbGliL3R4LW91dC5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL2xpYi90eC5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL2xpYi92YXItaW50LmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbGliL3dvcmtlcnMtY21kLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbGliL3dvcmtlcnMtcmVzdWx0LmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbGliL3dvcmtlcnMuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9ub2RlX21vZHVsZXMvYXNpbmsvaW5kZXguanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9ub2RlX21vZHVsZXMvYmFzZS14L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9icm9yYW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9lZHdhcmRzLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvbW9udC5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmUvc2hvcnQuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlcy5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VjL2tleS5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMvc2lnbmF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWRkc2Eva2V5LmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9zaWduYXR1cmUuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2htYWMtZHJiZy5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvcHJlY29tcHV0ZWQvc2VjcDI1NmsxLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2htYWMuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9yaXBlbWQuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEuanMiLCJub2RlX21vZHVsZXMveW91cnMtYml0Y29pbi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbm9kZV9tb2R1bGVzL2luamVjdGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3lvdXJzLWJpdGNvaW4vbm9kZV9tb2R1bGVzL3JhbmRvbWJ5dGVzL2Jyb3dzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBOzs7Ozs7O0FBT0EsSUFBTSxNQUFNLEVBQVo7QUFDQSxJQUFJLEtBQUosR0FBWSxRQUFRLGdCQUFSLENBQVo7QUFDQSxJQUFJLE9BQUosR0FBYyxRQUFRLGtCQUFSLENBQWQ7QUFDQSxJQUFJLE1BQUosR0FBYSxRQUFRLGlCQUFSLENBQWI7QUFDQSxJQUFJLE1BQUosR0FBYSxRQUFRLGlCQUFSLENBQWI7QUFDQSxJQUFJLE1BQUosR0FBYSxRQUFRLGlCQUFSLENBQWI7O0FBR0EsT0FBTyxPQUFQLEdBQWlCLEdBQWpCOzs7QUNmQTs7Ozs7Ozs7OztBQUNBLElBQUksU0FBUyxRQUFRLDBCQUFSLENBQWI7QUFDQSxJQUFJLFFBQVEsUUFBUSxPQUFSLENBQVo7O0FBRUEsSUFBSSxVQUFVLFFBQVEsMkJBQVIsQ0FBZDtBQUNBLElBQUksVUFBVSxRQUFRLDRCQUFSLENBQWQ7O0lBRU0sYzs7O0FBQ0osMEJBQWEsT0FBYixFQUFzQixPQUF0QixFQUErQixPQUEvQixFQUF3QztBQUFBOztBQUFBOztBQUV0QyxVQUFLLFVBQUwsQ0FBZ0IsRUFBQyxnQkFBRCxFQUFVLGdCQUFWLEVBQW1CLGdCQUFuQixFQUFoQjtBQUZzQztBQUd2Qzs7OztvQ0FFZ0IsTyxFQUFTO0FBQ3hCLGFBQU8sOEJBQU07QUFBQTtBQUFBO0FBQUE7QUFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN3ZEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTs7QUNGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwRkE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0EsT0FBTyxPQUFQLEdBQWlCLFVBQVUsR0FBVixFQUFlO0FBQzlCLFNBQU8sT0FBTyxJQUFQLEtBQWdCLFNBQVMsR0FBVCxLQUFpQixhQUFhLEdBQWIsQ0FBakIsSUFBc0MsQ0FBQyxDQUFDLElBQUksU0FBNUQsQ0FBUDtBQUNELENBRkQ7O0FBSUEsU0FBUyxRQUFULENBQW1CLEdBQW5CLEVBQXdCO0FBQ3RCLFNBQU8sQ0FBQyxDQUFDLElBQUksV0FBTixJQUFxQixPQUFPLElBQUksV0FBSixDQUFnQixRQUF2QixLQUFvQyxVQUF6RCxJQUF1RSxJQUFJLFdBQUosQ0FBZ0IsUUFBaEIsQ0FBeUIsR0FBekIsQ0FBOUU7QUFDRDs7QUFFRDtBQUNBLFNBQVMsWUFBVCxDQUF1QixHQUF2QixFQUE0QjtBQUMxQixTQUFPLE9BQU8sSUFBSSxXQUFYLEtBQTJCLFVBQTNCLElBQXlDLE9BQU8sSUFBSSxLQUFYLEtBQXFCLFVBQTlELElBQTRFLFNBQVMsSUFBSSxLQUFKLENBQVUsQ0FBVixFQUFhLENBQWIsQ0FBVCxDQUFuRjtBQUNEOzs7QUNwQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogXCJBZ2VudFwiIGlzIHRoZSBjZW50cmFsIGNvbXBvbmVudCBvZiBhIHBheW1lbnQgY2hhbm5lbC4gQW4gYWdlbnQgaGFzIGFsbCB0aGVcbiAqIGluZm9ybWF0aW9uIGFib3V0IG9uZSBvZiB0aGUgc2lkZXMgb2YgYSBwYXltZW50IGNoYW5uZWwuICBUbyB1c2UgdGhlIEFnZW50XG4gKiBjbGFzczpcbiAqXG4gKiBsZXQgQWdlbnQgPSByZXF1aXJlKCd5b3Vycy1jaGFubmVscycpLkFnZW50XG4gKi9cbmNvbnN0IGxpYiA9IHt9O1xubGliLkFnZW50ID0gcmVxdWlyZSgnLi9saWIvYWdlbnQuanMnKTtcbmxpYi5DaGFubmVsID0gcmVxdWlyZSgnLi9saWIvY2hhbm5lbC5qcycpO1xubGliLkNvbnN0cyA9IHJlcXVpcmUoJy4vbGliL2NvbnN0cy5qcycpO1xubGliLk91dHB1dCA9IHJlcXVpcmUoJy4vbGliL291dHB1dC5qcycpO1xubGliLldhbGxldCA9IHJlcXVpcmUoJy4vbGliL3dhbGxldC5qcycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbGliO1xuIiwiJ3VzZSBzdHJpY3QnXG5sZXQgU3RydWN0ID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvc3RydWN0JylcbmxldCBhc2luayA9IHJlcXVpcmUoJ2FzaW5rJylcblxubGV0IEFkZHJlc3MgPSByZXF1aXJlKCd5b3Vycy1iaXRjb2luL2xpYi9hZGRyZXNzJylcbmxldCBLZXlQYWlyID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIva2V5LXBhaXInKVxuXG5jbGFzcyBLZXlQYWlyQWRkcmVzcyBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yIChwcml2S2V5LCBrZXlQYWlyLCBhZGRyZXNzKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZnJvbU9iamVjdCh7cHJpdktleSwga2V5UGFpciwgYWRkcmVzc30pXG4gIH1cblxuICBhc3luY0luaXRpYWxpemUgKHByaXZLZXkpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBpZiAoIXByaXZLZXkgfHwgcHJpdktleS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnUHJpdktleScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGlzLnByaXZLZXkgbXVzdCBiZSBzZXQgYmVmb3JlIG11bHRpc2lnQWRkcmVzcyBjYW4gYmUgaW5pdGlhbGl6ZWQnKVxuICAgICAgfVxuICAgICAgdGhpcy5rZXlQYWlyID0geWllbGQgS2V5UGFpci5hc3luY0Zyb21Qcml2S2V5KHByaXZLZXkpXG4gICAgICB0aGlzLmFkZHJlc3MgPSB5aWVsZCBBZGRyZXNzLmFzeW5jRnJvbVB1YktleSh0aGlzLmtleVBhaXIucHViS2V5KVxuXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBmcm9tSlNPTiAoanNvbikge1xuICAgIHRoaXMua2V5UGFpciA9IGpzb24ua2V5UGFpciA/IEtleVBhaXIuZnJvbUpTT04oanNvbi5rZXlQYWlyKSA6IHVuZGVmaW5lZFxuICAgIHRoaXMuYWRkcmVzcyA9IGpzb24uYWRkcmVzcyA/IEFkZHJlc3MuZnJvbUpTT04oanNvbi5hZGRyZXNzKSA6IHVuZGVmaW5lZFxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBqc29uLmluaXRpYWxpemVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvUHVibGljICgpIHtcbiAgICBsZXQga2V5UGFpckFkZHJlc3MgPSBuZXcgS2V5UGFpckFkZHJlc3MoKVxuICAgIGtleVBhaXJBZGRyZXNzLmtleVBhaXIgPSB0aGlzLmtleVBhaXIgPyB0aGlzLmtleVBhaXIudG9QdWJsaWMoKSA6IHVuZGVmaW5lZFxuICAgIGtleVBhaXJBZGRyZXNzLmFkZHJlc3MgPSB0aGlzLmFkZHJlc3NcbiAgICBrZXlQYWlyQWRkcmVzcy5pbml0aWFsaXplZCA9IHRoaXMuaW5pdGlhbGl6ZWRcbiAgICByZXR1cm4ga2V5UGFpckFkZHJlc3NcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5UGFpckFkZHJlc3NcbiIsIid1c2Ugc3RyaWN0J1xubGV0IFN0cnVjdCA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3N0cnVjdCcpXG5sZXQgYXNpbmsgPSByZXF1aXJlKCdhc2luaycpXG5sZXQgU2NyaXB0ID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvc2NyaXB0JylcbmxldCBQcml2S2V5ID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvcHJpdi1rZXknKVxubGV0IFB1YktleSA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3B1Yi1rZXknKVxubGV0IEFkZHJlc3MgPSByZXF1aXJlKCd5b3Vycy1iaXRjb2luL2xpYi9hZGRyZXNzJylcbmxldCBLZXlQYWlyID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIva2V5LXBhaXInKVxuXG5jbGFzcyBNdWx0aXNpZyBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yIChwcml2S2V5LFxuICAgIHB1YktleSxcbiAgICBvdGhlclB1YktleSxcbiAgICBwdWJLZXlzLFxuICAgIHNjcmlwdCxcbiAgICBhZGRyZXNzLFxuICAgIGtleVBhaXIsXG4gICAgaW5pdGlhbGl6ZWRcbiAgKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZnJvbU9iamVjdCh7cHJpdktleSxcbiAgICAgIHB1YktleSxcbiAgICAgIG90aGVyUHViS2V5LFxuICAgICAgcHViS2V5cyxcbiAgICAgIHNjcmlwdCxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBrZXlQYWlyLFxuICAgICAgaW5pdGlhbGl6ZWRcbiAgICB9KVxuICB9XG5cbiAgaW5pdGlhbGl6ZVByaXZLZXkgKHByaXZLZXkpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICB0aGlzLnByaXZLZXkgPSBwcml2S2V5XG4gICAgICB0aGlzLnB1YktleSA9IHlpZWxkIFB1YktleS5hc3luY0Zyb21Qcml2S2V5KHByaXZLZXkpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIGFzeW5jSW5pdGlhbGl6ZSAob3RoZXJQdWJLZXkpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucHJpdktleSB8fCB0aGlzLnByaXZLZXkuY29uc3RydWN0b3IubmFtZSAhPT0gJ1ByaXZLZXknKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcy5wcml2S2V5IG11c3QgYmUgc2V0IGJlZm9yZSBtdWx0aXNpZ0FkZHJlc3MgY2FuIGJlIGluaXRpYWxpemVkJylcbiAgICAgIH1cbiAgICAgIGlmICghb3RoZXJQdWJLZXkgfHwgb3RoZXJQdWJLZXkuY29uc3RydWN0b3IubmFtZSAhPT0gJ1B1YktleScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdGhlclB1YktleSByZXF1aXJlZCB0byBidWlsZCBhIG11bHRpc2lnQWRkcmVzcycpXG4gICAgICB9XG4gICAgICB0aGlzLm90aGVyUHViS2V5ID0gb3RoZXJQdWJLZXlcbiAgICAgIHRoaXMucHViS2V5ID0geWllbGQgUHViS2V5LmFzeW5jRnJvbVByaXZLZXkodGhpcy5wcml2S2V5KVxuXG4gICAgICB0aGlzLnB1YktleXMgPSBbdGhpcy5wdWJLZXksIHRoaXMub3RoZXJQdWJLZXldXG4gICAgICB0aGlzLnNjcmlwdCA9IFNjcmlwdC5mcm9tUHViS2V5cygyLCB0aGlzLnB1YktleXMpXG4gICAgICB0aGlzLmFkZHJlc3MgPSB5aWVsZCBBZGRyZXNzLmFzeW5jRnJvbVJlZGVlbVNjcmlwdCh0aGlzLnNjcmlwdClcbiAgICAgIHRoaXMua2V5UGFpciA9IHlpZWxkIEtleVBhaXIuYXN5bmNGcm9tUHJpdktleSh0aGlzLnByaXZLZXkpXG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIGZyb21KU09OIChqc29uKSB7XG4gICAgdGhpcy5wcml2S2V5ID0ganNvbi5wcml2S2V5ID8gUHJpdktleS5mcm9tSGV4KGpzb24ucHJpdktleSkgOiB1bmRlZmluZWRcbiAgICB0aGlzLnB1YktleSA9IGpzb24ucHViS2V5ID8gUHViS2V5LmZyb21GYXN0SGV4KGpzb24ucHViS2V5KSA6IHVuZGVmaW5lZFxuICAgIHRoaXMub3RoZXJQdWJLZXkgPSBqc29uLm90aGVyUHViS2V5ID8gUHViS2V5LmZyb21GYXN0SGV4KGpzb24ub3RoZXJQdWJLZXkpIDogdW5kZWZpbmVkXG4gICAgdGhpcy5zY3JpcHQgPSBqc29uLnNjcmlwdCA/IFNjcmlwdC5mcm9tSGV4KGpzb24uc2NyaXB0KSA6IHVuZGVmaW5lZFxuICAgIHRoaXMuYWRkcmVzcyA9IGpzb24uYWRkcmVzcyA/IEFkZHJlc3MuZnJvbUpTT04oanNvbi5hZGRyZXNzKSA6IHVuZGVmaW5lZFxuICAgIHRoaXMua2V5UGFpciA9IGpzb24ua2V5UGFpciA/IEtleVBhaXIuZnJvbUpTT04oanNvbi5rZXlQYWlyKSA6IHVuZGVmaW5lZFxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBqc29uLmluaXRpYWxpemVkXG4gICAgaWYgKGpzb24ucHViS2V5cykge1xuICAgICAgbGV0IHB1YktleXMgPSBbXVxuICAgICAganNvbi5wdWJLZXlzLmZvckVhY2goZnVuY3Rpb24gKHB1YktleSkge1xuICAgICAgICBwdWJLZXlzLnB1c2goUHViS2V5LmZyb21GYXN0SGV4KHB1YktleSkpXG4gICAgICB9KVxuICAgICAgdGhpcy5wdWJLZXlzID0gcHViS2V5c1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdG9QdWJsaWMgKCkge1xuICAgIGxldCBtdWx0aXNpZ0FkZHJlc3MgPSBuZXcgTXVsdGlzaWcoKS5mcm9tT2JqZWN0KHRoaXMpXG4gICAgbXVsdGlzaWdBZGRyZXNzLnByaXZLZXkgPSB1bmRlZmluZWRcbiAgICBtdWx0aXNpZ0FkZHJlc3Mua2V5UGFpciA9IHRoaXMua2V5UGFpciA/IHRoaXMua2V5UGFpci50b1B1YmxpYygpIDogdW5kZWZpbmVkXG4gICAgcmV0dXJuIG11bHRpc2lnQWRkcmVzc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTXVsdGlzaWdcbiIsIid1c2Ugc3RyaWN0J1xubGV0IGJhYmVsID0gcmVxdWlyZSgnYmFiZWwtcG9seWZpbGwnKVxubGV0IFN0cnVjdCA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3N0cnVjdCcpXG5sZXQgYXNpbmsgPSByZXF1aXJlKCdhc2luaycpXG5sZXQgQm4gPSByZXF1aXJlKCd5b3Vycy1iaXRjb2luL2xpYi9ibicpXG5sZXQgTXVsdGlzaWcgPSByZXF1aXJlKCcuL2FkZHJzL211bHRpc2lnJylcbmxldCBLZXlQYWlyQWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcnMva2V5LXBhaXItYWRkcmVzcycpXG5sZXQgSHRsY1NlY3JldCA9IHJlcXVpcmUoJy4vc2NydHMvaHRsYy1zZWNyZXQnKVxubGV0IFJldlNlY3JldCA9IHJlcXVpcmUoJy4vc2NydHMvcmV2LXNlY3JldCcpXG5sZXQgRnVuZGluZyA9IHJlcXVpcmUoJy4vdHhzL2Z1bmRpbmcnKVxubGV0IENvbW1pdG1lbnQgPSByZXF1aXJlKCcuL3R4cy9jb21taXRtZW50JylcbmxldCBXYWxsZXQgPSByZXF1aXJlKCcuL3dhbGxldCcpXG5cbmNsYXNzIEFnZW50IGV4dGVuZHMgU3RydWN0IHtcbiAgY29uc3RydWN0b3IgKGlkLFxuICAgIHNvdXJjZUFkZHJlc3MsIC8vIHRoZSBhZGRyZXNzIHRoYXQgdGhlIGZ1bmRpbmcgdHJhbnNhY3Rpb24gaXMgZnVuZGVkIGZyb21cbiAgICBtdWx0aXNpZ0FkZHJlc3MsIC8vIHRoZSBzaGFyZWQgbXVsdGlzaWdBZGRyZXNzIGFkZHJlc3NcbiAgICBkZXN0aW5hdGlvbkFkZHJlc3MsIC8vIHRoZSBhZGRyZXNzIHRoYXQgdGhlIHNwZW5kaW5nIHRyYW5zYWN0aW9ucyBzcGVuZCB0b1xuICAgIGZ1bmRpbmcsIC8vIGFuIG9iamVjdCBzdG9yaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmdW5kaW5nIHR4XG4gICAgY29tbWl0bWVudHMsIC8vIGEgbGlzdCBvZiBvYmplY3RzIHN0b3JpbmcgaW5mb3JtYXRpb24gYWJvdXQgcHJldmlvdXMgY29tbWl0bWVudCB0eHNcbiAgICB3YWxsZXQsIC8vIHRoZSB3YWxsZXQgKGR1bW15IGZvciBub3cpXG4gICAgaW5pdGlhbGl6ZWQsIC8vIGJvb2xlYW4sIHNldCB0byB0cnVlIG9uY2UgbG9jYWwgaW5pdGlhbGl6YXRpb24gaXMgY29tcGxldGVcbiAgICBmdW5kZXIsIC8vIGJvb2xlYW4sIHNldCB0byB0cnVlIGlmIGFnZW50IGZ1bmRzIHRoZSBjaGFubmVsXG4gICAgc2VuZGVyLCAvLyBib29sZWFuLCBzZXQgdG8gdHJ1ZSBpZiBhZ2VudCBoYXMgc2VudCB0aGUgbGFzdCBwYXltZW50XG4gICAgb3RoZXIsIC8vIHB1YmxpYyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3RoZXIgYWdlbnQgYW5kIGFsbCBjb21taXRtZW50IHR4cyB0aGF0IGhlIHN0b3Jlc1xuICAgIHJlbW90ZUFnZW50IC8vIHVzZWQgdGVtcG9yYXJpbHkgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgb3RoZXIgYWdlbnQgKHdpbGwgZ28gYXdheSBvbmNlIHdlIGludGVncmF0ZSBtc2dzKVxuICApIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5mcm9tT2JqZWN0KHtpZCxcbiAgICAgIHNvdXJjZUFkZHJlc3MsXG4gICAgICBtdWx0aXNpZ0FkZHJlc3MsXG4gICAgICBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICBmdW5kaW5nLFxuICAgICAgY29tbWl0bWVudHMsXG4gICAgICB3YWxsZXQsXG4gICAgICBpbml0aWFsaXplZCxcbiAgICAgIGZ1bmRlcixcbiAgICAgIHNlbmRlcixcbiAgICAgIG90aGVyLFxuICAgICAgcmVtb3RlQWdlbnRcbiAgICB9KVxuICB9XG5cbiAgLyogLS0tLSBJTklUSUFMSVpBVElPTiAtLS0tICovXG5cbiAgLypcbiAgICogSW5pdGlhbGl6ZXMgYW4gYWdlbnQgbG9jYWxseS4gSW4gcGFydGljdWxhciwgdGhlIHNvdXJjZUFkZHJlc3MgYWRkcmVzcywgdGhlIG11bHRpc2lnQWRkcmVzc1xuICAgKiBhZGRyZXNzLCB0aGUgZGVzdGluYXRpb25BZGRyZXNzIGFkZHJlc3MgYXJlIGluaXRpYWxpemVkLiBUaGUgbGlzdCBvZiBjb21taXRtZW50IHR4b3V0c1xuICAgKiBpcyBpbml0aWFsaXplZCB3aXRoIHNlY3JldHMgZm9yIHRoZSBuZXh0IHBheW1lbnQuXG4gICAqL1xuICBhc3luY0luaXRpYWxpemUgKHNvdXJjZVByaXZLZXksIG11bHRpc2lnUHJpdktleSwgZGVzdGluYXRpb25Qcml2S2V5KSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgaWYgKCFzb3VyY2VQcml2S2V5IHx8ICFtdWx0aXNpZ1ByaXZLZXkgfHwgIWRlc3RpbmF0aW9uUHJpdktleSB8fCBzb3VyY2VQcml2S2V5LmNvbnN0cnVjdG9yLm5hbWUgIT09ICdQcml2S2V5JyB8fCBtdWx0aXNpZ1ByaXZLZXkuY29uc3RydWN0b3IubmFtZSAhPT0gJ1ByaXZLZXknIHx8IGRlc3RpbmF0aW9uUHJpdktleS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnUHJpdktleScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VQcml2S2V5LCBtdWx0aXNpZ1ByaXZLZXksIGRlc3RpbmF0aW9uUHJpdktleSBtdXN0IGJlIFByaXZLZXlzIGFuZCBhcmUgcmVxdWlyZWQgaW4gYXN5bmNJbml0aWFsaXplJylcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIGFkZHJlc3MgdGhhdCdzIHRoZSBpbnB1dCB0byB0aGUgc291cmNlQWRkcmVzcyB0cmFzbmFjdGlvblxuICAgICAgdGhpcy5zb3VyY2VBZGRyZXNzID0gbmV3IEtleVBhaXJBZGRyZXNzKClcbiAgICAgIHlpZWxkIHRoaXMuc291cmNlQWRkcmVzcy5hc3luY0luaXRpYWxpemUoc291cmNlUHJpdktleSlcblxuICAgICAgLy8gdGhlIHNoYXJlZCBtdWx0aXNpZ0FkZHJlc3MgYWRkcmVzc1xuICAgICAgdGhpcy5tdWx0aXNpZ0FkZHJlc3MgPSBuZXcgTXVsdGlzaWcoKVxuICAgICAgeWllbGQgdGhpcy5tdWx0aXNpZ0FkZHJlc3MuaW5pdGlhbGl6ZVByaXZLZXkobXVsdGlzaWdQcml2S2V5KVxuXG4gICAgICAvLyB0aGUgYWRkcmVzcyB0aGF0J3MgdGhlIG91dHB1dCB0byBhIGNvbW1pdG1lbnQgdHJhc25hY3Rpb25cbiAgICAgIHRoaXMuZGVzdGluYXRpb25BZGRyZXNzID0gbmV3IEtleVBhaXJBZGRyZXNzKClcbiAgICAgIHlpZWxkIHRoaXMuZGVzdGluYXRpb25BZGRyZXNzLmFzeW5jSW5pdGlhbGl6ZShkZXN0aW5hdGlvblByaXZLZXkpXG5cbiAgICAgIC8vIGluaXRpYWxpemUgZmlyc3QgY29tbWl0bWVudFxuICAgICAgdGhpcy5jb21taXRtZW50cyA9IFtdXG4gICAgICAvLyB5aWVsZCB0aGlzLmFzeW5jSW5pdGlhbGl6ZUNvbW1pdG1lbnQoKVxuXG4gICAgICAvLyB0aGUgd2FsbGV0XG4gICAgICB0aGlzLndhbGxldCA9IG5ldyBXYWxsZXQoKVxuXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICAvKiAtLS0tIFBST1RPQ09MIC0tLS0gKi9cblxuICAvKlxuICAgKiBUaGlzIGlzIHRoZSBmaXJzdCBwb2ludCBvZiBjb21tdW5pY2F0aW9uIGJldHdlZW4gdGhlIHR3byBhZ2VudHMuIEFyZ3VtZW50cyBhcmVcbiAgICogdGhlIGFtb3VudCB0byBmdW5kIHRoZSBjaGFubmVsIHdpdGggYW5kIHRoZSBwdWJsaWMgcHJvamVjdGlvbiBvZiB0aGUgb3RoZXIgYWdlbnQuXG4gICAqIFN0b3JlcyB0aGUgcHVibGljIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvdGhlciBhZ2VudCBhbmQgaW5pdGlhbGl6ZXMgdGhlIG11bHRpc2lnQWRkcmVzc1xuICAgKiBhZGRyZXNzLiBUaGUgZnVuZGVyIG9mIHRoZSBjaGFubmVsIHdpbGwgYnVpbGQgdGhlIGZ1bmRpbmcgdHJhbnNhY3Rpb24gYW5kIHNlbmRcbiAgICogaXQncyBoYXNoIHRvIHRoZSBvdGhlciBwYXJ0eS5cbiAgICovXG4gIGFzeW5jT3BlbkNoYW5uZWwgKGFtb3VudCwgcHVibGljT3RoZXIpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICAvLyBpbml0aWFsaXplIGluZm9ybWF0aW9uIGFib3V0IG90aGVyIGFnZW50XG4gICAgICB0aGlzLm90aGVyID0gcHVibGljT3RoZXJcblxuICAgICAgLy8gaW5pdGlhbGl6ZSBtdWx0aXNpZ0FkZHJlc3NcbiAgICAgIHlpZWxkIHRoaXMubXVsdGlzaWdBZGRyZXNzLmFzeW5jSW5pdGlhbGl6ZSh0aGlzLm90aGVyLm11bHRpc2lnQWRkcmVzcy5wdWJLZXkpXG5cbiAgICAgIGlmICghdGhpcy5mdW5kZXIpIHtcbiAgICAgICAgLy8gc2VuZCB5b3VyIGluZm9ybWF0aW9uIHRvIHRoZSBvdGhlciBhZ2VudFxuICAgICAgICAvLyBUT0RPIHNpZ24gZnVuZGluZ1R4IGFuZCBzZW5kIGJhY2sgdG8gZnVuZGVyXG4gICAgICAgIHlpZWxkIHRoaXMucmVtb3RlQWdlbnQuYXN5bmNPcGVuQ2hhbm5lbChhbW91bnQsIHlpZWxkIHRoaXMuYXN5bmNUb1B1YmxpYygpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlIGZ1bmRlciB3aWxsIGJ1aWxkIHRoZSBzb3VyY2VBZGRyZXNzIHRyYW5zYWN0aW9uIGFuZCBjYWNoZSBpdCdzIGhhc2hidWYgYW5kIHR4b3V0XG4gICAgICAgIGxldCBmZWUgPSBCbigyMDAwMClcbiAgICAgICAgbGV0IG91dHB1dCA9IHRoaXMud2FsbGV0LmdldFVuc3BlbnRPdXRwdXQoYW1vdW50LmFkZChmZWUpLCB0aGlzLnNvdXJjZUFkZHJlc3Mua2V5UGFpci5wdWJLZXkpXG5cbiAgICAgICAgdGhpcy5mdW5kaW5nID0gbmV3IEZ1bmRpbmcoKVxuICAgICAgICB0aGlzLmZ1bmRpbmcuYXN5bmNJbml0aWFsaXplKGFtb3VudCwgdGhpcy5zb3VyY2VBZGRyZXNzLCB0aGlzLm11bHRpc2lnQWRkcmVzcyxcbiAgICAgICAgICBvdXRwdXQudHhoYXNoYnVmLCBvdXRwdXQudHhvdXRudW0sIG91dHB1dC50eG91dCwgb3V0cHV0LnB1YktleSlcblxuICAgICAgICAvLyBzZW5kIHRoZSBzb3VyY2VBZGRyZXNzIHR4IGhhc2ggdG8gdGhlIG90aGVyIGFnZW50XG4gICAgICAgIHRoaXMucmVtb3RlQWdlbnQuc2V0RnVuZGluZyh5aWVsZCB0aGlzLmZ1bmRpbmcuYXN5bmNUb1B1YmxpYygpKVxuICAgICAgfVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBhc3luY1NlbmRPdXRwdXRzIChvdXRwdXRzLCBjaGFuZ2VPdXRwdXQpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBpZiAoIXRoaXMubXVsdGlzaWdBZGRyZXNzIHx8ICF0aGlzLmZ1bmRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZ2VudCBub3Qgc3VmZmljaWVudGx5IGluaXRpYWxpemVkIGluIGFzeW5jU2VuZE91dHB1dHMnKVxuICAgICAgfVxuXG4gICAgICAvLyBjcmVhdGUgbmV3IGNvbW1pdG1lbnQgYW5kIGFkZCBhbGwgaW5mbyB0aGF0IGlzIG5vdCByZWFsdGVkIHRvIGJ1aWxkZXIgdnMgb3duZXJcbiAgICAgIGxldCBjb21taXRtZW50ID0gbmV3IENvbW1pdG1lbnQoKVxuICAgICAgY29tbWl0bWVudC5yZXZTZWNyZXQgPSBuZXcgUmV2U2VjcmV0KClcbiAgICAgIHlpZWxkIGNvbW1pdG1lbnQucmV2U2VjcmV0LmFzeW5jSW5pdGlhbGl6ZSgpXG4gICAgICBjb21taXRtZW50Lm11bHRpc2lnQWRkcmVzcyA9IHRoaXMubXVsdGlzaWdBZGRyZXNzXG4gICAgICBjb21taXRtZW50LmZ1bmRpbmcgPSB0aGlzLmZ1bmRpbmdcbiAgICAgIGNvbW1pdG1lbnQub3V0cHV0cyA9IG91dHB1dHMubWFwKChvdXRwdXQpID0+IHRoaXMuY29tcGxldGVPdXRwdXQob3V0cHV0LCBjb21taXRtZW50LnJldlNlY3JldCkpXG4gICAgICBjb21taXRtZW50LmNoYW5nZU91dHB1dCA9IHRoaXMuY29tcGxldGVPdXRwdXQoY2hhbmdlT3V0cHV0LCBjb21taXRtZW50LnJldlNlY3JldClcbiAgICAgIHRoaXMuY29tbWl0bWVudHMucHVzaChjb21taXRtZW50KVxuICAgICAgdGhpcy5vdGhlci5jb21taXRtZW50cy5wdXNoKGNvbW1pdG1lbnQpXG5cbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgeWllbGQgdGhpcy5yZW1vdGVBZ2VudC5hc3luY1NlbmRPdXRwdXRzKG91dHB1dHMsIGNoYW5nZU91dHB1dClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHRoaXMucmVtb3RlQWdlbnQuYXN5bmNCdWlsZENvbW1pdG1lbnQoKVxuICAgICAgfVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBhc3luY0J1aWxkQ29tbWl0bWVudCAoKSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgbGV0IG90aGVyQ29tbWl0bWVudCA9IHRoaXMub3RoZXIuY29tbWl0bWVudHMucG9wKClcbiAgICAgIG90aGVyQ29tbWl0bWVudC5idWlsZGVySWQgPSB0aGlzLmlkXG4gICAgICBvdGhlckNvbW1pdG1lbnQuYnVpbGRlckRlc3RpbmF0aW9uQWRkcmVzcyA9IHRoaXMuZGVzdGluYXRpb25BZGRyZXNzXG4gICAgICBvdGhlckNvbW1pdG1lbnQub3duZXJJZCA9IHRoaXMub3RoZXIuaWRcbiAgICAgIG90aGVyQ29tbWl0bWVudC5vd25lckRlc3RpbmF0aW9uQWRkcmVzcyA9IHRoaXMub3RoZXIuZGVzdGluYXRpb25BZGRyZXNzXG4gICAgICB5aWVsZCBvdGhlckNvbW1pdG1lbnQuYXN5bmNCdWlsZCgpXG4gICAgICB0aGlzLm90aGVyLmNvbW1pdG1lbnRzLnB1c2gob3RoZXJDb21taXRtZW50KVxuXG4gICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucmVtb3RlQWdlbnQuYXN5bmNCdWlsZENvbW1pdG1lbnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgdGhpcy5yZW1vdGVBZ2VudC5zZW5kQ29tbWl0bWVudChvdGhlckNvbW1pdG1lbnQpXG4gICAgICB9XG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIHNlbmRDb21taXRtZW50IChuZXdDb21taXRtZW50KSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgbGV0IHN0b3JlZENvbW1pdG1lbnQgPSB0aGlzLmNvbW1pdG1lbnRzW3RoaXMuY29tbWl0bWVudHMubGVuZ3RoIC0gMV1cbiAgICAgIGlmICh0aGlzLmNoZWNrQ29tbWl0bWVudChzdG9yZWRDb21taXRtZW50LCBuZXdDb21taXRtZW50KSkge1xuICAgICAgICB5aWVsZCBuZXdDb21taXRtZW50LnR4Yi5hc3luY1NpZ24oMCwgdGhpcy5tdWx0aXNpZ0FkZHJlc3Mua2V5UGFpciwgdGhpcy5mdW5kaW5nLnR4Yi50eC50eE91dHNbMF0pXG5cbiAgICAgICAgdGhpcy5jb21taXRtZW50cy5wb3AoKVxuICAgICAgICB0aGlzLmNvbW1pdG1lbnRzLnB1c2gobmV3Q29tbWl0bWVudClcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICBsZXQgb3RoZXJDb21taXRtZW50ID0gdGhpcy5vdGhlci5jb21taXRtZW50c1t0aGlzLm90aGVyLmNvbW1pdG1lbnRzLmxlbmd0aCAtIDFdXG4gICAgICAgIHlpZWxkIHRoaXMucmVtb3RlQWdlbnQuc2VuZENvbW1pdG1lbnQob3RoZXJDb21taXRtZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJldlNlY3JldCA9IHRoaXMuZ2V0UmV2U2VjcmV0KClcbiAgICAgICAgaWYgKHJldlNlY3JldCkge1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVtb3RlQWdlbnQuc2VuZFJldlNlY3JldChyZXZTZWNyZXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgc2VuZFJldlNlY3JldCAocmV2U2VjcmV0KSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgLy8gVE9ET1xuICAgIH0sIHRoaXMpXG4gIH1cblxuICAvKiAtLS0tIFNFVFRFUlMgLS0tLSAqL1xuXG4gIHNldEZ1bmRpbmcgKHR4bykge1xuICAgIHRoaXMuZnVuZGluZyA9IHR4b1xuICB9XG5cbiAgc2V0Q29tbWl0bWVudCAodHhvKSB7XG4gICAgdGhpcy5jb21taXRtZW50c1t0aGlzLmNvbW1pdG1lbnRzLmxlbmd0aCAtIDFdID0gdHhvXG4gIH1cblxuICBzZXRPdGhlckNvbW1pdG1lbnQgKHR4bykge1xuICAgIHRoaXMub3RoZXIuY29tbWl0bWVudHNbdGhpcy5vdGhlci5jb21taXRtZW50cy5sZW5ndGggLSAxXSA9IHR4b1xuICB9XG5cbiAgLyogLS0tLSBHRVRURVJTIC0tLS0gKi9cblxuICBnZXRSZXZTZWNyZXQgKCkge1xuICAgIC8vIGlmIHRoZXJlIGlzIGEgdHJhbnNhY3Rpb24gdG8gcmV2b2tlLCByZXR1cm4gaXQncyByZXYgc2VjcmV0XG4gICAgaWYgKHRoaXMuY29tbWl0bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tbWl0bWVudHNbdGhpcy5jb21taXRtZW50cy5sZW5ndGggLSAyXS5yZXZTZWNyZXRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyogLS0tLSBIRUxQRVJTIC0tLS0gKi9cblxuICBjb21wbGV0ZU91dHB1dCAob3V0cHV0LCByZXZTZWNyZXQpIHtcbiAgICBpZiAob3V0cHV0LmludGVybWVkaWF0ZURlc3RJZCA9PT0gdGhpcy5pZCkge1xuICAgICAgb3V0cHV0LnJldlNlY3JldCA9IHJldlNlY3JldFxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0XG4gIH1cblxuICBjaGVja0NvbW1pdG1lbnQgKHN0b3JlZENvbW1pdG1lbnQsIG5ld0NvbW1pdG1lbnQpIHtcbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIFdlIGhhdmUgdG8gZGVsZXRlIG90aGVyIGFuZCByZW1vdGVBZ2VudCBhbmQgcmVzdG9yZSBhZnRlciBjb25zdHJ1Y3RpbmcganNvbi5cbiAgLy8gSWRlYWxsdCB3ZSdkIGNhbGwgc3VwZXIudG9KU09OIGFmdGVyIHRoYXQsIGJ1dCB0aGF0J3Mgbm90IHBvc3NpYmxlIGR1ZSB0b1xuICAvLyBzb21lIHN0dXBpZCBlcnJvciAoVE9ETylcbiAgdG9KU09OICgpIHtcbiAgICBsZXQgb3RoZXIgPSB0aGlzLm90aGVyXG4gICAgbGV0IHJlbW90ZUFnZW50ID0gdGhpcy5yZW1vdGVBZ2VudFxuICAgIGxldCB0aGF0ID0gdGhpc1xuICAgIHRoYXQub3RoZXIgPSB1bmRlZmluZWRcbiAgICB0aGF0LnJlbW90ZUFnZW50ID0gdW5kZWZpbmVkXG4gICAgdmFyIGpzb24gPSB7fVxuICAgIGZvciAodmFyIHZhbCBpbiB0aGlzKSB7XG4gICAgICBpZiAodGhpc1t2YWxdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgbGV0IGFyciA9IFtdXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpc1t2YWxdKSB7XG4gICAgICAgICAgYXJyLnB1c2godGhpc1t2YWxdW2ldLnRvSlNPTigpKVxuICAgICAgICB9XG4gICAgICAgIGpzb25bdmFsXSA9IGFyclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpc1t2YWxdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBqc29uW3ZhbF0gPSB0aGlzW3ZhbF0udG9KU09OKClcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXNbdmFsXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAganNvblt2YWxdID0gdGhpc1t2YWxdXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub3RoZXIgPSBvdGhlclxuICAgIHRoaXMucmVtb3RlQWdlbnQgPSByZW1vdGVBZ2VudFxuICAgIHJldHVybiBqc29uXG4gIH1cblxuICBmcm9tSlNPTiAoanNvbikge1xuICAgIHRoaXMubmFtZSA9IGpzb24ubmFtZVxuICAgIHRoaXMuc291cmNlQWRkcmVzcyA9IGpzb24uc291cmNlQWRkcmVzcyA/IG5ldyBLZXlQYWlyQWRkcmVzcygpLmZyb21KU09OKGpzb24uc291cmNlQWRkcmVzcykgOiB1bmRlZmluZWRcbiAgICB0aGlzLm11bHRpc2lnQWRkcmVzcyA9IGpzb24ubXVsdGlzaWdBZGRyZXNzID8gbmV3IE11bHRpc2lnKCkuZnJvbUpTT04oanNvbi5tdWx0aXNpZ0FkZHJlc3MpIDogdW5kZWZpbmVkXG4gICAgdGhpcy5kZXN0aW5hdGlvbkFkZHJlc3MgPSBqc29uLmRlc3RpbmF0aW9uQWRkcmVzcyA/IG5ldyBLZXlQYWlyQWRkcmVzcygpLmZyb21KU09OKGpzb24uZGVzdGluYXRpb25BZGRyZXNzKSA6IHVuZGVmaW5lZFxuICAgIHRoaXMuaHRsY1NlY3JldCA9IGpzb24uaHRsY1NlY3JldCA/IG5ldyBIdGxjU2VjcmV0KCkuZnJvbUpTT04oanNvbi5odGxjU2VjcmV0KSA6IHVuZGVmaW5lZFxuICAgIHRoaXMubmV4dFJldlNlY3JldCA9IGpzb24ubmV4dFJldlNlY3JldCA/IG5ldyBSZXZTZWNyZXQoKS5mcm9tSlNPTihqc29uLm5leHRSZXZTZWNyZXQpIDogdW5kZWZpbmVkXG4gICAgdGhpcy5mdW5kZXIgPSBqc29uLmZ1bmRlclxuICAgIHRoaXMud2FsbGV0ID0ganNvbi53YWxsZXQgPyBuZXcgV2FsbGV0KCkuZnJvbUpTT04oanNvbi53YWxsZXQpIDogdW5kZWZpbmVkXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGpzb24uaW5pdGlhbGl6ZWRcbiAgICB0aGlzLnNlbmRlciA9IGpzb24uc2VuZGVyXG4gICAgdGhpcy5mdW5kaW5nID0ganNvbi5mdW5kaW5nID8gbmV3IEZ1bmRpbmcoKS5mcm9tSlNPTihqc29uLmZ1bmRpbmcpIDogdW5kZWZpbmVkXG4gICAgaWYgKGpzb24uY29tbWl0bWVudHMpIHtcbiAgICAgIGxldCBjb21taXRtZW50cyA9IFtdXG4gICAgICBqc29uLmNvbW1pdG1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHR4KSB7XG4gICAgICAgIGNvbW1pdG1lbnRzLnB1c2gobmV3IENvbW1pdG1lbnQoKS5mcm9tSlNPTih0eCkpXG4gICAgICB9KVxuICAgICAgdGhpcy5jb21taXRtZW50cyA9IGNvbW1pdG1lbnRzXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhc3luY1RvUHVibGljICgpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBsZXQgYWdlbnQgPSBuZXcgQWdlbnQoKVxuICAgICAgYWdlbnQuaWQgPSB0aGlzLmlkXG4gICAgICBhZ2VudC5zb3VyY2VBZGRyZXNzID0gdGhpcy5zb3VyY2VBZGRyZXNzID8gdGhpcy5zb3VyY2VBZGRyZXNzLnRvUHVibGljKCkgOiB1bmRlZmluZWRcbiAgICAgIGFnZW50Lm11bHRpc2lnQWRkcmVzcyA9IHRoaXMubXVsdGlzaWdBZGRyZXNzID8gdGhpcy5tdWx0aXNpZ0FkZHJlc3MudG9QdWJsaWMoKSA6IHVuZGVmaW5lZFxuICAgICAgYWdlbnQuZGVzdGluYXRpb25BZGRyZXNzID0gdGhpcy5kZXN0aW5hdGlvbkFkZHJlc3MgPyB0aGlzLmRlc3RpbmF0aW9uQWRkcmVzcy50b1B1YmxpYygpIDogdW5kZWZpbmVkXG4gICAgICBhZ2VudC5mdW5kaW5nID0gdGhpcy5mdW5kaW5nID8geWllbGQgdGhpcy5mdW5kaW5nLmFzeW5jVG9QdWJsaWMoKSA6IHVuZGVmaW5lZFxuICAgICAgaWYgKHRoaXMuY29tbWl0bWVudHMpIHtcbiAgICAgICAgbGV0IGNvbW1pdG1lbnRzID0gW11cbiAgICAgICAgdGhpcy5jb21taXRtZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0eG8pIHtcbiAgICAgICAgICBjb21taXRtZW50cy5wdXNoKHR4by50b1B1YmxpYygpKVxuICAgICAgICB9KVxuICAgICAgICBhZ2VudC5jb21taXRtZW50cyA9IGNvbW1pdG1lbnRzXG4gICAgICB9XG4gICAgICBhZ2VudC53YWxsZXQgPSB0aGlzLndhbGxldCA/IHRoaXMud2FsbGV0LnRvUHVibGljKCkgOiB1bmRlZmluZWRcbiAgICAgIGFnZW50LmluaXRpYWxpemVkID0gdGhpcy5pbml0aWFsaXplZFxuICAgICAgYWdlbnQuZnVuZGVyID0gdGhpcy5mdW5kZXJcbiAgICAgIGFnZW50LnNlbmRlciA9IHRoaXMuc2VuZGVyXG4gICAgICByZXR1cm4gYWdlbnRcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWdlbnRcbi8qKlxuXG5Qcm90b2NvbHNcbi0tLS0tLS0tLVxuXG5XZSBub3cgZGVzY3JpYmUgdGhlIHByb3RvY29sIHRoYXQgdGhlIHBhcnRpZXMgdXNlIHRvIGNvbnN0cnVjdCB0aGUgdHJhbnNhY3Rpb25zXG5zaG93biBhYm92ZS5cblxuIyMjIExvY2FsIGluaXRpYWxpemF0aW9uIChhc3luY0luaXRpYWxpemUpXG5cbioqMS4gTG9jYWwgaW5pdGlhbGl6YXRpb24gLioqIEJvdGggYWdlbnRzIGluaXRpYWxpemUgdGhlIGZvbGxvd2luZ1xuLSB0aGVpciBsb2NhbCBhZGRyZXNzZXMgKHNvdXJjZSwgZGVzdGluYXRpb24pXG4tIGEgaHRsYyBhbmQgcmV2b2NhdGlvbiBzZWNyZXQgdG8gYmUgdXNlZCBpbiB0aGUgZmlyc3QgcGF5bWVudFxuLSB0aGUgc2hhcmVkIG11bHRpc2lnIG9iamVjdCBpcyBpbml0aWFsaXplZCwgYnV0IHRoZSBhZGRyZXNzIGhhcyBub3QgYmVlblxuICBnZW5lcmF0ZWQgeWV0LlxuXG4jIyMgT3BlbmluZyB0aGUgY2hhbm5lbCAoYXN5bmNPcGVuQ2hhbm5lbClcblxuQXMgdGhlcmUgYXJlIGluaGVyZW50IG1hbGxlYWJpbGl0eSBwcm9ibGVtcyBpZiB0d28gcGFydGllcyBmdW5kIGEgcGF5bWVudFxuY2hhbm5lbC4gVG8gYXZvaWQgdGhpcyBwcm9ibGVtIHdlIHVzZSBhIHZlcnNpb24gd2hlcmUgb25seSBBbGljZSBmdW5kcyB0aGVcbmNoYW5uZWwuXG5cbioqMS4gQWxpY2UgYW5kIEJvYiBleGNoYW5nZSB0aGVpciBwdWJsaWMgcHJvamVjdGlvbnMgKGluaXRpYWxpemVPdGhlcikuKiogVGhpc1xuYWxsb3dzIHRoZW0gdG8gYnVpbGQgYSBzaGFyZWQgbXVsdGlzaWcgYWRkcmVzcyBhbmQgdG8ga25vdyB0aGUgcHVibGljIHZlcnNpb25zXG5vZiB0aGUgb3RoZXIgYWdlbnRzIGh0bGMgYW5kIHJldm9jYXRpb24gc2VjcmV0LiBBZnRlciB0aGlzIHN0ZXAgdGhlIGZvbGxvd2luZ1xuaXMgaW5pdGlhbGl6ZWRcblxuKioyLiBBbGljZSBhbmQgQm9iIGJ1aWxkIHRoZSBzaGFyZWQgbXVsdGlzaWcgKGFzeW5jSW5pdGlhbGl6ZU11bHRpc2lnKS4qKiBOb3dcbnRoYXQgdGhleSBoYXZlIGV4Y2hhbmdlZCBwdWJsaWMga2V5cyBmb3IgdGhlIG11bHRpc2lnIGFkZHJlc3MsIHRoZXkgY2FuIGJvdGhcbmJ1aWxkIGl0LlxuXG4qKjMuIFRoZSBmdW5kZXIgKEFsaWNlKSBidWlsZHMgYSBmdW5kaW5nIHRyYW5zYWN0aW9uLioqIFRoZSBhZ2VudCB0aGF0IGZ1bmRzXG50aGUgY2hhbm5lbCBjcmVhdGVzIHRoZSBmdW5kaW5nIHRyYW5zYWN0aW9uIHRoYXQgc3BlbmRzIHRvIHRoZSBzaGFyZWQgbXVsdGlzaWdcbmFkZHJlc3MuIFNoZSBkb2VzIG5vdCBicm9hZGNhc3QgaXQgeWV0LiBTaGUgdGhlbiBzZW5kcyB0aGUgZnVuZGluZyBhbW91bnQgYW5kXG5mdW5kaW5nIHRyYW5zYWN0aW9uIGhhc2ggdG8gQm9iLlxuXG4qKjQuIEJvYiBidWlsZHMgYW5kIHNpZ25zIGEgcmVmdW5kIHRyYW5zYWN0aW9uLCBzZW5kcyBpdCB0byBBbGljZS4qKiBBbGljZSBhbmRcbkJvYiBnbyB0aHJvdWdoIHRoZSBwcm90b2NvbCBkZXNjcmliZWQgYmVsb3cgZm9yIGNyZWF0aW5nIGEgcGF5bWVudCwgaW4gdGhlIGNhc2VcbndoZXJlIEJvYiBzZW5kcyBhIHBheW1lbnQgdG8gQWxpY2UuIFRoZSBwYXltZW50IHNwZW5kcyBhbGwgZnVuZHMgZnJvbSB0aGVcbmZ1bmRpbmcgdHJhbnNhY3Rpb24gdG8gQWxpY2UuXG5cbioqNS4gQWxpY2UgYnJvYWRjYXN0cyB0aGUgZnVuZGluZyB0cmFuc2FjdGlvbi4qKiBXaGVuIHRoZSByZWZ1bmQgdHJhbnNhY3Rpb24gaXNcbmNyZWF0ZWQgYW5kIGRpc3RyaWJ1dGVkIGJldHdlZW4gdGhlIHR3byBwYXJ0aWVzLCBBbGljZSBicm9hZGNhc3RzIHRoZSBmdW5kaW5nXG50cmFuc2FjdGlvbi4gVGhlIGNoYW5uZWwgaXMgb3BlbiB3aGVuIHRoZSBmdW5kaW5nIHRyYW5zYWN0aW9uIGlzIGNvbmZpcm1lZCBpbnRvXG50aGUgYmxvY2tjaGFpbi5cblxuQXQgdGhlIGVuZCBvZiB0aGUgY2hhbm5lbCBvcGVuaW5nIHByb2Nlc3MsIGJvdGggYWdlbnRzIHN0b3JlIHRoZSBmb2xsb3dpbmdcbmluZm9ybWF0aW9uOlxuXG4tIHRocmVlIGFkZHJlc3NlcyAoc291cmNlLCBkZXN0aW5hdGlvbiwgbXVsdGlzaWcpXG4tIGEgbGlzdCBvZiBjb21taXRtZW50IHRyYW5zYWN0aW9ucyBvYmplY3RzLiBUaGUgbGlzdCBoYXMgb25lIGVudHJ5IHRoYXRcbiAgY29udGFpbnMgdGhlIHNlY3JldHMgdXNlZCBmb3IgdGhlIGZpcnN0IHBheW1lbnRcbi0gdGhlIHB1YmxpYyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3RoZXIgY2xpZW50OyB0aGlzIGFsc28gY29udGFpbnMgYSBsaXN0IG9mXG4gIGNvbW1pdG1lbnQgdHJhbnNhY3Rpb24gb2JqZWN0cyB3aXRoIG9uZSBlbnRyeSBjb250YWluaW5nIHRoZSBwdWJsaWNcbiAgcHJvamVjdGlvbnMgKGhhaGVzKSBvZiB0d28gc2VjcmV0cy5cblxuIyMjIENyZWF0aW5nIHRoZSBwYXltZW50IChhc3luY1NlbmQpXG5cbldlIGRlc2NyaWJlIGEgcGF5bWVudCBmcm9tIEFsaWNlIHRvIEJvYi4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdFxucGF5bWVudCwgQWxpY2UgaGFzIHRoZSBoYXNoIG9mIEJvYidzIGxhc3QgcmV2b2NhdGlvbiBzZWNyZXQsIGFuZCB0aGUgaGFzaCBvZlxuQm9iJ3MgbGFzdCBIVExDIHNlY3JldC4gSWYgdGhpcyBpcyB0aGUgZmlyc3QgcGF5bWVudCwgcmV2b2tpbmcgaXNuJ3QgbmVjZXNzYXJ5XG5hbmQgdGhlc2Ugc2VjcmV0cyBhcmUgbm90IG5lZWRlZC5cblxuKioxLiBBbGljZSBidWlsZHMgYSBjb21taXRtZW50IHRyYW5zYWN0aW9uIGZvciBCb2IsIHN0b3JlcyBpdCwgYW5kIGFza3MgaGltIHRvXG5kbyB0aGUgc2FtZSAoYXN5bmNTZW5kKS4qKiBBbGljZSBidWlsZHMgdGhlIHRyYW5zYWN0aW9uIGxhYmVsZWQgXCJrbm93biBvbmx5IHRvXG5Cb2JcIiBhYm92ZS4gU2hlIHRoZW4gYXNrcyBCb2IgdG8gYnVpbGQgb25lIGZvciBoZXIuPCEtLVNoZSB1c2VzIHRoZSBwdWJsaWNcbnZlcnNpb25zIG9mIHRoZSBzZWNyZXRzIG9idGFpbmVkIGZyb20gQm9iIGluIHN0ZXAgMiBhbmQgaGVyIG93biBzZWNyZXRzXG5nZW5lcmF0ZWQgaW4gU3RlcCAxLiBTaGUgc2lnbnMgdGhlIHRyYW5zYWN0aW9uIGFuZCBzZW5kcyBpdCB0byBCb2IuLS0+XG5cbioqMi4gQm9iIGJ1aWxkcyBhIGNvbW1pdG1lbnQgdHJhbnNhY3Rpb24gZm9yIEFsaWNlLCBzdG9yZXMgaXQsIGFuZCBzZW5kcyBpdCB0b1xuQWxpY2UgKGFzeW5jU2VuZCkuKipcblxuKiozLiBBbGljZSBjaGVja3MgdGhlIG5ldyBjb21taXRtZW50IHRyYW5zYWN0aW9uLCBzdG9yZXMgaXQsIGFuZCBzZW5kcyB0aGVcbnRyYW5zYWN0aW9uIGJ1aWx0IGluIHN0ZXAgMSB0byBCb2IgKGFzeW5jU2VuZFR4YikuKipcblxuKio0LiBCb2IgY2hlY2tzIHRoZSBuZXcgY29tbWl0bWVudCB0cmFuc2FjdGlvbiwgc3RvcmVzIGl0LCBhbmQgcmV2b2tlcyB0aGUgb2xkXG5jb21taXRtZW50IHRyYW5zYWN0aW9uIChhc3luY1NlbmRUeGIpLioqXG5cbioqNS4gQWxpY2UgY2hlY2tzIHRoZSByZXZvY2F0aW9uIHNlY3JldCwgc3RvcmVzIGl0LCBnZW5lcmF0ZXMgbmV3IHNlY3JldHMsIGFuZFxucmV2b2tlcyB0aGUgb2xkIGNvbW1pdG1lbnQgdHJhbnNhY3Rpb24gKGFzeW5jUHJlcGFyZU5leHRQYXltZW50KS4qKlxuXG4qKjYuIEJvYiBjaGVja3MgdGhlIHJldm9jYXRpb24gc2VjcmV0LCBzdG9yZXMgaXQsIGdlbmVyYXRlcyBuZXcgc2VjcmV0cyBmb3IgdGhlXG5uZXh0IHBheW1lbnQuKipcblxuPCEtLVxuKio0LiBBbGljZSBjaGVja3MgdGhlIHRyYW5zYWN0aW9uLCBidWlsZHMgb25lIGZvciBBbGljZSBhbmQgc2VuZHMgaXQgdG8gaGVyLioqXG5Cb2IgY2hlY2tzIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHNwZW5kcyBmcm9tIHRoZSBzaGFyZWQgbXVsdGlzaWcgYWRkcmVzcywgc3BlbmRzXG50byBoaXMgZGVzdGluYXRpb24gYWRkcmVzcywgdGhhdCB0aGUgc2VjcmV0cyB1c2VkIGFyZSB0aGUgb25lcyBoZSBnZW5lcmF0ZWQgaW5cblN0ZXAgMiwgYW5kIHRoYXQgdGhlIHNwZW5kaW5nIGFtb3VudHMgYXJlIGFzIGV4cGVjdGVkLiBJZiB0aGUgdGVzdCBwYXNzZXMsIGhlXG5idWlsZHMgdGhlIHRyYW5zYWN0aW9uIGxhYmVsbGVkIFwia25vd24gb25seSB0byBBbGljZVwiIGFuZCBzZW5kcyBpdCB0byBoZXIgKHRoaXNcbmlzIHN5bW1ldHJpYyB0byBjYXNlIDMuKS5cblxuKio1LiBBbGljZSBjaGVja3MgdGhlIHRyYW5zYWN0aW9uIG9idGFpbmVkIGZyb20gQm9iLCBhbmQgcmV2b2tlcyBoZXIgbGFzdFxucGF5bWVudCBpZiB0aGUgY2hlY2sgcGFzc2VzLioqIFRvIHJldm9rZSB0aGUgcHJldmlvdXMgcGF5bWVudCwgQWxpY2Ugc2VuZHMgaGVyXG5yZXZvY2F0aW9uIHNlY3JldCBmcm9tIHRoZSBsYXN0IGNvbW1pdG1lbnQgdHJhbnNhY3Rpb24gdG8gQm9iLlxuXG4qKjYuIEJvYiByZXZva2VzLioqIFN5bW1ldHJpY2FsbHksIEJvYiBzZW5kcyBBbGljZSBoaXMgcmV2b2NhdGlvbiBzZWNyZXQgZnJvbVxudGhlIGxhc3QgY29tbWl0bWVudCB0cmFuc2FjdGlvbi5cblxuKioxLiBBbGljZSBnZW5lcmF0ZXMgbmV3IHNlY3JldHMgYW5kIHNlbmRzIHRoZW0gdG8gQm9iLioqIFNoZSBsb2NhbGx5IGNyZWF0ZXMgYVxucmV2b2NhdGlvbiBzZWNyZXQgYW5kIGEgaHRsYyBzZWNyZXQgZm9yIHVzZSBvbiB0aGUgbmV4dCB0cmFuc2FjdGlvbi4gU2hlIHRoZW5cbnNlbmRzIHRoZSBwdWJsaWMgdmVyc2lvbnMgKGhhc2hlcykgb2YgdGhlc2Ugc2VjcmV0cyB0byBCb2IuXG5cbioqMi4gQm9iIGdlbmVyYXRlcyBhIG5ldyBzZWNyZXRzIGFuZCBzZW5kcyB0aGVtIHRvIEFsaWNlLioqIFRoaXMgaXMgc3ltbWV0cmljXG50byB0aGUgY2FzZSBhYm92ZVxuLS0+XG4jIyMgQ2xvc2luZyB0aGUgY2hhbm5lbFxuXG5FaXRoZXIgcGFydHkgY2FuIGJyb2FkY2FzdCB0aGVpciBtb3N0IHJlY2VudCBjb21taXRtZW50IHRyYW5zYWN0aW9uIHRvIHRoZVxuYmxvY2tjaGFpbi4gSW4gdGhpcyBjYXNlIGJvdGggcGFydGllcyBnbyB0aHJvdWdoIHRoZSBmb2xsb3dpbmcgcHJvdG9jb2xcblxuKioxLiBGaW5kIHRoZSBtb3N0IHJlY2VudCBIVExDIHNlY3JldC4qKlxuXG4qKjIuIEJ1aWxkIGEgc3BlbmRpbmcgdHJhbnNhY3Rpb24uKipcblxuKiozLiBCcm9hZGNhc3Qgc3BlbmRpbmcgdHJhbnNhY3Rpb24gYW5kIHRoZSBtb3N0IHJlY2VudCBjb21taXRtZW50XG50cmFuc2FjdGlvbi4qKlxuXG5UaGUgcGFydHkgdGhhdCBicm9hZGNhc3RzIHRoZSBjb21taXRtZW50IHRyYW5zYWN0aW9uIG11c3Qgd2FpdCBmb3IgYSBkYXkgdG8gZG9cbnRoYXQsIHRoZSBvdGhlciBwYXJ0eSBjYW4gZG8gc28gYXMgc29vbiBhcyBwb3NzaWJsZS5cblxuIyMjIEVuZm9yY2luZyB0aGUgSFRMQ1xuXG5JbiBjYXNlIG9uZSBwYXJ0eSBmYWlscyB0byBzcGVuZCBhbiBvdXRwdXQgYnkgcHJvdmlkaW5nIHRoZSBIVExDIHNlY3JldCwgdGhlXG5vdGhlciBwYXJ0eSBjYW4gc3BlbmQgdGhlIEhUTEMgb3V0cHV0IGFmdGVyIDIgZGF5cy5cblxuKioxLiBCdWlsZCBzcGVuZGluZyB0cmFuc2FjdGlvbiB1c2luZyBzcGVuZGluZyBrZXkuKipcblxuKiozLiBCcm9hZGNhc3Qgc3BlbmRpbmcgdHJhbnNhY3Rpb24gYW5kIHRoZSBtb3N0IHJlY2VudCBjb21taXRtZW50XG50cmFuc2FjdGlvbi4qKlxuXG4jIyMgUmVhY3QgdG8gb3RoZXIgYWdlbnQgYnJvYWRjYXN0aW5nIGFuIG9sZCBjb21taXRtZW50IHRyYW5zYWN0aW9uXG5cbkluIHRoYXQgY2FzZSBvbmUgcGFydHkgYnJvYWRjYXN0cyBhbiBvbGQgY29tbWl0bWVudCB0cmFuc2FjdGlvbixcbnRoZSBvdGhlciBwYXJ0eSBnb2VzIHRyb3VnaCB0aGUgZm9sbG93aW5nOlxuXG4qKjEuIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgSFRMQyBzZWNyZXQuKipcblxuKioyLiBDcmVhdGUgYW4gb3V0cHV0IHNjcmlwdCB0aGF0IHNwZW5kcyB0aGUgSFRMQyBvdXRwdXQuKipcblxuKiozLiBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIHJldm9jYXRpb24gc2VjcmV0LioqXG5cbioqNC4gQ3JlYXRlIGFuIG91dHB1dCBzY3JpcHQgdGhhdCBzcGVuZHMgdGhlIHJldm9jYXRpb24gb3V0cHV0LioqXG5cbioqNS4gQnVpbGQgYSB0cmFuc2FjdGlvbiB0aGF0IHNwZW5kcyBib3RoIG91dHB1dHMuKipcblxuVGhpcyBoYXMgdG8gaGFwcGVuIHdpdGhpbiBvbmUgZGF5LCBpbiBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgcmV2b2NhdGlvblxub3V0cHV0IGNhbiBiZSBzcGVudC5cblxuKiovXG4iLCIvLyBUT0RPOiBBbGwgY2hhbm5lbCBwcm9wZXJ0aWVzIG5lZWQgdG8gYmUgc2F2ZWQgaW4gYSBkYXRhYmFzZSwgbm90IGluIG1lbW9yeSxcbi8vIHNvIHRoYXQgdGhlIHN0YXRlIGlzIGNvbnNpc3RlbnQgYWNyb3NzIHRhYnMgYW5kIGNhbiBiZSBzeW5jZWQgYWNyb3NzXG4vLyBkZXZpY2VzLlxuJ3VzZSBzdHJpY3QnXG5sZXQgU3RydWN0ID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvc3RydWN0JylcbmxldCBNc2dVcGRhdGUgPSByZXF1aXJlKCcuL21zZ3MvbXNnLXVwZGF0ZScpXG5sZXQgU2VjcmV0ID0gcmVxdWlyZSgnLi9zY3J0cy9zZWNyZXQnKVxubGV0IFJhbmRvbSA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3JhbmRvbScpXG5sZXQgU2NyaXB0ID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvc2NyaXB0JylcbmxldCBBZGRyZXNzID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvYWRkcmVzcycpXG5sZXQgS2V5UGFpciA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL2tleS1wYWlyJylcbmxldCBCbiA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL2JuJylcbmxldCBPdXRwdXQgPSByZXF1aXJlKCcuLi9saWIvb3V0cHV0JylcbmxldCBTcGVuZGluZyA9IHJlcXVpcmUoJy4uL2xpYi90eHMvc3BlbmRpbmcuanMnKVxubGV0IENvbW1pdG1lbnQgPSByZXF1aXJlKCcuLi9saWIvdHhzL2NvbW1pdG1lbnQnKVxubGV0IFR4T3V0ID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvdHgtb3V0JylcbmxldCBNc2dTZWNyZXRzID0gcmVxdWlyZSgnLi9tc2dzL21zZy1zZWNyZXRzJylcbmxldCBhc2luayA9IHJlcXVpcmUoJ2FzaW5rJylcblxuY2xhc3MgQ2hhbm5lbCBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yIChcbiAgICBmdW5kaW5nQW1vdW50LFxuICAgIG15WFBydixcbiAgICB0aGVpclhQdWIsXG4gICAgY2hhblBhdGgsXG4gICAgbXlDaGFuWFBydixcbiAgICB0aGVpckNoYW5YUHViLFxuICAgIG15SWQsXG4gICAgdGhlaXJJZCxcbiAgICBzdGF0ZSA9IENoYW5uZWwuU1RBVEVfSU5JVElBTCxcbiAgICBtdWx0aVNpZ1NjcmlwdCxcbiAgICBtdWx0aVNpZ0FkZHIsXG4gICAgaWQsXG4gICAgc2VjcmV0TWFwID0gbmV3IE1hcCgpLFxuICAgIGZ1bmRlciA9IGZhbHNlLFxuICAgIGZ1bmRpbmdUeCxcbiAgICBmdW5kaW5nVHhIYXNoLFxuICAgIGZ1bmRlZCA9IGZhbHNlLFxuICAgIG15Q29tbWl0bWVudHMgPSBbXSxcbiAgICB0aGVpckNvbW1pdG1lbnRzID0gW10sXG4gICAgZXJyU3RyID0gJydcbiAgKSB7XG4gICAgc3VwZXIoe1xuICAgICAgZnVuZGluZ0Ftb3VudCxcbiAgICAgIG15WFBydixcbiAgICAgIHRoZWlyWFB1YixcbiAgICAgIGNoYW5QYXRoLFxuICAgICAgbXlDaGFuWFBydixcbiAgICAgIHRoZWlyQ2hhblhQdWIsXG4gICAgICBteUlkLFxuICAgICAgdGhlaXJJZCxcbiAgICAgIHN0YXRlLFxuICAgICAgbXVsdGlTaWdTY3JpcHQsXG4gICAgICBtdWx0aVNpZ0FkZHIsXG4gICAgICBpZCxcbiAgICAgIHNlY3JldE1hcCxcbiAgICAgIGZ1bmRlcixcbiAgICAgIGZ1bmRpbmdUeCxcbiAgICAgIGZ1bmRpbmdUeEhhc2gsXG4gICAgICBmdW5kZWQsXG4gICAgICBteUNvbW1pdG1lbnRzLFxuICAgICAgdGhlaXJDb21taXRtZW50cyxcbiAgICAgIGVyclN0clxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNoYW5uZWwgYnkgZGVyaXZpbmcgdGhlIGNoYW5uZWwga2V5cyBhbmQgaWQncyBhbmQgYnlcbiAgICogYnVpbGRpbmcgYW5kIHN0b3JpbmcgdGhlIG11bHRpc2lnIGFkZHJlc3NcbiAgICovXG4gIGFzeW5jSW5pdGlhbGl6ZSAoKSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgaWYgKCF0aGlzLmNoYW5QYXRoKSB7XG4gICAgICAgIHRoaXMucmFuZG9tQ2hhblBhdGgoKVxuICAgICAgfVxuICAgICAgdGhpcy5teUNoYW5YUHJ2ID0geWllbGQgdGhpcy5teVhQcnYuYXN5bmNEZXJpdmUodGhpcy5jaGFuUGF0aClcbiAgICAgIHRoaXMudGhlaXJDaGFuWFB1YiA9IHlpZWxkIHRoaXMudGhlaXJYUHViLmFzeW5jRGVyaXZlKHRoaXMuY2hhblBhdGgpXG4gICAgICB0aGlzLm15SWQgPSB5aWVsZCB0aGlzLm15WFBydi50b1B1YmxpYygpLmFzeW5jVG9TdHJpbmcoKVxuICAgICAgdGhpcy50aGVpcklkID0geWllbGQgdGhpcy50aGVpclhQdWIuYXN5bmNUb1N0cmluZygpXG4gICAgICByZXR1cm4gdGhpcy5hc3luY0J1aWxkTXVsdGlTaWdBZGRyKClcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gMCBhbmQgMHg3ZmZmZmZmZlxuICAgKi9cbiAgc3RhdGljIHJhbmRvbUluZGV4ICgpIHtcbiAgICAvLyBub24taGFyZGVuZWQgYmlwIDMyIHBhdGggaW5kaWNlcyBjYW4gYmUgYW55IDMxIGJpdCBpbnRlZ2VyLiAodGhlIDMybmRcbiAgICAvLyBiaXQgaXMgdXNlZCB0byBzcGVjaWZ5IHRoZSBoYXJkZW5pbmcsIHdoaWNoIGlzIG5vdCB1c2VkIGhlcmUpLlxuICAgIHJldHVybiBSYW5kb20uZ2V0UmFuZG9tQnVmZmVyKDQpLnJlYWRJbnQzMkJFKDApICYgMHg3ZmZmZmZmZlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHJhbmRvbSBjaGFubmVsIHBhdGhcbiAgICovXG4gIHN0YXRpYyByYW5kb21DaGFuUGF0aCAoKSB7XG4gICAgbGV0IHggPSBDaGFubmVsLnJhbmRvbUluZGV4KClcbiAgICBsZXQgeSA9IENoYW5uZWwucmFuZG9tSW5kZXgoKVxuICAgIHJldHVybiBgbS8ke3h9LyR7eX1gXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNoYW5uZWwgcGF0aCB0byBhIHJhbmRvbSBvbmVcbiAgICovXG4gIHJhbmRvbUNoYW5QYXRoICgpIHtcbiAgICB0aGlzLmNoYW5QYXRoID0gQ2hhbm5lbC5yYW5kb21DaGFuUGF0aCgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIG11bHRpc2lnIGFkZHJlc3MgZnJvbSB0aGUgYWdlbnRzIHB1YmxpYyBrZXlzXG4gICAqL1xuICBhc3luY0J1aWxkTXVsdGlTaWdBZGRyICgpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBsZXQgcHViS2V5MSA9IHRoaXMubXlDaGFuWFBydi5wdWJLZXlcbiAgICAgIGxldCBwdWJLZXkyID0gdGhpcy50aGVpckNoYW5YUHViLnB1YktleVxuICAgICAgbGV0IHNjcmlwdCA9IFNjcmlwdC5mcm9tUHViS2V5cygyLCBbcHViS2V5MSwgcHViS2V5Ml0pXG4gICAgICB0aGlzLm11bHRpU2lnU2NyaXB0ID0gc2NyaXB0XG4gICAgICB0aGlzLm11bHRpU2lnQWRkciA9IHlpZWxkIEFkZHJlc3MuYXN5bmNGcm9tUmVkZWVtU2NyaXB0KHRoaXMubXVsdGlTaWdTY3JpcHQpXG4gICAgICB0aGlzLmlkID0geWllbGQgdGhpcy5tdWx0aVNpZ0FkZHIuYXN5bmNUb1N0cmluZygpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2hhbm5lbCBpZCwgd2hpY2ggaXMgdGhlIG11bHRpc2lnIGFkZHJlc3NcbiAgICovXG4gIGFzeW5jR2V0SWQgKCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpU2lnQWRkci5hc3luY1RvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBuZXcgc2VjcmV0IGFuZCBzdG9yZXMgaXQgaW4gdGhpcy5zZWNyZXRNYXBcbiAgICovXG4gIGFzeW5jTmV3U2VjcmV0ICgpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBsZXQgc2VjcmV0ID0gbmV3IFNlY3JldCgpXG4gICAgICB5aWVsZCBzZWNyZXQuYXN5bmNJbml0aWFsaXplKClcbiAgICAgIHRoaXMuc2VjcmV0TWFwLnNldChzZWNyZXQuaGFzaC50b1N0cmluZygnaGV4JyksIHNlY3JldC5idWYpXG4gICAgICByZXR1cm4gc2VjcmV0XG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmUtaW1hZ2Ugb2YgYSBzdG9yZWQgc2VjcmV0XG4gICAqL1xuICBnZXRTZWNyZXQgKGhhc2gpIHtcbiAgICByZXR1cm4gdGhpcy5zZWNyZXRNYXAuZ2V0KGhhc2gudG9TdHJpbmcoJ2hleCcpKVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIGEgY2hhbm5lbC4gU2V0cyB0aGUgZnVuZGluZyB0eCBhbmQgcmV0dXJucyB0aGUgXCJ1cGRhdGVcIiBtZXNzYWdlXG4gICAqIGZvciB0aGUgcmVmdW5kIHR4LlxuICAgKi9cbiAgYXN5bmNPcGVuIChmdW5kaW5nVHgsIGNoYW5uZWxTb3VyY2VJbmRleCA9IENoYW5uZWwucmFuZG9tSW5kZXgoKSwgY2hhbm5lbERlc3RJbmRleCA9IENoYW5uZWwucmFuZG9tSW5kZXgoKSkge1xuICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgIHRoaXMuZnVuZGVyID0gdHJ1ZVxuICAgICAgdGhpcy5mdW5kaW5nVHggPSBmdW5kaW5nVHggLy8gVE9ETzogVmFsaWRhdGUgdGhhdCBmdW5kaW5nIHR4IHNwZW5kcyB0byBtdWx0aXNpZ1xuICAgICAgdGhpcy5mdW5kaW5nVHhIYXNoID0geWllbGQgZnVuZGluZ1R4LmFzeW5jSGFzaCgpXG4gICAgICBsZXQgcmV2U2VjcmV0ID0geWllbGQgdGhpcy5hc3luY05ld1NlY3JldCgpXG4gICAgICBsZXQgb3V0cHV0ID0gbmV3IE91dHB1dCgpLmZyb21PYmplY3Qoe1xuICAgICAgICBraW5kOiAncHViS2V5JyxcbiAgICAgICAgbmV0d29ya1NvdXJjZUlkOiB0aGlzLnRoZWlySWQsXG4gICAgICAgIGNoYW5uZWxTb3VyY2VJZDogdGhpcy50aGVpcklkLFxuICAgICAgICBjaGFubmVsRGVzdElkOiB0aGlzLm15SWQsXG4gICAgICAgIG5ldHdvcmtEZXN0SWQ6IHRoaXMubXlJZCxcbiAgICAgICAgY2hhbm5lbFNvdXJjZVBhdGg6IGBtLzAvJHtjaGFubmVsU291cmNlSW5kZXh9YCxcbiAgICAgICAgY2hhbm5lbERlc3RQYXRoOiBgbS8wLyR7Y2hhbm5lbERlc3RJbmRleH1gLFxuICAgICAgICAvLyBodGxjU2VjcmV0LCAvLyBOb3QgdXNlZCBpbiByZWZ1bmQgdHhcbiAgICAgICAgcmV2U2VjcmV0OiByZXZTZWNyZXQudG9QdWJsaWMoKVxuICAgICAgICAvLyBhbW91bnQgLy8gTGVmdCB1bmRlZmluZWQgYmVjYXVzZSB0aGlzIGlzIHRoZSBjaGFuZ2Ugb3V0cHV0XG4gICAgICB9KVxuICAgICAgbGV0IG91dHB1dHMgPSBbb3V0cHV0XVxuICAgICAgcmV0dXJuIHRoaXMuYXN5bmNVcGRhdGUob3V0cHV0cylcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGZ1bmRpbmcgdHJhbnNhY3Rpb24gaXMgY29uZmlybWVkIG9uIHRoZSBibG9ja2NoYWluLCBjYWxsIHRoaXNcbiAgICogbWV0aG9kLlxuICAgKi9cbiAgYXN5bmNDb25maXJtRnVuZGluZ1R4IChmdW5kaW5nVHgpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICB0aGlzLmZ1bmRpbmdUeCA9IGZ1bmRpbmdUeFxuICAgICAgdGhpcy5mdW5kaW5nVHhIYXNoID0geWllbGQgZnVuZGluZ1R4LmFzeW5jSGFzaCgpXG4gICAgICB0aGlzLmZ1bmRlZCA9IHRydWVcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgY29tbWl0bWVudCB0cmFuc2FjdGlvbiBmb3IgYSBnaXZlbiBvdXRwdXQgZGVzY3JpcHRpb24gbGlzdFxuICAgKi9cbiAgYXN5bmNCdWlsZENvbW1pdG1lbnQgKG91dHB1dHMsIGZ1bmRpbmdUeEhhc2gsIGZ1bmRpbmdUeE91dCkge1xuICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgIGxldCBjb21taXRtZW50ID0gbmV3IENvbW1pdG1lbnQoKVxuICAgICAgY29tbWl0bWVudC5vdXRwdXRzID0gb3V0cHV0c1xuICAgICAgbGV0IHhQdWJzID0ge1xuICAgICAgICBbdGhpcy5teUlkXTogdGhpcy5teUNoYW5YUHJ2LnRvUHVibGljKCksXG4gICAgICAgIFt0aGlzLnRoZWlySWRdOiB0aGlzLnRoZWlyQ2hhblhQdWJcbiAgICAgIH1cbiAgICAgIGxldCBrZXlQYWlyID0gbmV3IEtleVBhaXIodGhpcy5teUNoYW5YUHJ2LnByaXZLZXksIHRoaXMubXlDaGFuWFBydi5wdWJLZXkpXG4gICAgICAvLyBUT0RPOiBjYW4gdGhpcyBiZSBhIGRlZmF1bHQgcGFyYW1ldGVyP1xuICAgICAgaWYgKGZ1bmRpbmdUeEhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmdW5kaW5nVHhIYXNoID0geWllbGQgdGhpcy5mdW5kaW5nVHguYXN5bmNIYXNoKClcbiAgICAgIH1cbiAgICAgIGZ1bmRpbmdUeE91dCA9IGZ1bmRpbmdUeE91dCB8fCB0aGlzLmZ1bmRpbmdUeC50eE91dHNbMF1cblxuICAgICAgcmV0dXJuIGNvbW1pdG1lbnQuYXN5bmNCdWlsZChmdW5kaW5nVHhIYXNoLCBmdW5kaW5nVHhPdXQsIHtzY3JpcHQ6IHRoaXMubXVsdGlTaWdTY3JpcHQsIGtleVBhaXJ9LCB0aGlzLm15SWQsIHhQdWJzKVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBhc3luY0J1aWxkU3BlbmRpbmcgKGFkZHJlc3MsIGNvbW1pdG1lbnQsIGNvbW1pdG1lbnRUeERlcHRoKSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgbGV0IHNwZW5kaW5nID0gbmV3IFNwZW5kaW5nKClcbiAgICAgIHlpZWxkIHNwZW5kaW5nLmFzeW5jQnVpbGQoXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgIHRoaXMubXlDaGFuWFBydixcbiAgICAgICAgdGhpcy5teUlkLFxuICAgICAgICBjb21taXRtZW50VHhEZXB0aCxcbiAgICAgICAgdGhpcy5zZWNyZXRNYXApIC8vIFRPRE86IGZpbHRlciBzZWNyZXRNYXAgdG9cbiAgICAgIHJldHVybiBzcGVuZGluZ1xuICAgIH0sIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFkZCBhbiBhZGRpdGlvbmFsIG91dHB1dCB0byB0aGUgb3V0cHV0IGRlc2NyaXB0aW9uIGxpc3RcbiAgICogUmV0dXJucyBhIG1lc3NhZ2Ugb2YgdHlwZSBcInVwZGF0ZVwiIHdpdGggYW4gY29tbWl0bWVudCB0eCBmb3IgdGhlIGxpc3QuXG4gICAqIEh0bGNTZWNyZXQgaXMgb3B0aW9uYWwuXG4gICAqL1xuICBhc3luY1BheSAoYW1vdW50LCBodGxjU2VjcmV0LCBwYXRoSW5kZXggPSBDaGFubmVsLnJhbmRvbUluZGV4KCkpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBsZXQgb3V0cHV0cyA9IHRoaXMubXlDb21taXRtZW50c1t0aGlzLm15Q29tbWl0bWVudHMubGVuZ3RoIC0gMV0ub3V0cHV0c1xuICAgICAgb3V0cHV0cyA9IG91dHB1dHMubWFwKChvdXRwdXQpID0+IG91dHB1dC5jbG9uZSgpKVxuICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCBsYXN0IG91dHB1dCBzcGVuZHMgdG8gbWUgYW5kIGlzIGNoYW5nZSwgaS5lLlxuICAgICAgLy8gVE9ETzogY2hlY2sgc3VmZmljaWVudCBiYWxhbmNlXG4gICAgICBsZXQgcmV2U2VjcmV0ID0geWllbGQgdGhpcy5hc3luY05ld1NlY3JldCgpXG4gICAgICBsZXQgb3V0cHV0ID0gbmV3IE91dHB1dCgpLmZyb21PYmplY3Qoe1xuICAgICAgICBraW5kOiBodGxjU2VjcmV0ID8gJ2h0bGMnIDogJ3B1YktleScsXG4gICAgICAgIG5ldHdvcmtTb3VyY2VJZDogdGhpcy5teUlkLFxuICAgICAgICBjaGFubmVsU291cmNlSWQ6IHRoaXMubXlJZCxcbiAgICAgICAgY2hhbm5lbERlc3RJZDogdGhpcy50aGVpcklkLFxuICAgICAgICBuZXR3b3JrRGVzdElkOiB0aGlzLnRoZWlySWQsXG4gICAgICAgIGNoYW5uZWxTb3VyY2VQYXRoOiBgbS8wLyR7cGF0aEluZGV4fWAsXG4gICAgICAgIGNoYW5uZWxEZXN0UGF0aDogYG0vMC8ke3BhdGhJbmRleH1gLFxuICAgICAgICBodGxjU2VjcmV0OiBodGxjU2VjcmV0ID8gaHRsY1NlY3JldC50b1B1YmxpYygpIDogdW5kZWZpbmVkLFxuICAgICAgICByZXZTZWNyZXQ6IHJldlNlY3JldC50b1B1YmxpYygpLFxuICAgICAgICBhbW91bnQ6IGFtb3VudFxuICAgICAgfSlcbiAgICAgIG91dHB1dHMgPSB5aWVsZCB0aGlzLmFzeW5jQWRkT3V0cHV0KG91dHB1dCwgb3V0cHV0cylcbiAgICAgIG91dHB1dHMgPSB0aGlzLnJlZHVjZU91dHB1dHMob3V0cHV0cylcbiAgICAgIHJldHVybiB0aGlzLmFzeW5jVXBkYXRlKG91dHB1dHMpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb3V0cHV0IGRlc2NyaXB0aW9uIHRvIG91dHB1dGxpc3QgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBjaGFuZ2Ugb3V0cHV0XG4gICAqL1xuICBhc3luY0FkZE91dHB1dCAob3V0cHV0LCBvdXRwdXRzKSB7XG4gICAgb3V0cHV0cyA9IG91dHB1dHMubWFwKChvdXRwdXQpID0+IG91dHB1dC5jbG9uZSgpKVxuICAgIGxldCBjaGFuZ2UgPSBvdXRwdXRzLnBvcCgpXG4gICAgb3V0cHV0cy5wdXNoKG91dHB1dClcbiAgICBvdXRwdXRzLnB1c2goY2hhbmdlKVxuICAgIHJldHVybiBvdXRwdXRzXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2VzIG91dHB1dHMgd2hlbmV2ZXIgcG9zc2libGVcbiAgICovXG4gIHJlZHVjZU91dHB1dHMgKG91dHB1dHMpIHtcbiAgICByZXR1cm4gb3V0cHV0c1xuICAgIC8vIFRPRE86IGNhbGwgYXN5bmNSZWR1Y2VIdGxjT3V0cHV0IGFuZCByZWR1Y2VQdWJLZXlPdXRwdXRzIGhlcmVcbiAgfVxuXG4gIC8qXG4gICAqIFByZWxpbWluYXJ5IHZlcnNpb24gb2YgcmVkdWNlUHViS2V5T3V0cHV0cywgcmV0dXJucyBhbiBhcnJheSB3aGVyZSB0aGUgbGFzdFxuICAgKiBlbGVtZW50IGlzIGEgY2hhbmdlIG91dHB1dCAod2l0aCBhbiBhbW91bnQpXG4gICAqIFRPRE86IHNraXAgaHRsYyBvdXRwdXRzXG4gICAqL1xuICByZWR1Y2VQdWJLZXlPdXRwdXRzIChvdXRwdXRzKSB7XG4gICAgLy8gb3V0cHV0cyB3aWxsIGJlIGdyb3VwZWQgdG9nZXRoZXIgaWYgdGhleSBoYXZlIHRoZSBzYW1lIGtleSBkZWYgYmVsb3dcbiAgICAvLyBvdXRwdXRzIGluIHRoZSBzYW1lIGdyb3VwIHdpbGwgYmUgbWVyZ2VkIGZ1cnRoZXIgZG93biBiZWxvd1xuICAgIC8vIG5vdCBleGFjdGx5IHN1cmUgd2hlbiBleGFjdGx5IHR3byBvdXRwdXRzIGNhbiBiZSBtZXJnZWQsIHdlJ2xsIGhhdmUgdG8gYWRhcHQgdGhpc1xuICAgIHZhciBncm91cGVkID0ge31cbiAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgdmFyIGtleSA9IG91dHB1dC5raW5kICsgJzonICsgb3V0cHV0LmNoYW5uZWxTb3VyY2VJZCArICc6JyArIG91dHB1dC5jaGFubmVsRGVzdElkXG4gICAgICBpZiAoa2V5IGluIGdyb3VwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGdyb3VwZWRba2V5XSA9IFtdXG4gICAgICB9XG4gICAgICBncm91cGVkW2tleV0ucHVzaChvdXRwdXQpXG4gICAgfSlcblxuICAgIGxldCBhbW91bnRzLCBvdXRwdXRcbiAgICBsZXQgcmVkdWNlZCA9IFtdXG4gICAgZm9yICh2YXIga2V5IGluIGdyb3VwZWQpIHtcbiAgICAgIC8vIHN1bSB1cCB0aGUgYW1vdW50cyBmb3IgZWFjaCBncm91cFxuICAgICAgYW1vdW50cyA9IGdyb3VwZWRba2V5XS5tYXAoKGVsKSA9PiBlbC5hbW91bnQgPyBlbC5hbW91bnQgOiAnYm90dG9tJylcbiAgICAgIG91dHB1dCA9IGdyb3VwZWRba2V5XVswXVxuICAgICAgb3V0cHV0LmFtb3VudCA9IGFtb3VudHMucmVkdWNlKChhY2MsIGN1cikgPT4ge1xuICAgICAgICByZXR1cm4gYWNjICE9PSAnYm90dG9tJyAmJiBjdXIgIT09ICdib3R0b20nID8gYWNjLmFkZChjdXIpIDogJ2JvdHRvbSdcbiAgICAgIH0sIEJuKDApKVxuICAgICAgcmVkdWNlZC5wdXNoKG91dHB1dClcbiAgICB9XG5cbiAgICAvLyBzb3J0IHJlZHVjZWQgc28gdGhhdCB0aGUgbGFzdCBvdXRwdXQgaXMgdGhlIGNoYW5nZSBvdXRwdXRcbiAgICByZWR1Y2VkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIGNvbmNlcHR1YWx5IHdlIGNvbnNpZGVyIFwiYm90dG9tXCIgdG8gYmUgdGhlIGJpZ2dlciB0aGFuIGFsbCB2YWx1ZXMgaW4gQm4uXG4gICAgICAvLyB0aGlzIHdheSB0aGUgY2hhbmdlIG91dHB1dCB3aWxsIGFsd2F5cyBiZSBsYXN0XG4gICAgICBpZiAoYS5hbW91bnQgPT09ICdib3R0b20nICYmIGIuYW1vdW50ICE9PSAnYm90dG9tJykge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhLmFtb3VudCAhPT0gJ2JvdHRvbScgJiYgYi5hbW91bnQgPT09ICdib3R0b20nKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gZGVsZXRlIFwiYW1vdW50OiAnYm90dG9tJ1wiIGZyb20gdGhlIGxhc3Qgb3V0cHV0XG4gICAgZGVsZXRlIHJlZHVjZWRbcmVkdWNlZC5sZW5ndGggLSAxXS5hbW91bnRcbiAgICByZXR1cm4gcmVkdWNlZFxuICB9XG5cbiAgLypcbiAgICogUHJlbGltaW5hcnkgdmVyc2lvbiBvZiBhc3luY1JlZHVjZUh0bGNPdXRwdXQuIENoYW5nZXMgdGhlIGtpbmQgb2YgYW4gaHRsY1xuICAgKiBvdXRwdXQgdG8gcHViS2V5IGlmIGl0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBodGxjU2VjcmV0LlxuICAgKiBUT0RPOiBlaXRoZXIgY2FsbCByZWR1Y2VQdWJLZXlPdXRwdXRzIGF0IHRoZSBlbmQgb3IgbWFrZSBzdXJlIHRoYXQgaXQgaXNcbiAgICogYWx3YXlzIGNhbGxlZCBhZnRlciBhc3luY1JlZHVjZUh0bGNPdXRwdXQgKGVnIGluIHJlZHVjZU91dHB1dHMpXG4gICAqL1xuICBhc3luY1JlZHVjZUh0bGNPdXRwdXQgKG91dHB1dHMsIGh0bGNTZWNyZXQpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBpZiAoeWllbGQgaHRsY1NlY3JldC5hc3luY1N1cGVyQ2hlY2soKSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0cy5tYXAoZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICAgIGlmIChvdXRwdXQua2luZCA9PT0gJ2h0bGMnICYmIG91dHB1dC5odGxjU2VjcmV0LmJ1ZiA9PT0gaHRsY1NlY3JldC5idWYpIHtcbiAgICAgICAgICAgIG91dHB1dC5raW5kID0gJ3B1YktleSdcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgbmV3IFwidXBkYXRlXCIgbWVzc2FnZSBmb3IgYSBnaXZlbiBvdXRwdXQgZGVzY3JpcHRpb24gbGlzdC5cbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhY3RpdmF0ZSB0aGUgcHJvdG9jb2wgZm9yIGEgbmV3IHBheW1lbnQuXG4gICAqIFRPRE86IGNoZWNrIHRoYXQgY2hhbm5lbCBpcyBmdW5kZWQuXG4gICAqL1xuICBhc3luY1VwZGF0ZSAob3V0cHV0cykge1xuICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBDaGFubmVsLlNUQVRFX0lOSVRJQUwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBkYXRlIGR1cmluZyAke3RoaXMuc3RhdGV9IHN0YXRlYClcbiAgICAgIH1cbiAgICAgIGxldCBjb21taXRtZW50ID0geWllbGQgdGhpcy5hc3luY0J1aWxkQ29tbWl0bWVudChvdXRwdXRzKVxuICAgICAgdGhpcy50aGVpckNvbW1pdG1lbnRzLnB1c2goY29tbWl0bWVudClcblxuICAgICAgbGV0IG1zZyA9IG5ldyBNc2dVcGRhdGUoKVxuICAgICAgICAuc2V0Q2hhbklkKHRoaXMuaWQpXG4gICAgICAgIC5zZXRDaGFuUGF0aCh0aGlzLmNoYW5QYXRoKVxuICAgICAgICAuc2V0Q29tbWl0bWVudChjb21taXRtZW50KVxuICAgICAgICAuc2V0RnVuZGluZ0Ftb3VudCh0aGlzLmZ1bmRpbmdBbW91bnQpXG4gICAgICB0aGlzLnN0YXRlID0gQ2hhbm5lbC5TVEFURV9CVUlMVFxuICAgICAgcmV0dXJuIG1zZ1xuICAgIH0sIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBuZXcgbWVzc2FnZSBvZiB0eXBlIFwidXBkYXRlXCIgaXMgcmVjZWl2ZWQuIFNpZ25zIHRoZSB0eCBpbiB0aGVcbiAgICogbWVzc2FnZSwgc3RvcmVzIGl0IGluIG15Q29tbWl0bWVudHMuIFRoZW4gYnVpbGRzIGEgY29tbWl0bWVudCB0eCBmb3IgdGhlXG4gICAqIG90aGVyIGFnZW50LCBwYWNrcyBpdCBpbnRvIGEgbWVzc2FnZSBvZiB0eXBlIFwidXBkYXRlXCIgYW5kIHJldHVybnMgdGhpcyBtZXNzYWdlXG4gICAqL1xuICBhc3luY0hhbmRsZU1zZ1VwZGF0ZSAobXNnVXBkYXRlKSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IENoYW5uZWwuU1RBVEVfSU5JVElBTCkge1xuICAgICAgICAvLyBUT0RPOiBDaGVjayB2YWxpZGl0eVxuICAgICAgICB0aGlzLnN0YXRlID0gQ2hhbm5lbC5TVEFURV9CVUlMVF9BTkRfU1RPUkVEXG4gICAgICAgIGxldCBteUNvbW1pdG1lbnQgPSBtc2dVcGRhdGUuZ2V0Q29tbWl0bWVudCgpXG4gICAgICAgIGxldCBrZXlQYWlyID0gbmV3IEtleVBhaXIodGhpcy5teUNoYW5YUHJ2LnByaXZLZXksIHRoaXMubXlDaGFuWFBydi5wdWJLZXkpXG4gICAgICAgIGxldCBzY3JpcHQgPSB0aGlzLm11bHRpU2lnQWRkci50b1NjcmlwdCgpXG4gICAgICAgIGxldCB0eE91dCA9IFR4T3V0LmZyb21Qcm9wZXJ0aWVzKHRoaXMuZnVuZGluZ0Ftb3VudCwgc2NyaXB0KVxuICAgICAgICB5aWVsZCBteUNvbW1pdG1lbnQudHhiLmFzeW5jU2lnbigwLCBrZXlQYWlyLCB0eE91dClcbiAgICAgICAgdGhpcy5teUNvbW1pdG1lbnRzLnB1c2gobXlDb21taXRtZW50KVxuXG4gICAgICAgIGxldCBvdXRwdXRzID0gbXlDb21taXRtZW50Lm91dHB1dHMubWFwKChvdXRwdXQpID0+IE91dHB1dC5mcm9tSlNPTihvdXRwdXQudG9KU09OKCkpKVxuICAgICAgICB0aGlzLmZ1bmRpbmdUeEhhc2ggPSBteUNvbW1pdG1lbnQudHhiLnR4LnR4SW5zWzBdLnR4SGFzaEJ1ZlxuICAgICAgICBsZXQgZnVuZGluZ1R4T3V0ID0gVHhPdXQuZnJvbVByb3BlcnRpZXModGhpcy5mdW5kaW5nQW1vdW50LCB0aGlzLm11bHRpU2lnQWRkci50b1NjcmlwdCgpKVxuICAgICAgICBsZXQgdGhlaXJDb21taXRtZW50ID0geWllbGQgdGhpcy5hc3luY0J1aWxkQ29tbWl0bWVudChvdXRwdXRzLCB0aGlzLmZ1bmRpbmdUeEhhc2gsIGZ1bmRpbmdUeE91dClcbiAgICAgICAgdGhpcy50aGVpckNvbW1pdG1lbnRzLnB1c2godGhlaXJDb21taXRtZW50KVxuXG4gICAgICAgIGxldCBtc2cgPSBuZXcgTXNnVXBkYXRlKClcbiAgICAgICAgICAuc2V0Q2hhbklkKHRoaXMuaWQpXG4gICAgICAgICAgLnNldENoYW5QYXRoKHRoaXMuY2hhblBhdGgpXG4gICAgICAgICAgLnNldENvbW1pdG1lbnQodGhlaXJDb21taXRtZW50KVxuICAgICAgICAgIC5zZXRGdW5kaW5nQW1vdW50KHRoaXMuZnVuZGluZ0Ftb3VudClcbiAgICAgICAgcmV0dXJuIG1zZ1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDaGFubmVsLlNUQVRFX0JVSUxUKSB7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIHZhbGlkaXR5XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDaGFubmVsLlNUQVRFX1NUT1JFRFxuICAgICAgICB0aGlzLm15Q29tbWl0bWVudHMucHVzaChtc2dVcGRhdGUuZ2V0Q29tbWl0bWVudCgpKVxuICAgICAgICByZXR1cm4gdGhpcy5hc3luY0dldE1zZ1NlY3JldHMoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmNFcnJvcihgQ2Fubm90IHJlY2VpdmUgbXNnVXBkYXRlIGluICR7dGhpcy5zdGF0ZX0gc3RhdGVgKVxuICAgICAgfVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdHlwZSBcInNlY3JldFwiIGNvbnRhaW5pbmcgdGhlIHJldm9jYXRpb24gc2VjcmV0XG4gICAqL1xuICBhc3luY0dldE1zZ1NlY3JldHMgKCkge1xuICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgIC8vIFN1cHBvc2UgeW91IGhhdmUgMTAgY29tbWl0bWVudCB0eHMuXG4gICAgICAvLyBZb3UgZG9uJ3Qgd2FudCB0byByZXZva2UgdGhlIDEwdGggb25lLCBidXQgeW91IHdhbnQgdG8gcmV2b2tlIHRoZSA5dGggb25lLlxuICAgICAgLy8gR2V0IHJldm9jYXRpb24gaGFzaCBmcm9tIDl0aCBjb21taXRtZW50IHR4IG91dHB1dCBkZXNjcmlwdGlvbiBsaXN0LlxuICAgICAgbGV0IG1zZyA9IG5ldyBNc2dTZWNyZXRzKClcbiAgICAgICAgLnNldENoYW5JZCh0aGlzLmlkKVxuICAgICAgICAuc2V0Q2hhblBhdGgodGhpcy5jaGFuUGF0aClcbiAgICAgIGlmICh0aGlzLm15Q29tbWl0bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBsZXQgY29tbWl0bWVudCA9IHRoaXMubXlDb21taXRtZW50c1t0aGlzLm15Q29tbWl0bWVudHMubGVuZ3RoIC0gMl1cbiAgICAgICAgbGV0IG91dHB1dHMgPSBjb21taXRtZW50Lm91dHB1dHNcbiAgICAgICAgbGV0IHJldlNlY3JldHMgPSBbXVxuICAgICAgICBmb3IgKGxldCBpbmRleCBpbiBvdXRwdXRzKSB7XG4gICAgICAgICAgbGV0IHNlY3JldCA9IG91dHB1dHNbaW5kZXhdLnJldlNlY3JldFxuICAgICAgICAgIGxldCBidWYgPSB0aGlzLmdldFNlY3JldChzZWNyZXQuaGFzaClcbiAgICAgICAgICBpZiAoYnVmKSB7XG4gICAgICAgICAgICBzZWNyZXQuYnVmID0gYnVmXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldlNlY3JldHMucHVzaChzZWNyZXQpXG4gICAgICAgIH1cbiAgICAgICAgbXNnLnNldFNlY3JldHMocmV2U2VjcmV0cylcbiAgICAgIH1cbiAgICAgIHJldHVybiBtc2dcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgbmV3IG1lc3NhZ2Ugb2YgdHlwZSBcInNlY3JldFwiIGlzIHJlY2VpdmVkXG4gICAqL1xuICBhc3luY0hhbmRsZU1zZ1NlY3JldHMgKG1zZ1NlY3JldHMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ2hhbm5lbC5TVEFURV9CVUlMVF9BTkRfU1RPUkVEKSB7XG4gICAgICAvLyBUT0RPOiBDaGVjayB2YWxpZGl0eVxuICAgICAgdGhpcy5zdGF0ZSA9IENoYW5uZWwuU1RBVEVfSU5JVElBTFxuICAgICAgbGV0IHNlY3JldHMgPSBtc2dTZWNyZXRzLmdldFNlY3JldHMoKVxuICAgICAgaWYgKHRoaXMubXlDb21taXRtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHNldCBzZWNyZXRzIG9uIGNvbW1pdG1lbnRcbiAgICAgICAgbGV0IGNvbW1pdG1lbnQgPSB0aGlzLm15Q29tbWl0bWVudHNbdGhpcy5teUNvbW1pdG1lbnRzLmxlbmd0aCAtIDJdXG4gICAgICAgIGNvbW1pdG1lbnQub3V0cHV0cyA9IGNvbW1pdG1lbnQub3V0cHV0cy5tYXAoKG91dHB1dCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBvdXRwdXQucmV2U2VjcmV0LmJ1ZiA9IG91dHB1dC5yZXZTZWNyZXQuYnVmIHx8IHNlY3JldHNbaW5kZXhdLmJ1ZlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFzeW5jR2V0TXNnU2VjcmV0cygpXG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBDaGFubmVsLlNUQVRFX1NUT1JFRCkge1xuICAgICAgLy8gVE9ETzogQ2hlY2sgdmFsaWRpdHlcbiAgICAgIHRoaXMuc3RhdGUgPSBDaGFubmVsLlNUQVRFX0lOSVRJQUxcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmFzeW5jRXJyb3IoYENhbm5vdCByZWNlaXZlIG1zZ1NlY3JldCBpbiAke3RoaXMuc3RhdGV9IHN0YXRlYClcbiAgICB9XG4gIH1cblxuICBhc3luY0Vycm9yIChlcnJTdHIpIHtcbiAgICB0aGlzLnN0YXRlID0gQ2hhbm5lbC5TVEFURV9FUlJPUlxuICAgIHRoaXMuZXJyU3RyID0gZXJyU3RyXG4gICAgLy8gVE9ETzogV2hhdCBub3c/IENsb3NlIGNoYW5uZWw/XG4gIH1cbn1cblxuQ2hhbm5lbC5TVEFURV9JTklUSUFMID0gJ2luaXRpYWwnXG5DaGFubmVsLlNUQVRFX0VSUk9SID0gJ2Vycm9yJ1xuQ2hhbm5lbC5TVEFURV9CVUlMVF9BTkRfU1RPUkVEID0gJ2J1aWx0LWFuZC1zdG9yZWQnXG5DaGFubmVsLlNUQVRFX0JVSUxUID0gJ2J1aWx0J1xuQ2hhbm5lbC5TVEFURV9TVE9SRUQgPSAnc3RvcmVkJ1xuQ2hhbm5lbC5TVEFURV9DTE9TRUQgPSAnY2xvc2VkJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5uZWxcbiIsImxldCBCbiA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL2JuJylcblxuLy8gc2VlIGhlcmUgZm9yIGV4cGxhbmF0aW9uOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1OTU1MDkvaG93LWRvLXlvdS1zaGFyZS1jb25zdGFudHMtaW4tbm9kZWpzLW1vZHVsZXNcbmZ1bmN0aW9uIGRlZmluZSAobmFtZSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KVxufVxuXG5kZWZpbmUoJ0NTVl9ERUxBWScsIEJuKDEwMCkpXG4iLCIvKipcbiAqIE1zZ1NlY3JldHNcbiAqID09PT09PT09PT1cbiAqXG4gKiBXaGVuIGFuIGFnZW50IG5lZWRzIHRvIHJldmVhbCB0aGUgc2VjcmV0IGZvciBhIHBhcnRpY3VsYXIgaGFzaC4gVGhpcyB3b3Jrc1xuICogZWl0aGVyIGZvciBhbiBIVExDIHNlY3JldCBvciBhIHJldm9jYXRpb24gc2VjcmV0LlxuICovXG4ndXNlIHN0cmljdCdcbmxldCBTZWNyZXQgPSByZXF1aXJlKCcuLi9zY3J0cy9zZWNyZXQnKVxubGV0IE1zZyA9IHJlcXVpcmUoJy4vbXNnJylcblxuY2xhc3MgTXNnU2VjcmV0cyBleHRlbmRzIE1zZyB7XG4gIGNvbnN0cnVjdG9yIChhcmdzID0ge3NlY3JldHM6IFtdfSwgY2hhbklkKSB7XG4gICAgbGV0IGNtZCA9ICdzZWNyZXQnXG4gICAgc3VwZXIoY21kLCBhcmdzLCBjaGFuSWQpXG4gIH1cblxuICBzZXRTZWNyZXRzIChzZWNyZXRzKSB7XG4gICAgdGhpcy5hcmdzLnNlY3JldHMgPSBzZWNyZXRzLm1hcCgoc2VjcmV0KSA9PiBzZWNyZXQudG9KU09OKCkpXG4gIH1cblxuICBnZXRTZWNyZXRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnNlY3JldHMubWFwKChzZWNyZXQpID0+IG5ldyBTZWNyZXQoKS5mcm9tSlNPTihzZWNyZXQpKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTXNnU2VjcmV0c1xuIiwiLyoqXG4gKiBNc2dVcGRhdGVcbiAqID09PT09PT09PVxuICpcbiAqIE1lc3NhZ2UgdG8gdXBkYXRlIHRoZSBjb21taXRtZW50IHRyYW5zYWN0aW9uLiBXaGVuIGFuIGFnZW50IHdpc2hlcyB0byBtYWtlIGFcbiAqIHBheW1lbnQgb3IgdG8gdXBkYXRlIHRoZSBjb21taXRtZW50IHRyYW5zYWN0aW9uIGZvciBhbnkgb3RoZXIgcmVhc29uLCBzdWNoXG4gKiBhcyByZWR1Y2luZyB0aGUgb3V0cHV0IGxpc3Qgb3IgY2hhbmdpbmcgdGhlIGZlZSBhbW91bnQsIHRoZXkgc2VuZCBhblxuICogJ3VwZGF0ZScgbWVzc2FnZS4gIFdoZW4gYW4gYWdlbnQgc2VuZHMgYW4gdXBkYXRlIG1lc3NhZ2Ugd2l0aCBhIG5ld1xuICogY29tbWl0bWVudCB0eCwgdGhleSBleHBlY3QgdGhlIG90aGVyIHBhcnR5IHRvIGFsc28gc2VuZCBhbiB1cGRhdGUgbWVzc2FnZVxuICogd2l0aCBhIG5ldyBjb21taXRtZW50IHR4LiBUaGVuIGJvdGggcGFydGllcyBzaG91bGQgcmV2b2tlIGFueSBvbGQgb3V0cHV0cy5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5sZXQgTXNnID0gcmVxdWlyZSgnLi9tc2cnKVxubGV0IENvbW1pdG1lbnQgPSByZXF1aXJlKCcuLi8uLi9saWIvdHhzL2NvbW1pdG1lbnQnKVxubGV0IEJuID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvYm4nKVxuXG5jbGFzcyBNc2dVcGRhdGUgZXh0ZW5kcyBNc2cge1xuICBjb25zdHJ1Y3RvciAoYXJncywgY2hhbklkKSB7XG4gICAgbGV0IGNtZCA9ICd1cGRhdGUnXG4gICAgc3VwZXIoY21kLCBhcmdzLCBjaGFuSWQpXG4gIH1cblxuICBzZXRDb21taXRtZW50IChjb21taXRtZW50KSB7XG4gICAgdGhpcy5hcmdzLmNvbW1pdG1lbnQgPSBjb21taXRtZW50LnRvUHVibGljKCkudG9KU09OKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0Q29tbWl0bWVudCAoKSB7XG4gICAgcmV0dXJuIENvbW1pdG1lbnQuZnJvbUpTT04odGhpcy5hcmdzLmNvbW1pdG1lbnQpXG4gIH1cblxuICBzZXRGdW5kaW5nQW1vdW50IChmdW5kaW5nQW1vdW50KSB7XG4gICAgdGhpcy5hcmdzLmZ1bmRpbmdBbW91bnQgPSBmdW5kaW5nQW1vdW50LnRvU3RyaW5nKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0RnVuZGluZ0Ftb3VudCAoKSB7XG4gICAgcmV0dXJuIEJuKHRoaXMuYXJncy5mdW5kaW5nQW1vdW50KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTXNnVXBkYXRlXG4iLCIvKipcbiAqIFByb3RvY29sIE1lc3NhZ2VcbiAqID09PT09PT09PT09PT09PT1cbiAqXG4gKiAtIGNtZDogQSBzaG9ydCBzdHJpbmcgc3BlY2lmeWluZyB0aGUgY29tbWFuZCBuYW1lLCBsaWtlICdvcGVuLWNoYW5uZWwnXG4gKiAtIGFyZ3M6IEEganNvbiBzdHJpbmdpZmlhYmxlIG9iamVjdFxuICogLSBjaGFuSWQ6IFRoZSBpZCBvZiB0aGUgY2hhbm5lbCwgd2hpY2ggaXMgdGhlIHN0cmluZyBmb3JtIG9mIHRoZSBtdWx0aVNpZ1xuICogYWRkcmVzcyBmb3IgdGhlIGZ1bmRpbmcgdHJhbnNhY3Rpb24gb2YgdGhpcyBjaGFubmVsLlxuICogLSBjb252SWQ6IFRoZSBpZCBvZiB0aGUgY29udmVyc2F0aW9uIC0gb2Z0ZW4sIGEgbG9uZyBzZXJpZXMgb2YgbWVzc2FnZXMgbmVlZFxuICogdG8gYmUgZXhjaGFuZ2VkIGluIGEgcGFydGljdWxhciBvcmRlci4gRWFjaCBzZXF1ZW5jZSBuZWVkcyB0byBzaGFyZSB0aGUgc2FtZVxuICogJ2NvbnZlcnNhdGlvbiBpZCcgb3IgJ2NvbnZJZCcuXG4gKi9cbmxldCBTdHJ1Y3QgPSByZXF1aXJlKCd5b3Vycy1iaXRjb2luL2xpYi9zdHJ1Y3QnKVxubGV0IFJhbmRvbSA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3JhbmRvbScpXG5cbmNsYXNzIE1zZyBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yIChcbiAgICBjbWQsXG4gICAgYXJncyA9IHt9LFxuICAgIGNoYW5JZCxcbiAgICBjb252SWQgPSBSYW5kb20uZ2V0UmFuZG9tQnVmZmVyKDE2KS50b1N0cmluZygnaGV4JyksXG4gICAgY2hhblBhdGggPSAnbSdcbiAgKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZnJvbU9iamVjdCh7XG4gICAgICBjbWQsXG4gICAgICBhcmdzLFxuICAgICAgY2hhbklkLFxuICAgICAgY29udklkLFxuICAgICAgY2hhblBhdGhcbiAgICB9KVxuICB9XG5cbiAgc2V0Q2hhbklkIChjaGFuSWQpIHtcbiAgICB0aGlzLmNoYW5JZCA9IGNoYW5JZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRDaGFuSWQgKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5JZFxuICB9XG5cbiAgc2V0Q2hhblBhdGggKGNoYW5QYXRoKSB7XG4gICAgdGhpcy5jaGFuUGF0aCA9IGNoYW5QYXRoXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldENoYW5QYXRoICgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFuUGF0aFxuICB9XG5cbiAgc2V0Q29udklkIChjb252SWQpIHtcbiAgICB0aGlzLmNvbnZJZCA9IGNvbnZJZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRDb252SWQgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnZJZFxuICB9XG5cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY21kOiB0aGlzLmNtZCxcbiAgICAgIGFyZ3M6IHRoaXMuYXJncyxcbiAgICAgIGNoYWluSWQ6IHRoaXMuY2hhbklkXG4gICAgfVxuICB9XG5cbiAgZnJvbUpTT04gKGpzb24pIHtcbiAgICB0aGlzLmNtZCA9IGpzb24uY21kXG4gICAgdGhpcy5hcmdzID0ganNvbi5hcmdzXG4gICAgdGhpcy5jaGFpbklkID0ganNvbi5jaGFuSWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaXNWYWxpZCAoKSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgdmFsaWRpdHkgb2YgY2hhblBhdGhcbiAgICBpZiAodHlwZW9mIHRoaXMuY21kICE9PSAnc3RyaW5nJyB8fCB0aGlzLmNtZC5sZW5ndGggPiAzMCB8fCB0aGlzLmNtZC5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLmFyZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAvLyB0aGlzLmFyZ3MgQ0FOIGJlIGFuIGFycmF5XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLmNoYW5JZCAhPT0gJ3N0cmluZycgfHwgIShcbiAgICAgIHRoaXMuY2hhbklkLnN0YXJ0c1dpdGgoJzMnKSB8fCAvLyBtYWlubmV0XG4gICAgICB0aGlzLmNoYW5JZC5zdGFydHNXaXRoKCcyJykgLy8gdGVzdG5ldFxuICAgICkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuY29udklkICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNc2dcbiIsIi8vIGp1c3QgYSBkdW1teSBhdCB0aGlzIHBvaW50XG4ndXNlIHN0cmljdCdcbmxldCBTdHJ1Y3QgPSByZXF1aXJlKCd5b3Vycy1iaXRjb2luL2xpYi9zdHJ1Y3QnKVxubGV0IEJuID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvYm4nKVxubGV0IFNjcmlwdCA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3NjcmlwdCcpXG5sZXQgSHRsY1NlY3JldCA9IHJlcXVpcmUoJy4vc2NydHMvaHRsYy1zZWNyZXQnKVxubGV0IFJldlNlY3JldCA9IHJlcXVpcmUoJy4vc2NydHMvcmV2LXNlY3JldCcpXG5cbmNsYXNzIE91dHB1dCBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yIChcbiAgICBraW5kLFxuICAgIG5ldHdvcmtTb3VyY2VJZCxcbiAgICBjaGFubmVsU291cmNlSWQsXG4gICAgY2hhbm5lbERlc3RJZCxcbiAgICBuZXR3b3JrRGVzdElkLFxuICAgIGNoYW5uZWxTb3VyY2VQYXRoLFxuICAgIGNoYW5uZWxEZXN0UGF0aCxcbiAgICBodGxjU2VjcmV0LFxuICAgIHJldlNlY3JldCxcbiAgICBhbW91bnQsXG4gICAgcmV2b2NhYmxlLFxuICAgIHJlZGVlbVNjcmlwdCxcbiAgICBzY3JpcHRQdWJrZXlcbiAgKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZnJvbU9iamVjdCh7XG4gICAgICBraW5kLFxuICAgICAgbmV0d29ya1NvdXJjZUlkLFxuICAgICAgY2hhbm5lbFNvdXJjZUlkLFxuICAgICAgY2hhbm5lbERlc3RJZCxcbiAgICAgIG5ldHdvcmtEZXN0SWQsXG4gICAgICBjaGFubmVsU291cmNlUGF0aCxcbiAgICAgIGNoYW5uZWxEZXN0UGF0aCxcbiAgICAgIGh0bGNTZWNyZXQsXG4gICAgICByZXZTZWNyZXQsXG4gICAgICBhbW91bnQsXG4gICAgICByZXZvY2FibGUsXG4gICAgICByZWRlZW1TY3JpcHQsXG4gICAgICBzY3JpcHRQdWJrZXlcbiAgICB9KVxuICB9XG5cbiAgZnJvbUpTT04gKGpzb24pIHtcbiAgICB0aGlzLmNoYW5uZWxTb3VyY2VQYXRoID0ganNvbi5jaGFubmVsU291cmNlUGF0aFxuICAgIHRoaXMuY2hhbm5lbERlc3RQYXRoID0ganNvbi5jaGFubmVsRGVzdFBhdGhcbiAgICB0aGlzLm5ldHdvcmtTb3VyY2VJZCA9IGpzb24ubmV0d29ya1NvdXJjZUlkXG4gICAgdGhpcy5jaGFubmVsU291cmNlSWQgPSBqc29uLmNoYW5uZWxTb3VyY2VJZFxuICAgIHRoaXMuY2hhbm5lbERlc3RJZCA9IGpzb24uY2hhbm5lbERlc3RJZFxuICAgIHRoaXMubmV0d29ya0Rlc3RJZCA9IGpzb24ubmV0d29ya0Rlc3RJZFxuICAgIHRoaXMua2luZCA9IGpzb24ua2luZFxuICAgIHRoaXMuaHRsY1NlY3JldCA9IGpzb24uaHRsY1NlY3JldCA/IG5ldyBIdGxjU2VjcmV0KCkuZnJvbUpTT04oanNvbi5odGxjU2VjcmV0KSA6IHVuZGVmaW5lZFxuICAgIHRoaXMucmV2U2VjcmV0ID0ganNvbi5yZXZTZWNyZXQgPyBuZXcgUmV2U2VjcmV0KCkuZnJvbUpTT04oanNvbi5yZXZTZWNyZXQpIDogdW5kZWZpbmVkXG4gICAgdGhpcy5hbW91bnQgPSBqc29uLmFtb3VudCA/IG5ldyBCbigpLmZyb21KU09OKGpzb24uYW1vdW50KSA6IHVuZGVmaW5lZFxuICAgIHRoaXMucmV2b2NhYmxlID0ganNvbi5yZXZvY2FibGVcbiAgICB0aGlzLnJlZGVlbVNjcmlwdCA9IGpzb24ucmVkZWVtU2NyaXB0ID8gU2NyaXB0LmZyb21KU09OKGpzb24ucmVkZWVtU2NyaXB0KSA6IHVuZGVmaW5lZFxuICAgIHRoaXMuc2NyaXB0UHVia2V5ID0ganNvbi5zY3JpcHRQdWJrZXkgPyBTY3JpcHQuZnJvbUpTT04oanNvbi5zY3JpcHRQdWJrZXkpIDogdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvUHVibGljICgpIHtcbiAgICBsZXQgb3V0cHV0RGVzYyA9IG5ldyBPdXRwdXQoKVxuICAgIG91dHB1dERlc2MuY2hhbm5lbFNvdXJjZVBhdGggPSB0aGlzLmNoYW5uZWxTb3VyY2VQYXRoXG4gICAgb3V0cHV0RGVzYy5jaGFubmVsRGVzdFBhdGggPSB0aGlzLmNoYW5uZWxEZXN0UGF0aFxuICAgIG91dHB1dERlc2MubmV0d29ya1NvdXJjZUlkID0gdGhpcy5uZXR3b3JrU291cmNlSWRcbiAgICBvdXRwdXREZXNjLmNoYW5uZWxTb3VyY2VJZCA9IHRoaXMuY2hhbm5lbFNvdXJjZUlkXG4gICAgb3V0cHV0RGVzYy5jaGFubmVsRGVzdElkID0gdGhpcy5jaGFubmVsRGVzdElkXG4gICAgb3V0cHV0RGVzYy5uZXR3b3JrRGVzdElkID0gdGhpcy5uZXR3b3JrRGVzdElkXG4gICAgb3V0cHV0RGVzYy5raW5kID0gdGhpcy5raW5kXG4gICAgb3V0cHV0RGVzYy5odGxjU2VjcmV0ID0gdGhpcy5odGxjU2VjcmV0ID8gdGhpcy5odGxjU2VjcmV0LnRvUHVibGljKCkgOiB1bmRlZmluZWRcbiAgICBvdXRwdXREZXNjLnJldlNlY3JldCA9IHRoaXMucmV2U2VjcmV0ID8gdGhpcy5yZXZTZWNyZXQudG9QdWJsaWMoKSA6IHVuZGVmaW5lZFxuICAgIG91dHB1dERlc2MuYW1vdW50ID0gdGhpcy5hbW91bnRcbiAgICBvdXRwdXREZXNjLnJldm9jYWJsZSA9IHRoaXMucmV2b2NhYmxlXG4gICAgb3V0cHV0RGVzYy5yZWRlZW1TY3JpcHQgPSB0aGlzLnJlZGVlbVNjcmlwdCA/IHRoaXMucmVkZWVtU2NyaXB0LnRvSlNPTigpIDogdW5kZWZpbmVkXG4gICAgb3V0cHV0RGVzYy5zY3JpcHRQdWJrZXkgPSB0aGlzLnNjcmlwdFB1YmtleSA/IHRoaXMuc2NyaXB0UHVia2V5LnRvSlNPTigpIDogdW5kZWZpbmVkXG4gICAgcmV0dXJuIG91dHB1dERlc2NcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE91dHB1dFxuIiwiJ3VzZSBzdHJpY3QnXG5sZXQgU2VjcmV0ID0gcmVxdWlyZSgnLi9zZWNyZXQnKVxubGV0IGFzaW5rID0gcmVxdWlyZSgnYXNpbmsnKVxuXG5jbGFzcyBIdGxjU2VjcmV0IGV4dGVuZHMgU2VjcmV0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmZyb21PYmplY3Qoe30pXG4gIH1cblxuICBhc3luY0NoZWNrIChvdGhlclNlY3JldCkge1xuICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgIHJldHVybiB5aWVsZCB0aGlzLmFzeW5jU3VwZXJDaGVjaygpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIHRvUHVibGljICgpIHtcbiAgICBsZXQgc2VjcmV0ID0gbmV3IEh0bGNTZWNyZXQoKVxuICAgIHNlY3JldC5oYXNoID0gdGhpcy5oYXNoXG4gICAgcmV0dXJuIHNlY3JldFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSHRsY1NlY3JldFxuIiwiJ3VzZSBzdHJpY3QnXG5sZXQgU2VjcmV0ID0gcmVxdWlyZSgnLi9zZWNyZXQnKVxubGV0IGFzaW5rID0gcmVxdWlyZSgnYXNpbmsnKVxuXG5jbGFzcyBSZXZvY2F0aW9uU2VjcmV0IGV4dGVuZHMgU2VjcmV0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmZyb21PYmplY3Qoe30pXG4gIH1cblxuICBhc3luY0NoZWNrIChvdGhlclNlY3JldCkge1xuICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgIGlmIChvdGhlclNlY3JldCkge1xuICAgICAgICBpZiAoIW90aGVyU2VjcmV0Lmhhc2ggfHwgb3RoZXJTZWNyZXQuaGFzaC50b1N0cmluZygnaGV4JykgIT09IHRoaXMuaGFzaC50b1N0cmluZygnaGV4JykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHNlY3JldCBkb2VzIG5vdCBtYXRjaCBsb2NhbCBzZWNyZXQnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geWllbGQgdGhpcy5hc3luY1N1cGVyQ2hlY2soKVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICB0b1B1YmxpYyAoKSB7XG4gICAgbGV0IHNlY3JldCA9IG5ldyBSZXZvY2F0aW9uU2VjcmV0KClcbiAgICBzZWNyZXQuaGFzaCA9IHRoaXMuaGFzaFxuICAgIHJldHVybiBzZWNyZXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJldm9jYXRpb25TZWNyZXRcbiIsIid1c2Ugc3RyaWN0J1xubGV0IFN0cnVjdCA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3N0cnVjdCcpXG5sZXQgYXNpbmsgPSByZXF1aXJlKCdhc2luaycpXG5sZXQgSGFzaCA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL2hhc2gnKVxubGV0IFJhbmRvbSA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3JhbmRvbScpXG5cbmNsYXNzIFNlY3JldCBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yIChidWYsIGhhc2gpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5mcm9tT2JqZWN0KHtidWYsIGhhc2h9KVxuICB9XG5cbiAgYXN5bmNJbml0aWFsaXplICgpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlQnVmKClcbiAgICAgIHlpZWxkIHRoaXMuYXN5bmNHZW5lcmF0ZUhhc2goKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgZ2VuZXJhdGVCdWYgKCkge1xuICAgIHRoaXMuYnVmID0gUmFuZG9tLmdldFJhbmRvbUJ1ZmZlcigzMilcbiAgfVxuXG4gIGFzeW5jR2VuZXJhdGVIYXNoICgpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBpZiAoIXRoaXMuYnVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGdlbmVyYXRlZCBiZWZvcmUgaGFzaCBjYW4gYmUnKVxuICAgICAgfVxuICAgICAgdGhpcy5oYXNoID0geWllbGQgSGFzaC5hc3luY1NoYTI1NlJpcGVtZDE2MCh0aGlzLmJ1ZilcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgYXN5bmNTdXBlckNoZWNrICgpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBpZiAoIXRoaXMuYnVmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VjcmV0LmJ1ZiBpcyBub3Qgc2V0JylcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5oYXNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VjcmV0Lmhhc2ggaXMgbm90IHNldCcpXG4gICAgICB9XG4gICAgICBsZXQgaGFzaGVkQnVmID0geWllbGQgSGFzaC5hc3luY1NoYTI1NlJpcGVtZDE2MCh0aGlzLmJ1ZilcbiAgICAgIHJldHVybiBoYXNoZWRCdWYuZXF1YWxzKHRoaXMuaGFzaClcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgLypcbiAgICogcmV0dXJucyBhIG5ldyBzZWNyZXQgd2l0aCB0aGUgYnVmZmVyIHRvUHVibGljXG4gICAqL1xuICB0b1B1YmxpYyAoKSB7XG4gICAgbGV0IHNlY3JldCA9IG5ldyBTZWNyZXQoKS5mcm9tT2JqZWN0KHRoaXMpXG4gICAgc2VjcmV0LmJ1ZiA9IHVuZGVmaW5lZFxuICAgIHJldHVybiBzZWNyZXRcbiAgfVxuXG4gIHRvSlNPTiAoKSB7XG4gICAgbGV0IGpzb24gPSB7fVxuICAgIGpzb24uYnVmID0gdGhpcy5idWYgPyB0aGlzLmJ1Zi50b1N0cmluZygnaGV4JykgOiB1bmRlZmluZWRcbiAgICBqc29uLmhhc2ggPSB0aGlzLmhhc2ggPyB0aGlzLmhhc2gudG9TdHJpbmcoJ2hleCcpIDogdW5kZWZpbmVkXG4gICAgcmV0dXJuIGpzb25cbiAgfVxuXG4gIGZyb21KU09OIChqc29uKSB7XG4gICAgdGhpcy5idWYgPSBqc29uLmJ1ZiA/IG5ldyBCdWZmZXIoanNvbi5idWYsICdoZXgnKSA6IHVuZGVmaW5lZFxuICAgIHRoaXMuaGFzaCA9IGpzb24uaGFzaCA/IG5ldyBCdWZmZXIoanNvbi5oYXNoLCAnaGV4JykgOiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VjcmV0XG4iLCIndXNlIHN0cmljdCdcbmxldCBhc2luayA9IHJlcXVpcmUoJ2FzaW5rJylcbmxldCBUeCA9IHJlcXVpcmUoJy4vdHgnKVxubGV0IE91dHB1dCA9IHJlcXVpcmUoJy4uL291dHB1dCcpXG5sZXQgVHhCdWlsZGVyID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvdHgtYnVpbGRlcicpXG5sZXQgU2NyaXB0ID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvc2NyaXB0JylcbmxldCBPcENvZGUgPSByZXF1aXJlKCd5b3Vycy1iaXRjb2luL2xpYi9vcC1jb2RlJylcbmxldCBBZGRyZXNzID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvYWRkcmVzcycpXG5sZXQgQm4gPSByZXF1aXJlKCd5b3Vycy1iaXRjb2luL2xpYi9ibicpXG5sZXQgQ29uc3RzID0gcmVxdWlyZSgnLi4vY29uc3RzLmpzJylcblxuY2xhc3MgQ29tbWl0bWVudCBleHRlbmRzIFR4IHtcbiAgY29uc3RydWN0b3IgKG91dHB1dHMsIHR4Yikge1xuICAgIHN1cGVyKHtvdXRwdXRzLCB0eGJ9KVxuICB9XG5cbiAgYXN5bmNCdWlsZCAoZnVuZGluZ1R4SGFzaCwgZnVuZGluZ1R4T3V0LCBtdWx0aXNpZ0FkZHJlc3MsIGJ1aWxkZXJJZCwgeFB1YnMpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBpZiAoIXRoaXMub3V0cHV0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbW1pdG1lbnQgbm90IHN1ZmZpY2llbnRseSBpbml0aWFsaXplZCcpXG4gICAgICB9XG5cbiAgICAgIHRoaXMudHhiID0gbmV3IFR4QnVpbGRlcigpXG4gICAgICB0aGlzLnR4Yi5pbnB1dEZyb21TY3JpcHRIYXNoTXVsdGlTaWcoZnVuZGluZ1R4SGFzaCwgMCwgZnVuZGluZ1R4T3V0LCBtdWx0aXNpZ0FkZHJlc3Muc2NyaXB0KVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYnVpbGQgb3V0cHV0IHNjcmlwdHNcbiAgICAgICAgdGhpcy5vdXRwdXRzW2ldLnJldm9jYWJsZSA9IHRoaXMub3V0cHV0c1tpXS5jaGFubmVsRGVzdElkICE9PSBidWlsZGVySWRcbiAgICAgICAgdGhpcy5vdXRwdXRzW2ldLnJlZGVlbVNjcmlwdCA9IHRoaXMuYnVpbGRSZWRlZW1TY3JpcHQodGhpcy5vdXRwdXRzW2ldLCBidWlsZGVySWQsIHhQdWJzKVxuICAgICAgICB0aGlzLm91dHB1dHNbaV0uc2NyaXB0UHVia2V5ID0gQWRkcmVzcy5mcm9tUmVkZWVtU2NyaXB0KHRoaXMub3V0cHV0c1tpXS5yZWRlZW1TY3JpcHQpLnRvU2NyaXB0KClcblxuICAgICAgICBpZiAoaSA8IHRoaXMub3V0cHV0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdGhpcy50eGIub3V0cHV0VG9TY3JpcHQodGhpcy5vdXRwdXRzW2ldLmFtb3VudCwgdGhpcy5vdXRwdXRzW2ldLnNjcmlwdFB1YmtleSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnR4Yi5zZXRDaGFuZ2VTY3JpcHQodGhpcy5vdXRwdXRzW2ldLnNjcmlwdFB1YmtleSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnR4Yi5idWlsZCgpXG4gICAgICB5aWVsZCB0aGlzLnR4Yi5hc3luY1NpZ24oMCwgbXVsdGlzaWdBZGRyZXNzLmtleVBhaXIsIGZ1bmRpbmdUeE91dClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIGJ1aWxkUmVkZWVtU2NyaXB0IChvdXRwdXRPYmplY3QsIGJ1aWxkZXJJZCwgeFB1YnMpIHtcbiAgICBpZiAob3V0cHV0T2JqZWN0LmtpbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgYXJndW1lbnRzIGZvciBidWlsZFJlZGVlbVNjcmlwdCcpXG4gICAgfVxuXG4gICAgbGV0IHNvdXJjZVBhdGggPSBvdXRwdXRPYmplY3QuY2hhbm5lbFNvdXJjZVBhdGhcbiAgICBsZXQgc291cmNlQmlwID0geFB1YnNbb3V0cHV0T2JqZWN0LmNoYW5uZWxTb3VyY2VJZF1cbiAgICBsZXQgc291cmNlUHViS2V5ID0gc291cmNlQmlwLmRlcml2ZShzb3VyY2VQYXRoKS5wdWJLZXkgLy8gVE9ETzogYXN5bmNEZXJpdmVcblxuICAgIGxldCBkZXN0UGF0aCA9IG91dHB1dE9iamVjdC5jaGFubmVsRGVzdFBhdGhcbiAgICBsZXQgZGVzdEJpcCA9IHhQdWJzW291dHB1dE9iamVjdC5jaGFubmVsRGVzdElkXVxuICAgIGxldCBkZXN0UHViS2V5ID0gZGVzdEJpcC5kZXJpdmUoZGVzdFBhdGgpLnB1YktleSAvLyBUT0RPOiBhc3luY0Rlcml2ZVxuXG4gICAgaWYgKG91dHB1dE9iamVjdC5raW5kID09PSAncHViS2V5JyAmJiBvdXRwdXRPYmplY3QuY2hhbm5lbERlc3RJZCA9PT0gYnVpbGRlcklkKSB7XG4gICAgICAvLyBidWlsZCBhbiBzcGVuZCB0byBwdWJrZXkgc2NyaXB0XG4gICAgICByZXR1cm4gdGhpcy5wdWJLZXlSZWRlZW1TY3JpcHQoZGVzdFB1YktleSlcbiAgICB9IGVsc2UgaWYgKG91dHB1dE9iamVjdC5raW5kID09PSAncHViS2V5JyAmJiBvdXRwdXRPYmplY3QuY2hhbm5lbERlc3RJZCAhPT0gYnVpbGRlcklkKSB7XG4gICAgICAvLyBidWlsZCBhIHJldm9jYWJsZSBzcGVuZCB0byBwdWJrZXkgc2NyaXB0XG4gICAgICByZXR1cm4gdGhpcy5yZXZQdWJLZXlSZWRlZW1TY3JpcHQoZGVzdFB1YktleSwgc291cmNlUHViS2V5LCBvdXRwdXRPYmplY3QpXG4gICAgfSBlbHNlIGlmIChvdXRwdXRPYmplY3Qua2luZCA9PT0gJ2h0bGMnICYmIG91dHB1dE9iamVjdC5jaGFubmVsRGVzdElkID09PSBidWlsZGVySWQpIHtcbiAgICAgIC8vIGJ1aWxkIGFuIEhUTEMgc2NyaXB0XG4gICAgICByZXR1cm4gdGhpcy5odGxjUmVkZWVtU2NyaXB0KGRlc3RQdWJLZXksIHNvdXJjZVB1YktleSwgb3V0cHV0T2JqZWN0KVxuICAgIH0gaWYgKG91dHB1dE9iamVjdC5raW5kID09PSAnaHRsYycgJiYgb3V0cHV0T2JqZWN0LmNoYW5uZWxEZXN0SWQgIT09IGJ1aWxkZXJJZCkge1xuICAgICAgLy8gYnVpbGQgYSByZXZvY2FibGUgSFRMQyBzY3RpcHRcbiAgICAgIHJldHVybiB0aGlzLnJldkh0bGNSZWRlZW1TY3JpcHQoZGVzdFB1YktleSwgc291cmNlUHViS2V5LCBvdXRwdXRPYmplY3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBraW5kIGluIENvbW1pdG1lbnQuYXN5bmNCdWlsZCcpXG4gICAgfVxuICB9XG5cbiAgcHViS2V5UmVkZWVtU2NyaXB0IChkZXN0UHViS2V5KSB7XG4gICAgLy8gb3V0cHV0IHRvIGNoYW5uZWwgZGVzdFxuICAgIHJldHVybiBuZXcgU2NyaXB0KClcbiAgICAgIC53cml0ZUJ1ZmZlcihkZXN0UHViS2V5LnRvQnVmZmVyKCkpXG4gICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0NIRUNLU0lHKVxuICB9XG5cbiAgLy8gYWxsIGNoZWNrcyBidXQgdGhlIGxhc3Qgc2hvdWxkIGJlIC4uLlZFUklGWVxuICByZXZQdWJLZXlSZWRlZW1TY3JpcHQgKGRlc3RQdWJLZXksIHNvdXJjZVB1YktleSwgb3V0cHV0T2JqZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBTY3JpcHQoKVxuICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9JRilcbiAgICAgICAgLy8gb3V0cHV0IHRvIGNoYW5uZWwgZGVzdFxuICAgICAgICAvLyBlbmN1bWJlcmVkIGJ5IGEgQ1NWX0RFTEFZIENTViB0aW1lIGxvY2tcbiAgICAgICAgLy8gdGltZSBsb2NrIGlzIG5lZWRlZCB0byBhbGxvdyBjaGFubmVsIHNvdXJjZSB0byBzcGVuZCB2aWEgYnJhbmNoIDJcbiAgICAgICAgLy8gc2hvdWxkIHRoZSB0eCBiZSByZXZva2VkXG4gICAgICAgIC53cml0ZUJ1ZmZlcihkZXN0UHViS2V5LnRvQnVmZmVyKCkpXG4gICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfQ0hFQ0tTSUcpXG4gICAgICAgIC53cml0ZUJuKG91dHB1dE9iamVjdC5jc3ZEZWxheSB8fCBDb25zdHMuQ1NWX0RFTEFZKVxuICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0NIRUNLU0VRVUVOQ0VWRVJJRlkpXG4gICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfRFJPUClcbiAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfRUxTRSlcbiAgICAgICAgLy8gb3V0cHV0IHRvIGNoYW5uZWwgc291cmNlXG4gICAgICAgIC8vIHNvdXJjZVB1YktleSAmIG93bmVyJ3MgcmV2b2NhdGlvbiBzZWNyZXQgbmVlZGVkIHRvIHNwZW5kXG4gICAgICAgIC8vIHRoaXMgYnJhbmNoIGlzIHVzZWQgaWYgYSByZXZva2VkIGNvbW1pdG1lbnQgdHggaGFzIGJlZW4gYnJvYWRjYXN0XG4gICAgICAgIC53cml0ZUJ1ZmZlcihzb3VyY2VQdWJLZXkudG9CdWZmZXIoKSlcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9DSEVDS1NJR1ZFUklGWSlcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9IQVNIMTYwKVxuICAgICAgICAud3JpdGVCdWZmZXIob3V0cHV0T2JqZWN0LnJldlNlY3JldC5oYXNoKVxuICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0VRVUFMKVxuICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9FTkRJRilcbiAgfVxuXG4gIGh0bGNSZWRlZW1TY3JpcHQgKGRlc3RQdWJLZXksIHNvdXJjZVB1YktleSwgb3V0cHV0T2JqZWN0KSB7XG4gICAgbGV0IHNjcmlwdCA9IG5ldyBTY3JpcHQoKVxuICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9JRilcbiAgICAgICAgLy8gb3V0cHV0IHRvIGNoYW5uZWwgZGVzdFxuICAgICAgICAvLyBjaGFubmVsIGRlc3QncyBzaWcgJiBhbmQgbmV0d29yayBkZXN0J3MgSFRMQyBzZWNyZXQgbmVlZGVkIHRvIHNwZW5kXG4gICAgICAgIC8vIHRoaXMgYnJhbmNoIGNhbiBiZSBzcGVudCBpZiBjaGFuZWwgZGVzdCBoYXMgdGhlIGh0bGMgc2VjcmV0XG4gICAgICAgIC53cml0ZUJ1ZmZlcihkZXN0UHViS2V5LnRvQnVmZmVyKCkpIC8vIHB1c2ggdGhlIGFnZW50J3MgcHViS2V5XG4gICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfQ0hFQ0tTSUdWRVJJRlkpIC8vIGNoZWNrIHNpZyBhZ2FpbnN0IHJlZGVlbSBzY3JpcHRcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9IQVNIMTYwKSAvLyBoYXNoIGh0bGMgc2VjcmV0IGZyb20gcmVkZWVtIHNjcmlwdFxuICAgICAgICAud3JpdGVCdWZmZXIob3V0cHV0T2JqZWN0Lmh0bGNTZWNyZXQuaGFzaCkgLy8gcHVzaCBodGxjIHNlY3JldCBoYXNoIG9mIHRoZSBodGxjIHNlY3JldFxuICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0VRVUFMKSAvLyBjaGVjayBlcXVhbGl0eVxuICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9FTFNFKVxuICAgICAgICAvLyBvdXRwdXQgdG8gY2hhbm5lbCBzb3VyY2VcbiAgICAgICAgLy8gY2hhbm5lbCBzb3VyY2UncyBzaWcgbmVlZGVkIHRvIHNwZW5kLCBzdWJqZWN0IHRvIFNWQyBsb2NrXG4gICAgICAgIC8vIHRoaXMgYnJhbmNoIGNhbiBiZSBzcGVudCBpZiBjaGFubmVsIGRlc3QgZG9lcyBub3QgcmV2ZWlsIHRoZSBodGxjIHNlY3JldCBpbiB0aW1lXG4gICAgICAgIC53cml0ZUJ1ZmZlcihzb3VyY2VQdWJLZXkudG9CdWZmZXIoKSlcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9DSEVDS1NJRylcbiAgICAgICAgLndyaXRlQm4ob3V0cHV0T2JqZWN0LmNzdkRlbGF5IHx8IENvbnN0cy5DU1ZfREVMQVkpXG4gICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfQ0hFQ0tTRVFVRU5DRVZFUklGWSlcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9EUk9QKVxuICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9FTkRJRilcbiAgICByZXR1cm4gc2NyaXB0XG4gIH1cblxuICByZXZIdGxjUmVkZWVtU2NyaXB0IChkZXN0UHViS2V5LCBzb3VyY2VQdWJLZXksIG91dHB1dE9iamVjdCkge1xuICAgIGxldCBsb25nRGVsYXkgPSBvdXRwdXRPYmplY3QuY3N2RGVsYXkgfHwgQ29uc3RzLkNTVl9ERUxBWVxuICAgIGxldCBzaG9ydERlbGF5ID0gbG9uZ0RlbGF5LmRpdihCbigyKSlcbiAgICByZXR1cm4gbmV3IFNjcmlwdCgpXG4gICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0lGKVxuICAgICAgICAvLyBvdXRwdXQgdG8gY2hhbm5lbCBkZXN0XG4gICAgICAgIC8vIGNoYW5uZWwgZGVzdCdzIHNpZyAmIGFuZCBuZXR3b3JrIGRlc3QncyBIVExDIHNlY3JldCBuZWVkZWQgdG8gc3BlbmRcbiAgICAgICAgLy8gdGhpcyBicmFuY2ggY2FuIGJlIHNwZW50IGlmIGNoYW5lbCBkZXN0IGhhcyB0aGUgaHRsYyBzZWNyZXRcbiAgICAgICAgLy8gY29ycmVzcG9uZHMgdG8gdGhlIGZpcnN0IGJyYW5jaCBvZiB0aGUgaHRsYyBzY3JpcHRcbiAgICAgICAgLy8gbXVzdCBiZSBlbmN1bWJlcmVkIGJ5IGEgdGltZSBsb2NrIHRvIGFsbG93IGNoYW5uZWwgc291cmNlIHRvIHNwZW5kIGlmIHR4IHdhcyByZXZva2VkXG4gICAgICAgIC53cml0ZUJ1ZmZlcihkZXN0UHViS2V5LnRvQnVmZmVyKCkpIC8vIGNoZWNrIHB1YmtleVxuICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0NIRUNLU0lHVkVSSUZZKVxuICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0hBU0gxNjApIC8vIGNoZWNrIGh0bGMgc2VjcmV0XG4gICAgICAgIC53cml0ZUJ1ZmZlcihvdXRwdXRPYmplY3QuaHRsY1NlY3JldC5oYXNoKVxuICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0VRVUFMVkVSSUZZKVxuICAgICAgICAud3JpdGVCbihzaG9ydERlbGF5KSAvLyBjaGVjayB0aW1lIGxvY2tcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9DSEVDS1NFUVVFTkNFVkVSSUZZKVxuICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9FTFNFKVxuICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfSUYpXG4gICAgICAgICAvLyBvdXRwdXQgdG8gY2hhbm5lbCBzb3VyY2VcbiAgICAgICAgIC8vIGNoYW5uZWwgc291cmNlJ3Mgc2lnIG5lZWRlZCB0byBzcGVuZCwgc3ViamVjdCB0byBTVkMgbG9ja1xuICAgICAgICAgLy8gdGhpcyBicmFuY2ggY2FuIGJlIHNwZW50IGlmIGNoYW5uZWwgZGVzdCBkb2VzIG5vdCByZXZlaWwgdGhlIGh0bGMgc2VjcmV0IGluIHRpbWVcbiAgICAgICAgIC8vIGNvcnJlc3BvbmRzIHRvIHNlY29uZCBicmFuY2ggb2YgaHRsYyBzY3JpcHRcbiAgICAgICAgLndyaXRlQnVmZmVyKHNvdXJjZVB1YktleS50b0J1ZmZlcigpKVxuICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0NIRUNLU0lHKVxuICAgICAgICAud3JpdGVCbihsb25nRGVsYXkpXG4gICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfQ0hFQ0tTRVFVRU5DRVZFUklGWSlcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9EUk9QKVxuICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9FTFNFKVxuICAgICAgICAvLyBvdXRwdXQgdG8gY2hhbm5lbCBzb3VyY2VcbiAgICAgICAgLy8gc291cmNlUHViS2V5ICYgb3duZXIncyByZXZvY2F0aW9uIHNlY3JldCBuZWVkZWQgdG8gc3BlbmRcbiAgICAgICAgLy8gdGhpcyBicmFuY2ggaXMgdXNlZCBpZiBhIHJldm9rZWQgY29tbWl0bWVudCB0eCBoYXMgYmVlbiBicm9hZGNhc3RcbiAgICAgICAgLy8gdGhpcyBjb3JyZXNwb25kcyB0byBzZWNvbmQgYnJhbmNoIG9mIHJldiBwdWJLZXkgc2NyaXB0XG4gICAgICAgIC53cml0ZUJ1ZmZlcihzb3VyY2VQdWJLZXkudG9CdWZmZXIoKSlcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9DSEVDS1NJR1ZFUklGWSlcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9IQVNIMTYwKVxuICAgICAgICAud3JpdGVCdWZmZXIob3V0cHV0T2JqZWN0LnJldlNlY3JldC5oYXNoKVxuICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0VRVUFMKVxuICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9FTkRJRilcbiAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0VORElGKVxuICB9XG5cbiAgZnJvbUpTT04gKGpzb24pIHtcbiAgICBpZiAoanNvbi5vdXRwdXRzKSB7XG4gICAgICB0aGlzLm91dHB1dHMgPSBbXVxuICAgICAgZm9yIChsZXQgaSBpbiBqc29uLm91dHB1dHMpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2gobmV3IE91dHB1dCgpLmZyb21KU09OKGpzb24ub3V0cHV0c1tpXSkpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHhiID0ganNvbi50eGIgPyBuZXcgVHhCdWlsZGVyKCkuZnJvbUpTT04oanNvbi50eGIpIDogdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvUHVibGljICgpIHtcbiAgICBsZXQgY29tbWl0bWVudCA9IG5ldyBDb21taXRtZW50KCkuZnJvbU9iamVjdCgpXG4gICAgaWYgKHRoaXMub3V0cHV0cykge1xuICAgICAgY29tbWl0bWVudC5vdXRwdXRzID0gW11cbiAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgIGNvbW1pdG1lbnQub3V0cHV0cy5wdXNoKHRoaXMub3V0cHV0c1tpXS50b1B1YmxpYygpKVxuICAgICAgfVxuICAgIH1cbiAgICBjb21taXRtZW50LnR4YiA9IHRoaXMudHhiXG4gICAgcmV0dXJuIGNvbW1pdG1lbnRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1pdG1lbnRcbiIsIid1c2Ugc3RyaWN0J1xubGV0IGFzaW5rID0gcmVxdWlyZSgnYXNpbmsnKVxubGV0IFR4QnVpbGRlciA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3R4LWJ1aWxkZXInKVxubGV0IFR4ID0gcmVxdWlyZSgnLi90eCcpXG5cbmNsYXNzIEZ1bmRpbmcgZXh0ZW5kcyBUeCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5mcm9tT2JqZWN0KHt9KVxuICB9XG5cbiAgYXN5bmNJbml0aWFsaXplIChhbW91bnQsIHNvdXJjZUFkZHJlc3MsIG11bHRpc2lnQWRkcmVzcywgaW5wdXRUeEhhc2hidWYsIGlucHV0VHhvdXRudW0sIGlucHV0VHhvdXQsIHB1YktleSkge1xuICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgIGlmICghYW1vdW50IHx8ICFzb3VyY2VBZGRyZXNzIHx8ICFtdWx0aXNpZ0FkZHJlc3MgfHwgIWlucHV0VHhIYXNoYnVmIHx8XG4gICAgICAgICAgdHlwZW9mIGlucHV0VHhvdXRudW0gIT09ICdudW1iZXInIHx8ICFpbnB1dFR4b3V0IHx8ICFwdWJLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgYXJndW1lbnRzIGZvciBGdW5kaW5nLmFzeW5jSW5pdGlhbGl6ZScpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYW1vdW50ID0gYW1vdW50XG4gICAgICB0aGlzLnR4YiA9IG5ldyBUeEJ1aWxkZXIoKVxuICAgICAgdGhpcy50eGIuaW5wdXRGcm9tUHViS2V5SGFzaChpbnB1dFR4SGFzaGJ1ZiwgaW5wdXRUeG91dG51bSwgaW5wdXRUeG91dCwgcHViS2V5KVxuICAgICAgdGhpcy50eGIuc2V0Q2hhbmdlQWRkcmVzcyhzb3VyY2VBZGRyZXNzLmFkZHJlc3MpXG4gICAgICB0aGlzLnR4Yi5vdXRwdXRUb0FkZHJlc3MoYW1vdW50LCBtdWx0aXNpZ0FkZHJlc3MuYWRkcmVzcylcbiAgICAgIHRoaXMudHhiLmJ1aWxkKClcbiAgICAgIHRoaXMudHhiLnNpZ24oMCwgc291cmNlQWRkcmVzcy5rZXlQYWlyLCBpbnB1dFR4b3V0KVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBmcm9tSlNPTiAoanNvbikge1xuICAgIHRoaXMuZnJvbU9iamVjdCh7XG4gICAgICBhbW91bnQ6IGpzb24uYW1vdW50LFxuICAgICAgdHhiOiBuZXcgVHhCdWlsZGVyKCkuZnJvbUpTT04oanNvbi50eGIpXG4gICAgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYXN5bmNUb1B1YmxpYyAoKSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgbGV0IGZ1bmRpbmcgPSBuZXcgRnVuZGluZygpXG4gICAgICBsZXQgaGFzaCA9IHlpZWxkIHRoaXMudHhiLnR4LmFzeW5jSGFzaCgpXG4gICAgICBmdW5kaW5nLmFtb3VudCA9IHRoaXMuYW1vdW50XG4gICAgICBmdW5kaW5nLnR4YiA9IG5ldyBUeEJ1aWxkZXIoKVxuICAgICAgZnVuZGluZy50eGIudHgudHhPdXRzID0gdGhpcy50eGIudHgudHhPdXRzXG4gICAgICBmdW5kaW5nLnR4Yi50eC5oYXNoID0gKCkgPT4gaGFzaFxuICAgICAgcmV0dXJuIGZ1bmRpbmdcbiAgICB9LCB0aGlzKVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGdW5kaW5nXG4iLCIndXNlIHN0cmljdCdcbmxldCBhc2luayA9IHJlcXVpcmUoJ2FzaW5rJylcbmxldCBUeCA9IHJlcXVpcmUoJy4vdHgnKVxubGV0IFR4QnVpbGRlciA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3R4LWJ1aWxkZXInKVxubGV0IFNjcmlwdCA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3NjcmlwdCcpXG5sZXQgU2lnID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvc2lnJylcbmxldCBPcENvZGUgPSByZXF1aXJlKCd5b3Vycy1iaXRjb2luL2xpYi9vcC1jb2RlJylcbmxldCBIYXNoID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvaGFzaCcpXG5sZXQgS2V5UGFpciA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL2tleS1wYWlyJylcbmxldCBCbiA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL2JuJylcbmxldCBDb25zdHMgPSByZXF1aXJlKCcuLi9jb25zdHMuanMnKVxuXG5jbGFzcyBTcGVuZGluZyBleHRlbmRzIFR4IHtcbiAgY29uc3RydWN0b3IgKHR4Yikge1xuICAgIHN1cGVyKHt0eGJ9KVxuICB9XG5cbiAgLypcbiAgKiBVc2VkIHRvIGJ1aWxkIGRlc3RpbmF0aW9uIHRyYW5zYWN0aW9ucyBpbiB3aGljaCBzcGVuZCBmcm9tIG5vbi1zdGFuZGFyZCBvdXRwdXRzXG4gICogbGlrZSBodGxjIG9yIHJodGxjLiBDb252ZW5pYW5jZSBmdW5jdGlvbiB0aGF0IGFsbCBkZXN0aW5hdGlvbiB0cmFuc2FjdGlvbnMgY2FsbFxuICAqL1xuICBhc3luY0J1aWxkIChhZGRyZXNzLCBjb21taXRtZW50LCB4UHJ2LCBteUlkLCBjb21taXRtZW50VHhEZXB0aCwgc2VjcmV0TWFwKSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgdGhpcy50eGIgPSBuZXcgVHhCdWlsZGVyKClcbiAgICAgIHRoaXMudHhiLnNldFZlcnNpb24oMilcblxuICAgICAgLy8gYnVpbGQgaW5wdXQgc2NyaXB0cyBmb3JtIG91dHB1dHNcbiAgICAgIGZvciAobGV0IGkgaW4gY29tbWl0bWVudC5vdXRwdXRzKSB7XG4gICAgICAgIGkgPSBwYXJzZUludChpKVxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIGNvbW1pdG1lbnQub3V0cHV0c1tpXSxcbiAgICAgICAgICB0aGlzLmJ1aWxkSW5wdXRTY3JpcHQoY29tbWl0bWVudC5vdXRwdXRzW2ldLCBteUlkLCBjb21taXRtZW50VHhEZXB0aCwgc2VjcmV0TWFwKSlcblxuICAgICAgICBpZiAoY29tbWl0bWVudC5vdXRwdXRzW2ldLnBhcnRpYWxTY3JpcHRTaWcpIHtcbiAgICAgICAgICBsZXQgc2NyaXB0U2lnID0gdGhpcy50b1Ayc2hJbnB1dChcbiAgICAgICAgICAgIGNvbW1pdG1lbnQub3V0cHV0c1tpXS5wYXJ0aWFsU2NyaXB0U2lnLFxuICAgICAgICAgICAgY29tbWl0bWVudC5vdXRwdXRzW2ldLnJlZGVlbVNjcmlwdClcbiAgICAgICAgICB0aGlzLnR4Yi5pbnB1dEZyb21TY3JpcHQoXG4gICAgICAgICAgICBjb21taXRtZW50LnR4Yi50eC5oYXNoKCksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY29tbWl0bWVudC50eGIudHgudHhPdXRzW2ldLFxuICAgICAgICAgICAgc2NyaXB0U2lnLFxuICAgICAgICAgICAgY29tbWl0bWVudC5vdXRwdXRzW2ldLmNzdkRlbGF5IHx8IENvbnN0cy5DU1ZfREVMQVkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnR4Yi50eElucy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBzcGVuZGFibGUgb3V0cHV0cyBmb3VuZCcpXG4gICAgICB9XG5cbiAgICAgIHRoaXMudHhiLnNldENoYW5nZUFkZHJlc3MoYWRkcmVzcylcbiAgICAgIHRoaXMudHhiLmJ1aWxkKHRydWUpXG5cbiAgICAgIC8vIHNpZ24gdGhlIGlucHV0IHNjcmlwdHNcbiAgICAgIGxldCBuSW4gPSAwXG4gICAgICBmb3IgKGxldCBpIGluIGNvbW1pdG1lbnQub3V0cHV0cykge1xuICAgICAgICBpID0gcGFyc2VJbnQoaSlcbiAgICAgICAgaWYgKGNvbW1pdG1lbnQub3V0cHV0c1tpXS5wYXJ0aWFsU2NyaXB0U2lnKSB7XG4gICAgICAgICAgbGV0IHBhdGggPSBjb21taXRtZW50Lm91dHB1dHNbaV0uY2hhbm5lbERlc3RQYXRoXG5cbiAgICAgICAgICBsZXQga2V5UGFpciA9IG5ldyBLZXlQYWlyKFxuICAgICAgICAgICAgKHlpZWxkIHhQcnYuYXN5bmNEZXJpdmUocGF0aCkpLnByaXZLZXksXG4gICAgICAgICAgICAoeWllbGQgeFBydi5hc3luY0Rlcml2ZShwYXRoKSkucHViS2V5XG4gICAgICAgICAgKVxuICAgICAgICAgIGxldCBzaWcgPSB0aGlzLnR4Yi5nZXRTaWcoXG4gICAgICAgICAgICBrZXlQYWlyLFxuICAgICAgICAgICAgU2lnLlNJR0hBU0hfQUxMLFxuICAgICAgICAgICAgbkluLFxuICAgICAgICAgICAgY29tbWl0bWVudC5vdXRwdXRzW2ldLnJlZGVlbVNjcmlwdClcbiAgICAgICAgICBjb21taXRtZW50Lm91dHB1dHNbaV0ucGFydGlhbFNjcmlwdFNpZy5zZXRDaHVua0J1ZmZlcihcbiAgICAgICAgICAgIGNvbW1pdG1lbnQub3V0cHV0c1tpXS5zaWdQb3MsXG4gICAgICAgICAgICBzaWcudG9UeEZvcm1hdCgpKVxuICAgICAgICAgIHRoaXMudHhiLnR4LnR4SW5zW25Jbl0uc2V0U2NyaXB0KGNvbW1pdG1lbnQub3V0cHV0c1tpXS5wYXJ0aWFsU2NyaXB0U2lnKVxuICAgICAgICAgIG5JbisrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgYnVpbGRJbnB1dFNjcmlwdCAob3V0cHV0T2JqZWN0LCBteUlkLCBjb21taXRtZW50VHhEZXB0aCwgc2VjcmV0TWFwKSB7XG4gICAgaWYgKG91dHB1dE9iamVjdC5raW5kID09PSAncHViS2V5JyAmJiAhb3V0cHV0T2JqZWN0LnJldm9jYWJsZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHViS2V5SW5wdXRTY3JpcHQob3V0cHV0T2JqZWN0LCBteUlkKVxuICAgIH0gZWxzZSBpZiAob3V0cHV0T2JqZWN0LmtpbmQgPT09ICdwdWJLZXknICYmIG91dHB1dE9iamVjdC5yZXZvY2FibGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldlB1YktleUlucHV0U2NyaXB0KG91dHB1dE9iamVjdCwgbXlJZCwgY29tbWl0bWVudFR4RGVwdGgsIHNlY3JldE1hcClcbiAgICB9IGVsc2UgaWYgKG91dHB1dE9iamVjdC5raW5kID09PSAnaHRsYycgJiYgIW91dHB1dE9iamVjdC5yZXZvY2FibGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmh0bGNJbnB1dFNjcmlwdChvdXRwdXRPYmplY3QsIG15SWQsIGNvbW1pdG1lbnRUeERlcHRoLCBzZWNyZXRNYXApXG4gICAgfSBlbHNlIGlmIChvdXRwdXRPYmplY3Qua2luZCA9PT0gJ2h0bGMnICYmIG91dHB1dE9iamVjdC5yZXZvY2FibGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldkh0bGNJbnB1dFNjcmlwdChvdXRwdXRPYmplY3QsIG15SWQsIGNvbW1pdG1lbnRUeERlcHRoLCBzZWNyZXRNYXApXG4gICAgfVxuICB9XG5cbiAgLyogc3BlbmRpbmcgZnJvbSBwdWJrZXkgc2NyaXB0ICovXG4gIHB1YktleUlucHV0U2NyaXB0IChvdXRwdXRPYmplY3QsIG15SWQpIHtcbiAgICBpZiAobXlJZCA9PT0gb3V0cHV0T2JqZWN0LmNoYW5uZWxEZXN0SWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcnRpYWxTY3JpcHRTaWc6IG5ldyBTY3JpcHQoKVxuICAgICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfVFJVRSksICAgLy8gc2lnbmF0dXJlIHdpbGwgZ28gaGVyZVxuICAgICAgICBzaWdQb3M6IDBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICB9XG5cbiAgLyogc3BlbmRpbmcgZnJvbSByZXZvY2FibGUgcHVia2V5IHNjcmlwdCAqL1xuICByZXZQdWJLZXlJbnB1dFNjcmlwdCAob3V0cHV0T2JqZWN0LCBteUlkLCBjb21taXRtZW50VHhEZXB0aCwgc2VjcmV0TWFwKSB7XG4gICAgbGV0IGNzdkRlbGF5ID0gb3V0cHV0T2JqZWN0LmNzdkRlbGF5IHx8IENvbnN0cy5DU1ZfREVMQVlcbiAgICBpZiAobXlJZCA9PT0gb3V0cHV0T2JqZWN0LmNoYW5uZWxEZXN0SWQgJiYgcGFyc2VJbnQoY29tbWl0bWVudFR4RGVwdGgpID49IHBhcnNlSW50KGNzdkRlbGF5KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFydGlhbFNjcmlwdFNpZzogbmV3IFNjcmlwdCgpXG4gICAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9UUlVFKSAgIC8vIHNpZ25hdHVyZSB3aWxsIGdvIGhlcmVcbiAgICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX1RSVUUpLFxuICAgICAgICBzaWdQb3M6IDBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG15SWQgIT09IG91dHB1dE9iamVjdC5jaGFubmVsRGVzdElkICYmIG91dHB1dE9iamVjdC5yZXZTZWNyZXQuYnVmKSB7XG4gICAgICBsZXQgcmV2U2VjcmV0QnVmID0gc2VjcmV0TWFwLmdldChvdXRwdXRPYmplY3QucmV2U2VjcmV0Lmhhc2gudG9TdHJpbmcoJ2hleCcpKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFydGlhbFNjcmlwdFNpZzogbmV3IFNjcmlwdCgpXG4gICAgICAgICAgLndyaXRlQnVmZmVyKHJldlNlY3JldEJ1ZilcbiAgICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX1RSVUUpICAgLy8gc2lnbmF0dXJlIHdpbGwgZ28gaGVyZVxuICAgICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfRkFMU0UpLFxuICAgICAgICBzaWdQb3M6IDFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICB9XG5cbiAgLyogc3BlbmRpbmcgZnJvbSBodGxjIHNjcmlwdCAqL1xuICBodGxjSW5wdXRTY3JpcHQgKG91dHB1dE9iamVjdCwgbXlJZCwgY29tbWl0bWVudFR4RGVwdGgsIHNlY3JldE1hcCkge1xuICAgIGxldCBjc3ZEZWxheSA9IG91dHB1dE9iamVjdC5jc3ZEZWxheSB8fCBDb25zdHMuQ1NWX0RFTEFZXG4gICAgbGV0IGh0bGNTZWNyZXRCdWYgPSBzZWNyZXRNYXAuZ2V0KG91dHB1dE9iamVjdC5odGxjU2VjcmV0Lmhhc2gudG9TdHJpbmcoJ2hleCcpKVxuXG4gICAgaWYgKG15SWQgPT09IG91dHB1dE9iamVjdC5jaGFubmVsRGVzdElkICYmIGh0bGNTZWNyZXRCdWYpIHtcbiAgICAgIC8vIHNwZW5kcyBmcm9tIGJyYW5jaCAxIG9mIGh0bGNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcnRpYWxTY3JpcHRTaWc6IG5ldyBTY3JpcHQoKVxuICAgICAgICAgIC53cml0ZUJ1ZmZlcihodGxjU2VjcmV0QnVmKVxuICAgICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfVFJVRSkgICAvLyBzaWduYXR1cmUgd2lsbCBnbyBoZXJlXG4gICAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9UUlVFKSxcbiAgICAgICAgc2lnUG9zOiAxXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChteUlkICE9PSBvdXRwdXRPYmplY3QuY2hhbm5lbERlc3RJZCAmJiBwYXJzZUludChjb21taXRtZW50VHhEZXB0aCkgPj0gcGFyc2VJbnQoY3N2RGVsYXkpKSB7XG4gICAgICAvLyBzcGVuZHMgZnJvbSBicmFuY2ggMiBvZiBodGxjXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJ0aWFsU2NyaXB0U2lnOiBuZXcgU2NyaXB0KClcbiAgICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX1RSVUUpICAgLy8gc2lnbmF0dXJlIHdpbGwgZ28gaGVyZVxuICAgICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfRkFMU0UpLFxuICAgICAgICBzaWdQb3M6IDBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICB9XG5cbiAgcmV2SHRsY0lucHV0U2NyaXB0IChvdXRwdXRPYmplY3QsIG15SWQsIGNvbW1pdG1lbnRUeERlcHRoLCBzZWNyZXRNYXApIHtcbiAgICBsZXQgbG9uZ0RlbGF5ID0gb3V0cHV0T2JqZWN0LmNzdkRlbGF5IHx8IENvbnN0cy5DU1ZfREVMQVlcbiAgICBsZXQgc2hvcnREZWxheSA9IGxvbmdEZWxheS5kaXYoQm4oMikpXG4gICAgbGV0IGh0bGNTZWNyZXRCdWYgPSBzZWNyZXRNYXAuZ2V0KG91dHB1dE9iamVjdC5odGxjU2VjcmV0Lmhhc2gudG9TdHJpbmcoJ2hleCcpKVxuICAgIGxldCByZXZTZWNyZXRCdWYgPSBzZWNyZXRNYXAuZ2V0KG91dHB1dE9iamVjdC5yZXZTZWNyZXQuaGFzaC50b1N0cmluZygnaGV4JykpXG5cbiAgICBpZiAobXlJZCA9PT0gb3V0cHV0T2JqZWN0LmNoYW5uZWxEZXN0SWQgJiYgaHRsY1NlY3JldEJ1ZiAmJiBwYXJzZUludChjb21taXRtZW50VHhEZXB0aCkgPj0gcGFyc2VJbnQoc2hvcnREZWxheSkpIHtcbiAgICAgIC8vIHNwZW5kcyBmcm9tIGJyYW5jaCAxIG9mIHJodGxjXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJ0aWFsU2NyaXB0U2lnOiBuZXcgU2NyaXB0KClcbiAgICAgICAgICAud3JpdGVCdWZmZXIoaHRsY1NlY3JldEJ1ZilcbiAgICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX1RSVUUpICAgLy8gc2lnbmF0dXJlIHdpbGwgZ28gaGVyZVxuICAgICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfVFJVRSksXG4gICAgICAgIHNpZ1BvczogMVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXlJZCAhPT0gb3V0cHV0T2JqZWN0LmNoYW5uZWxEZXN0SWQgJiYgcGFyc2VJbnQoY29tbWl0bWVudFR4RGVwdGgpID49IHBhcnNlSW50KGxvbmdEZWxheSkpIHsgLy8gY2hlY2sgQ1NWIGNvbnN0cmFpbnQgaGVyZVxuICAgICAgLy8gc3BlbmRzIGZyb20gYnJhbmNoIDIgb2Ygcmh0bGNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcnRpYWxTY3JpcHRTaWc6IG5ldyBTY3JpcHQoKVxuICAgICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfVFJVRSkgICAvLyBzaWduYXR1cmUgd2lsbCBnbyBoZXJlXG4gICAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9UUlVFKVxuICAgICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfRkFMU0UpLFxuICAgICAgICBzaWdQb3M6IDBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG15SWQgIT09IG91dHB1dE9iamVjdC5jaGFubmVsRGVzdElkICYmIHJldlNlY3JldEJ1Zikge1xuICAgICAgLy8gc3BlbmRzIGZyb20gYnJhbmNoIDMgb2Ygcmh0bGNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcnRpYWxTY3JpcHRTaWc6IG5ldyBTY3JpcHQoKVxuICAgICAgICAgIC53cml0ZUJ1ZmZlcihyZXZTZWNyZXRCdWYpXG4gICAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9UUlVFKSAgIC8vIHNpZ25hdHVyZSB3aWxsIGdvIGhlcmVcbiAgICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0ZBTFNFKVxuICAgICAgICAgIC53cml0ZU9wQ29kZShPcENvZGUuT1BfRkFMU0UpLFxuICAgICAgICBzaWdQb3M6IDFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICB9XG5cbiAgdG9QMnNoSW5wdXQgKHNjcmlwdCwgcmVkZWVtU2NyaXB0KSB7XG4gICAgaWYgKCFzY3JpcHQgfHwgIXJlZGVlbVNjcmlwdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgcGFyYW1ldGVycyBmb3IgdG9QMnNoSW5wdXQnKVxuICAgIH1cbiAgICByZXR1cm4gc2NyaXB0LndyaXRlQnVmZmVyKHJlZGVlbVNjcmlwdC50b0J1ZmZlcigpKVxuICB9XG5cbiAgYXN5bmNUb1Ayc2hPdXRwdXQgKHNjcmlwdCkge1xuICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgIGlmICghc2NyaXB0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdWZmaWNpZW50IHBhcmFtZXRlcnMgZm9yIGFzeW5jVG9QMnNoT3V0cHV0JylcbiAgICAgIH1cbiAgICAgIGxldCBzY3JpcHRIYXNoID0geWllbGQgSGFzaC5hc3luY1NoYTI1NlJpcGVtZDE2MChzY3JpcHQudG9CdWZmZXIoKSlcblxuICAgICAgcmV0dXJuIG5ldyBTY3JpcHQoKVxuICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0hBU0gxNjApXG4gICAgICAgIC53cml0ZUJ1ZmZlcihzY3JpcHRIYXNoKVxuICAgICAgICAud3JpdGVPcENvZGUoT3BDb2RlLk9QX0VRVUFMKVxuICAgIH0sIHRoaXMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTcGVuZGluZ1xuIiwiJ3VzZSBzdHJpY3QnXG5sZXQgYXNpbmsgPSByZXF1aXJlKCdhc2luaycpXG5sZXQgSGFzaCA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL2hhc2gnKVxubGV0IFN0cnVjdCA9IHJlcXVpcmUoJ3lvdXJzLWJpdGNvaW4vbGliL3N0cnVjdCcpXG5sZXQgU2NyaXB0ID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvc2NyaXB0JylcbmxldCBPcENvZGUgPSByZXF1aXJlKCd5b3Vycy1iaXRjb2luL2xpYi9vcC1jb2RlJylcblxuY2xhc3MgVHggZXh0ZW5kcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZnJvbU9iamVjdCh7fSlcbiAgfVxuXG4gIHRvUDJzaElucHV0IChzY3JpcHQsIHJlZGVlbVNjcmlwdCkge1xuICAgIGlmICghc2NyaXB0IHx8ICFyZWRlZW1TY3JpcHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdWZmaWNpZW50IHBhcmFtZXRlcnMgZm9yIHRvUDJzaElucHV0JylcbiAgICB9XG4gICAgbGV0IG5ld1NjcmlwdCA9IFNjcmlwdC5mcm9tQnVmZmVyKHNjcmlwdC50b0J1ZmZlcigpKSAvLyBjb3B5XG4gICAgbmV3U2NyaXB0LndyaXRlQnVmZmVyKHJlZGVlbVNjcmlwdC50b0J1ZmZlcigpKVxuICAgIHJldHVybiBuZXdTY3JpcHRcbiAgfVxuXG4gIGFzeW5jVG9QMnNoT3V0cHV0IChzY3JpcHQpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3VmZmljaWVudCBwYXJhbWV0ZXJzIGZvciBhc3luY1RvUDJzaE91dHB1dCcpXG4gICAgICB9XG4gICAgICBsZXQgc2NyaXB0SGFzaCA9IHlpZWxkIEhhc2guYXN5bmNTaGEyNTZSaXBlbWQxNjAoc2NyaXB0LnRvQnVmZmVyKCkpXG5cbiAgICAgIHJldHVybiBuZXcgU2NyaXB0KClcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9IQVNIMTYwKVxuICAgICAgICAud3JpdGVCdWZmZXIoc2NyaXB0SGFzaClcbiAgICAgICAgLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9FUVVBTClcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHhcbiIsIi8vIGp1c3QgYSBkdW1teSBhdCB0aGlzIHBvaW50XG4ndXNlIHN0cmljdCdcbmxldCBTdHJ1Y3QgPSByZXF1aXJlKCd5b3Vycy1iaXRjb2luL2xpYi9zdHJ1Y3QnKVxubGV0IFR4b3V0ID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvdHgtb3V0JylcbmxldCBBZGRyZXNzID0gcmVxdWlyZSgneW91cnMtYml0Y29pbi9saWIvYWRkcmVzcycpXG5cbmNsYXNzIFdhbGxldCBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5mcm9tT2JqZWN0KHt9KVxuICB9XG5cbiAgLypcbiAgICoganVzdCBhIG1vY2t1cCBhdCB0aGlzIHBvaW50XG4gICAqL1xuICBnZXRVbnNwZW50T3V0cHV0IChhbW91bnQsIHB1YmtleSkge1xuICAgIC8vIGZyb20gbGluZSA0NDQgc2NyaXRwLWV4YW1wbGVzXG4gICAgbGV0IGlucHV0VHhBZGRyZXNzID0gQWRkcmVzcy5mcm9tUHViS2V5KHB1YmtleSlcbiAgICBsZXQgc2NyaXB0UHVia2V5ID0gaW5wdXRUeEFkZHJlc3MudG9TY3JpcHQoKVxuICAgIGxldCBpbnB1dFR4SGFzaGJ1ZiA9IG5ldyBCdWZmZXIoMzIpXG4gICAgaW5wdXRUeEhhc2hidWYuZmlsbCgwKSAvLyBhIGZha2UsIG5vbi1leGlzdGVudCBpbnB1dCB0cmFuc2FjdGlvblxuICAgIGxldCBpbnB1dFR4b3V0bnVtID0gMFxuICAgIGxldCBpbnB1dFR4b3V0ID0gbmV3IFR4b3V0KGFtb3VudCkuc2V0U2NyaXB0KHNjcmlwdFB1YmtleSlcblxuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFR4b3V0OiBuZXcgVHhvdXQoYW1vdW50KS5zZXRTY3JpcHQoaW5wdXRUeEFkZHJlc3MudG9TY3JpcHQoKSksXG4gICAgICB0eGhhc2hidWY6IGlucHV0VHhIYXNoYnVmLFxuICAgICAgdHhvdXRudW06IGlucHV0VHhvdXRudW0sXG4gICAgICB0eG91dDogaW5wdXRUeG91dCxcbiAgICAgIHB1YktleTogcHVia2V5XG4gICAgfVxuICB9XG5cbiAgZnJvbUpTT04gKGpzb24pIHtcbiAgICB0aGlzLmZyb21PYmplY3Qoe30pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRvUHVibGljICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2FsbGV0XG4iLCIvKipcbiAqIGFzaW5rXG4gKiA9PT09PVxuICpcbiAqIGFzaW5rIGlzIHRoZSBzYW1lIHRoaW5nIGFzLCBvciBhIHJlbmFtZSBvZiwgc3Bhd24uIHNwYXduIGluIHR1cm4gaXMgYSB0b29sXG4gKiBmb3IgcmVwZWF0ZWRseSBjYWxsaW5nIHRoZSAudGhlbnMgb2YgcHJvbWlzZXMgeWllbGRlZCBieSBhIGdlbmVyYXRvci5cbiAqIEJhc2ljYWxseSwgdGhpcyBtYWtlcyBpdCBwb3NzaWJsZSB0byB3cml0ZSBhc3luY2hyb25vdXMsIHByb21pc2lmaWVkIGNvZGVcbiAqIHdpdGggbm9ybWFsIHRyeS9jYXRjaGVzIHRoYXQgbG9vayBqdXN0IGxpa2Ugc3luY2hyb25vdXMgY29kZS4gSXQgY3JlYXRlc1xuICogc2hvcnRlciBhbmQgZWFzaWVyIHRvIHVuZGVyc3RhbmQgY29kZS4gSHlwb3RoZXRpY2FsbHksIHRoZXJlIHdpbGwgYmUgYVxuICogZmVhdHVyZSBpbiB0aGUgbmV4dCB2ZXJzaW9uIG9mIGphdmFzY3JpcHQsIEVTNywgY2FsbGVkIFwiYXN5bmMgZnVuY3Rpb25zXCIsXG4gKiB3aGljaCBkbyBleGFjdGx5IHdoYXQgYXNpbmsgZG9lcy4gV2hlbi9pZiB0aGF0IGhhcHBlbnMgYW5kIHdlIGNhbiBhY2Nlc3MgaXRcbiAqIGluIG5vZGUsIHdlIGNhbiBzaW1wbHkgcmVtb3ZlIGFsbCBjYWxscyB0byBhc2luayBhbmQgb3VyIGNvZGUgc2hvdWxkIGJlaGF2ZVxuICogaW4gdGhlIHNhbWUgd2F5LlxuICpcbiAqIFNlZTpcbiAqIGh0dHA6Ly90YzM5LmdpdGh1Yi5pby9lY21hc2NyaXB0LWFzeW5jYXdhaXQvXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hc2NyaXB0LWFzeW5jYXdhaXRcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2pha2VhcmNoaWJhbGQvMzFiODljYmE2Mjc5MjQ5NzJhZDZcbiAqIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2VzNi9wcm9taXNlcy9cbiAqIGh0dHBzOi8vYmxvZ3Mud2luZG93cy5jb20vbXNlZGdlZGV2LzIwMTUvMDkvMzAvYXN5bmNocm9ub3VzLWNvZGUtZ2V0cy1lYXNpZXItd2l0aC1lczIwMTYtYXN5bmMtZnVuY3Rpb24tc3VwcG9ydC1pbi1jaGFrcmEtYW5kLW1pY3Jvc29mdC1lZGdlL1xuICovXG4ndXNlIHN0cmljdCdcbmZ1bmN0aW9uIHNwYXduIChnZW5GLCBzZWxmKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGdlbiA9IGdlbkYuY2FsbChzZWxmKVxuICAgIGZ1bmN0aW9uIHN0ZXAgKG5leHRGKSB7XG4gICAgICB2YXIgbmV4dFxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV4dCA9IG5leHRGKClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZmluaXNoZWQgd2l0aCBmYWlsdXJlLCByZWplY3QgdGhlIHByb21pc2VcbiAgICAgICAgcmVqZWN0KGUpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICAvLyBmaW5pc2hlZCB3aXRoIHN1Y2Nlc3MsIHJlc29sdmUgdGhlIHByb21pc2VcbiAgICAgICAgcmVzb2x2ZShuZXh0LnZhbHVlKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIG5vdCBmaW5pc2hlZCwgY2hhaW4gb2ZmIHRoZSB5aWVsZGVkIHByb21pc2UgYW5kIGBzdGVwYCBhZ2FpblxuICAgICAgUHJvbWlzZS5yZXNvbHZlKG5leHQudmFsdWUpLnRoZW4oZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgc3RlcChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW4ubmV4dCh2KSB9KVxuICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc3RlcChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW4udGhyb3coZSkgfSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHN0ZXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuLm5leHQodW5kZWZpbmVkKSB9KVxuICB9KVxufVxubW9kdWxlLmV4cG9ydHMgPSBzcGF3blxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL3NoaW1cIik7XG5cbnJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWVcIik7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGVcIik7XG5cbmlmIChnbG9iYWwuX2JhYmVsUG9seWZpbGwpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgaW5zdGFuY2Ugb2YgYmFiZWwtcG9seWZpbGwgaXMgYWxsb3dlZFwiKTtcbn1cbmdsb2JhbC5fYmFiZWxQb2x5ZmlsbCA9IHRydWU7XG5cbnZhciBERUZJTkVfUFJPUEVSVFkgPSBcImRlZmluZVByb3BlcnR5XCI7XG5mdW5jdGlvbiBkZWZpbmUoTywga2V5LCB2YWx1ZSkge1xuICBPW2tleV0gfHwgT2JqZWN0W0RFRklORV9QUk9QRVJUWV0oTywga2V5LCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cblxuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkTGVmdFwiLCBcIlwiLnBhZFN0YXJ0KTtcbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZFJpZ2h0XCIsIFwiXCIucGFkRW5kKTtcblxuXCJwb3AscmV2ZXJzZSxzaGlmdCxrZXlzLHZhbHVlcyxlbnRyaWVzLGluZGV4T2YsZXZlcnksc29tZSxmb3JFYWNoLG1hcCxmaWx0ZXIsZmluZCxmaW5kSW5kZXgsaW5jbHVkZXMsam9pbixzbGljZSxjb25jYXQscHVzaCxzcGxpY2UsdW5zaGlmdCxzb3J0LGxhc3RJbmRleE9mLHJlZHVjZSxyZWR1Y2VSaWdodCxjb3B5V2l0aGluLGZpbGxcIi5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFtdW2tleV0gJiYgZGVmaW5lKEFycmF5LCBrZXksIEZ1bmN0aW9uLmNhbGwuYmluZChbXVtrZXldKSk7XG59KTsiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBtc2cpe1xuICBpZih0eXBlb2YgaXQgIT0gJ251bWJlcicgJiYgY29mKGl0KSAhPSAnTnVtYmVyJyl0aHJvdyBUeXBlRXJyb3IobXNnKTtcbiAgcmV0dXJuICtpdDtcbn07IiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJylcbiAgLCBBcnJheVByb3RvICA9IEFycmF5LnByb3RvdHlwZTtcbmlmKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZClyZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCl7XG4gIGlmKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKXtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldC8qPSAwKi8sIHN0YXJ0Lyo9IDAsIGVuZCA9IEBsZW5ndGgqLyl7XG4gIHZhciBPICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgLCBsZW4gICA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxuICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgLCBlbmQgICA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkXG4gICAgLCBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKVxuICAgICwgaW5jICAgPSAxO1xuICBpZihmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpe1xuICAgIGluYyAgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byAgICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZShjb3VudC0tID4gMCl7XG4gICAgaWYoZnJvbSBpbiBPKU9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byAgICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07IiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0ID0gMCwgZW5kID0gQGxlbmd0aCAqLyl7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGlzKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCAgPSB0b0luZGV4KGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpXG4gICAgLCBlbmQgICAgPSBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZFxuICAgICwgZW5kUG9zID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUoZW5kUG9zID4gaW5kZXgpT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlciwgSVRFUkFUT1Ipe1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59OyIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFzYyAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVFlQRSwgJGNyZWF0ZSl7XG4gIHZhciBJU19NQVAgICAgICAgID0gVFlQRSA9PSAxXG4gICAgLCBJU19GSUxURVIgICAgID0gVFlQRSA9PSAyXG4gICAgLCBJU19TT01FICAgICAgID0gVFlQRSA9PSAzXG4gICAgLCBJU19FVkVSWSAgICAgID0gVFlQRSA9PSA0XG4gICAgLCBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2XG4gICAgLCBOT19IT0xFUyAgICAgID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVhcbiAgICAsIGNyZWF0ZSAgICAgICAgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KXtcbiAgICB2YXIgTyAgICAgID0gdG9PYmplY3QoJHRoaXMpXG4gICAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAgICwgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWRcbiAgICAgICwgdmFsLCByZXM7XG4gICAgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKXtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2luZGV4XSA9IHJlczsgICAgICAgICAgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZihyZXMpc3dpdGNoKFRZUEUpe1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiByZXN1bHQucHVzaCh2YWwpOyAgICAgICAgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYoSVNfRVZFUlkpcmV0dXJuIGZhbHNlOyAgICAgICAgICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTsiLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KXtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhhdClcbiAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgaW5kZXggID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwXG4gICAgLCBpICAgICAgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZihhTGVuIDwgMilmb3IoOzspe1xuICAgIGlmKGluZGV4IGluIHNlbGYpe1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvcig7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSlpZihpbmRleCBpbiBzZWxmKXtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGlzQXJyYXkgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIFNQRUNJRVMgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCl7XG4gIHZhciBDO1xuICBpZihpc0FycmF5KG9yaWdpbmFsKSl7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKUMgPSB1bmRlZmluZWQ7XG4gICAgaWYoaXNPYmplY3QoQykpe1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZihDID09PSBudWxsKUMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59OyIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwsIGxlbmd0aCl7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaW52b2tlICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlXG4gICwgZmFjdG9yaWVzICA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24oRiwgbGVuLCBhcmdzKXtcbiAgaWYoIShsZW4gaW4gZmFjdG9yaWVzKSl7XG4gICAgZm9yKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qLCBhcmdzLi4uICovKXtcbiAgdmFyIGZuICAgICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbigvKiBhcmdzLi4uICovKXtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYoaXNPYmplY3QoZm4ucHJvdG90eXBlKSlib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07IiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmb3JPZiAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpXG4gICwgc3RlcCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIHNldFNwZWNpZXMgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIGZhc3RLZXkgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXlcbiAgLCBTSVpFICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24odGhhdCwga2V5KXtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KSwgZW50cnk7XG4gIGlmKGluZGV4ICE9PSAnRicpcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgaWYoZW50cnkuayA9PSBrZXkpcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCl7XG4gICAgICAgIGZvcih2YXIgdGhhdCA9IHRoaXMsIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKGVudHJ5LnApZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAgICwgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZihlbnRyeSl7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uXG4gICAgICAgICAgICAsIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmKHByZXYpcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZihuZXh0KW5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYodGhhdC5fZiA9PSBlbnRyeSl0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZih0aGF0Ll9sID09IGVudHJ5KXRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCAnZm9yRWFjaCcpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMylcbiAgICAgICAgICAsIGVudHJ5O1xuICAgICAgICB3aGlsZShlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2Ype1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSl7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYoREVTQ1JJUFRPUlMpZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gZGVmaW5lZCh0aGlzW1NJWkVdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpXG4gICAgICAsIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmKGVudHJ5KXtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmKCF0aGF0Ll9mKXRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmKHByZXYpcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmKGluZGV4ICE9PSAnRicpdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24oQywgTkFNRSwgSVNfTUFQKXtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICAgICAgdGhpcy5fdCA9IGl0ZXJhdGVkOyAgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICwga2luZCAgPSB0aGF0Ll9rXG4gICAgICAgICwgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZighdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKXtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycgLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIGZyb20gICAgPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgaWYoY2xhc3NvZih0aGlzKSAhPSBOQU1FKXRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZ2V0V2VhayAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2Vha1xuICAsIGFuT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpXG4gICwgJGhhcyAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIGFycmF5RmluZCAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgLCBhcnJheUZpbmRJbmRleCAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpXG4gICwgaWQgICAgICAgICAgICAgICAgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24odGhhdCl7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uKHN0b3JlLCBrZXkpe1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZihlbnRyeSlyZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZihlbnRyeSllbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZih+aW5kZXgpdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYoZGF0YSA9PT0gdHJ1ZSl1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsICRleHBvcnQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCByZWRlZmluZUFsbCAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgbWV0YSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgaXNPYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZhaWxzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsICRpdGVyRGV0ZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKVxuICAsIHNldFRvU3RyaW5nVGFnICAgID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKXtcbiAgdmFyIEJhc2UgID0gZ2xvYmFsW05BTUVdXG4gICAgLCBDICAgICA9IEJhc2VcbiAgICAsIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJ1xuICAgICwgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlXG4gICAgLCBPICAgICA9IHt9O1xuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24oS0VZKXtcbiAgICB2YXIgZm4gPSBwcm90b1tLRVldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBLRVksXG4gICAgICBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbihhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IHVuZGVmaW5lZCA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSl7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiBzZXQoYSwgYil7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTsgcmV0dXJuIHRoaXM7IH1cbiAgICApO1xuICB9O1xuICBpZih0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKXtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluc3RhbmNlICAgICAgICAgICAgID0gbmV3IENcbiAgICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICAgICwgSEFTTlRfQ0hBSU5JTkcgICAgICAgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlXG4gICAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICAgICwgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbigpeyBpbnN0YW5jZS5oYXMoMSk7IH0pXG4gICAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgICAsIEFDQ0VQVF9JVEVSQUJMRVMgICAgID0gJGl0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7IG5ldyBDKGl0ZXIpOyB9KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgICAsIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBDKClcbiAgICAgICAgICAsIGluZGV4ICAgICA9IDU7XG4gICAgICAgIHdoaWxlKGluZGV4LS0pJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgICAgfSk7XG4gICAgaWYoIUFDQ0VQVF9JVEVSQUJMRVMpeyBcbiAgICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgaXRlcmFibGUpe1xuICAgICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UsIHRhcmdldCwgQyk7XG4gICAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgcHJvdG8uY29uc3RydWN0b3IgPSBDO1xuICAgIH1cbiAgICBpZihUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKXtcbiAgICAgIGZpeE1ldGhvZCgnZGVsZXRlJyk7XG4gICAgICBmaXhNZXRob2QoJ2hhcycpO1xuICAgICAgSVNfTUFQICYmIGZpeE1ldGhvZCgnZ2V0Jyk7XG4gICAgfVxuICAgIGlmKEJVR0dZX1pFUk8gfHwgSEFTTlRfQ0hBSU5JTkcpZml4TWV0aG9kKEFEREVSKTtcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmKElTX1dFQUsgJiYgcHJvdG8uY2xlYXIpZGVsZXRlIHByb3RvLmNsZWFyO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEMgIT0gQmFzZSksIE8pO1xuXG4gIGlmKCFJU19XRUFLKWNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XG4gIGlmKGluZGV4IGluIG9iamVjdCkkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTsiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIE5VTUJFUiAgICAgID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGludCl7XG4gIGlmKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xuICByZXR1cm4gdG9QcmltaXRpdmUoYW5PYmplY3QodGhpcyksIGhpbnQgIT0gTlVNQkVSKTtcbn07IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTsiLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSlcbiAgICAsIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQpcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dClleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoKGUpe1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaChmKXsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG52YXIgaGlkZSAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBmYWlscyAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHdrcyAgICAgID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBsZW5ndGgsIGV4ZWMpe1xuICB2YXIgU1lNQk9MICAgPSB3a3MoS0VZKVxuICAgICwgZm5zICAgICAgPSBleGVjKGRlZmluZWQsIFNZTUJPTCwgJydbS0VZXSlcbiAgICAsIHN0cmZuICAgID0gZm5zWzBdXG4gICAgLCByeGZuICAgICA9IGZuc1sxXTtcbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9O1xuICAgIHJldHVybiAnJ1tLRVldKE8pICE9IDc7XG4gIH0pKXtcbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uKHN0cmluZywgYXJnKXsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbihzdHJpbmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHRoYXQgICA9IGFuT2JqZWN0KHRoaXMpXG4gICAgLCByZXN1bHQgPSAnJztcbiAgaWYodGhhdC5nbG9iYWwpICAgICByZXN1bHQgKz0gJ2cnO1xuICBpZih0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmKHRoYXQubXVsdGlsaW5lKSAgcmVzdWx0ICs9ICdtJztcbiAgaWYodGhhdC51bmljb2RlKSAgICByZXN1bHQgKz0gJ3UnO1xuICBpZih0aGF0LnN0aWNreSkgICAgIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59OyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgLCBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTsiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCB0YXJnZXQsIEMpe1xuICB2YXIgUCwgUyA9IHRhcmdldC5jb25zdHJ1Y3RvcjtcbiAgaWYoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZil7XG4gICAgc2V0UHJvdG90eXBlT2YodGhhdCwgUCk7XG4gIH0gcmV0dXJuIHRoYXQ7XG59OyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTsiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTsiLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgSVRFUkFUT1IgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07IiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZsb29yICAgID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KXtcbiAgcmV0dXJuICFpc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTsiLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgY29mICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIE1BVENIICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59OyIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoKGUpe1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYocmV0ICE9PSB1bmRlZmluZWQpYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTsiLCJ2YXIgSVRFUkFUT1IgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbigpeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xuICBBcnJheS5mcm9tKHJpdGVyLCBmdW5jdGlvbigpeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjLCBza2lwQ2xvc2luZyl7XG4gIGlmKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKXJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyICA9IFs3XVxuICAgICAgLCBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uKCl7IHJldHVybiB7ZG9uZTogc2FmZSA9IHRydWV9OyB9O1xuICAgIGFycltJVEVSQVRPUl0gPSBmdW5jdGlvbigpeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTsiLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xOyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07IiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTsiLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTsiLCJ2YXIgTWFwICAgICA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpXG4gICwgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2hhcmVkICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdtZXRhZGF0YScpXG4gICwgc3RvcmUgICA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSk7XG5cbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSl7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICBpZighdGFyZ2V0TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBzdG9yZS5zZXQodGFyZ2V0LCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9XG4gIHZhciBrZXlNZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhLmdldCh0YXJnZXRLZXkpO1xuICBpZigha2V5TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0YXJnZXRNZXRhZGF0YS5zZXQodGFyZ2V0S2V5LCBrZXlNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9IHJldHVybiBrZXlNZXRhZGF0YTtcbn07XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApe1xuICBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59O1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXkpe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSlcbiAgICAsIGtleXMgICAgICAgID0gW107XG4gIGlmKG1ldGFkYXRhTWFwKW1ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24oXywga2V5KXsga2V5cy5wdXNoKGtleSk7IH0pO1xuICByZXR1cm4ga2V5cztcbn07XG52YXIgdG9NZXRhS2V5ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xudmFyIGV4cCA9IGZ1bmN0aW9uKE8pe1xuICAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCBPKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yZTogc3RvcmUsXG4gIG1hcDogZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCxcbiAgaGFzOiBvcmRpbmFyeUhhc093bk1ldGFkYXRhLFxuICBnZXQ6IG9yZGluYXJ5R2V0T3duTWV0YWRhdGEsXG4gIHNldDogb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSxcbiAga2V5czogb3JkaW5hcnlPd25NZXRhZGF0YUtleXMsXG4gIGtleTogdG9NZXRhS2V5LFxuICBleHA6IGV4cFxufTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBtYWNyb3Rhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgT2JzZXJ2ZXIgID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXJcbiAgLCBwcm9jZXNzICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIFByb21pc2UgICA9IGdsb2JhbC5Qcm9taXNlXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZihpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSlwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlKGhlYWQpe1xuICAgICAgZm4gICA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIGlmKGhlYWQpbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYocGFyZW50KXBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYoaXNOb2RlKXtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcbiAgLy8gYnJvd3NlcnMgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gIH0gZWxzZSBpZihPYnNlcnZlcil7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICwgbm9kZSAgID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZihQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSl7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oZm4pe1xuICAgIHZhciB0YXNrID0ge2ZuOiBmbiwgbmV4dDogdW5kZWZpbmVkfTtcbiAgICBpZihsYXN0KWxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYoIWhlYWQpe1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTsiLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCAkYXNzaWduICA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgYUxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmZcbiAgICAsIGlzRW51bSAgICAgPSBwSUUuZjtcbiAgd2hpbGUoYUxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduOyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07IiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTsiLCIvLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKXx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBLID0gTWF0aC5yYW5kb20oKTtcbiAgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcbiAgX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG51bGwsIEssIGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovfSk7XG4gIGRlbGV0ZSByZXF1aXJlKCcuL19nbG9iYWwnKVtLXTtcbn0pOyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTsiLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTsiLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYoaGFzKE8sIElFX1BST1RPKSlyZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07IiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07IiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBpc0VudW0gICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNFbnRyaWVzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KGl0KVxuICAgICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGkgICAgICA9IDBcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSl7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59OyIsIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgUmVmbGVjdCAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KXtcbiAgdmFyIGtleXMgICAgICAgPSBnT1BOLmYoYW5PYmplY3QoaXQpKVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTsiLCJ2YXIgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUZsb2F0XG4gICwgJHRyaW0gICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW07XG5cbm1vZHVsZS5leHBvcnRzID0gMSAvICRwYXJzZUZsb2F0KHJlcXVpcmUoJy4vX3N0cmluZy13cycpICsgJy0wJykgIT09IC1JbmZpbml0eSA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKVxuICAgICwgcmVzdWx0ID0gJHBhcnNlRmxvYXQoc3RyaW5nKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gMCAmJiBzdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6ICRwYXJzZUZsb2F0OyIsInZhciAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wYXJzZUludFxuICAsICR0cmltICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIHdzICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgaGV4ICAgICAgID0gL15bXFwtK10/MFt4WF0vO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRwYXJzZUludCh3cyArICcwOCcpICE9PSA4IHx8ICRwYXJzZUludCh3cyArICcweDE2JykgIT09IDIyID8gZnVuY3Rpb24gcGFyc2VJbnQoc3RyLCByYWRpeCl7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiAkcGFyc2VJbnQoc3RyaW5nLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChzdHJpbmcpID8gMTYgOiAxMCkpO1xufSA6ICRwYXJzZUludDsiLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCAgICAgID0gcmVxdWlyZSgnLi9fcGF0aCcpXG4gICwgaW52b2tlICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKC8qIC4uLnBhcmdzICovKXtcbiAgdmFyIGZuICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgcGFyZ3MgID0gQXJyYXkobGVuZ3RoKVxuICAgICwgaSAgICAgID0gMFxuICAgICwgXyAgICAgID0gcGF0aC5fXG4gICAgLCBob2xkZXIgPSBmYWxzZTtcbiAgd2hpbGUobGVuZ3RoID4gaSlpZigocGFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXSkgPT09IF8paG9sZGVyID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBqID0gMCwgayA9IDAsIGFyZ3M7XG4gICAgaWYoIWhvbGRlciAmJiAhYUxlbilyZXR1cm4gaW52b2tlKGZuLCBwYXJncywgdGhhdCk7XG4gICAgYXJncyA9IHBhcmdzLnNsaWNlKCk7XG4gICAgaWYoaG9sZGVyKWZvcig7bGVuZ3RoID4gajsgaisrKWlmKGFyZ3Nbal0gPT09IF8pYXJnc1tqXSA9IGFyZ3VtZW50c1trKytdO1xuICAgIHdoaWxlKGFMZW4gPiBrKWFyZ3MucHVzaChhcmd1bWVudHNbaysrXSk7XG4gICAgcmV0dXJuIGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgU1JDICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpXG4gICwgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR11cbiAgLCBUUEwgICAgICAgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmKE9ba2V5XSA9PT0gdmFsKXJldHVybjtcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYoTyA9PT0gZ2xvYmFsKXtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYoIXNhZmUpe1xuICAgICAgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihPW2tleV0pT1trZXldID0gdmFsO1xuICAgICAgZWxzZSBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVnRXhwLCByZXBsYWNlKXtcbiAgdmFyIHJlcGxhY2VyID0gcmVwbGFjZSA9PT0gT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24ocGFydCl7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBTdHJpbmcoaXQpLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlcik7XG4gIH07XG59OyIsIi8vIDcuMi45IFNhbWVWYWx1ZSh4LCB5KVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSl7XG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTsiLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59OyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTsiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59OyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07IiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIGFyZyl7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uKCl7fSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59OyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59OyIsIi8vIGhlbHBlciBmb3IgU3RyaW5nI3tzdGFydHNXaXRoLCBlbmRzV2l0aCwgaW5jbHVkZXN9XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSl7XG4gIGlmKGlzUmVnRXhwKHNlYXJjaFN0cmluZykpdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59OyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBxdW90ICAgID0gL1wiL2c7XG4vLyBCLjIuMy4yLjEgQ3JlYXRlSFRNTChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSlcbnZhciBjcmVhdGVIVE1MID0gZnVuY3Rpb24oc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSlcbiAgICAsIHAxID0gJzwnICsgdGFnO1xuICBpZihhdHRyaWJ1dGUgIT09ICcnKXAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgU3RyaW5nKHZhbHVlKS5yZXBsYWNlKHF1b3QsICcmcXVvdDsnKSArICdcIic7XG4gIHJldHVybiBwMSArICc+JyArIFMgKyAnPC8nICsgdGFnICsgJz4nO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgZXhlYyl7XG4gIHZhciBPID0ge307XG4gIE9bTkFNRV0gPSBleGVjKGNyZWF0ZUhUTUwpO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRlc3QgPSAnJ1tOQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSksICdTdHJpbmcnLCBPKTtcbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgcmVwZWF0ICAgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0JylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcsIGxlZnQpe1xuICB2YXIgUyAgICAgICAgICAgID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgLCBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aFxuICAgICwgZmlsbFN0ciAgICAgID0gZmlsbFN0cmluZyA9PT0gdW5kZWZpbmVkID8gJyAnIDogU3RyaW5nKGZpbGxTdHJpbmcpXG4gICAgLCBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICBpZihpbnRNYXhMZW5ndGggPD0gc3RyaW5nTGVuZ3RoIHx8IGZpbGxTdHIgPT0gJycpcmV0dXJuIFM7XG4gIHZhciBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoXG4gICAgLCBzdHJpbmdGaWxsZXIgPSByZXBlYXQuY2FsbChmaWxsU3RyLCBNYXRoLmNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKXN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIGxlZnQgPyBzdHJpbmdGaWxsZXIgKyBTIDogUyArIHN0cmluZ0ZpbGxlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChjb3VudCl7XG4gIHZhciBzdHIgPSBTdHJpbmcoZGVmaW5lZCh0aGlzKSlcbiAgICAsIHJlcyA9ICcnXG4gICAgLCBuICAgPSB0b0ludGVnZXIoY291bnQpO1xuICBpZihuIDwgMCB8fCBuID09IEluZmluaXR5KXRocm93IFJhbmdlRXJyb3IoXCJDb3VudCBjYW4ndCBiZSBuZWdhdGl2ZVwiKTtcbiAgZm9yKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpaWYobiAmIDEpcmVzICs9IHN0cjtcbiAgcmV0dXJuIHJlcztcbn07IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNwYWNlcyAgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKVxuICAsIHNwYWNlICAgPSAnWycgKyBzcGFjZXMgKyAnXSdcbiAgLCBub24gICAgID0gJ1xcdTIwMGJcXHUwMDg1J1xuICAsIGx0cmltICAgPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJylcbiAgLCBydHJpbSAgID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24oS0VZLCBleGVjLCBBTElBUyl7XG4gIHZhciBleHAgICA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZihBTElBUylleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24oc3RyaW5nLCBUWVBFKXtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmKFRZUEUgJiAxKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmKFRZUEUgJiAyKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyOyIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJzsiLCJ2YXIgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBpbnZva2UgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGh0bWwgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNlbCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBzZXRUYXNrICAgICAgICAgICAgPSBnbG9iYWwuc2V0SW1tZWRpYXRlXG4gICwgY2xlYXJUYXNrICAgICAgICAgID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlXG4gICwgTWVzc2FnZUNoYW5uZWwgICAgID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsXG4gICwgY291bnRlciAgICAgICAgICAgID0gMFxuICAsIHF1ZXVlICAgICAgICAgICAgICA9IHt9XG4gICwgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSdcbiAgLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcbnZhciBydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgaWQgPSArdGhpcztcbiAgaWYocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpe1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZighc2V0VGFzayB8fCAhY2xlYXJUYXNrKXtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbil7XG4gICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24oKXtcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCl7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYoTWVzc2FnZUNoYW5uZWwpe1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWw7XG4gICAgcG9ydCAgICA9IGNoYW5uZWwucG9ydDI7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaXN0ZW5lcjtcbiAgICBkZWZlciA9IGN0eChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHNldFRpbWVvdXQoY3R4KHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiAgIHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSl7XG4gIHZhciBMSUJSQVJZICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICAgLCBnbG9iYWwgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgICAsIGZhaWxzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICAgLCAkZXhwb3J0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgICAsICR0eXBlZCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICAgLCAkYnVmZmVyICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgICAsIGN0eCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAgICwgYW5JbnN0YW5jZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgICAsIHByb3BlcnR5RGVzYyAgICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgICAsIGhpZGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgICAsIHJlZGVmaW5lQWxsICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAgICwgdG9JbnRlZ2VyICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAgICwgdG9MZW5ndGggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICAgLCB0b0luZGV4ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAgICwgdG9QcmltaXRpdmUgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICAgLCBoYXMgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgICAsIHNhbWUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJylcbiAgICAsIGNsYXNzb2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgICAsIGlzT2JqZWN0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAgICwgdG9PYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICAgLCBpc0FycmF5SXRlciAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICAgLCBjcmVhdGUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICAgLCBnZXRQcm90b3R5cGVPZiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICAgLCBnT1BOICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICAgLCBnZXRJdGVyRm4gICAgICAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAgICwgdWlkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICAgLCB3a3MgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgICAsIGNyZWF0ZUFycmF5TWV0aG9kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgICAsIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpXG4gICAgLCBzcGVjaWVzQ29uc3RydWN0b3IgID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICAgLCBBcnJheUl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAgICwgSXRlcmF0b3JzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICAgLCAkaXRlckRldGVjdCAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKVxuICAgICwgc2V0U3BlY2llcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgICAsIGFycmF5RmlsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgICAsIGFycmF5Q29weVdpdGhpbiAgICAgPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpXG4gICAgLCAkRFAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgICAsICRHT1BEICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICAgLCBkUCAgICAgICAgICAgICAgICAgID0gJERQLmZcbiAgICAsIGdPUEQgICAgICAgICAgICAgICAgPSAkR09QRC5mXG4gICAgLCBSYW5nZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlJhbmdlRXJyb3JcbiAgICAsIFR5cGVFcnJvciAgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICAgLCBVaW50OEFycmF5ICAgICAgICAgID0gZ2xvYmFsLlVpbnQ4QXJyYXlcbiAgICAsIEFSUkFZX0JVRkZFUiAgICAgICAgPSAnQXJyYXlCdWZmZXInXG4gICAgLCBTSEFSRURfQlVGRkVSICAgICAgID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVJcbiAgICAsIEJZVEVTX1BFUl9FTEVNRU5UICAgPSAnQllURVNfUEVSX0VMRU1FTlQnXG4gICAgLCBQUk9UT1RZUEUgICAgICAgICAgID0gJ3Byb3RvdHlwZSdcbiAgICAsIEFycmF5UHJvdG8gICAgICAgICAgPSBBcnJheVtQUk9UT1RZUEVdXG4gICAgLCAkQXJyYXlCdWZmZXIgICAgICAgID0gJGJ1ZmZlci5BcnJheUJ1ZmZlclxuICAgICwgJERhdGFWaWV3ICAgICAgICAgICA9ICRidWZmZXIuRGF0YVZpZXdcbiAgICAsIGFycmF5Rm9yRWFjaCAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgwKVxuICAgICwgYXJyYXlGaWx0ZXIgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpXG4gICAgLCBhcnJheVNvbWUgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMylcbiAgICAsIGFycmF5RXZlcnkgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg0KVxuICAgICwgYXJyYXlGaW5kICAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpXG4gICAgLCBhcnJheUZpbmRJbmRleCAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgICAsIGFycmF5SW5jbHVkZXMgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpXG4gICAgLCBhcnJheUluZGV4T2YgICAgICAgID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSlcbiAgICAsIGFycmF5VmFsdWVzICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXNcbiAgICAsIGFycmF5S2V5cyAgICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5rZXlzXG4gICAgLCBhcnJheUVudHJpZXMgICAgICAgID0gQXJyYXlJdGVyYXRvcnMuZW50cmllc1xuICAgICwgYXJyYXlMYXN0SW5kZXhPZiAgICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2ZcbiAgICAsIGFycmF5UmVkdWNlICAgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZVxuICAgICwgYXJyYXlSZWR1Y2VSaWdodCAgICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHRcbiAgICAsIGFycmF5Sm9pbiAgICAgICAgICAgPSBBcnJheVByb3RvLmpvaW5cbiAgICAsIGFycmF5U29ydCAgICAgICAgICAgPSBBcnJheVByb3RvLnNvcnRcbiAgICAsIGFycmF5U2xpY2UgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlXG4gICAgLCBhcnJheVRvU3RyaW5nICAgICAgID0gQXJyYXlQcm90by50b1N0cmluZ1xuICAgICwgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmdcbiAgICAsIElURVJBVE9SICAgICAgICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgICAsIFRBRyAgICAgICAgICAgICAgICAgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgICAsIFRZUEVEX0NPTlNUUlVDVE9SICAgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJylcbiAgICAsIERFRl9DT05TVFJVQ1RPUiAgICAgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpXG4gICAgLCBBTExfQ09OU1RSVUNUT1JTICAgID0gJHR5cGVkLkNPTlNUUlxuICAgICwgVFlQRURfQVJSQVkgICAgICAgICA9ICR0eXBlZC5UWVBFRFxuICAgICwgVklFVyAgICAgICAgICAgICAgICA9ICR0eXBlZC5WSUVXXG4gICAgLCBXUk9OR19MRU5HVEggICAgICAgID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24oTywgbGVuZ3RoKXtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHN0cmljdFRvTGVuZ3RoID0gZnVuY3Rpb24oaXQsIFNBTUUpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdmFyIG51bWJlciA9ICtpdFxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChpdCk7XG4gICAgaWYoU0FNRSAmJiAhc2FtZShudW1iZXIsIGxlbmd0aCkpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH07XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24oaXQsIEJZVEVTKXtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgICBpZihpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24oQywgbGVuZ3RoKXtcbiAgICBpZighKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKXtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24oTywgbGlzdCl7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbihDLCBsaXN0KXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBsZW5ndGggPSBsaXN0Lmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKGl0LCBrZXksIGludGVybmFsKXtcbiAgICBkUChpdCwga2V5LCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH19KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiwgbWFwZm4sIHRoaXNBcmcgKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3Qoc291cmNlKVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKXtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmKG1hcHBpbmcgJiYgYUxlbiA+IDIpbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKyl7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKi4uLml0ZW1zKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKXtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyosIGVuZCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qLCBzdGFydCwgZW5kICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qLCBpbml0aWFsVmFsdWUgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKXtcbiAgICAgIHZhciB0aGF0ICAgPSB0aGlzXG4gICAgICAgICwgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoXG4gICAgICAgICwgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKVxuICAgICAgICAsIGluZGV4ICA9IDBcbiAgICAgICAgLCB2YWx1ZTtcbiAgICAgIHdoaWxlKGluZGV4IDwgbWlkZGxlKXtcbiAgICAgICAgdmFsdWUgICAgICAgICA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSAgPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpe1xuICAgICAgdmFyIE8gICAgICA9IHZhbGlkYXRlKHRoaXMpXG4gICAgICAgICwgbGVuZ3RoID0gTy5sZW5ndGhcbiAgICAgICAgLCAkYmVnaW4gPSB0b0luZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qLCBvZmZzZXQgKi8pe1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpXG4gICAgICAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgICAsIHNyYyAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgbGVuICAgID0gdG9MZW5ndGgoc3JjLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICBpZihsZW4gKyBvZmZzZXQgPiBsZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlKGluZGV4IDwgbGVuKXRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKXtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCl7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKXtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uKHRhcmdldCwga2V5KXtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYyl7XG4gICAgaWYoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICl7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmKCFBTExfQ09OU1RSVUNUT1JTKXtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgICA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAgICAgICAgICAgJHNldERlc2NcbiAgfSk7XG5cbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpe1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAgICAgICAgICAkc2xpY2UsXG4gICAgc2V0OiAgICAgICAgICAgICRzZXQsXG4gICAgY29uc3RydWN0b3I6ICAgIGZ1bmN0aW9uKCl7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogICAgICAgYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCl7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSAgICAgICA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5J1xuICAgICAgLCBJU05UX1VJTlQ4ID0gTkFNRSAhPSAnVWludDhBcnJheSdcbiAgICAgICwgR0VUVEVSICAgICA9ICdnZXQnICsgS0VZXG4gICAgICAsIFNFVFRFUiAgICAgPSAnc2V0JyArIEtFWVxuICAgICAgLCBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdXG4gICAgICAsIEJhc2UgICAgICAgPSBUeXBlZEFycmF5IHx8IHt9XG4gICAgICAsIFRBQyAgICAgICAgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpXG4gICAgICAsIEZPUkNFRCAgICAgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVlxuICAgICAgLCBPICAgICAgICAgID0ge31cbiAgICAgICwgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCl7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24odGhhdCwgaW5kZXgsIHZhbHVlKXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmKENMQU1QRUQpdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmKEZPUkNFRCl7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICAgICAsIG9mZnNldCA9IDBcbiAgICAgICAgICAsIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXtcbiAgICAgICAgICBsZW5ndGggICAgID0gc3RyaWN0VG9MZW5ndGgoZGF0YSwgdHJ1ZSlcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyICAgICA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZigkbGVuZ3RoID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoJGxlbiAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCA8IDApdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSl7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZShpbmRleCA8IGxlbmd0aClhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZighJGl0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7XG4gICAgICAvLyBWOCB3b3JrcyB3aXRoIGl0ZXJhdG9ycywgYnV0IGZhaWxzIGluIG1hbnkgb3RoZXIgY2FzZXNcbiAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00NTUyXG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmKCFpc09iamVjdChkYXRhKSlyZXR1cm4gbmV3IEJhc2Uoc3RyaWN0VG9MZW5ndGgoZGF0YSwgSVNOVF9VSU5UOCkpO1xuICAgICAgICBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmKFRZUEVEX0FSUkFZIGluIGRhdGEpcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGlmKCEoa2V5IGluIFR5cGVkQXJyYXkpKWhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYoIUxJQlJBUlkpVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgICA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgICAsIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3IgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZClcbiAgICAgICwgJGl0ZXJhdG9yICAgICAgICAgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSl7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVMsXG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHtzZXQ6ICRzZXR9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZyksIE5BTUUsIHt0b1N0cmluZzogYXJyYXlUb1N0cmluZ30pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpe1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwge3NsaWNlOiAkc2xpY2V9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpXG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHt0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZighTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICR0eXBlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmVBbGwgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGZhaWxzICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFuSW5zdGFuY2UgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIHRvSW50ZWdlciAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgdG9MZW5ndGggICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdPUE4gICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgYXJyYXlGaWxsICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBBUlJBWV9CVUZGRVIgICA9ICdBcnJheUJ1ZmZlcidcbiAgLCBEQVRBX1ZJRVcgICAgICA9ICdEYXRhVmlldydcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgV1JPTkdfTEVOR1RIICAgPSAnV3JvbmcgbGVuZ3RoISdcbiAgLCBXUk9OR19JTkRFWCAgICA9ICdXcm9uZyBpbmRleCEnXG4gICwgJEFycmF5QnVmZmVyICAgPSBnbG9iYWxbQVJSQVlfQlVGRkVSXVxuICAsICREYXRhVmlldyAgICAgID0gZ2xvYmFsW0RBVEFfVklFV11cbiAgLCBNYXRoICAgICAgICAgICA9IGdsb2JhbC5NYXRoXG4gICwgUmFuZ2VFcnJvciAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAsIEluZmluaXR5ICAgICAgID0gZ2xvYmFsLkluZmluaXR5XG4gICwgQmFzZUJ1ZmZlciAgICAgPSAkQXJyYXlCdWZmZXJcbiAgLCBhYnMgICAgICAgICAgICA9IE1hdGguYWJzXG4gICwgcG93ICAgICAgICAgICAgPSBNYXRoLnBvd1xuICAsIGZsb29yICAgICAgICAgID0gTWF0aC5mbG9vclxuICAsIGxvZyAgICAgICAgICAgID0gTWF0aC5sb2dcbiAgLCBMTjIgICAgICAgICAgICA9IE1hdGguTE4yXG4gICwgQlVGRkVSICAgICAgICAgPSAnYnVmZmVyJ1xuICAsIEJZVEVfTEVOR1RIICAgID0gJ2J5dGVMZW5ndGgnXG4gICwgQllURV9PRkZTRVQgICAgPSAnYnl0ZU9mZnNldCdcbiAgLCAkQlVGRkVSICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19iJyA6IEJVRkZFUlxuICAsICRMRU5HVEggICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2wnIDogQllURV9MRU5HVEhcbiAgLCAkT0ZGU0VUICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19vJyA6IEJZVEVfT0ZGU0VUO1xuXG4vLyBJRUVFNzU0IGNvbnZlcnNpb25zIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxudmFyIHBhY2tJRUVFNzU0ID0gZnVuY3Rpb24odmFsdWUsIG1MZW4sIG5CeXRlcyl7XG4gIHZhciBidWZmZXIgPSBBcnJheShuQnl0ZXMpXG4gICAgLCBlTGVuICAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgID0gZU1heCA+PiAxXG4gICAgLCBydCAgICAgPSBtTGVuID09PSAyMyA/IHBvdygyLCAtMjQpIC0gcG93KDIsIC03NykgOiAwXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBzICAgICAgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/IDEgOiAwXG4gICAgLCBlLCBtLCBjO1xuICB2YWx1ZSA9IGFicyh2YWx1ZSlcbiAgaWYodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IEluZmluaXR5KXtcbiAgICBtID0gdmFsdWUgIT0gdmFsdWUgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gZmxvb3IobG9nKHZhbHVlKSAvIExOMik7XG4gICAgaWYodmFsdWUgKiAoYyA9IHBvdygyLCAtZSkpIDwgMSl7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBwb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYodmFsdWUgKiBjID49IDIpe1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cbiAgICBpZihlICsgZUJpYXMgPj0gZU1heCl7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZihlICsgZUJpYXMgPj0gMSl7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogcG93KDIsIGVCaWFzIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cbiAgZm9yKDsgbUxlbiA+PSA4OyBidWZmZXJbaSsrXSA9IG0gJiAyNTUsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IoOyBlTGVuID4gMDsgYnVmZmVyW2krK10gPSBlICYgMjU1LCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcbiAgYnVmZmVyWy0taV0gfD0gcyAqIDEyODtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG52YXIgdW5wYWNrSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGVMZW4gID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gICAgLCBlTWF4ICA9ICgxIDw8IGVMZW4pIC0gMVxuICAgICwgZUJpYXMgPSBlTWF4ID4+IDFcbiAgICAsIG5CaXRzID0gZUxlbiAtIDdcbiAgICAsIGkgICAgID0gbkJ5dGVzIC0gMVxuICAgICwgcyAgICAgPSBidWZmZXJbaS0tXVxuICAgICwgZSAgICAgPSBzICYgMTI3XG4gICAgLCBtO1xuICBzID4+PSA3O1xuICBmb3IoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICBlID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvcig7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIGlmKGUgPT09IDApe1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZihlID09PSBlTWF4KXtcbiAgICByZXR1cm4gbSA/IE5hTiA6IHMgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIHBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9IHJldHVybiAocyA/IC0xIDogMSkgKiBtICogcG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbnZhciB1bnBhY2tJMzIgPSBmdW5jdGlvbihieXRlcyl7XG4gIHJldHVybiBieXRlc1szXSA8PCAyNCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xufTtcbnZhciBwYWNrSTggPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmXTtcbn07XG52YXIgcGFja0kxNiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmXTtcbn07XG52YXIgcGFja0kzMiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmYsIGl0ID4+IDggJiAweGZmLCBpdCA+PiAxNiAmIDB4ZmYsIGl0ID4+IDI0ICYgMHhmZl07XG59O1xudmFyIHBhY2tGNjQgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgNTIsIDgpO1xufTtcbnZhciBwYWNrRjMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDIzLCA0KTtcbn07XG5cbnZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbihDLCBrZXksIGludGVybmFsKXtcbiAgZFAoQ1tQUk9UT1RZUEVdLCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzW2ludGVybmFsXTsgfX0pO1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uKHZpZXcsIGJ5dGVzLCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBzdG9yZS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcyk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiBwYWNrLnJldmVyc2UoKTtcbn07XG52YXIgc2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBjb252ZXJzaW9uLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4pe1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXhcbiAgICAsIGludEluZGV4ID0gdG9JbnRlZ2VyKG51bUluZGV4KTtcbiAgaWYobnVtSW5kZXggIT0gaW50SW5kZXggfHwgaW50SW5kZXggPCAwIHx8IGludEluZGV4ICsgYnl0ZXMgPiB2aWV3WyRMRU5HVEhdKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgc3RvcmUgPSB2aWV3WyRCVUZGRVJdLl9iXG4gICAgLCBzdGFydCA9IGludEluZGV4ICsgdmlld1skT0ZGU0VUXVxuICAgICwgcGFjayAgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlczsgaSsrKXN0b3JlW3N0YXJ0ICsgaV0gPSBwYWNrW2lzTGl0dGxlRW5kaWFuID8gaSA6IGJ5dGVzIC0gaSAtIDFdO1xufTtcblxudmFyIHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHMgPSBmdW5jdGlvbih0aGF0LCBsZW5ndGgpe1xuICBhbkluc3RhbmNlKHRoYXQsICRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbiAgdmFyIG51bWJlckxlbmd0aCA9ICtsZW5ndGhcbiAgICAsIGJ5dGVMZW5ndGggICA9IHRvTGVuZ3RoKG51bWJlckxlbmd0aCk7XG4gIGlmKG51bWJlckxlbmd0aCAhPSBieXRlTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgcmV0dXJuIGJ5dGVMZW5ndGg7XG59O1xuXG5pZighJHR5cGVkLkFCVil7XG4gICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzKHRoaXMsIGxlbmd0aCk7XG4gICAgdGhpcy5fYiAgICAgICA9IGFycmF5RmlsbC5jYWxsKEFycmF5KGJ5dGVMZW5ndGgpLCAwKTtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICAkRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpe1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlclskTEVOR1RIXVxuICAgICAgLCBvZmZzZXQgICAgICAgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aChieXRlTGVuZ3RoKTtcbiAgICBpZihvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB0aGlzWyRCVUZGRVJdID0gYnVmZmVyO1xuICAgIHRoaXNbJE9GRlNFVF0gPSBvZmZzZXQ7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgaWYoREVTQ1JJUFRPUlMpe1xuICAgIGFkZEdldHRlcigkQXJyYXlCdWZmZXIsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCVUZGRVIsICdfYicpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfTEVOR1RILCAnX2wnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX09GRlNFVCwgJ19vJyk7XG4gIH1cblxuICByZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIGdldEludDg6IGZ1bmN0aW9uIGdldEludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpe1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gKGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXSkgPDwgMTYgPj4gMTY7XG4gICAgfSxcbiAgICBnZXRVaW50MTY6IGZ1bmN0aW9uIGdldFVpbnQxNihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSTMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCAyMywgNCk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgNTIsIDgpO1xuICAgIH0sXG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0SW50MTY6IGZ1bmN0aW9uIHNldEludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDE2OiBmdW5jdGlvbiBzZXRVaW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MzI6IGZ1bmN0aW9uIHNldFVpbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0MzI6IGZ1bmN0aW9uIHNldEZsb2F0MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0YzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGNjQsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBpZighZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyOyAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3ICRBcnJheUJ1ZmZlciguNSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pKXtcbiAgICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpe1xuICAgICAgcmV0dXJuIG5ldyBCYXNlQnVmZmVyKHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90byA9ICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQmFzZUJ1ZmZlcltQUk9UT1RZUEVdO1xuICAgIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZUJ1ZmZlciksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgKXtcbiAgICAgIGlmKCEoKGtleSA9IGtleXNbaisrXSkgaW4gJEFycmF5QnVmZmVyKSloaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBCYXNlQnVmZmVyW2tleV0pO1xuICAgIH07XG4gICAgaWYoIUxJQlJBUlkpQXJyYXlCdWZmZXJQcm90by5jb25zdHJ1Y3RvciA9ICRBcnJheUJ1ZmZlcjtcbiAgfVxuICAvLyBpT1MgU2FmYXJpIDcueCBidWdcbiAgdmFyIHZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpXG4gICAgLCAkc2V0SW50OCA9ICREYXRhVmlld1tQUk9UT1RZUEVdLnNldEludDg7XG4gIHZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdmlldy5zZXRJbnQ4KDEsIDIxNDc0ODM2NDkpO1xuICBpZih2aWV3LmdldEludDgoMCkgfHwgIXZpZXcuZ2V0SW50OCgxKSlyZWRlZmluZUFsbCgkRGF0YVZpZXdbUFJPVE9UWVBFXSwge1xuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfSxcbiAgICBzZXRVaW50ODogZnVuY3Rpb24gc2V0VWludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgJHNldEludDguY2FsbCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnNldFRvU3RyaW5nVGFnKCRBcnJheUJ1ZmZlciwgQVJSQVlfQlVGRkVSKTtcbnNldFRvU3RyaW5nVGFnKCREYXRhVmlldywgREFUQV9WSUVXKTtcbmhpZGUoJERhdGFWaWV3W1BST1RPVFlQRV0sICR0eXBlZC5WSUVXLCB0cnVlKTtcbmV4cG9ydHNbQVJSQVlfQlVGRkVSXSA9ICRBcnJheUJ1ZmZlcjtcbmV4cG9ydHNbREFUQV9WSUVXXSA9ICREYXRhVmlldzsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFRZUEVEICA9IHVpZCgndHlwZWRfYXJyYXknKVxuICAsIFZJRVcgICA9IHVpZCgndmlldycpXG4gICwgQUJWICAgID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldylcbiAgLCBDT05TVFIgPSBBQlZcbiAgLCBpID0gMCwgbCA9IDksIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZShpIDwgbCl7XG4gIGlmKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pe1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6ICAgIEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiAgVFlQRUQsXG4gIFZJRVc6ICAgVklFV1xufTsiLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTsiLCJ2YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwge3ZhbHVlOiB3a3NFeHQuZihuYW1lKX0pO1xufTsiLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTsiLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTsiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlICAgICA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywge2VzY2FwZTogZnVuY3Rpb24gZXNjYXBlKGl0KXsgcmV0dXJuICRyZShpdCk7IH19KTtcbiIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRldmVyeSAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7ZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNilcbiAgLCBLRVkgICAgID0gJ2ZpbmRJbmRleCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZpbmQgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg1KVxuICAsIEtFWSAgICAgPSAnZmluZCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4vKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKShLRVkpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCBTVFJJQ1QgICA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmRleE9mICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5pbmRleE9mXG4gICwgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIi8vIDIyLjEuMi4yIC8gMTUuNC4zLjIgQXJyYXkuaXNBcnJheShhcmcpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0FycmF5Jywge2lzQXJyYXk6IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyl9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9JbnRlZ2VyICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIHRvTGVuZ3RoICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5sYXN0SW5kZXhPZlxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ID0gQFsqLTFdICovKXtcbiAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgaWYoTkVHQVRJVkVfWkVSTylyZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCh0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gbGVuZ3RoIC0gMTtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSlpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgaWYoaW5kZXggPCAwKWluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgZm9yKDtpbmRleCA+PSAwOyBpbmRleC0tKWlmKGluZGV4IGluIE8paWYoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpcmV0dXJuIGluZGV4IHx8IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJG1hcCAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgxKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLm1hcCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE1IC8gMTUuNC40LjE5IEFycmF5LnByb3RvdHlwZS5tYXAoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkbWFwKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBGKCl7fVxuICByZXR1cm4gIShBcnJheS5vZi5jYWxsKEYpIGluc3RhbmNlb2YgRik7XG59KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMyBBcnJheS5vZiggLi4uaXRlbXMpXG4gIG9mOiBmdW5jdGlvbiBvZigvKiAuLi5hcmdzICovKXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBhTGVuICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IG5ldyAodHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheSkoYUxlbik7XG4gICAgd2hpbGUoYUxlbiA+IGluZGV4KWNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGFMZW47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZVJpZ2h0LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBodG1sICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY29mICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgdG9JbmRleCAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBpZihodG1sKWFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKXtcbiAgICB2YXIgbGVuICAgPSB0b0xlbmd0aCh0aGlzLmxlbmd0aClcbiAgICAgICwga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYoa2xhc3MgPT0gJ0FycmF5JylyZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCAgPSB0b0luZGV4KGJlZ2luLCBsZW4pXG4gICAgICAsIHVwVG8gICA9IHRvSW5kZXgoZW5kLCBsZW4pXG4gICAgICAsIHNpemUgICA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydClcbiAgICAgICwgY2xvbmVkID0gQXJyYXkoc2l6ZSlcbiAgICAgICwgaSAgICAgID0gMDtcbiAgICBmb3IoOyBpIDwgc2l6ZTsgaSsrKWNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkc29tZSAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDMpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uc29tZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjIzIC8gMTUuNC40LjE3IEFycmF5LnByb3RvdHlwZS5zb21lKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGZhaWxzICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkc29ydCAgICAgPSBbXS5zb3J0XG4gICwgdGVzdCAgICAgID0gWzEsIDIsIDNdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICAvLyBJRTgtXG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IGJ1Z1xuICB0ZXN0LnNvcnQobnVsbCk7XG4gIC8vIE9sZCBXZWJLaXRcbn0pIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJHNvcnQpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjUgQXJyYXkucHJvdG90eXBlLnNvcnQoY29tcGFyZWZuKVxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6ICRzb3J0LmNhbGwodG9PYmplY3QodGhpcyksIGFGdW5jdGlvbihjb21wYXJlZm4pKTtcbiAgfVxufSk7IiwicmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKSgnQXJyYXknKTsiLCIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHtub3c6IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfX0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcblxudmFyIGx6ID0gZnVuY3Rpb24obnVtKXtcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XG59O1xuXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuZXcgRGF0ZSgtNWUxMyAtIDEpLnRvSVNPU3RyaW5nKCkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgbmV3IERhdGUoTmFOKS50b0lTT1N0cmluZygpO1xufSkpLCAnRGF0ZScsIHtcbiAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCl7XG4gICAgaWYoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gICAgdmFyIGQgPSB0aGlzXG4gICAgICAsIHkgPSBkLmdldFVUQ0Z1bGxZZWFyKClcbiAgICAgICwgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKClcbiAgICAgICwgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcbiAgICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgICAnLScgKyBseihkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArIGx6KGQuZ2V0VVRDRGF0ZSgpKSArXG4gICAgICAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICtcbiAgICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGwgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoe3RvSVNPU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfX0pICE9PSAxO1xufSksICdEYXRlJywge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpe1xuICAgIHZhciBPICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7IiwidmFyIFRPX1BSSU1JVElWRSA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1ByaW1pdGl2ZScpXG4gICwgcHJvdG8gICAgICAgID0gRGF0ZS5wcm90b3R5cGU7XG5cbmlmKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSlyZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7IiwidmFyIERhdGVQcm90byAgICA9IERhdGUucHJvdG90eXBlXG4gICwgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSdcbiAgLCBUT19TVFJJTkcgICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgID0gRGF0ZVByb3RvW1RPX1NUUklOR11cbiAgLCBnZXRUaW1lICAgICAgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufSIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7YmluZDogcmVxdWlyZSgnLi9fYmluZCcpfSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIEhBU19JTlNUQU5DRSAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJylcbiAgLCBGdW5jdGlvblByb3RvICA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYoIShIQVNfSU5TVEFOQ0UgaW4gRnVuY3Rpb25Qcm90bykpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihGdW5jdGlvblByb3RvLCBIQVNfSU5TVEFOQ0UsIHt2YWx1ZTogZnVuY3Rpb24oTyl7XG4gIGlmKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKXJldHVybiBmYWxzZTtcbiAgaWYoIWlzT2JqZWN0KHRoaXMucHJvdG90eXBlKSlyZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSlpZih0aGlzLnByb3RvdHlwZSA9PT0gTylyZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufX0pOyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBoYXMgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBGUHJvdG8gICAgID0gRnVuY3Rpb24ucHJvdG90eXBlXG4gICwgbmFtZVJFICAgICA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopL1xuICAsIE5BTUUgICAgICAgPSAnbmFtZSc7XG5cbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAsIG5hbWUgPSAoJycgKyB0aGF0KS5tYXRjaChuYW1lUkUpWzFdO1xuICAgICAgaGFzKHRoYXQsIE5BTUUpIHx8ICFpc0V4dGVuc2libGUodGhhdCkgfHwgZFAodGhhdCwgTkFNRSwgY3JlYXRlRGVzYyg1LCBuYW1lKSk7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTsiLCIvLyAyMC4yLjIuMyBNYXRoLmFjb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbG9nMXAgICA9IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKVxuICAsIHNxcnQgICAgPSBNYXRoLnNxcnRcbiAgLCAkYWNvc2ggID0gTWF0aC5hY29zaDtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhY29zaFxuICAvLyBWOCBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNTA5XG4gICYmIE1hdGguZmxvb3IoJGFjb3NoKE51bWJlci5NQVhfVkFMVUUpKSA9PSA3MTBcbiAgLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFjb3NoKEluZmluaXR5KSAtPiBOYU4gXG4gICYmICRhY29zaChJbmZpbml0eSkgPT0gSW5maW5pdHlcbiksICdNYXRoJywge1xuICBhY29zaDogZnVuY3Rpb24gYWNvc2goeCl7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NlxuICAgICAgPyBNYXRoLmxvZyh4KSArIE1hdGguTE4yXG4gICAgICA6IGxvZzFwKHggLSAxICsgc3FydCh4IC0gMSkgKiBzcXJ0KHggKyAxKSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi41IE1hdGguYXNpbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXNpbmggID0gTWF0aC5hc2luaDtcblxuZnVuY3Rpb24gYXNpbmgoeCl7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCArIDEpKTtcbn1cblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmFzaW5oKDApIC0+IC0wIFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhc2luaCAmJiAxIC8gJGFzaW5oKDApID4gMCksICdNYXRoJywge2FzaW5oOiBhc2luaH0pOyIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXRhbmggID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwIFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpe1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCl7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCl7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZXhwbTEgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywge2V4cG0xOiAkZXhwbTF9KTsiLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgICA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpXG4gICwgcG93ICAgICAgID0gTWF0aC5wb3dcbiAgLCBFUFNJTE9OICAgPSBwb3coMiwgLTUyKVxuICAsIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpXG4gICwgTUFYMzIgICAgID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMilcbiAgLCBNSU4zMiAgICAgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGZyb3VuZDogZnVuY3Rpb24gZnJvdW5kKHgpe1xuICAgIHZhciAkYWJzICA9IE1hdGguYWJzKHgpXG4gICAgICAsICRzaWduID0gc2lnbih4KVxuICAgICAgLCBhLCByZXN1bHQ7XG4gICAgaWYoJGFicyA8IE1JTjMyKXJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gICAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICAgIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAgIGlmKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gICAgcmV0dXJuICRzaWduICogcmVzdWx0O1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhYnMgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gID0gMFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBsYXJnID0gMFxuICAgICAgLCBhcmcsIGRpdjtcbiAgICB3aGlsZShpIDwgYUxlbil7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYobGFyZyA8IGFyZyl7XG4gICAgICAgIGRpdiAgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZihhcmcgPiAwKXtcbiAgICAgICAgZGl2ICA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW11bCAgID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsIHhuID0gK3hcbiAgICAgICwgeW4gPSAreVxuICAgICAgLCB4bCA9IFVJTlQxNiAmIHhuXG4gICAgICAsIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpfSk7IiwiLy8gMjAuMi4yLjIyIE1hdGgubG9nMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBsb2cyOiBmdW5jdGlvbiBsb2cyKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4yO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7c2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJyl9KTsiLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCl7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMzMgTWF0aC50YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0YW5oOiBmdW5jdGlvbiB0YW5oKHgpe1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KVxuICAgICAgLCBiID0gZXhwbTEoLXgpO1xuICAgIHJldHVybiBhID09IEluZmluaXR5ID8gMSA6IGIgPT0gSW5maW5pdHkgPyAtMSA6IChhIC0gYikgLyAoZXhwKHgpICsgZXhwKC14KSk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCl7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIGNvZiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBnT1BOICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIGdPUEQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mXG4gICwgZFAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgJHRyaW0gICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW1cbiAgLCBOVU1CRVIgICAgICAgICAgICA9ICdOdW1iZXInXG4gICwgJE51bWJlciAgICAgICAgICAgPSBnbG9iYWxbTlVNQkVSXVxuICAsIEJhc2UgICAgICAgICAgICAgID0gJE51bWJlclxuICAsIHByb3RvICAgICAgICAgICAgID0gJE51bWJlci5wcm90b3R5cGVcbiAgLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nXG4gICwgQlJPS0VOX0NPRiAgICAgICAgPSBjb2YocmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpKHByb3RvKSkgPT0gTlVNQkVSXG4gICwgVFJJTSAgICAgICAgICAgICAgPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbihhcmd1bWVudCl7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIGlmKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKXtcbiAgICBpdCA9IFRSSU0gPyBpdC50cmltKCkgOiAkdHJpbShpdCwgMyk7XG4gICAgdmFyIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKVxuICAgICAgLCB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG4gICAgaWYoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSl7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZih0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMClyZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmKGZpcnN0ID09PSA0OCl7XG4gICAgICBzd2l0Y2goaXQuY2hhckNvZGVBdCgxKSl7XG4gICAgICAgIGNhc2UgNjYgOiBjYXNlIDk4ICA6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OSA6IGNhc2UgMTExIDogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdCA6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBmb3IodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspe1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZihjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuaWYoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKXtcbiAgJE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSl7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWVcbiAgICAgICwgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24oKXsgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOyB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvcih2YXIga2V5cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BOKEJhc2UpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKyl7XG4gICAgaWYoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSl7XG4gICAgICBkUCgkTnVtYmVyLCBrZXksIGdPUEQoQmFzZSwga2V5KSk7XG4gICAgfVxuICB9XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59IiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge0VQU0lMT046IE1hdGgucG93KDIsIC01Mil9KTsiLCIvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgX2lzRmluaXRlID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuaXNGaW5pdGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNGaW5pdGUoaXQpe1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKX0pOyIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi41IE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKVxuICAsIGFicyAgICAgICA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpe1xuICAgIHJldHVybiBpc0ludGVnZXIobnVtYmVyKSAmJiBhYnMobnVtYmVyKSA8PSAweDFmZmZmZmZmZmZmZmZmO1xuICB9XG59KTsiLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7TUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZn0pOyIsIi8vIDIwLjEuMi4xMCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7TUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmZ9KTsiLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDIwLjEuMi4xMiBOdW1iZXIucGFyc2VGbG9hdChzdHJpbmcpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksICdOdW1iZXInLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTsiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywge3BhcnNlSW50OiAkcGFyc2VJbnR9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0ludGVnZXIgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBhTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuL19hLW51bWJlci12YWx1ZScpXG4gICwgcmVwZWF0ICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG4gICwgJHRvRml4ZWQgICAgID0gMS4udG9GaXhlZFxuICAsIGZsb29yICAgICAgICA9IE1hdGguZmxvb3JcbiAgLCBkYXRhICAgICAgICAgPSBbMCwgMCwgMCwgMCwgMCwgMF1cbiAgLCBFUlJPUiAgICAgICAgPSAnTnVtYmVyLnRvRml4ZWQ6IGluY29ycmVjdCBpbnZvY2F0aW9uISdcbiAgLCBaRVJPICAgICAgICAgPSAnMCc7XG5cbnZhciBtdWx0aXBseSA9IGZ1bmN0aW9uKG4sIGMpe1xuICB2YXIgaSAgPSAtMVxuICAgICwgYzIgPSBjO1xuICB3aGlsZSgrK2kgPCA2KXtcbiAgICBjMiArPSBuICogZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG52YXIgZGl2aWRlID0gZnVuY3Rpb24obil7XG4gIHZhciBpID0gNlxuICAgICwgYyA9IDA7XG4gIHdoaWxlKC0taSA+PSAwKXtcbiAgICBjICs9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGZsb29yKGMgLyBuKTtcbiAgICBjID0gKGMgJSBuKSAqIDFlNztcbiAgfVxufTtcbnZhciBudW1Ub1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpID0gNlxuICAgICwgcyA9ICcnO1xuICB3aGlsZSgtLWkgPj0gMCl7XG4gICAgaWYocyAhPT0gJycgfHwgaSA9PT0gMCB8fCBkYXRhW2ldICE9PSAwKXtcbiAgICAgIHZhciB0ID0gU3RyaW5nKGRhdGFbaV0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQuY2FsbChaRVJPLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH0gcmV0dXJuIHM7XG59O1xudmFyIHBvdyA9IGZ1bmN0aW9uKHgsIG4sIGFjYyl7XG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcbn07XG52YXIgbG9nID0gZnVuY3Rpb24oeCl7XG4gIHZhciBuICA9IDBcbiAgICAsIHgyID0geDtcbiAgd2hpbGUoeDIgPj0gNDA5Nil7XG4gICAgbiArPSAxMjtcbiAgICB4MiAvPSA0MDk2O1xuICB9XG4gIHdoaWxlKHgyID49IDIpe1xuICAgIG4gICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfSByZXR1cm4gbjtcbn07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKCEhJHRvRml4ZWQgJiYgKFxuICAwLjAwMDA4LnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHxcbiAgMC45LnRvRml4ZWQoMCkgIT09ICcxJyB8fFxuICAxLjI1NS50b0ZpeGVkKDIpICE9PSAnMS4yNScgfHxcbiAgMTAwMDAwMDAwMDAwMDAwMDEyOC4udG9GaXhlZCgwKSAhPT0gJzEwMDAwMDAwMDAwMDAwMDAxMjgnXG4pIHx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIC8vIFY4IH4gQW5kcm9pZCA0LjMtXG4gICR0b0ZpeGVkLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKXtcbiAgICB2YXIgeCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCBFUlJPUilcbiAgICAgICwgZiA9IHRvSW50ZWdlcihmcmFjdGlvbkRpZ2l0cylcbiAgICAgICwgcyA9ICcnXG4gICAgICAsIG0gPSBaRVJPXG4gICAgICAsIGUsIHosIGosIGs7XG4gICAgaWYoZiA8IDAgfHwgZiA+IDIwKXRocm93IFJhbmdlRXJyb3IoRVJST1IpO1xuICAgIGlmKHggIT0geClyZXR1cm4gJ05hTic7XG4gICAgaWYoeCA8PSAtMWUyMSB8fCB4ID49IDFlMjEpcmV0dXJuIFN0cmluZyh4KTtcbiAgICBpZih4IDwgMCl7XG4gICAgICBzID0gJy0nO1xuICAgICAgeCA9IC14O1xuICAgIH1cbiAgICBpZih4ID4gMWUtMjEpe1xuICAgICAgZSA9IGxvZyh4ICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcbiAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDtcbiAgICAgIGUgPSA1MiAtIGU7XG4gICAgICBpZihlID4gMCl7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBqID0gZjtcbiAgICAgICAgd2hpbGUoaiA+PSA3KXtcbiAgICAgICAgICBtdWx0aXBseSgxZTcsIDApO1xuICAgICAgICAgIGogLT0gNztcbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseShwb3coMTAsIGosIDEpLCAwKTtcbiAgICAgICAgaiA9IGUgLSAxO1xuICAgICAgICB3aGlsZShqID49IDIzKXtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpICsgcmVwZWF0LmNhbGwoWkVSTywgZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKGYgPiAwKXtcbiAgICAgIGsgPSBtLmxlbmd0aDtcbiAgICAgIG0gPSBzICsgKGsgPD0gZiA/ICcwLicgKyByZXBlYXQuY2FsbChaRVJPLCBmIC0gaykgKyBtIDogbS5zbGljZSgwLCBrIC0gZikgKyAnLicgKyBtLnNsaWNlKGsgLSBmKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBzICsgbTtcbiAgICB9IHJldHVybiBtO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmFpbHMgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsICR0b1ByZWNpc2lvbiA9IDEuLnRvUHJlY2lzaW9uO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU3LVxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgISRmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pe1xuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQpIDogJHRvUHJlY2lzaW9uLmNhbGwodGhhdCwgcHJlY2lzaW9uKTsgXG4gIH1cbn0pOyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jylcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7Y3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyl9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19vYmplY3QtZHBzJyl9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTsiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2ZyZWV6ZScsIGZ1bmN0aW9uKCRmcmVlemUpe1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KXtcbiAgICByZXR1cm4gJGZyZWV6ZSAmJiBpc09iamVjdChpdCkgPyAkZnJlZXplKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pOyIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24oJGlzRXh0ZW5zaWJsZSl7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTIgT2JqZWN0LmlzRnJvemVuKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc0Zyb3plbicsIGZ1bmN0aW9uKCRpc0Zyb3plbil7XG4gIHJldHVybiBmdW5jdGlvbiBpc0Zyb3plbihpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc0Zyb3plbiA/ICRpc0Zyb3plbihpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uKCRpc1NlYWxlZCl7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTsiLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2lzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJyl9KTsiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGtleXMgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24oJHByZXZlbnRFeHRlbnNpb25zKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KXtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdzZWFsJywgZnVuY3Rpb24oJHNlYWwpe1xuICByZXR1cm4gZnVuY3Rpb24gc2VhbChpdCl7XG4gICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0fSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIHRlc3QgICAgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJyl7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufSIsInZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMTguMi40IHBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksIHtwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdH0pOyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMTguMi41IHBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuRiAqIChwYXJzZUludCAhPSAkcGFyc2VJbnQpLCB7cGFyc2VJbnQ6ICRwYXJzZUludH0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuSW5zdGFuY2UgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsIHRhc2sgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBtaWNyb3Rhc2sgICAgICAgICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgUFJPTUlTRSAgICAgICAgICAgID0gJ1Byb21pc2UnXG4gICwgVHlwZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlR5cGVFcnJvclxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgJFByb21pc2UgICAgICAgICAgID0gZ2xvYmFsW1BST01JU0VdXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgICAgICAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGVtcHR5ICAgICAgICAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBJbnRlcm5hbCwgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSAgICAgPSAkUHJvbWlzZS5yZXNvbHZlKDEpXG4gICAgICAsIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbihleGVjKXsgZXhlYyhlbXB0eSwgZW1wdHkpOyB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIHdpdGggbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICByZXR1cm4gYSA9PT0gYiB8fCBhID09PSAkUHJvbWlzZSAmJiBiID09PSBXcmFwcGVyO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICByZXR1cm4gc2FtZUNvbnN0cnVjdG9yKCRQcm9taXNlLCBDKVxuICAgID8gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgOiBuZXcgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ICA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCAgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihwcm9taXNlLCBpc1JlamVjdCl7XG4gIGlmKHByb21pc2UuX24pcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBvayAgICA9IHByb21pc2UuX3MgPT0gMVxuICAgICAgLCBpICAgICA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKHJlYWN0aW9uKXtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWxcbiAgICAgICAgLCByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZVxuICAgICAgICAsIHJlamVjdCAgPSByZWFjdGlvbi5yZWplY3RcbiAgICAgICAgLCBkb21haW4gID0gcmVhY3Rpb24uZG9tYWluXG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXtcbiAgICAgICAgICAgIGlmKHByb21pc2UuX2ggPT0gMilvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihoYW5kbGVyID09PSB0cnVlKXJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgYWJydXB0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZihhYnJ1cHQpdGhyb3cgYWJydXB0LmVycm9yO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgaWYocHJvbWlzZS5faCA9PSAxKXJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jXG4gICAgLCBpICAgICA9IDBcbiAgICAsIHJlYWN0aW9uO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmKGlzTm9kZSl7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpe1xuICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92fSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZighcHJvbWlzZS5fYSlwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXNcbiAgICAsIHRoZW47XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYocHJvbWlzZSA9PT0gdmFsdWUpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7X3c6IHByb21pc2UsIF9kOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uICAgID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayAgICAgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgICA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX2EpdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX3Mpbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHByb21pc2UgID0gbmV3IEludGVybmFsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCAgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtQcm9taXNlOiAkUHJvbWlzZX0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpe1xuICAgIC8vIGluc3RhbmNlb2YgaW5zdGVhZCBvZiBpbnRlcm5hbCBzbG90IGNoZWNrIGJlY2F1c2Ugd2Ugc2hvdWxkIGZpeCBpdCB3aXRob3V0IHJlcGxhY2VtZW50IG5hdGl2ZSBQcm9taXNlIGNvcmVcbiAgICBpZih4IGluc3RhbmNlb2YgJFByb21pc2UgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZXNvbHZlICA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICAkJHJlc29sdmUoeCk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZXNvbHZlICAgID0gY2FwYWJpbGl0eS5yZXNvbHZlXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgdmFyIHZhbHVlcyAgICA9IFtdXG4gICAgICAgICwgaW5kZXggICAgID0gMFxuICAgICAgICAsIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICB2YXIgJGluZGV4ICAgICAgICA9IGluZGV4KytcbiAgICAgICAgICAsIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICBpZihhbHJlYWR5Q2FsbGVkKXJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkICA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMSBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCByQXBwbHkgICAgPSAocmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdCB8fCB7fSkuYXBwbHlcbiAgLCBmQXBwbHkgICAgPSBGdW5jdGlvbi5hcHBseTtcbi8vIE1TIEVkZ2UgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByQXBwbHkoZnVuY3Rpb24oKXt9KTtcbn0pLCAnUmVmbGVjdCcsIHtcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KXtcbiAgICB2YXIgVCA9IGFGdW5jdGlvbih0YXJnZXQpXG4gICAgICAsIEwgPSBhbk9iamVjdChhcmd1bWVudHNMaXN0KTtcbiAgICByZXR1cm4gckFwcGx5ID8gckFwcGx5KFQsIHRoaXNBcmd1bWVudCwgTCkgOiBmQXBwbHkuY2FsbChULCB0aGlzQXJndW1lbnQsIEwpO1xuICB9XG59KTsiLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGJpbmQgICAgICAgPSByZXF1aXJlKCcuL19iaW5kJylcbiAgLCByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBGKCl7fVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbigpe1xuICByQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKXJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZihUYXJnZXQgPT0gbmV3VGFyZ2V0KXtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0O1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byAgICA9IG5ld1RhcmdldC5wcm90b3R5cGVcbiAgICAgICwgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKVxuICAgICAgLCByZXN1bHQgICA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7IiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7dmFsdWU6IDF9KSwgMSwge3ZhbHVlOiAyfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pOyIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdPUEQgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgdmFyIGRlc2MgPSBnT1BEKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgICByZXR1cm4gZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW10gICAgICAgLy8ga2V5c1xuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24oKXtcbiAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLCBrZXlzID0gdGhhdC5fa1xuICAgICwga2V5O1xuICBkbyB7XG4gICAgaWYodGhhdC5faSA+PSBrZXlzLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICB9IHdoaWxlKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4ge3ZhbHVlOiBrZXksIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCl7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7IiwiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpe1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7IiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdXG4gICAgLCBkZXNjLCBwcm90bztcbiAgaWYoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgID8gZGVzYy52YWx1ZVxuICAgIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge2dldDogZ2V0fSk7IiwiLy8gMjYuMS45IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBwcm9wZXJ0eUtleSBpbiB0YXJnZXQ7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTAgUmVmbGVjdC5pc0V4dGVuc2libGUodGFyZ2V0KVxudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGlzRXh0ZW5zaWJsZTogZnVuY3Rpb24gaXNFeHRlbnNpYmxlKHRhcmdldCl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICByZXR1cm4gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpfSk7IiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmKCRwcmV2ZW50RXh0ZW5zaW9ucykkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYoc2V0UHJvdG8pJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90byl7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdXG4gICAgLCBvd25EZXNjICA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSlcbiAgICAsIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmKCFvd25EZXNjKXtcbiAgICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmKGhhcyhvd25EZXNjLCAndmFsdWUnKSl7XG4gICAgaWYob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSlyZXR1cm4gZmFsc2U7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkgfHwgY3JlYXRlRGVzYygwKTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7c2V0OiBzZXR9KTsiLCJ2YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgZFAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBpc1JlZ0V4cCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgJGZsYWdzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgJFJlZ0V4cCAgICAgICAgICAgPSBnbG9iYWwuUmVnRXhwXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkUmVnRXhwXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkUmVnRXhwLnByb3RvdHlwZVxuICAsIHJlMSAgICAgICAgICAgICAgID0gL2EvZ1xuICAsIHJlMiAgICAgICAgICAgICAgID0gL2EvZ1xuICAvLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbiAgLCBDT1JSRUNUX05FVyAgICAgICA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSl7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZil7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cFxuICAgICAgLCBwaVJFID0gaXNSZWdFeHAocClcbiAgICAgICwgZmlVICA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbihrZXkpe1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihpdCl7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7IClwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpOyIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiByZXF1aXJlKCcuL19mbGFncycpXG59KTsiLCIvLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCl7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRtYXRjaF07XG59KTsiLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlKXtcbiAgLy8gMjEuMS4zLjE0IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKVxuICByZXR1cm4gW2Z1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7IiwiLy8gQEBzZWFyY2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKXtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRzZWFyY2hdO1xufSk7IiwiLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzcGxpdCcsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFNQTElULCAkc3BsaXQpe1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc1JlZ0V4cCAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgICAsIF9zcGxpdCAgICAgPSAkc3BsaXRcbiAgICAsICRwdXNoICAgICAgPSBbXS5wdXNoXG4gICAgLCAkU1BMSVQgICAgID0gJ3NwbGl0J1xuICAgICwgTEVOR1RIICAgICA9ICdsZW5ndGgnXG4gICAgLCBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG4gIGlmKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApe1xuICAgIHZhciBOUENHID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB1bmRlZmluZWQ7IC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xuICAgICAgaWYoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmKCFpc1JlZ0V4cChzZXBhcmF0b3IpKXJldHVybiBfc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IDQyOTQ5NjcyOTUgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGgsIGk7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIGlmKCFOUENHKXNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvckNvcHkuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICB3aGlsZShtYXRjaCA9IHNlcGFyYXRvckNvcHkuZXhlYyhzdHJpbmcpKXtcbiAgICAgICAgLy8gYHNlcGFyYXRvckNvcHkubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgIGlmKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpe1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBOUENHXG4gICAgICAgICAgaWYoIU5QQ0cgJiYgbWF0Y2hbTEVOR1RIXSA+IDEpbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgYXJndW1lbnRzW0xFTkdUSF0gLSAyOyBpKyspaWYoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYobWF0Y2hbTEVOR1RIXSA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmdbTEVOR1RIXSkkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZihsYXN0TGFzdEluZGV4ID09PSBzdHJpbmdbTEVOR1RIXSl7XG4gICAgICAgIGlmKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpb3V0cHV0LnB1c2goJycpO1xuICAgICAgfSBlbHNlIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0W0xFTkdUSF0gPiBzcGxpdExpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIHNwbGl0TGltaXQpIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSl7XG4gICAgJHNwbGl0ID0gZnVuY3Rpb24oc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IF9zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH1cbiAgLy8gMjEuMS4zLjE3IFN0cmluZy5wcm90b3R5cGUuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpIDogJHNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgfSwgJHNwbGl0XTtcbn0pOyIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4vZXM2LnJlZ2V4cC5mbGFncycpO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkZmxhZ3MgICAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBUT19TVFJJTkcgICA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgICA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgZGVmaW5lID0gZnVuY3Rpb24oZm4pe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZm4sIHRydWUpO1xufTtcblxuLy8gMjEuMi41LjE0IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcoKVxuaWYocmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpeyByZXR1cm4gJHRvU3RyaW5nLmNhbGwoe3NvdXJjZTogJ2EnLCBmbGFnczogJ2InfSkgIT0gJy9hL2InOyB9KSl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgcmV0dXJuICcvJy5jb25jYXQoUi5zb3VyY2UsICcvJyxcbiAgICAgICdmbGFncycgaW4gUiA/IFIuZmxhZ3MgOiAhREVTQ1JJUFRPUlMgJiYgUiBpbnN0YW5jZW9mIFJlZ0V4cCA/ICRmbGFncy5jYWxsKFIpIDogdW5kZWZpbmVkKTtcbiAgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxufSBlbHNlIGlmKCR0b1N0cmluZy5uYW1lICE9IFRPX1NUUklORyl7XG4gIGRlZmluZShmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvbGQoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykoZmFsc2UpO1xuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4zIFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQocG9zKVxuICBjb2RlUG9pbnRBdDogZnVuY3Rpb24gY29kZVBvaW50QXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pOyIsIi8vIDIxLjEuMy42IFN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgoc2VhcmNoU3RyaW5nIFssIGVuZFBvc2l0aW9uXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY29udGV4dCAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIEVORFNfV0lUSCA9ICdlbmRzV2l0aCdcbiAgLCAkZW5kc1dpdGggPSAnJ1tFTkRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKEVORFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcgLyosIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLyl7XG4gICAgdmFyIHRoYXQgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgRU5EU19XSVRIKVxuICAgICAgLCBlbmRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIGxlbiAgICA9IHRvTGVuZ3RoKHRoYXQubGVuZ3RoKVxuICAgICAgLCBlbmQgICAgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogTWF0aC5taW4odG9MZW5ndGgoZW5kUG9zaXRpb24pLCBsZW4pXG4gICAgICAsIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkZW5kc1dpdGhcbiAgICAgID8gJGVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOCBTdHJpbmcucHJvdG90eXBlLmZvbnRzaXplKHNpemUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250c2l6ZScsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpO1xuICB9XG59KTsiLCJ2YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSW5kZXggICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIGZyb21DaGFyQ29kZSAgID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAsICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyAgPSBbXVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBjb2RlO1xuICAgIHdoaWxlKGFMZW4gPiBpKXtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZih0b0luZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSl0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTsiLCIvLyAyMS4xLjMuNyBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzKHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb250ZXh0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBJTkNMVURFUyA9ICdpbmNsdWRlcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoSU5DTFVERVMpLCAnU3RyaW5nJywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIHJldHVybiAhIX5jb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgSU5DTFVERVMpXG4gICAgICAuaW5kZXhPZihzZWFyY2hTdHJpbmcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxpbmsodXJsKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnbGluaycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gbGluayh1cmwpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9XG59KTsiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKXtcbiAgICB2YXIgdHBsICA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpXG4gICAgICAsIGxlbiAgPSB0b0xlbmd0aCh0cGwubGVuZ3RoKVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXMgID0gW11cbiAgICAgICwgaSAgICA9IDA7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmKGkgPCBhTGVuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXQoY291bnQpXG4gIHJlcGVhdDogcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzbWFsbCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH1cbn0pOyIsIi8vIDIxLjEuMy4xOCBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIFssIHBvc2l0aW9uIF0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjb250ZXh0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBTVEFSVFNfV0lUSCA9ICdzdGFydHNXaXRoJ1xuICAsICRzdGFydHNXaXRoID0gJydbU1RBUlRTX1dJVEhdO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKFNUQVJUU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgdmFyIHRoYXQgICA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBTVEFSVFNfV0lUSClcbiAgICAgICwgaW5kZXggID0gdG9MZW5ndGgoTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSlcbiAgICAgICwgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRzdGFydHNXaXRoXG4gICAgICA/ICRzdGFydHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBpbmRleClcbiAgICAgIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1Yigpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xNCBTdHJpbmcucHJvdG90eXBlLnN1cCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdXAnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1cCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdXAnLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHR5cGVkICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAsIGJ1ZmZlciAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpXG4gICwgYW5PYmplY3QgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0luZGV4ICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIEFycmF5QnVmZmVyICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLkFycmF5QnVmZmVyXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgJEFycmF5QnVmZmVyID0gYnVmZmVyLkFycmF5QnVmZmVyXG4gICwgJERhdGFWaWV3ICAgID0gYnVmZmVyLkRhdGFWaWV3XG4gICwgJGlzVmlldyAgICAgID0gJHR5cGVkLkFCViAmJiBBcnJheUJ1ZmZlci5pc1ZpZXdcbiAgLCAkc2xpY2UgICAgICAgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlXG4gICwgVklFVyAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgLCBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwge0FycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXJ9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhJHR5cGVkLkNPTlNUUiwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyhhcmcpXG4gIGlzVmlldzogZnVuY3Rpb24gaXNWaWV3KGl0KXtcbiAgICByZXR1cm4gJGlzVmlldyAmJiAkaXNWaWV3KGl0KSB8fCBpc09iamVjdChpdCkgJiYgVklFVyBpbiBpdDtcbiAgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5VICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gIW5ldyAkQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSksIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIGlmKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKXJldHVybiAkc2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB2YXIgbGVuICAgID0gYW5PYmplY3QodGhpcykuYnl0ZUxlbmd0aFxuICAgICAgLCBmaXJzdCAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgICAsIGZpbmFsICA9IHRvSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbilcbiAgICAgICwgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluYWwgLSBmaXJzdCkpXG4gICAgICAsIHZpZXdTICA9IG5ldyAkRGF0YVZpZXcodGhpcylcbiAgICAgICwgdmlld1QgID0gbmV3ICREYXRhVmlldyhyZXN1bHQpXG4gICAgICAsIGluZGV4ICA9IDA7XG4gICAgd2hpbGUoZmlyc3QgPCBmaW5hbCl7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL190eXBlZCcpLkFCViwge1xuICBEYXRhVmlldzogcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJykuRGF0YVZpZXdcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIHJlZGVmaW5lICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBtZXRhICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBhc3NpZ24gICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJylcbiAgLCB3ZWFrICAgICAgICAgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0V2VhayAgICAgID0gbWV0YS5nZXRXZWFrXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZVxuICAsIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmVcbiAgLCB0bXAgICAgICAgICAgPSB7fVxuICAsIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCl7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICBpZihpc09iamVjdChrZXkpKXtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha01hcCcsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZihuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3KXtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIpO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBwcm90byAgPSAkV2Vha01hcC5wcm90b3R5cGVcbiAgICAgICwgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbihhLCBiKXtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSl7XG4gICAgICAgIGlmKCF0aGlzLl9mKXRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXA7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yd2FsZHJvbi90YzM5LW5vdGVzL2Jsb2IvbWFzdGVyL2VzNi8yMDE0LTA5L3NlcHQtMjUubWQjNTEwLWdsb2JhbGFzYXAtZm9yLWVucXVldWluZy1hLW1pY3JvdGFza1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIHByb2Nlc3MgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pe1xuICAgIHZhciBkb21haW4gPSBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW47XG4gICAgbWljcm90YXNrKGRvbWFpbiA/IGRvbWFpbi5iaW5kKGZuKSA6IGZuKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1pcy1lcnJvclxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvZiAgICAgPSByZXF1aXJlKCcuL19jb2YnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdFcnJvcicsIHtcbiAgaXNFcnJvcjogZnVuY3Rpb24gaXNFcnJvcihpdCl7XG4gICAgcmV0dXJuIGNvZihpdCkgPT09ICdFcnJvcic7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlhZGRoOiBmdW5jdGlvbiBpYWRkaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgKyAoeTEgPj4+IDApICsgKCgkeDAgJiAkeTAgfCAoJHgwIHwgJHkwKSAmIH4oJHgwICsgJHkwID4+PiAwKSkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGltdWxoOiBmdW5jdGlvbiBpbXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+PiAxNlxuICAgICAgLCB2MSA9ICR2ID4+IDE2XG4gICAgICAsIHQgID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4gMTYpO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpc3ViaDogZnVuY3Rpb24gaXN1YmgoeDAsIHgxLCB5MCwgeTEpe1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMFxuICAgICAgLCAkeDEgPSB4MSA+Pj4gMFxuICAgICAgLCAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxIC0gKHkxID4+PiAwKSAtICgofiR4MCAmICR5MCB8IH4oJHgwIF4gJHkwKSAmICR4MCAtICR5MCA+Pj4gMCkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHVtdWxoOiBmdW5jdGlvbiB1bXVsaCh1LCB2KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsICR1ID0gK3VcbiAgICAgICwgJHYgPSArdlxuICAgICAgLCB1MCA9ICR1ICYgVUlOVDE2XG4gICAgICAsIHYwID0gJHYgJiBVSU5UMTZcbiAgICAgICwgdTEgPSAkdSA+Pj4gMTZcbiAgICAgICwgdjEgPSAkdiA+Pj4gMTZcbiAgICAgICwgdCAgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4+IDE2KSArICgodTAgKiB2MSA+Pj4gMCkgKyAodCAmIFVJTlQxNikgPj4+IDE2KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKXtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge2dldDogYUZ1bmN0aW9uKGdldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4zIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVTZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpe1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7c2V0OiBhRnVuY3Rpb24oc2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCl7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgb3duS2V5cyAgICAgICAgPSByZXF1aXJlKCcuL19vd24ta2V5cycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3Qpe1xuICAgIHZhciBPICAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAgICwgZ2V0RGVzYyA9IGdPUEQuZlxuICAgICAgLCBrZXlzICAgID0gb3duS2V5cyhPKVxuICAgICAgLCByZXN1bHQgID0ge31cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGtleXMubGVuZ3RoID4gaSljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSA9IGtleXNbaSsrXSwgZ2V0RGVzYyhPLCBrZXkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi40IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwR2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwR2V0dGVyX18oUCl7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcbiAgICAgICwgRDtcbiAgICBkbyB7XG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELmdldDtcbiAgICB9IHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjUgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKXtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKVxuICAgICAgLCBEO1xuICAgIGRvIHtcbiAgICAgIGlmKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpcmV0dXJuIEQuc2V0O1xuICAgIH0gd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KXtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgbWljcm90YXNrICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgT0JTRVJWQUJMRSAgPSByZXF1aXJlKCcuL193a3MnKSgnb2JzZXJ2YWJsZScpXG4gICwgYUZ1bmN0aW9uICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGhpZGUgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIFJFVFVSTiAgICAgID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oZm4pe1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFGdW5jdGlvbihmbik7XG59O1xuXG52YXIgY2xlYW51cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHZhciBjbGVhbnVwID0gc3Vic2NyaXB0aW9uLl9jO1xuICBpZihjbGVhbnVwKXtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbi5fbyA9PT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGNsb3NlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24ob2JzZXJ2ZXIsIHN1YnNjcmliZXIpe1xuICBhbk9iamVjdChvYnNlcnZlcik7XG4gIHRoaXMuX2MgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgb2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG4gIHRyeSB7XG4gICAgdmFyIGNsZWFudXAgICAgICA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpXG4gICAgICAsIHN1YnNjcmlwdGlvbiA9IGNsZWFudXA7XG4gICAgaWYoY2xlYW51cCAhPSBudWxsKXtcbiAgICAgIGlmKHR5cGVvZiBjbGVhbnVwLnVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKWNsZWFudXAgPSBmdW5jdGlvbigpeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgIGVsc2UgYUZ1bmN0aW9uKGNsZWFudXApO1xuICAgICAgdGhpcy5fYyA9IGNsZWFudXA7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZihzdWJzY3JpcHRpb25DbG9zZWQodGhpcykpY2xlYW51cFN1YnNjcmlwdGlvbih0aGlzKTtcbn07XG5cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKXsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xufTtcblxuU3Vic2NyaXB0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCh2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLm5leHQpO1xuICAgICAgICBpZihtKXJldHVybiBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmKCFtKXRocm93IHZhbHVlO1xuICAgICAgdmFsdWUgPSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmNvbXBsZXRlKTtcbiAgICAgICAgdmFsdWUgPSBtID8gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpe1xuICBhbkluc3RhbmNlKHRoaXMsICRPYnNlcnZhYmxlLCAnT2JzZXJ2YWJsZScsICdfZicpLl9mID0gYUZ1bmN0aW9uKHN1YnNjcmliZXIpO1xufTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUucHJvdG90eXBlLCB7XG4gIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKXtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZlciwgdGhpcy5fZik7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4pe1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBhRnVuY3Rpb24oZm4pO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoYXQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCA6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZSwge1xuICBmcm9tOiBmdW5jdGlvbiBmcm9tKHgpe1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYobWV0aG9kKXtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gYW5PYmplY3QobWV0aG9kLmNhbGwoeCkpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMgPyBvYnNlcnZhYmxlIDogbmV3IEMoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCFkb25lKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYoZm9yT2YoeCwgZmFsc2UsIGZ1bmN0aW9uKGl0KXtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdCk7XG4gICAgICAgICAgICAgIGlmKGRvbmUpcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICBpZihkb25lKXRocm93IGU7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9LFxuICBvZjogZnVuY3Rpb24gb2YoKXtcbiAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBBcnJheShsKTsgaSA8IGw7KWl0ZW1zW2ldID0gYXJndW1lbnRzW2krK107XG4gICAgcmV0dXJuIG5ldyAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGUpKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWRvbmUpe1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICAgIGlmKGRvbmUpcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5oaWRlKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwgT0JTRVJWQUJMRSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge09ic2VydmFibGU6ICRPYnNlcnZhYmxlfSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHtkZWZpbmVNZXRhZGF0YTogZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgYW5PYmplY3QodGFyZ2V0KSwgdG9NZXRhS2V5KHRhcmdldEtleSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gbWV0YWRhdGEubWFwXG4gICwgc3RvcmUgICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLnN0b3JlO1xuXG5tZXRhZGF0YS5leHAoe2RlbGV0ZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICB2YXIgdGFyZ2V0S2V5ICAgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pXG4gICAgLCBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoYW5PYmplY3QodGFyZ2V0KSwgdGFyZ2V0S2V5LCBmYWxzZSk7XG4gIGlmKG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgfHwgIW1ldGFkYXRhTWFwWydkZWxldGUnXShtZXRhZGF0YUtleSkpcmV0dXJuIGZhbHNlO1xuICBpZihtZXRhZGF0YU1hcC5zaXplKXJldHVybiB0cnVlO1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgdGFyZ2V0TWV0YWRhdGFbJ2RlbGV0ZSddKHRhcmdldEtleSk7XG4gIHJldHVybiAhIXRhcmdldE1ldGFkYXRhLnNpemUgfHwgc3RvcmVbJ2RlbGV0ZSddKHRhcmdldCk7XG59fSk7IiwidmFyIFNldCAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9lczYuc2V0JylcbiAgLCBmcm9tICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKVxuICAsIG1ldGFkYXRhICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbihPLCBQKXtcbiAgdmFyIG9LZXlzICA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXG4gICAgLCBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgaWYocGFyZW50ID09PSBudWxsKXJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzICA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0XG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5R2V0TWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYoaGFzT3duKXJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IHVuZGVmaW5lZDtcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGE6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXRcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhOiBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlIYXNNZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZihoYXNPd24pcmV0dXJuIHRydWU7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiBmYWxzZTtcbn07XG5cbm1ldGFkYXRhLmV4cCh7aGFzTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtoYXNPd25NZXRhZGF0YTogZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHttZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpe1xuICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKFxuICAgICAgbWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsXG4gICAgICAodGFyZ2V0S2V5ICE9PSB1bmRlZmluZWQgPyBhbk9iamVjdCA6IGFGdW5jdGlvbikodGFyZ2V0KSxcbiAgICAgIHRvTWV0YUtleSh0YXJnZXRLZXkpXG4gICAgKTtcbiAgfTtcbn19KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0Jyl9KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgYXQ6IGZ1bmN0aW9uIGF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL1N0cmluZy5wcm90b3R5cGUubWF0Y2hBbGwvXG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGlzUmVnRXhwICAgID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCBnZXRGbGFncyAgICA9IHJlcXVpcmUoJy4vX2ZsYWdzJylcbiAgLCBSZWdFeHBQcm90byA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciAkUmVnRXhwU3RyaW5nSXRlcmF0b3IgPSBmdW5jdGlvbihyZWdleHAsIHN0cmluZyl7XG4gIHRoaXMuX3IgPSByZWdleHA7XG4gIHRoaXMuX3MgPSBzdHJpbmc7XG59O1xuXG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKCRSZWdFeHBTdHJpbmdJdGVyYXRvciwgJ1JlZ0V4cCBTdHJpbmcnLCBmdW5jdGlvbiBuZXh0KCl7XG4gIHZhciBtYXRjaCA9IHRoaXMuX3IuZXhlYyh0aGlzLl9zKTtcbiAgcmV0dXJuIHt2YWx1ZTogbWF0Y2gsIGRvbmU6IG1hdGNoID09PSBudWxsfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCl7XG4gICAgZGVmaW5lZCh0aGlzKTtcbiAgICBpZighaXNSZWdFeHAocmVnZXhwKSl0aHJvdyBUeXBlRXJyb3IocmVnZXhwICsgJyBpcyBub3QgYSByZWdleHAhJyk7XG4gICAgdmFyIFMgICAgID0gU3RyaW5nKHRoaXMpXG4gICAgICAsIGZsYWdzID0gJ2ZsYWdzJyBpbiBSZWdFeHBQcm90byA/IFN0cmluZyhyZWdleHAuZmxhZ3MpIDogZ2V0RmxhZ3MuY2FsbChyZWdleHApXG4gICAgICAsIHJ4ICAgID0gbmV3IFJlZ0V4cChyZWdleHAuc291cmNlLCB+ZmxhZ3MuaW5kZXhPZignZycpID8gZmxhZ3MgOiAnZycgKyBmbGFncyk7XG4gICAgcngubGFzdEluZGV4ID0gdG9MZW5ndGgocmVnZXhwLmxhc3RJbmRleCk7XG4gICAgcmV0dXJuIG5ldyAkUmVnRXhwU3RyaW5nSXRlcmF0b3IocngsIFMpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFkICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiwgZmlsbFN0cmluZyA9ICcgJyAqLyl7XG4gICAgcmV0dXJuICRwYWQodGhpcywgbWF4TGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1MZWZ0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59LCAndHJpbVN0YXJ0Jyk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbVJpZ2h0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbVJpZ2h0KCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDIpO1xuICB9O1xufSwgJ3RyaW1FbmQnKTsiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTsiLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWdsb2JhbFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTeXN0ZW0nLCB7Z2xvYmFsOiByZXF1aXJlKCcuL19nbG9iYWwnKX0pOyIsInZhciAkaXRlcmF0b3JzICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAsIHJlZGVmaW5lICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgZ2xvYmFsICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIEl0ZXJhdG9ycyAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHdrcyAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIElURVJBVE9SICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgLCBUT19TVFJJTkdfVEFHID0gd2tzKCd0b1N0cmluZ1RhZycpXG4gICwgQXJyYXlWYWx1ZXMgICA9IEl0ZXJhdG9ycy5BcnJheTtcblxuZm9yKHZhciBjb2xsZWN0aW9ucyA9IFsnTm9kZUxpc3QnLCAnRE9NVG9rZW5MaXN0JywgJ01lZGlhTGlzdCcsICdTdHlsZVNoZWV0TGlzdCcsICdDU1NSdWxlTGlzdCddLCBpID0gMDsgaSA8IDU7IGkrKyl7XG4gIHZhciBOQU1FICAgICAgID0gY29sbGVjdGlvbnNbaV1cbiAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cbiAgICAsIHByb3RvICAgICAgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAgLCBrZXk7XG4gIGlmKHByb3RvKXtcbiAgICBpZighcHJvdG9bSVRFUkFUT1JdKWhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYoIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGZvcihrZXkgaW4gJGl0ZXJhdG9ycylpZighcHJvdG9ba2V5XSlyZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pOyIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBwYXJ0aWFsICAgID0gcmVxdWlyZSgnLi9fcGFydGlhbCcpXG4gICwgbmF2aWdhdG9yICA9IGdsb2JhbC5uYXZpZ2F0b3JcbiAgLCBNU0lFICAgICAgID0gISFuYXZpZ2F0b3IgJiYgL01TSUUgLlxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbihzZXQpe1xuICByZXR1cm4gTVNJRSA/IGZ1bmN0aW9uKGZuLCB0aW1lIC8qLCAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gc2V0KGludm9rZShcbiAgICAgIHBhcnRpYWwsXG4gICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pXG4gICAgKSwgdGltZSk7XG4gIH0gOiBzZXQ7XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6ICB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7IiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ibGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1YicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5qb2luJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb21lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcuYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaXN1YmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pbXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFzYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvX2NvcmUnKTsiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvcixcbiAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcbiIsIi8qKlxuICogQml0Y29pbiBBZGRyZXNzXG4gKiA9PT09PT09PT09PT09PT1cbiAqXG4gKiBBIGJpdGNvaW4gYWRkcmVzcy4gTm9ybWFsIHVzZSBjYXNlczpcbiAqIGxldCBhZGRyZXNzID0gbmV3IEFkZHJlc3MoKS5mcm9tUHViS2V5KHB1YktleSlcbiAqIGxldCBhZGRyZXNzID0gbmV3IEFkZHJlc3MoKS5mcm9tUmVkZWVtU2NyaXB0KHNjcmlwdClcbiAqIGxldCBhZGRyZXNzID0gbmV3IEFkZHJlc3MoKS5mcm9tU3RyaW5nKHN0cmluZylcbiAqIGxldCBzdHJpbmcgPSBhZGRyZXNzLnRvU3RyaW5nKClcbiAqIGxldCBzY3JpcHQgPSBhZGRyZXNzLnRvU2NyaXB0KClcbiAqIGxldCBpc1ZhbGlkID0gQWRkcmVzcy5pc1ZhbGlkKHN0cmluZylcbiAqXG4gKiBDYW4gYWxzbyBkbyB0ZXN0bmV0OlxuICogbGV0IGFkZHJlc3MgPSBBZGRyZXNzLlRlc3RuZXQoKVxuICpcbiAqIE5vdGUgdGhhdCBhbiBBZGRyZXNzIGFuZCBhbiBBZGRyIGFyZSB0d28gY29tcGxldGVseSBkaWZmZXJlbnQgdGhpbmdzLiBBblxuICogQWRkcmVzcyBpcyB3aGF0IHlvdSBzZW5kIGJpdGNvaW4gdG8uIEFuIEFkZHIgaXMgYW4gaXAgYWRkcmVzcyBhbmQgcG9ydCB0aGF0XG4gKiB5b3UgY29ubmVjdCB0byBvdmVyIHRoZSBpbnRlcm5ldC5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5sZXQgZGVwZW5kZW5jaWVzID0ge1xuICBCYXNlNThDaGVjazogcmVxdWlyZSgnLi9iYXNlLTU4LWNoZWNrJyksXG4gIENvbnN0YW50czogcmVxdWlyZSgnLi9jb25zdGFudHMnKS5EZWZhdWx0LkFkZHJlc3MsXG4gIEhhc2g6IHJlcXVpcmUoJy4vaGFzaCcpLFxuICBPcENvZGU6IHJlcXVpcmUoJy4vb3AtY29kZScpLFxuICBQdWJLZXk6IHJlcXVpcmUoJy4vcHViLWtleScpLFxuICBTY3JpcHQ6IHJlcXVpcmUoJy4vc2NyaXB0JyksXG4gIFN0cnVjdDogcmVxdWlyZSgnLi9zdHJ1Y3QnKSxcbiAgV29ya2VyczogcmVxdWlyZSgnLi93b3JrZXJzJyksXG4gIGFzaW5rOiByZXF1aXJlKCdhc2luaycpXG59XG5cbmxldCBpbmplY3QgPSBmdW5jdGlvbiAoZGVwcykge1xuICBsZXQgQmFzZTU4Q2hlY2sgPSBkZXBzLkJhc2U1OENoZWNrXG4gIGxldCBDb25zdGFudHMgPSBkZXBzLkNvbnN0YW50c1xuICBsZXQgSGFzaCA9IGRlcHMuSGFzaFxuICBsZXQgT3BDb2RlID0gZGVwcy5PcENvZGVcbiAgbGV0IFB1YktleSA9IGRlcHMuUHViS2V5XG4gIGxldCBTY3JpcHQgPSBkZXBzLlNjcmlwdFxuICBsZXQgU3RydWN0ID0gZGVwcy5TdHJ1Y3RcbiAgbGV0IFdvcmtlcnMgPSBkZXBzLldvcmtlcnNcbiAgbGV0IGFzaW5rID0gZGVwcy5hc2lua1xuXG4gIGNsYXNzIEFkZHJlc3MgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yICh2ZXJzaW9uQnl0ZU51bSwgaGFzaEJ1Zikge1xuICAgICAgc3VwZXIoe3ZlcnNpb25CeXRlTnVtLCBoYXNoQnVmfSlcbiAgICB9XG5cbiAgICBmcm9tQnVmZmVyIChidWYpIHtcbiAgICAgIGlmIChidWYubGVuZ3RoICE9PSAxICsgMjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRyZXNzIGJ1ZmZlcnMgbXVzdCBiZSBleGFjdGx5IDIxIGJ5dGVzJylcbiAgICAgIH1cbiAgICAgIGlmIChidWZbMF0gIT09IENvbnN0YW50cy5wdWJLZXlIYXNoICYmIGJ1ZlswXSAhPT0gQ29uc3RhbnRzLnNjcmlwdEhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRyZXNzOiBpbnZhbGlkIHZlcnNpb25CeXRlTnVtIGJ5dGUnKVxuICAgICAgfVxuICAgICAgdGhpcy52ZXJzaW9uQnl0ZU51bSA9IGJ1ZlswXVxuICAgICAgdGhpcy5oYXNoQnVmID0gYnVmLnNsaWNlKDEpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGZyb21QdWJLZXlIYXNoQnVmIChoYXNoQnVmKSB7XG4gICAgICB0aGlzLmhhc2hCdWYgPSBoYXNoQnVmXG4gICAgICB0aGlzLnZlcnNpb25CeXRlTnVtID0gQ29uc3RhbnRzWydwdWJLZXlIYXNoJ11cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21QdWJLZXlIYXNoQnVmIChoYXNoQnVmKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tUHViS2V5SGFzaEJ1ZihoYXNoQnVmKVxuICAgIH1cblxuICAgIGZyb21QdWJLZXkgKHB1YktleSkge1xuICAgICAgbGV0IGhhc2hCdWYgPSBIYXNoLnNoYTI1NlJpcGVtZDE2MChwdWJLZXkudG9CdWZmZXIoKSlcbiAgICAgIHJldHVybiB0aGlzLmZyb21QdWJLZXlIYXNoQnVmKGhhc2hCdWYpXG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21QdWJLZXkgKHB1YktleSkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbVB1YktleShwdWJLZXkpXG4gICAgfVxuXG4gICAgYXN5bmNGcm9tUHViS2V5IChwdWJLZXkpIHtcbiAgICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgbGV0IGFyZ3MgPSBbcHViS2V5XVxuICAgICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNPYmplY3RNZXRob2QodGhpcywgJ2Zyb21QdWJLZXknLCBhcmdzKVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tRmFzdEJ1ZmZlcih3b3JrZXJzUmVzdWx0LnJlc2J1ZilcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jRnJvbVB1YktleSAocHViS2V5KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5hc3luY0Zyb21QdWJLZXkocHViS2V5KVxuICAgIH1cblxuICAgIGZyb21Qcml2S2V5IChwcml2S2V5KSB7XG4gICAgICBsZXQgcHViS2V5ID0gbmV3IFB1YktleSgpLmZyb21Qcml2S2V5KHByaXZLZXkpXG4gICAgICBsZXQgaGFzaEJ1ZiA9IEhhc2guc2hhMjU2UmlwZW1kMTYwKHB1YktleS50b0J1ZmZlcigpKVxuICAgICAgcmV0dXJuIHRoaXMuZnJvbVB1YktleUhhc2hCdWYoaGFzaEJ1ZilcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVByaXZLZXkgKHByaXZLZXkpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmZyb21Qcml2S2V5KHByaXZLZXkpXG4gICAgfVxuXG4gICAgYXN5bmNGcm9tUHJpdktleSAocHJpdktleSkge1xuICAgICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgICBsZXQgYXJncyA9IFtwcml2S2V5XVxuICAgICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNPYmplY3RNZXRob2QodGhpcywgJ2Zyb21Qcml2S2V5JywgYXJncylcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUZhc3RCdWZmZXIod29ya2Vyc1Jlc3VsdC5yZXNidWYpXG4gICAgICB9LCB0aGlzKVxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luY0Zyb21Qcml2S2V5IChwcml2S2V5KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tUHJpdktleShwcml2S2V5KVxuICAgIH1cblxuICAgIGZyb21SZWRlZW1TY3JpcHRIYXNoQnVmIChoYXNoQnVmKSB7XG4gICAgICB0aGlzLmhhc2hCdWYgPSBoYXNoQnVmXG4gICAgICBsZXQgdHlwZVN0ciA9ICdzY3JpcHRIYXNoJ1xuICAgICAgdGhpcy52ZXJzaW9uQnl0ZU51bSA9IENvbnN0YW50c1t0eXBlU3RyXVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVJlZGVlbVNjcmlwdEhhc2hCdWYgKGhhc2hCdWYpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmZyb21SZWRlZW1TY3JpcHRIYXNoQnVmKGhhc2hCdWYpXG4gICAgfVxuXG4gICAgZnJvbVJlZGVlbVNjcmlwdCAoc2NyaXB0KSB7XG4gICAgICBsZXQgaGFzaEJ1ZiA9IEhhc2guc2hhMjU2UmlwZW1kMTYwKHNjcmlwdC50b0J1ZmZlcigpKVxuICAgICAgcmV0dXJuIHRoaXMuZnJvbVJlZGVlbVNjcmlwdEhhc2hCdWYoaGFzaEJ1ZilcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVJlZGVlbVNjcmlwdCAoc2NyaXB0KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tUmVkZWVtU2NyaXB0KHNjcmlwdClcbiAgICB9XG5cbiAgICBhc3luY0Zyb21SZWRlZW1TY3JpcHQgKHNjcmlwdCkge1xuICAgICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgICBsZXQgYXJncyA9IFtzY3JpcHRdXG4gICAgICAgIGxldCB3b3JrZXJzUmVzdWx0ID0geWllbGQgV29ya2Vycy5hc3luY09iamVjdE1ldGhvZCh0aGlzLCAnZnJvbVJlZGVlbVNjcmlwdCcsIGFyZ3MpXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21GYXN0QnVmZmVyKHdvcmtlcnNSZXN1bHQucmVzYnVmKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmNGcm9tUmVkZWVtU2NyaXB0IChzY3JpcHQpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmFzeW5jRnJvbVJlZGVlbVNjcmlwdChzY3JpcHQpXG4gICAgfVxuXG4gICAgZnJvbVN0cmluZyAoc3RyKSB7XG4gICAgICBsZXQgYnVmID0gQmFzZTU4Q2hlY2suZGVjb2RlKHN0cilcbiAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmKVxuICAgIH1cblxuICAgIGFzeW5jRnJvbVN0cmluZyAoc3RyKSB7XG4gICAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCBhcmdzID0gW3N0cl1cbiAgICAgICAgbGV0IHdvcmtlcnNSZXN1bHQgPSB5aWVsZCBXb3JrZXJzLmFzeW5jT2JqZWN0TWV0aG9kKHRoaXMsICdmcm9tU3RyaW5nJywgYXJncylcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUZhc3RCdWZmZXIod29ya2Vyc1Jlc3VsdC5yZXNidWYpXG4gICAgICB9LCB0aGlzKVxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luY0Zyb21TdHJpbmcgKHN0cikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuYXN5bmNGcm9tU3RyaW5nKHN0cilcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNWYWxpZCAoYWRkcnN0cikge1xuICAgICAgbGV0IGFkZHJlc3NcbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHJlc3MgPSBuZXcgQWRkcmVzcygpLmZyb21TdHJpbmcoYWRkcnN0cilcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkcmVzcy5pc1ZhbGlkKClcbiAgICB9XG5cbiAgICBpc1ZhbGlkICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0eXBlICgpIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb25CeXRlTnVtID09PSBDb25zdGFudHNbJ3B1YktleUhhc2gnXSkge1xuICAgICAgICByZXR1cm4gJ3B1YktleUhhc2gnXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmVyc2lvbkJ5dGVOdW0gPT09IENvbnN0YW50c1snc2NyaXB0SGFzaCddKSB7XG4gICAgICAgIHJldHVybiAnc2NyaXB0SGFzaCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAndW5rbm93bidcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0b1NjcmlwdCAoKSB7XG4gICAgICBsZXQgdHlwZSA9IHRoaXMudHlwZSgpXG4gICAgICBsZXQgc2NyaXB0XG4gICAgICBpZiAodHlwZSA9PT0gJ3B1YktleUhhc2gnKSB7XG4gICAgICAgIHNjcmlwdCA9IG5ldyBTY3JpcHQoKVxuICAgICAgICBzY3JpcHQud3JpdGVPcENvZGUoT3BDb2RlLk9QX0RVUClcbiAgICAgICAgc2NyaXB0LndyaXRlT3BDb2RlKE9wQ29kZS5PUF9IQVNIMTYwKVxuICAgICAgICBzY3JpcHQud3JpdGVCdWZmZXIodGhpcy5oYXNoQnVmKVxuICAgICAgICBzY3JpcHQud3JpdGVPcENvZGUoT3BDb2RlLk9QX0VRVUFMVkVSSUZZKVxuICAgICAgICBzY3JpcHQud3JpdGVPcENvZGUoT3BDb2RlLk9QX0NIRUNLU0lHKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc2NyaXB0SGFzaCcpIHtcbiAgICAgICAgc2NyaXB0ID0gbmV3IFNjcmlwdCgpXG4gICAgICAgIHNjcmlwdC53cml0ZU9wQ29kZShPcENvZGUuT1BfSEFTSDE2MClcbiAgICAgICAgc2NyaXB0LndyaXRlQnVmZmVyKHRoaXMuaGFzaEJ1ZilcbiAgICAgICAgc2NyaXB0LndyaXRlT3BDb2RlKE9wQ29kZS5PUF9FUVVBTClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2NyaXB0IG11c3QgYmUgZWl0aGVyIHB1YktleUhhc2ggb3Igc2NyaXB0SGFzaCcpXG4gICAgICB9XG4gICAgICByZXR1cm4gc2NyaXB0XG4gICAgfVxuXG4gICAgdG9CdWZmZXIgKCkge1xuICAgICAgbGV0IHZlcnNpb25CeXRlQnVmID0gbmV3IEJ1ZmZlcihbdGhpcy52ZXJzaW9uQnl0ZU51bV0pXG4gICAgICBsZXQgYnVmID0gQnVmZmVyLmNvbmNhdChbdmVyc2lvbkJ5dGVCdWYsIHRoaXMuaGFzaEJ1Zl0pXG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgdG9KU09OICgpIHtcbiAgICAgIGxldCBqc29uID0ge31cbiAgICAgIGlmICh0aGlzLmhhc2hCdWYpIHtcbiAgICAgICAganNvbi5oYXNoQnVmID0gdGhpcy5oYXNoQnVmLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnZlcnNpb25CeXRlTnVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAganNvbi52ZXJzaW9uQnl0ZU51bSA9IHRoaXMudmVyc2lvbkJ5dGVOdW1cbiAgICAgIH1cbiAgICAgIHJldHVybiBqc29uXG4gICAgfVxuXG4gICAgZnJvbUpTT04gKGpzb24pIHtcbiAgICAgIGlmIChqc29uLmhhc2hCdWYpIHtcbiAgICAgICAgdGhpcy5oYXNoQnVmID0gbmV3IEJ1ZmZlcihqc29uLmhhc2hCdWYsICdoZXgnKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBqc29uLnZlcnNpb25CeXRlTnVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uQnl0ZU51bSA9IGpzb24udmVyc2lvbkJ5dGVOdW1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIEJhc2U1OENoZWNrLmVuY29kZSh0aGlzLnRvQnVmZmVyKCkpXG4gICAgfVxuXG4gICAgYXN5bmNUb1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCBhcmdzID0gW11cbiAgICAgICAgbGV0IHdvcmtlcnNSZXN1bHQgPSB5aWVsZCBXb3JrZXJzLmFzeW5jT2JqZWN0TWV0aG9kKHRoaXMsICd0b1N0cmluZycsIGFyZ3MpXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHdvcmtlcnNSZXN1bHQucmVzYnVmLnRvU3RyaW5nKCkpXG4gICAgICB9LCB0aGlzKVxuICAgIH1cblxuICAgIHZhbGlkYXRlICgpIHtcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMuaGFzaEJ1ZikgfHwgdGhpcy5oYXNoQnVmLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoQnVmIG11c3QgYmUgYSBidWZmZXIgb2YgMjAgYnl0ZXMnKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMudmVyc2lvbkJ5dGVOdW0gIT09IENvbnN0YW50c1sncHViS2V5SGFzaCddICYmXG4gICAgICAgIHRoaXMudmVyc2lvbkJ5dGVOdW0gIT09IENvbnN0YW50c1snc2NyaXB0SGFzaCddKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2ZXJzaW9uQnl0ZU51bScpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBBZGRyZXNzXG59XG5cbmluamVjdCA9IHJlcXVpcmUoJ2luamVjdGVyJykoaW5qZWN0LCBkZXBlbmRlbmNpZXMpXG5sZXQgQWRkcmVzcyA9IGluamVjdCgpXG5BZGRyZXNzLk1haW5uZXQgPSBpbmplY3Qoe1xuICBDb25zdGFudHM6IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuTWFpbm5ldC5BZGRyZXNzXG59KVxuQWRkcmVzcy5UZXN0bmV0ID0gaW5qZWN0KHtcbiAgQ29uc3RhbnRzOiByZXF1aXJlKCcuL2NvbnN0YW50cycpLlRlc3RuZXQuQWRkcmVzc1xufSlcbm1vZHVsZS5leHBvcnRzID0gQWRkcmVzc1xuIiwiLyoqXG4gKiBCYXNlNTggQ2hlY2sgRW5jb2RpbmdcbiAqID09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEJhc2U1OCBjaGVjayBlbmNvZGluZy4gVGhlIHVzdWFsIHdheSB0byB1c2UgaXQgaXNcbiAqIG5ldyBCYXNlNThDaGVjayhidWYpLnRvU3RyaW5nKCkgb3IgbmV3IEJhc2U1OENoZWNrKHN0cikudG9CdWZmZXIoKS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5sZXQgZGVwZW5kZW5jaWVzID0ge1xuICBCYXNlNTg6IHJlcXVpcmUoJy4vYmFzZS01OCcpLFxuICBjbXA6IHJlcXVpcmUoJy4vY21wJyksXG4gIEhhc2g6IHJlcXVpcmUoJy4vaGFzaCcpLFxuICBTdHJ1Y3Q6IHJlcXVpcmUoJy4vc3RydWN0Jylcbn1cblxubGV0IGluamVjdCA9IGZ1bmN0aW9uIChkZXBzKSB7XG4gIGxldCBCYXNlNTggPSBkZXBzLkJhc2U1OFxuICBsZXQgY21wID0gZGVwcy5jbXBcbiAgbGV0IEhhc2ggPSBkZXBzLkhhc2hcbiAgbGV0IFN0cnVjdCA9IGRlcHMuU3RydWN0XG5cbiAgY2xhc3MgQmFzZTU4Q2hlY2sgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yIChidWYpIHtcbiAgICAgIHN1cGVyKHtidWZ9KVxuICAgIH1cblxuICAgIGZyb21IZXggKGhleCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKGhleCwgJ2hleCcpKVxuICAgIH1cblxuICAgIHRvSGV4ICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpXG4gICAgfVxuXG4gICAgc3RhdGljIGRlY29kZSAocykge1xuICAgICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgYSBzdHJpbmcnKVxuICAgICAgfVxuXG4gICAgICBsZXQgYnVmID0gQmFzZTU4LmRlY29kZShzKVxuXG4gICAgICBpZiAoYnVmLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBzdHJpbmcgdG9vIHNob3J0JylcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWYuc2xpY2UoMCwgLTQpXG4gICAgICBsZXQgY3N1bSA9IGJ1Zi5zbGljZSgtNClcblxuICAgICAgbGV0IGhhc2ggPSBIYXNoLnNoYTI1NlNoYTI1NihkYXRhKVxuICAgICAgbGV0IGhhc2g0ID0gaGFzaC5zbGljZSgwLCA0KVxuXG4gICAgICBpZiAoIWNtcChjc3VtLCBoYXNoNCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGVja3N1bSBtaXNtYXRjaCcpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfVxuXG4gICAgc3RhdGljIGVuY29kZSAoYnVmKSB7XG4gICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIGJ1ZmZlcicpXG4gICAgICB9XG4gICAgICBsZXQgY2hlY2tlZEJ1ZiA9IG5ldyBCdWZmZXIoYnVmLmxlbmd0aCArIDQpXG4gICAgICBsZXQgaGFzaCA9IEhhc2guc2hhMjU2U2hhMjU2KGJ1ZilcbiAgICAgIGJ1Zi5jb3B5KGNoZWNrZWRCdWYpXG4gICAgICBoYXNoLmNvcHkoY2hlY2tlZEJ1ZiwgYnVmLmxlbmd0aClcbiAgICAgIHJldHVybiBCYXNlNTguZW5jb2RlKGNoZWNrZWRCdWYpXG4gICAgfVxuXG4gICAgZnJvbUJ1ZmZlciAoYnVmKSB7XG4gICAgICB0aGlzLmJ1ZiA9IGJ1ZlxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBmcm9tU3RyaW5nIChzdHIpIHtcbiAgICAgIGxldCBidWYgPSBCYXNlNThDaGVjay5kZWNvZGUoc3RyKVxuICAgICAgdGhpcy5idWYgPSBidWZcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdG9CdWZmZXIgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVmXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIEJhc2U1OENoZWNrLmVuY29kZSh0aGlzLmJ1ZilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQmFzZTU4Q2hlY2tcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBCYXNlNThDaGVjayA9IGluamVjdCgpXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U1OENoZWNrXG4iLCIvKipcbiAqIEJhc2U1OCBFbmNvZGluZ1xuICogPT09PT09PT09PT09PT09XG4gKlxuICogQmFzZTU4IChubyBjaGVjaylcbiAqL1xuJ3VzZSBzdHJpY3QnXG5sZXQgZGVwZW5kZW5jaWVzID0ge1xuICBiczU4OiByZXF1aXJlKCdiczU4JyksXG4gIFN0cnVjdDogcmVxdWlyZSgnLi9zdHJ1Y3QnKVxufVxuXG5sZXQgaW5qZWN0ID0gZnVuY3Rpb24gKGRlcHMpIHtcbiAgbGV0IGJzNTggPSBkZXBzLmJzNThcbiAgbGV0IFN0cnVjdCA9IGRlcHMuU3RydWN0XG5cbiAgY2xhc3MgQmFzZTU4IGV4dGVuZHMgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3RvciAoYnVmKSB7XG4gICAgICBzdXBlcih7YnVmfSlcbiAgICB9XG5cbiAgICBmcm9tSGV4IChoZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIobmV3IEJ1ZmZlcihoZXgsICdoZXgnKSlcbiAgICB9XG5cbiAgICB0b0hleCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKVxuICAgIH1cblxuICAgIHN0YXRpYyBlbmNvZGUgKGJ1Zikge1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHNob3VsZCBiZSBhIGJ1ZmZlcicpXG4gICAgICB9XG4gICAgICByZXR1cm4gYnM1OC5lbmNvZGUoYnVmKVxuICAgIH1cblxuICAgIHN0YXRpYyBkZWNvZGUgKHN0cikge1xuICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKGJzNTguZGVjb2RlKHN0cikpXG4gICAgfVxuXG4gICAgZnJvbUJ1ZmZlciAoYnVmKSB7XG4gICAgICB0aGlzLmJ1ZiA9IGJ1ZlxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBmcm9tU3RyaW5nIChzdHIpIHtcbiAgICAgIGxldCBidWYgPSBCYXNlNTguZGVjb2RlKHN0cilcbiAgICAgIHRoaXMuYnVmID0gYnVmXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRvQnVmZmVyICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1ZlxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBCYXNlNTguZW5jb2RlKHRoaXMuYnVmKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBCYXNlNThcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBCYXNlNTggPSBpbmplY3QoKVxubW9kdWxlLmV4cG9ydHMgPSBCYXNlNThcbiIsIi8qKlxuICogQmlnIE51bWJlclxuICogPT09PT09PT09PVxuICpcbiAqIFNpbmNlIGphdmFzY3JpcHQgbnVtYmVycyBhcmUgb25seSBwcmVjaXNlIHVwIHRvIDUzIGJpdHMsIGFuZCBiaXRjb2luIGlzXG4gKiBiYXNlZCBvbiBjcnlwdG9ncmFwaHkgdGhhdCB1c2VzIDI1NiBiaXQgbnVtYmVycywgd2UgbXVzdCB1c2UgYSBiaWcgbnVtYmVyXG4gKiBsaWJyYXJ5LiBUaGUgbGlicmFyeSB3ZSB1c2UgYXQgdGhlIG1vbWVudCBpcyBGZWRvciBJbmR1dG55J3MgYm4uanMgbGlicmFyeS5cbiAqIFNpbmNlIGJpZyBudW1iZXJzIGFyZSBleHRyZW1lbHkgdXNlZnVsLCB3ZSBwcm92aWRlIHNvbWUgdmVyeSBiYXNpYyB3cmFwcGVyc1xuICogZm9yIGhpcyBiaWcgbnVtYmVyIGNsYXNzIGFuZCBleHBvc2UgaXQuIFRoZSB3cmFwcGVycyBtZXJlbHkgYWxsb3cgeW91IHRvIGRvLFxuICogc2F5LCBibi5jbXAobnVtKSBpbnN0ZWFkIG9mIGp1c3QgYm4uY21wKGJuKSwgd2hpY2ggaXMgbmljZS4gVGhlIHByaW1hcnkgd2F5XG4gKiB0byB1c2UgdGhpcyBpczpcbiAqIGxldCBibiA9IEJOKHN0cikgLy8gc3RyIGlzIGJhc2UgMTBcbiAqIGxldCBibiA9IEJOKG51bSlcbiAqIGxldCBibiA9IEJOKCkuZnJvbUJ1ZmZlcihidWYpXG4gKiBsZXQgYm4gPSBCTigpLmZyb21TbShidWYpOyAvLyBzaWduK21hZ25pdHVkZSBmb3JtYXQsIGZpcnN0IGJpdCBpcyBzaWduXG4gKlxuICogRm9yIGxpdHRsZSBlbmRpYW4sIHBhc3MgaW4gYW4gb3B0aW9ucyB2YWx1ZTpcbiAqIGxldCBibiA9IEJOKCkuZnJvbUJ1ZmZlcihidWYsIHtlbmRpYW46ICdsaXR0bGUnfSlcbiAqIGxldCBibiA9IEJOKCkuZnJvbVNtKGJ1Ziwge2VuZGlhbjogJ2xpdHRsZSd9KVxuICpcbiAqIEdldHRpbmcgb3V0cHV0OlxuICogbGV0IHN0ciA9IEJOKCkudG9TdHJpbmcoKSAvLyBwcm9kdWNlcyBiYXNlIDEwIHN0cmluZ1xuICogbGV0IGJ1ZiA9IEJOKCkudG9CdWZmZXIoKSAvLyBwcm9kdWNlcyBidWZmZXIgcmVwcmVzZW50YXRpb25cbiAqIGxldCBidWYgPSBCTigpLnRvQnVmZmVyKHtzaXplOiAzMn0pIC8vcHJvZHVjZWQgMzIgYnl0ZSBidWZmZXJcbiAqL1xuJ3VzZSBzdHJpY3QnXG5sZXQgZGVwZW5kZW5jaWVzID0ge1xuICBfQk46IHJlcXVpcmUoJ2JuLmpzJylcbn1cblxubGV0IGluamVjdCA9IGZ1bmN0aW9uIChkZXBzKSB7XG4gIGxldCBfQk4gPSBkZXBzLl9CTlxuXG4gIGZ1bmN0aW9uIEJOIChuLCBiYXNlLCAuLi5yZXN0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJOKSkge1xuICAgICAgcmV0dXJuIG5ldyBCTihuLCBiYXNlLCAuLi5yZXN0KVxuICAgIH1cbiAgICBfQk4uY2FsbCh0aGlzLCBuLCBiYXNlLCAuLi5yZXN0KVxuICB9XG5cbiAgT2JqZWN0LmtleXMoX0JOKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBCTltrZXldID0gX0JOW2tleV1cbiAgfSlcbiAgQk4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShfQk4ucHJvdG90eXBlKVxuICBCTi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCTlxuXG4gIGZ1bmN0aW9uIHJldmVyc2VCdWYgKGJ1Zikge1xuICAgIGxldCBidWYyID0gbmV3IEJ1ZmZlcihidWYubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWYyW2ldID0gYnVmW2J1Zi5sZW5ndGggLSAxIC0gaV1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjJcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5mcm9tSGV4ID0gZnVuY3Rpb24gKGhleCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIobmV3IEJ1ZmZlcihoZXgsICdoZXgnKSwgb3B0cylcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CdWZmZXIob3B0cykudG9TdHJpbmcoJ2hleCcpXG4gIH1cblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBsZXQgYm4gPSBCTihzdHIpXG4gICAgYm4uY29weSh0aGlzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBCTi5wcm90b3R5cGUuZnJvbU51bWJlciA9IGZ1bmN0aW9uIChuKSB7XG4gICAgbGV0IGJuID0gQk4obilcbiAgICBibi5jb3B5KHRoaXMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpc1sndG9TdHJpbmcnXSgxMCksIDEwKVxuICB9XG5cbiAgQk4ucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyLCBiYXNlKSB7XG4gICAgbGV0IGJuID0gQk4oc3RyLCBiYXNlKVxuICAgIGJuLmNvcHkodGhpcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgQk4uZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uIChidWYsIG9wdHMgPSB7ZW5kaWFuOiAnYmlnJ30pIHtcbiAgICBpZiAob3B0cy5lbmRpYW4gPT09ICdsaXR0bGUnKSB7XG4gICAgICBidWYgPSByZXZlcnNlQnVmKGJ1ZilcbiAgICB9XG4gICAgbGV0IGhleCA9IGJ1Zi50b1N0cmluZygnaGV4JylcbiAgICBsZXQgYm4gPSBuZXcgQk4oaGV4LCAxNilcbiAgICByZXR1cm4gYm5cbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5mcm9tQnVmZmVyID0gZnVuY3Rpb24gKGJ1Ziwgb3B0cykge1xuICAgIGxldCBibiA9IEJOLmZyb21CdWZmZXIoYnVmLCBvcHRzKVxuICAgIGJuLmNvcHkodGhpcylcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiAob3B0cyA9IHtzaXplOiB1bmRlZmluZWQsIGVuZGlhbjogJ2JpZyd9KSB7XG4gICAgbGV0IGJ1ZlxuICAgIGlmIChvcHRzLnNpemUpIHtcbiAgICAgIGxldCBoZXggPSB0aGlzLnRvU3RyaW5nKDE2LCAyKVxuICAgICAgbGV0IG5hdGxlbiA9IGhleC5sZW5ndGggLyAyXG4gICAgICBidWYgPSBuZXcgQnVmZmVyKGhleCwgJ2hleCcpXG5cbiAgICAgIGlmIChuYXRsZW4gPT09IG9wdHMuc2l6ZSkge1xuICAgICAgICAvLyBwYXNzXG4gICAgICB9IGVsc2UgaWYgKG5hdGxlbiA+IG9wdHMuc2l6ZSkge1xuICAgICAgICBidWYgPSBidWYuc2xpY2UobmF0bGVuIC0gYnVmLmxlbmd0aCwgYnVmLmxlbmd0aClcbiAgICAgIH0gZWxzZSBpZiAobmF0bGVuIDwgb3B0cy5zaXplKSB7XG4gICAgICAgIGxldCByYnVmID0gbmV3IEJ1ZmZlcihvcHRzLnNpemUpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmJ1ZltyYnVmLmxlbmd0aCAtIDEgLSBpXSA9IGJ1ZltidWYubGVuZ3RoIC0gMSAtIGldXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRzLnNpemUgLSBuYXRsZW47IGkrKykge1xuICAgICAgICAgIHJidWZbaV0gPSAwXG4gICAgICAgIH1cbiAgICAgICAgYnVmID0gcmJ1ZlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaGV4ID0gdGhpcy50b1N0cmluZygxNiwgMilcbiAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoaGV4LCAnaGV4JylcbiAgICB9XG5cbiAgICBpZiAob3B0cy5lbmRpYW4gPT09ICdsaXR0bGUnKSB7XG4gICAgICBidWYgPSByZXZlcnNlQnVmKGJ1ZilcbiAgICB9XG4gICAgbGV0IGxvbmd6ZXJvID0gbmV3IEJ1ZmZlcihbMF0pXG4gICAgaWYgKEJ1ZmZlci5jb21wYXJlKGJ1ZiwgbG9uZ3plcm8pID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcihbXSlcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25lZCBtYWduaXR1ZGUgYnVmZmVyLiBNb3N0IHNpZ25pZmljYW50IGJpdCByZXByZXNlbnRzIHNpZ24gKDAgPSBwb3NpdGl2ZSxcbiAgICogMSA9IG5lZ2F0aXZlKS5cbiAgICovXG4gIEJOLnByb3RvdHlwZS5mcm9tU20gPSBmdW5jdGlvbiAoYnVmLCBvcHRzID0ge2VuZGlhbjogJ2JpZyd9KSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKFswXSkpXG4gICAgfVxuXG4gICAgbGV0IGVuZGlhbiA9IG9wdHMuZW5kaWFuXG4gICAgaWYgKGVuZGlhbiA9PT0gJ2xpdHRsZScpIHtcbiAgICAgIGJ1ZiA9IHJldmVyc2VCdWYoYnVmKVxuICAgIH1cblxuICAgIGlmIChidWZbMF0gJiAweDgwKSB7XG4gICAgICBidWZbMF0gPSBidWZbMF0gJiAweDdmXG4gICAgICB0aGlzLmZyb21CdWZmZXIoYnVmKVxuICAgICAgdGhpcy5uZWcoKS5jb3B5KHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZnJvbUJ1ZmZlcihidWYpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBCTi5wcm90b3R5cGUudG9TbSA9IGZ1bmN0aW9uIChvcHRzID0ge2VuZGlhbjogJ2JpZyd9KSB7XG4gICAgbGV0IGVuZGlhbiA9IG9wdHMuZW5kaWFuXG5cbiAgICBsZXQgYnVmXG4gICAgaWYgKHRoaXMuY21wKDApID09PSAtMSkge1xuICAgICAgYnVmID0gdGhpcy5uZWcoKS50b0J1ZmZlcigpXG4gICAgICBpZiAoYnVmWzBdICYgMHg4MCkge1xuICAgICAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKFsweDgwXSksIGJ1Zl0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZbMF0gPSBidWZbMF0gfCAweDgwXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZiA9IHRoaXMudG9CdWZmZXIoKVxuICAgICAgaWYgKGJ1ZlswXSAmIDB4ODApIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMHgwMF0pLCBidWZdKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChidWYubGVuZ3RoID09PSAxICYgYnVmWzBdID09PSAwKSB7XG4gICAgICBidWYgPSBuZXcgQnVmZmVyKFtdKVxuICAgIH1cblxuICAgIGlmIChlbmRpYW4gPT09ICdsaXR0bGUnKSB7XG4gICAgICBidWYgPSByZXZlcnNlQnVmKGJ1ZilcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSBhIEJOIGZyb20gdGhlIFwiYml0c1wiIHZhbHVlIGluIGEgYmxvY2toZWFkZXIuIEFuYWxhZ291cyB0byBCaXRjb2luXG4gICAqIENvcmUncyB1aW50MjU2IFNldENvbXBhY3QgbWV0aG9kLiBiaXRzIGlzIGFzc3VtZWQgdG8gYmUgVUludDMyLlxuICAgKi9cbiAgQk4ucHJvdG90eXBlLmZyb21CaXRzID0gZnVuY3Rpb24gKGJpdHMsIG9wdHMgPSB7c3RyaWN0OiBmYWxzZX0pIHtcbiAgICAvLyBUbyBwZXJmb3JtZWQgYml0d2lzZSBvcGVyYXRpb25zIGluIGphdmFzY3JpcHQsIHdlIG5lZWQgdG8gY29udmVydCB0byBhXG4gICAgLy8gc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAgICBsZXQgYnVmID0gbmV3IEJ1ZmZlcig0KVxuICAgIGJ1Zi53cml0ZVVJbnQzMkJFKGJpdHMsIDApXG4gICAgYml0cyA9IGJ1Zi5yZWFkSW50MzJCRSgwKVxuICAgIGlmIChvcHRzLnN0cmljdCAmJiAoYml0cyAmIDB4MDA4MDAwMDApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZ2F0aXZlIGJpdCBzZXQnKVxuICAgIH1cbiAgICBsZXQgbnNpemUgPSBiaXRzID4+IDI0XG4gICAgbGV0IG53b3JkID0gYml0cyAmIDB4MDA3ZmZmZmZcbiAgICBidWYgPSBuZXcgQnVmZmVyKDQpXG4gICAgYnVmLndyaXRlSW50MzJCRShud29yZClcbiAgICBpZiAobnNpemUgPD0gMykge1xuICAgICAgYnVmID0gYnVmLnNsaWNlKDEsIG5zaXplICsgMSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGZpbGwgPSBuZXcgQnVmZmVyKG5zaXplIC0gMylcbiAgICAgIGZpbGwuZmlsbCgwKVxuICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCBmaWxsXSlcbiAgICB9XG4gICAgdGhpcy5mcm9tQnVmZmVyKGJ1ZilcbiAgICBpZiAoYml0cyAmIDB4MDA4MDAwMDApIHtcbiAgICAgIEJOKDApLnN1Yih0aGlzKS5jb3B5KHRoaXMpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBCTiB0byB0aGUgXCJiaXRzXCIgdmFsdWUgaW4gYSBibG9ja2hlYWRlci4gQW5hbGFnb3VzIHRvIEJpdGNvaW5cbiAgICogQ29yZSdzIHVpbnQyNTYgR2V0Q29tcGFjdCBtZXRob2QuIGJpdHMgaXMgYSBVSW50MzIuXG4gICAqL1xuICBCTi5wcm90b3R5cGUudG9CaXRzID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBidWZcbiAgICBpZiAodGhpcy5sdCgwKSkge1xuICAgICAgYnVmID0gdGhpcy5uZWcoKS50b0J1ZmZlcigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZiA9IHRoaXMudG9CdWZmZXIoKVxuICAgIH1cbiAgICBsZXQgbnNpemUgPSBidWYubGVuZ3RoXG4gICAgbGV0IG53b3JkXG4gICAgaWYgKG5zaXplID4gMykge1xuICAgICAgbndvcmQgPSBCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKFswXSksIGJ1Zi5zbGljZSgwLCAzKV0pLnJlYWRVSW50MzJCRSgwKVxuICAgIH0gZWxzZSBpZiAobnNpemUgPD0gMykge1xuICAgICAgbGV0IGJsYW5rID0gbmV3IEJ1ZmZlcigzIC0gbnNpemUgKyAxKVxuICAgICAgYmxhbmsuZmlsbCgwKVxuICAgICAgbndvcmQgPSBCdWZmZXIuY29uY2F0KFtibGFuaywgYnVmLnNsaWNlKDAsIG5zaXplKV0pLnJlYWRVSW50MzJCRSgwKVxuICAgIH1cbiAgICBpZiAobndvcmQgJiAweDAwODAwMDAwKSB7XG4gICAgICAvLyBUaGUgbW9zdCBzaWduaWZpY2FudCBiaXQgZGVub3RlcyBzaWduLiBEbyBub3Qgd2FudCB1bmxlc3MgbnVtYmVyIGlzXG4gICAgICAvLyBhY3R1YWxseSBuZWdhdGl2ZS5cbiAgICAgIG53b3JkID4+PSA4XG4gICAgICBuc2l6ZSsrXG4gICAgfVxuICAgIGlmICh0aGlzLmx0KDApKSB7XG4gICAgICBud29yZCB8PSAweDAwODAwMDAwXG4gICAgfVxuICAgIGxldCBiaXRzID0gKG5zaXplIDw8IDI0KSB8IG53b3JkXG4gICAgLy8gY29udmVydCBiaXRzIHRvIFVJbnQzMiBiZWZvcmUgcmV0dXJuSW5nXG4gICAgYnVmID0gbmV3IEJ1ZmZlcig0KVxuICAgIGJ1Zi53cml0ZUludDMyQkUoYml0cywgMClcbiAgICByZXR1cm4gYnVmLnJlYWRVSW50MzJCRSgwKVxuICB9XG5cbiAgLy8gVGhpcyBpcyBhbmFsb2dvdXMgdG8gdGhlIGNvbnN0cnVjdG9yIGZvciBDU2NyaXB0TnVtIGluIGJpdGNvaW5kLiBNYW55IG9wc1xuICAvLyBpbiBiaXRjb2luZCdzIHNjcmlwdCBpbnRlcnByZXRlciB1c2UgQ1NjcmlwdE51bSwgd2hpY2ggaXMgbm90IHJlYWxseSBhXG4gIC8vIHByb3BlciBiaWdudW0uIEluc3RlYWQsIGFuIGVycm9yIGlzIHRocm93biBpZiB0cnlpbmcgdG8gaW5wdXQgYSBudW1iZXJcbiAgLy8gYmlnZ2VyIHRoYW4gNCBieXRlcy4gV2UgY29weSB0aGF0IGJlaGF2aW9yIGhlcmUuIFRoZXJlIGlzIG9uZSBleGNlcHRpb24gLVxuICAvLyBpbiBDSEVDS0xPQ0tUSU1FVkVSSUZZLCB0aGUgbnVtYmVycyBhcmUgYWxsb3dlZCB0byBiZSB1cCB0byA1IGJ5dGVzIGxvbmcuXG4gIC8vIFdlIGFsbG93IGZvciBzZXR0aW5nIHRoYXQgdmFyaWFibGUgaGVyZSBmb3IgdXNlIGluIENIRUNLTE9DS1RJTUVWRVJJRlkuXG4gIEJOLnByb3RvdHlwZS5mcm9tU2NyaXB0TnVtQnVmZmVyID0gZnVuY3Rpb24gKGJ1ZiwgZlJlcXVpcmVNaW5pbWFsLCBuTWF4TnVtU2l6ZSkge1xuICAgIGlmIChuTWF4TnVtU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuTWF4TnVtU2l6ZSA9IDRcbiAgICB9XG4gICAgaWYgKGJ1Zi5sZW5ndGggPiBuTWF4TnVtU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY3JpcHQgbnVtYmVyIG92ZXJmbG93JylcbiAgICB9XG4gICAgaWYgKGZSZXF1aXJlTWluaW1hbCAmJiBidWYubGVuZ3RoID4gMCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgbnVtYmVyIGlzIGVuY29kZWQgd2l0aCB0aGUgbWluaW11bSBwb3NzaWJsZVxuICAgICAgLy8gbnVtYmVyIG9mIGJ5dGVzLlxuICAgICAgLy9cbiAgICAgIC8vIElmIHRoZSBtb3N0LXNpZ25pZmljYW50LWJ5dGUgLSBleGNsdWRpbmcgdGhlIHNpZ24gYml0IC0gaXMgemVyb1xuICAgICAgLy8gdGhlbiB3ZSdyZSBub3QgbWluaW1hbC4gTm90ZSBob3cgdGhpcyB0ZXN0IGFsc28gcmVqZWN0cyB0aGVcbiAgICAgIC8vIG5lZ2F0aXZlLXplcm8gZW5jb2RpbmcsIDB4ODAuXG4gICAgICBpZiAoKGJ1ZltidWYubGVuZ3RoIC0gMV0gJiAweDdmKSA9PT0gMCkge1xuICAgICAgICAvLyBPbmUgZXhjZXB0aW9uOiBpZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUgYnl0ZSBhbmQgdGhlIG1vc3RcbiAgICAgICAgLy8gc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBzZWNvbmQtbW9zdC1zaWduaWZpY2FudC1ieXRlIGlzIHNldFxuICAgICAgICAvLyBpdCB3b3VsZCBjb25mbGljdCB3aXRoIHRoZSBzaWduIGJpdC4gQW4gZXhhbXBsZSBvZiB0aGlzIGNhc2VcbiAgICAgICAgLy8gaXMgKy0yNTUsIHdoaWNoIGVuY29kZSB0byAweGZmMDAgYW5kIDB4ZmY4MCByZXNwZWN0aXZlbHkuXG4gICAgICAgIC8vIChiaWctZW5kaWFuKS5cbiAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPD0gMSB8fCAoYnVmW2J1Zi5sZW5ndGggLSAyXSAmIDB4ODApID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub24tbWluaW1hbGx5IGVuY29kZWQgc2NyaXB0IG51bWJlcicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZnJvbVNtKGJ1Ziwge2VuZGlhbjogJ2xpdHRsZSd9KVxuICB9XG5cbiAgLy8gVGhlIGNvcm9sbGFyeSB0byB0aGUgYWJvdmUsIHdpdGggdGhlIG5vdGFibGUgZXhjZXB0aW9uIHRoYXQgd2UgZG8gbm90IHRocm93XG4gIC8vIGFuIGVycm9yIGlmIHRoZSBvdXRwdXQgaXMgbGFyZ2VyIHRoYW4gZm91ciBieXRlcy4gKFdoaWNoIGNhbiBoYXBwZW4gaWZcbiAgLy8gcGVyZm9ybWluZyBhIG51bWVyaWNhbCBvcGVyYXRpb24gdGhhdCByZXN1bHRzIGluIGFuIG92ZXJmbG93IHRvIG1vcmUgdGhhbiA0XG4gIC8vIGJ5dGVzKS5cbiAgQk4ucHJvdG90eXBlLnRvU2NyaXB0TnVtQnVmZmVyID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHJldHVybiB0aGlzLnRvU20oe2VuZGlhbjogJ2xpdHRsZSd9KVxuICB9XG5cbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgX25lZyA9IF9CTi5wcm90b3R5cGUubmVnLmNhbGwodGhpcylcbiAgICBsZXQgbmVnID0gT2JqZWN0LmNyZWF0ZShCTi5wcm90b3R5cGUpXG4gICAgX25lZy5jb3B5KG5lZylcbiAgICByZXR1cm4gbmVnXG4gIH1cblxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGJuKSB7XG4gICAgbGV0IF9ibiA9IF9CTi5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgYm4pXG4gICAgYm4gPSBPYmplY3QuY3JlYXRlKEJOLnByb3RvdHlwZSlcbiAgICBfYm4uY29weShibilcbiAgICByZXR1cm4gYm5cbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoYm4pIHtcbiAgICBsZXQgX2JuID0gX0JOLnByb3RvdHlwZS5zdWIuY2FsbCh0aGlzLCBibilcbiAgICBibiA9IE9iamVjdC5jcmVhdGUoQk4ucHJvdG90eXBlKVxuICAgIF9ibi5jb3B5KGJuKVxuICAgIHJldHVybiBiblxuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIChibikge1xuICAgIGxldCBfYm4gPSBfQk4ucHJvdG90eXBlLm11bC5jYWxsKHRoaXMsIGJuKVxuICAgIGJuID0gT2JqZWN0LmNyZWF0ZShCTi5wcm90b3R5cGUpXG4gICAgX2JuLmNvcHkoYm4pXG4gICAgcmV0dXJuIGJuXG4gIH1cblxuICAvKipcbiAgICogdG8gYmUgdXNlZCBpZiB0aGlzIGlzIHBvc2l0aXZlLlxuICAgKi9cbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIChibikge1xuICAgIGxldCBfYm4gPSBfQk4ucHJvdG90eXBlLm1vZC5jYWxsKHRoaXMsIGJuKVxuICAgIGJuID0gT2JqZWN0LmNyZWF0ZShCTi5wcm90b3R5cGUpXG4gICAgX2JuLmNvcHkoYm4pXG4gICAgcmV0dXJuIGJuXG4gIH1cblxuICAvKipcbiAgICogdG8gYmUgdXNlZCBpZiB0aGlzIGlzIG5lZ2F0aXZlLlxuICAgKi9cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiAoYm4pIHtcbiAgICBsZXQgX2JuID0gX0JOLnByb3RvdHlwZS51bW9kLmNhbGwodGhpcywgYm4pXG4gICAgYm4gPSBPYmplY3QuY3JlYXRlKEJOLnByb3RvdHlwZSlcbiAgICBfYm4uY29weShibilcbiAgICByZXR1cm4gYm5cbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gKGJuKSB7XG4gICAgbGV0IF9ibiA9IF9CTi5wcm90b3R5cGUuaW52bS5jYWxsKHRoaXMsIGJuKVxuICAgIGJuID0gT2JqZWN0LmNyZWF0ZShCTi5wcm90b3R5cGUpXG4gICAgX2JuLmNvcHkoYm4pXG4gICAgcmV0dXJuIGJuXG4gIH1cblxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKGJuKSB7XG4gICAgbGV0IF9ibiA9IF9CTi5wcm90b3R5cGUuZGl2LmNhbGwodGhpcywgYm4pXG4gICAgYm4gPSBPYmplY3QuY3JlYXRlKEJOLnByb3RvdHlwZSlcbiAgICBfYm4uY29weShibilcbiAgICByZXR1cm4gYm5cbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiAoYm4pIHtcbiAgICByZXR1cm4gX0JOLnByb3RvdHlwZS5jbXAuY2FsbCh0aGlzLCBibilcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGwgdGhlIHN0YW5kYXJkIGJpZyBudW1iZXIgb3BlcmF0aW9ucyBvcGVyYXRlIG9uIG90aGVyIGJpZyBudW1iZXJzLiBlLmcuLFxuICAgKiBibjEuYWRkKGJuMikuIEJ1dCBpdCBpcyBmcmVxdWVubHkgdmFsdWJsZSB0byBhZGQgbnVtYmVycyBvciBzdHJpbmdzLCBlLmcuXG4gICAqIGJuLmFkZCg1KSBvciBibi5hZGQoJzUnKS4gVGhlIGRlY29yYXRvciB3cmFwcyBhbGwgbWV0aG9kcyB3aGVyZSB0aGlzIHdvdWxkXG4gICAqIGJlIGNvbnZlbmllbnQgYW5kIG1ha2VzIHRoYXQgcG9zc2libGUuXG4gICAqL1xuICBmdW5jdGlvbiBkZWNvcmF0ZSAobmFtZSkge1xuICAgIEJOLnByb3RvdHlwZVsnXycgKyBuYW1lXSA9IEJOLnByb3RvdHlwZVtuYW1lXVxuICAgIGxldCBmID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYiA9IG5ldyBCTihiKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYiA9IG5ldyBCTihiLnRvU3RyaW5nKCkpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1snXycgKyBuYW1lXShiKVxuICAgIH1cbiAgICBCTi5wcm90b3R5cGVbbmFtZV0gPSBmXG4gIH1cblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiB0aGlzLmNtcChiKSA9PT0gMFxuICB9XG5cbiAgQk4ucHJvdG90eXBlLm5lcSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKGIpICE9PSAwXG4gIH1cblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiB0aGlzLmNtcChiKSA+IDBcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5nZXEgPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiB0aGlzLmNtcChiKSA+PSAwXG4gIH1cblxuICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiB0aGlzLmNtcChiKSA8IDBcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5sZXEgPSBmdW5jdGlvbiAoYikge1xuICAgIHJldHVybiB0aGlzLmNtcChiKSA8PSAwXG4gIH1cblxuICBkZWNvcmF0ZSgnYWRkJylcbiAgZGVjb3JhdGUoJ3N1YicpXG4gIGRlY29yYXRlKCdtdWwnKVxuICBkZWNvcmF0ZSgnbW9kJylcbiAgZGVjb3JhdGUoJ2ludm0nKVxuICBkZWNvcmF0ZSgnZGl2JylcbiAgZGVjb3JhdGUoJ2NtcCcpXG4gIGRlY29yYXRlKCdndCcpXG4gIGRlY29yYXRlKCdnZXEnKVxuICBkZWNvcmF0ZSgnbHQnKVxuICBkZWNvcmF0ZSgnbGVxJylcblxuICByZXR1cm4gQk5cbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBCTiA9IGluamVjdCgpXG5tb2R1bGUuZXhwb3J0cyA9IEJOXG4iLCIvKipcbiAqIEJ1ZmZlciBSZWFkZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgY2xhc3MgZm9yIHJlYWRpbmcgVmFySW50cyBhbmQgb3RoZXIgYmFzaWMgdHlwZXMgZnJvbSBhXG4gKiBidWZmZXIuIFRoaXMgY2xhc3MgaXMgbW9zdCB1c2VmdWwgZm9yIHJlYWRpbmcgVmFySW50cywgYW5kIGFsc28gZm9yIHNpZ25lZFxuICogb3IgdW5zaWduZWQgaW50ZWdlcnMgb2YgdmFyaW91cyB0eXBlcy4gSXQgY2FuIGFsc28gcmVhZCBhIGJ1ZmZlciBpbiByZXZlcnNlXG4gKiBvcmRlciwgd2hpY2ggaXMgdXNlZnVsIGluIGJpdGNvaW4gd2hpY2ggdXNlcyBsaXR0bGUgZW5kaWFuIG51bWJlcnMgYSBsb3Qgc29cbiAqIHlvdSBmaW5kIHRoYXQgeW91IG11c3QgcmV2ZXJzZSB0aGluZ3MuIFlvdSBwcm9iYWJseSB3YW50IHRvIHVzZSBpdCBsaWtlOlxuICogdmFySW50ID0gbmV3IEJyKGJ1ZikucmVhZG5ldyBWYXJJbnQoKVxuICovXG4ndXNlIHN0cmljdCdcbmxldCBkZXBlbmRlbmNpZXMgPSB7XG4gIEJuOiByZXF1aXJlKCcuL2JuJylcbn1cblxubGV0IGluamVjdCA9IGZ1bmN0aW9uIChkZXBzKSB7XG4gIGxldCBCbiA9IGRlcHMuQm5cblxuICBjbGFzcyBCciB7XG4gICAgY29uc3RydWN0b3IgKGJ1Zikge1xuICAgICAgdGhpcy5mcm9tT2JqZWN0KHtidWZ9KVxuICAgIH1cblxuICAgIGZyb21PYmplY3QgKG9iaikge1xuICAgICAgdGhpcy5idWYgPSBvYmouYnVmIHx8IHRoaXMuYnVmIHx8IHVuZGVmaW5lZFxuICAgICAgdGhpcy5wb3MgPSBvYmoucG9zIHx8IHRoaXMucG9zIHx8IDBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZW9mICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLmJ1Zi5sZW5ndGhcbiAgICB9XG5cbiAgICByZWFkIChsZW4gPSB0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgIGxldCBidWYgPSB0aGlzLmJ1Zi5zbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgKyBsZW4pXG4gICAgICB0aGlzLnBvcyA9IHRoaXMucG9zICsgbGVuXG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgcmVhZFJldmVyc2UgKGxlbiA9IHRoaXMuYnVmLmxlbmd0aCkge1xuICAgICAgbGV0IGJ1ZiA9IHRoaXMuYnVmLnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIGxlbilcbiAgICAgIHRoaXMucG9zID0gdGhpcy5wb3MgKyBsZW5cbiAgICAgIGxldCBidWYyID0gbmV3IEJ1ZmZlcihidWYubGVuZ3RoKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZjJbaV0gPSBidWZbYnVmLmxlbmd0aCAtIDEgLSBpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZjJcbiAgICB9XG5cbiAgICByZWFkVUludDggKCkge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50OCh0aGlzLnBvcylcbiAgICAgIHRoaXMucG9zID0gdGhpcy5wb3MgKyAxXG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgcmVhZEludDggKCkge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuYnVmLnJlYWRJbnQ4KHRoaXMucG9zKVxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDFcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG5cbiAgICByZWFkVUludDE2QkUgKCkge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MTZCRSh0aGlzLnBvcylcbiAgICAgIHRoaXMucG9zID0gdGhpcy5wb3MgKyAyXG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgcmVhZEludDE2QkUgKCkge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuYnVmLnJlYWRJbnQxNkJFKHRoaXMucG9zKVxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDJcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG5cbiAgICByZWFkVUludDE2TEUgKCkge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MTZMRSh0aGlzLnBvcylcbiAgICAgIHRoaXMucG9zID0gdGhpcy5wb3MgKyAyXG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgcmVhZEludDE2TEUgKCkge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuYnVmLnJlYWRJbnQxNkxFKHRoaXMucG9zKVxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDJcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG5cbiAgICByZWFkVUludDMyQkUgKCkge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJCRSh0aGlzLnBvcylcbiAgICAgIHRoaXMucG9zID0gdGhpcy5wb3MgKyA0XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgcmVhZEludDMyQkUgKCkge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuYnVmLnJlYWRJbnQzMkJFKHRoaXMucG9zKVxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDRcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG5cbiAgICByZWFkVUludDMyTEUgKCkge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcylcbiAgICAgIHRoaXMucG9zID0gdGhpcy5wb3MgKyA0XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuXG4gICAgcmVhZEludDMyTEUgKCkge1xuICAgICAgbGV0IHZhbCA9IHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zKVxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDRcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG5cbiAgICByZWFkVUludDY0QkVCbiAoKSB7XG4gICAgICBsZXQgYnVmID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgOClcbiAgICAgIGxldCBibiA9IG5ldyBCbigpLmZyb21CdWZmZXIoYnVmKVxuICAgICAgdGhpcy5wb3MgPSB0aGlzLnBvcyArIDhcbiAgICAgIHJldHVybiBiblxuICAgIH1cblxuICAgIHJlYWRVSW50NjRMRUJuICgpIHtcbiAgICAgIGxldCBidWYgPSB0aGlzLnJlYWRSZXZlcnNlKDgpXG4gICAgICBsZXQgYm4gPSBuZXcgQm4oKS5mcm9tQnVmZmVyKGJ1ZilcbiAgICAgIHJldHVybiBiblxuICAgIH1cblxuICAgIHJlYWRWYXJJbnROdW0gKCkge1xuICAgICAgbGV0IGZpcnN0ID0gdGhpcy5yZWFkVUludDgoKVxuICAgICAgbGV0IGJuLCBuXG4gICAgICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgICAgIGNhc2UgMHhGRDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVUludDE2TEUoKVxuICAgICAgICBjYXNlIDB4RkU6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVJbnQzMkxFKClcbiAgICAgICAgY2FzZSAweEZGOlxuICAgICAgICAgIGJuID0gdGhpcy5yZWFkVUludDY0TEVCbigpXG4gICAgICAgICAgbiA9IGJuLnRvTnVtYmVyKClcbiAgICAgICAgICBpZiAobiA8PSBNYXRoLnBvdygyLCA1MykpIHtcbiAgICAgICAgICAgIHJldHVybiBuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIHRvbyBsYXJnZSB0byByZXRhaW4gcHJlY2lzaW9uIC0gdXNlIHJlYWRWYXJJbnRCbicpXG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmaXJzdFxuICAgICAgfVxuICAgIH1cblxuICAgIHJlYWRWYXJJbnRCdWYgKCkge1xuICAgICAgbGV0IGZpcnN0ID0gdGhpcy5idWYucmVhZFVJbnQ4KHRoaXMucG9zKVxuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIDB4RkQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVhZCgxICsgMilcbiAgICAgICAgY2FzZSAweEZFOlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQoMSArIDQpXG4gICAgICAgIGNhc2UgMHhGRjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkKDEgKyA4KVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQoMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWFkVmFySW50Qm4gKCkge1xuICAgICAgbGV0IGZpcnN0ID0gdGhpcy5yZWFkVUludDgoKVxuICAgICAgc3dpdGNoIChmaXJzdCkge1xuICAgICAgICBjYXNlIDB4RkQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBCbih0aGlzLnJlYWRVSW50MTZMRSgpKVxuICAgICAgICBjYXNlIDB4RkU6XG4gICAgICAgICAgcmV0dXJuIG5ldyBCbih0aGlzLnJlYWRVSW50MzJMRSgpKVxuICAgICAgICBjYXNlIDB4RkY6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVJbnQ2NExFQm4oKVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBuZXcgQm4oZmlyc3QpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEJyXG59XG5cbmluamVjdCA9IHJlcXVpcmUoJ2luamVjdGVyJykoaW5qZWN0LCBkZXBlbmRlbmNpZXMpXG5sZXQgQnIgPSBpbmplY3QoKVxubW9kdWxlLmV4cG9ydHMgPSBCclxuIiwiLyoqXG4gKiBCdWZmZXIgV3JpdGVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhpcyBpcyB0aGUgd3JpdGluZyBjb21wbGVtZW50IG9mIHRoZSBCci4gWW91IGNhbiBlYXNpbHkgd3JpdGVcbiAqIFZhckludHMgYW5kIG90aGVyIGJhc2ljIG51bWJlciB0eXBlcy4gVGhlIHdheSB0byB1c2UgaXQgaXM6IGJ1ZiA9XG4gKiBuZXcgQncoKS53cml0ZShidWYxKS53cml0ZShidWYyKS50b0J1ZmZlcigpXG4gKi9cbid1c2Ugc3RyaWN0J1xubGV0IGRlcGVuZGVuY2llcyA9IHtcbn1cblxubGV0IGluamVjdCA9IGZ1bmN0aW9uIChkZXBzKSB7XG4gIGNsYXNzIEJ3IHtcbiAgICBjb25zdHJ1Y3RvciAoYnVmcykge1xuICAgICAgdGhpcy5mcm9tT2JqZWN0KHtidWZzfSlcbiAgICB9XG5cbiAgICBmcm9tT2JqZWN0IChvYmopIHtcbiAgICAgIHRoaXMuYnVmcyA9IG9iai5idWZzIHx8IHRoaXMuYnVmcyB8fCBbXVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXRMZW5ndGggKCkge1xuICAgICAgbGV0IGxlbiA9IDBcbiAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5idWZzKSB7XG4gICAgICAgIGxldCBidWYgPSB0aGlzLmJ1ZnNbaV1cbiAgICAgICAgbGVuID0gbGVuICsgYnVmLmxlbmd0aFxuICAgICAgfVxuICAgICAgcmV0dXJuIGxlblxuICAgIH1cblxuICAgIHRvQnVmZmVyICgpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KHRoaXMuYnVmcylcbiAgICB9XG5cbiAgICB3cml0ZSAoYnVmKSB7XG4gICAgICB0aGlzLmJ1ZnMucHVzaChidWYpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHdyaXRlUmV2ZXJzZSAoYnVmKSB7XG4gICAgICBsZXQgYnVmMiA9IG5ldyBCdWZmZXIoYnVmLmxlbmd0aClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmMi5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWYyW2ldID0gYnVmW2J1Zi5sZW5ndGggLSAxIC0gaV1cbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmcy5wdXNoKGJ1ZjIpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHdyaXRlVUludDggKG4pIHtcbiAgICAgIGxldCBidWYgPSBuZXcgQnVmZmVyKDEpXG4gICAgICBidWYud3JpdGVVSW50OChuLCAwKVxuICAgICAgdGhpcy53cml0ZShidWYpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHdyaXRlSW50OCAobikge1xuICAgICAgbGV0IGJ1ZiA9IG5ldyBCdWZmZXIoMSlcbiAgICAgIGJ1Zi53cml0ZUludDgobiwgMClcbiAgICAgIHRoaXMud3JpdGUoYnVmKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB3cml0ZVVJbnQxNkJFIChuKSB7XG4gICAgICBsZXQgYnVmID0gbmV3IEJ1ZmZlcigyKVxuICAgICAgYnVmLndyaXRlVUludDE2QkUobiwgMClcbiAgICAgIHRoaXMud3JpdGUoYnVmKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB3cml0ZUludDE2QkUgKG4pIHtcbiAgICAgIGxldCBidWYgPSBuZXcgQnVmZmVyKDIpXG4gICAgICBidWYud3JpdGVJbnQxNkJFKG4sIDApXG4gICAgICB0aGlzLndyaXRlKGJ1ZilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgd3JpdGVVSW50MTZMRSAobikge1xuICAgICAgbGV0IGJ1ZiA9IG5ldyBCdWZmZXIoMilcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkxFKG4sIDApXG4gICAgICB0aGlzLndyaXRlKGJ1ZilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgd3JpdGVJbnQxNkxFIChuKSB7XG4gICAgICBsZXQgYnVmID0gbmV3IEJ1ZmZlcigyKVxuICAgICAgYnVmLndyaXRlSW50MTZMRShuLCAwKVxuICAgICAgdGhpcy53cml0ZShidWYpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHdyaXRlVUludDMyQkUgKG4pIHtcbiAgICAgIGxldCBidWYgPSBuZXcgQnVmZmVyKDQpXG4gICAgICBidWYud3JpdGVVSW50MzJCRShuLCAwKVxuICAgICAgdGhpcy53cml0ZShidWYpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHdyaXRlSW50MzJCRSAobikge1xuICAgICAgbGV0IGJ1ZiA9IG5ldyBCdWZmZXIoNClcbiAgICAgIGJ1Zi53cml0ZUludDMyQkUobiwgMClcbiAgICAgIHRoaXMud3JpdGUoYnVmKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB3cml0ZVVJbnQzMkxFIChuKSB7XG4gICAgICBsZXQgYnVmID0gbmV3IEJ1ZmZlcig0KVxuICAgICAgYnVmLndyaXRlVUludDMyTEUobiwgMClcbiAgICAgIHRoaXMud3JpdGUoYnVmKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB3cml0ZUludDMyTEUgKG4pIHtcbiAgICAgIGxldCBidWYgPSBuZXcgQnVmZmVyKDQpXG4gICAgICBidWYud3JpdGVJbnQzMkxFKG4sIDApXG4gICAgICB0aGlzLndyaXRlKGJ1ZilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgd3JpdGVVSW50NjRCRUJuIChibikge1xuICAgICAgbGV0IGJ1ZiA9IGJuLnRvQnVmZmVyKHtzaXplOiA4fSlcbiAgICAgIHRoaXMud3JpdGUoYnVmKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB3cml0ZVVJbnQ2NExFQm4gKGJuKSB7XG4gICAgICBsZXQgYnVmID0gYm4udG9CdWZmZXIoe3NpemU6IDh9KVxuICAgICAgdGhpcy53cml0ZVJldmVyc2UoYnVmKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB3cml0ZVZhckludE51bSAobikge1xuICAgICAgbGV0IGJ1ZiA9IEJ3LnZhckludEJ1Zk51bShuKVxuICAgICAgdGhpcy53cml0ZShidWYpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHdyaXRlVmFySW50Qm4gKGJuKSB7XG4gICAgICBsZXQgYnVmID0gQncudmFySW50QnVmQm4oYm4pXG4gICAgICB0aGlzLndyaXRlKGJ1ZilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIHZhckludEJ1Zk51bSAobikge1xuICAgICAgbGV0IGJ1ZlxuICAgICAgaWYgKG4gPCAyNTMpIHtcbiAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcigxKVxuICAgICAgICBidWYud3JpdGVVSW50OChuLCAwKVxuICAgICAgfSBlbHNlIGlmIChuIDwgMHgxMDAwMCkge1xuICAgICAgICBidWYgPSBuZXcgQnVmZmVyKDEgKyAyKVxuICAgICAgICBidWYud3JpdGVVSW50OCgyNTMsIDApXG4gICAgICAgIGJ1Zi53cml0ZVVJbnQxNkxFKG4sIDEpXG4gICAgICB9IGVsc2UgaWYgKG4gPCAweDEwMDAwMDAwMCkge1xuICAgICAgICBidWYgPSBuZXcgQnVmZmVyKDEgKyA0KVxuICAgICAgICBidWYud3JpdGVVSW50OCgyNTQsIDApXG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKG4sIDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQnVmZmVyKDEgKyA4KVxuICAgICAgICBidWYud3JpdGVVSW50OCgyNTUsIDApXG4gICAgICAgIGJ1Zi53cml0ZUludDMyTEUobiAmIC0xLCAxKVxuICAgICAgICBidWYud3JpdGVVSW50MzJMRShNYXRoLmZsb29yKG4gLyAweDEwMDAwMDAwMCksIDUpXG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgc3RhdGljIHZhckludEJ1ZkJuIChibikge1xuICAgICAgbGV0IGJ1ZlxuICAgICAgbGV0IG4gPSBibi50b051bWJlcigpXG4gICAgICBpZiAobiA8IDI1Mykge1xuICAgICAgICBidWYgPSBuZXcgQnVmZmVyKDEpXG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KG4sIDApXG4gICAgICB9IGVsc2UgaWYgKG4gPCAweDEwMDAwKSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoMSArIDIpXG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KDI1MywgMClcbiAgICAgICAgYnVmLndyaXRlVUludDE2TEUobiwgMSlcbiAgICAgIH0gZWxzZSBpZiAobiA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoMSArIDQpXG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KDI1NCwgMClcbiAgICAgICAgYnVmLndyaXRlVUludDMyTEUobiwgMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBidyA9IG5ldyBCdygpXG4gICAgICAgIGJ3LndyaXRlVUludDgoMjU1KVxuICAgICAgICBidy53cml0ZVVJbnQ2NExFQm4oYm4pXG4gICAgICAgIGJ1ZiA9IGJ3LnRvQnVmZmVyKClcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQndcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBCdyA9IGluamVjdCgpXG5tb2R1bGUuZXhwb3J0cyA9IEJ3XG4iLCIvKipcbiAqIENvbnN0YW50LVRpbWUgQnVmZmVyIENvbXBhcmVcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBBIGNvbnN0YW50LXRpbWUgY29tcGFyaXNvbiBmdW5jdGlvbi4gVGhpcyBzaG91bGQgYmUgdXNlZCBpbiBhbnkgc2VjdXJpdHlcbiAqIHNlbnNpdGl2ZSBjb2RlIHdoZXJlIGxlYWtpbmcgdGltaW5nIGluZm9ybWF0aW9uIG1heSBsZWFkIHRvIGxlc3NlbmVkXG4gKiBzZWN1cml0eS4gTm90ZSB0aGF0IGlmIHRoZSBidWZmZXJzIGFyZSBub3QgZXF1YWwgaW4gbGVuZ3RoLCB0aGlzIGZ1bmN0aW9uXG4gKiBsb29wcyBmb3IgdGhlIGxvbmdlc3QgYnVmZmVyLCB3aGljaCBtYXkgbm90IGJlIG5lY2Vzc2FyeS4gVXN1YWxseSB0aGlzXG4gKiBmdW5jdGlvbiBzaG91bGQgYmUgdXNlZCBmb3IgYnVmZmVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBiZSBlcXVhbCBsZW5ndGgsXG4gKiBzdWNoIGFzIGEgaGFzaCwgcGFydGljdWxhcmx5IEhtYWNzLlxuICpcbiAqIFRoZSBhbGdvcml0aG0gaGVyZSwgd2hpY2ggaXMgWE9ScyBlYWNoIGJ5dGUgKG9yLCBpZiB1bmRlZmluZWQsIDApIHdpdGggdGhlXG4gKiBjb3JyZXNwb25kaW5nIG90aGVyIGJ5dGUsIGFuZCB0aGVuIE9ScyB0aGF0IHdpdGggYSBydW5uaW5nIHRvdGFsIChkKSwgaXNcbiAqIGFkYXB0ZWQgZnJvbSBoZXJlOlxuICpcbiAqIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyF0b3BpYy9rZXljemFyLWRpc2N1c3MvVlhIc29KU0xLaE1cbiAqL1xuJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNtcCAoYnVmMSwgYnVmMikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYxKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGJ1ZjIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdidWYxIGFuZCBidWYyIG11c3QgYmUgYnVmZmVycycpXG4gIH1cbiAgaWYgKGJ1ZjEubGVuZ3RoICE9PSBidWYyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgbGV0IGQgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmMS5sZW5ndGg7IGkrKykge1xuICAgIGxldCB4ID0gYnVmMVtpXVxuICAgIGxldCB5ID0gYnVmMltpXVxuICAgIGQgfD0gKHggXiB5KVxuICB9XG5cbiAgcmV0dXJuIGQgPT09IDBcbn1cbiIsIi8qKlxuICogQ29uc3RhbnRzXG4gKiA9PT09PT09PT1cbiAqXG4gKiBDb25zdGFudHMgdXNlZCB0byBkaXN0aW5ndWlzaCBtYWlubmV0IGZyb20gdGVzdG5ldC5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmxldCBDb25zdGFudHMgPSBtb2R1bGUuZXhwb3J0c1xuXG5Db25zdGFudHMuTWFpbm5ldCA9IHtcbiAgbWF4c2l6ZTogMHgwMjAwMDAwMCwgLy8gTUFYX1NJWkVcbiAgQWRkcmVzczoge1xuICAgIHB1YktleUhhc2g6IDB4MDAsXG4gICAgc2NyaXB0SGFzaDogMHgwNVxuICB9LFxuICBCaXAzMjoge1xuICAgIHB1YktleTogMHgwNDg4YjIxZSxcbiAgICBwcml2S2V5OiAweDA0ODhhZGU0XG4gIH0sXG4gIEJsb2NrOiB7XG4gICAgbWF4TkJpdHM6IDB4MWQwMGZmZmYsXG4gICAgbWFnaWNOdW06IDB4ZjliZWI0ZDlcbiAgfSxcbiAgTXNnOiB7XG4gICAgbWFnaWNOdW06IDB4ZjliZWI0ZDksXG4gICAgdmVyc2lvbkJ5dGVzTnVtOiA3MDAxMiAvLyBhcyBvZiBCaXRjb2luIENvcmUgdjAuMTIuMFxuICB9LFxuICBQcml2S2V5OiB7XG4gICAgdmVyc2lvbkJ5dGVOdW06IDB4ODBcbiAgfSxcbiAgU3RlYWx0aEFkZHJlc3M6IHtcbiAgICB2ZXJzaW9uQnl0ZU51bTogNDJcbiAgfSxcbiAgVHhCdWlsZGVyOiB7XG4gICAgZmVlUGVyS2JOdW06IDAuMDAwMWU4LFxuICAgIGR1c3ROdW06IDU0NlxuICB9XG59XG5cbkNvbnN0YW50cy5UZXN0bmV0ID0gT2JqZWN0LmFzc2lnbih7fSwgQ29uc3RhbnRzLk1haW5uZXQsIHtcbiAgQWRkcmVzczoge1xuICAgIHB1YktleUhhc2g6IDB4NmYsXG4gICAgc2NyaXB0SGFzaDogMHhjNFxuICB9LFxuICBCaXAzMjoge1xuICAgIHB1YktleTogMHgwNDM1ODdjZixcbiAgICBwcml2S2V5OiAweDA0MzU4Mzk0XG4gIH0sXG4gIEJsb2NrOiB7XG4gICAgbWF4TkJpdHM6IDB4MWQwMGZmZmYsXG4gICAgbWFnaWNOdW06IDB4MGIxMTA5MDdcbiAgfSxcbiAgTXNnOiB7XG4gICAgbWFnaWNOdW06IDB4MGIxMTA5MDcsXG4gICAgdmVyc2lvbkJ5dGVzTnVtOiA3MDAxMiAvLyBhcyBvZiBCaXRjb2luIENvcmUgdjAuMTIuMFxuICB9LFxuICBOZXR3b3JrOiB7XG4gICAgbWF4Y29ubmVjdGlvbnM6IDIwLFxuICAgIG1pbmNvbm5lY3Rpb25zOiA4LFxuICAgIHBvcnQ6IDgzMzMsXG4gICAgcmVuZGV6dm91czoge1xuICAgICAgaG9zdDogJ2xvY2FsaG9zdCcsXG4gICAgICBwb3J0OiAzMDAwLFxuICAgICAgcGF0aDogJy8nXG4gICAgfVxuICB9LFxuICBQcml2S2V5OiB7XG4gICAgdmVyc2lvbkJ5dGVOdW06IDB4ZWZcbiAgfSxcbiAgU3RlYWx0aEFkZHJlc3M6IHtcbiAgICB2ZXJzaW9uQnl0ZU51bTogNDNcbiAgfVxufSlcblxuQ29uc3RhbnRzLlJlZ3Rlc3QgPSBPYmplY3QuYXNzaWduKHt9LCBDb25zdGFudHMuTWFpbm5ldCwge1xuICBOZXR3b3JrOiB7XG4gICAgbWF4Y29ubmVjdGlvbnM6IDIwLFxuICAgIG1pbmNvbm5lY3Rpb25zOiA4LFxuICAgIHBvcnQ6IDE4NDQ0LFxuICAgIHJlbmRlenZvdXM6IHtcbiAgICAgIGhvc3Q6ICdsb2NhbGhvc3QnLFxuICAgICAgcG9ydDogMzAwMCxcbiAgICAgIHBhdGg6ICcvJ1xuICAgIH1cbiAgfVxufSlcblxuLyoqXG4gKiBZb3VycyBCaXRjb2luIGNhbiBiZSBnbG9iYWxseSBjb25maWd1cmVkIHRvIG1haW5uZXQsIHRlc3RuZXQsIG9yIHJlZ3Rlc3QuIFZpYSB0aGVcbiAqIGluamVjdCBwYXR0ZXJuLCB5b3UgYWx3YXlzIGhhdmUgYWNjZXNzIHRvIHRoZSBvdGhlciBuZXR3b3JrcyBhdCBhbnkgdGltZS5cbiAqIEhvd2V2ZXIsIGl0IGlzIHZlcnkgY29udmVuaWVudCB0byBiZSBhYmxlIHRvIGNoYW5nZSB0aGUgZGVmYXVsdFxuICogY29uZmlndXJhdGlvbi4gVGhlIGRlZmF1bHQgaXMgbWFpbm5ldCwgd2hpY2ggY2FuIGJlIGNoYW5nZWQgdG8gdGVzdG5ldCBvclxuICogcmVndGVzdC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52LllPVVJTX0JJVENPSU5fTkVUV09SSyA9PT0gJ3Rlc3RuZXQnKSB7XG4gIENvbnN0YW50cy5EZWZhdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgQ29uc3RhbnRzLlRlc3RuZXQpXG59IGVsc2UgaWYgKHByb2Nlc3MuZW52LllPVVJTX0JJVENPSU5fTkVUV09SSyA9PT0gJ3JlZ3Rlc3QnKSB7XG4gIENvbnN0YW50cy5EZWZhdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgQ29uc3RhbnRzLlJlZ3Rlc3QpXG59IGVsc2Uge1xuICBwcm9jZXNzLmVudi5ZT1VSU19CSVRDT0lOX05FVFdPUksgPSAnbWFpbm5ldCdcbiAgQ29uc3RhbnRzLkRlZmF1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBDb25zdGFudHMuTWFpbm5ldClcbn1cbiIsIi8qKlxuICogRWNkc2FcbiAqID09PT09XG4gKlxuICogRWNkc2EgaXMgdGhlIHNpZ25hdHVyZSBhbGdvcml0aG0gdXNlZCBieSBiaXRjb2luLiBUaGUgd2F5IHlvdSBwcm9iYWJseSB3YW50XG4gKiB0byB1c2UgdGhpcyBpcyB3aXRoIHRoZSBzdGF0aWMgRWNkc2Euc2lnbiggLi4uICkgYW5kIEVjZHNhLnZlcmlmeSggLi4uIClcbiAqIGZ1bmN0aW9ucy4gTm90ZSB0aGF0IGluIGJpdGNvaW4sIHRoZSBoYXNoQnVmIGlzIGxpdHRsZSBlbmRpYW4sIHNvIGlmIHlvdSBhcmVcbiAqIHNpZ25Jbmcgb3IgdmVyaWZ5aW5nIHNvbWV0aGluZyB0aGF0IGhhcyB0byBkbyB3aXRoIGEgdHJhbnNhY3Rpb24sIHlvdSBzaG91bGRcbiAqIGV4cGxpY2l0bHkgcGx1ZyBpbiB0aGF0IGl0IGlzIGxpdHRsZSBlbmRpYW4gYXMgYW4gb3B0aW9uIHRvIHRoZSBzaWduIGFuZFxuICogdmVyaWZ5IGZ1bmN0aW9ucy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIEVjZHNhIHVzZXMgZGV0ZXJtaW5pc3RpYyBzaWduYXR1cmVzIGFzIGRlZmluZWQgaW4gUkZDXG4gKiA2OTc5IGFzIHRoZSBkZWZhdWx0LCB3aGljaCBoYXMgYmVjb21lIGEgZGVmYWN0byBzdGFuZGFyZCBpbiBiaXRjb2luIHdhbGxldHNcbiAqIGR1ZSB0byByZWN1cnJpbmcgc2VjdXJpdHkgaXNzdWVzIGFyb3VuZCB1c2luZyBhIHZhbHVlIG9mIGsgcHVsbGVkIGZyb20gYVxuICogcG9zc2libHkgZmF1bHR5IGVudHJvcHkgcG9vbC4gSWYgeW91IHVzZSB0aGUgc2FtZSB2YWx1ZSBvZiBrIHR3aWNlLCBzb21lb25lXG4gKiBjYW4gZGVyaXZlIHlvdXIgcHJpdmF0ZSBrZXkuIERldGVybWluaXN0aWMgayBwcmV2ZW50cyB0aGlzIHdpdGhvdXQgbmVlZGluZ1xuICogYW4gZW50cm9weSBwb29sLlxuICovXG4ndXNlIHN0cmljdCdcbmxldCBkZXBlbmRlbmNpZXMgPSB7XG4gIEJuOiByZXF1aXJlKCcuL2JuJyksXG4gIEhhc2g6IHJlcXVpcmUoJy4vaGFzaCcpLFxuICBLZXlQYWlyOiByZXF1aXJlKCcuL2tleS1wYWlyJyksXG4gIFBvaW50OiByZXF1aXJlKCcuL3BvaW50JyksXG4gIFB1YktleTogcmVxdWlyZSgnLi9wdWIta2V5JyksXG4gIFJhbmRvbTogcmVxdWlyZSgnLi9yYW5kb20nKSxcbiAgU2lnOiByZXF1aXJlKCcuL3NpZycpLFxuICBTdHJ1Y3Q6IHJlcXVpcmUoJy4vc3RydWN0JyksXG4gIFdvcmtlcnM6IHJlcXVpcmUoJy4vd29ya2VycycpLFxuICBhc2luazogcmVxdWlyZSgnYXNpbmsnKVxufVxuXG5sZXQgaW5qZWN0ID0gZnVuY3Rpb24gKGRlcHMpIHtcbiAgbGV0IEJuID0gZGVwcy5CblxuICBsZXQgSGFzaCA9IGRlcHMuSGFzaFxuICBsZXQgS2V5UGFpciA9IGRlcHMuS2V5UGFpclxuICBsZXQgUG9pbnQgPSBkZXBzLlBvaW50XG4gIGxldCBQdWJLZXkgPSBkZXBzLlB1YktleVxuICBsZXQgUmFuZG9tID0gZGVwcy5SYW5kb21cbiAgbGV0IFNpZyA9IGRlcHMuU2lnXG4gIGxldCBTdHJ1Y3QgPSBkZXBzLlN0cnVjdFxuICBsZXQgV29ya2VycyA9IGRlcHMuV29ya2Vyc1xuICBsZXQgYXNpbmsgPSBkZXBzLmFzaW5rXG5cbiAgY2xhc3MgRWNkc2EgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yIChzaWcsIGtleVBhaXIsIGhhc2hCdWYsIGssIGVuZGlhbiwgdmVyaWZpZWQpIHtcbiAgICAgIHN1cGVyKHtzaWcsIGtleVBhaXIsIGhhc2hCdWYsIGssIGVuZGlhbiwgdmVyaWZpZWR9KVxuICAgIH1cblxuICAgIHRvSlNPTiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaWc6IHRoaXMuc2lnID8gdGhpcy5zaWcudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAga2V5UGFpcjogdGhpcy5rZXlQYWlyID8gdGhpcy5rZXlQYWlyLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpIDogdW5kZWZpbmVkLFxuICAgICAgICBoYXNoQnVmOiB0aGlzLmhhc2hCdWYgPyB0aGlzLmhhc2hCdWYudG9TdHJpbmcoJ2hleCcpIDogdW5kZWZpbmVkLFxuICAgICAgICBrOiB0aGlzLmsgPyB0aGlzLmsudG9TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZW5kaWFuOiB0aGlzLmVuZGlhbixcbiAgICAgICAgdmVyaWZpZWQ6IHRoaXMudmVyaWZpZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmcm9tSlNPTiAoanNvbikge1xuICAgICAgdGhpcy5zaWcgPSBqc29uLnNpZyA/IG5ldyBTaWcoKS5mcm9tU3RyaW5nKGpzb24uc2lnKSA6IHVuZGVmaW5lZFxuICAgICAgdGhpcy5rZXlQYWlyID0ganNvbi5rZXlQYWlyID8gbmV3IEtleVBhaXIoKS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoanNvbi5rZXlQYWlyLCAnaGV4JykpIDogdW5kZWZpbmVkXG4gICAgICB0aGlzLmhhc2hCdWYgPSBqc29uLmhhc2hCdWYgPyBuZXcgQnVmZmVyKGpzb24uaGFzaEJ1ZiwgJ2hleCcpIDogdW5kZWZpbmVkXG4gICAgICB0aGlzLmsgPSBqc29uLmsgPyBuZXcgQm4oKS5mcm9tU3RyaW5nKGpzb24uaykgOiB1bmRlZmluZWRcbiAgICAgIHRoaXMuZW5kaWFuID0ganNvbi5lbmRpYW5cbiAgICAgIHRoaXMudmVyaWZpZWQgPSBqc29uLnZlcmlmaWVkXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRvQnVmZmVyICgpIHtcbiAgICAgIGxldCBzdHIgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKVxuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc3RyKVxuICAgIH1cblxuICAgIGZyb21CdWZmZXIgKGJ1Zikge1xuICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKGJ1Zi50b1N0cmluZygpKVxuICAgICAgcmV0dXJuIHRoaXMuZnJvbUpTT04oanNvbilcbiAgICB9XG5cbiAgICBjYWxjcmVjb3ZlcnkgKCkge1xuICAgICAgZm9yIChsZXQgcmVjb3ZlcnkgPSAwOyByZWNvdmVyeSA8IDQ7IHJlY292ZXJ5KyspIHtcbiAgICAgICAgbGV0IFFwcmltZVxuICAgICAgICB0aGlzLnNpZy5yZWNvdmVyeSA9IHJlY292ZXJ5XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUXByaW1lID0gdGhpcy5zaWcyUHViS2V5KClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUXByaW1lLnBvaW50LmVxKHRoaXMua2V5UGFpci5wdWJLZXkucG9pbnQpKSB7XG4gICAgICAgICAgbGV0IGNvbXByZXNzZWQgPSB0aGlzLmtleVBhaXIucHViS2V5LmNvbXByZXNzZWRcbiAgICAgICAgICB0aGlzLnNpZy5jb21wcmVzc2VkID0gdGhpcy5rZXlQYWlyLnB1YktleS5jb21wcmVzc2VkID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29tcHJlc3NlZFxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zaWcucmVjb3ZlcnkgPSB1bmRlZmluZWRcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJylcbiAgICB9XG5cbiAgICBhc3luY0NhbGNyZWNvdmVyeSAoKSB7XG4gICAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCB3b3JrZXJzUmVzdWx0ID0geWllbGQgV29ya2Vycy5hc3luY09iamVjdE1ldGhvZCh0aGlzLCAnY2FsY3JlY292ZXJ5JywgW10pXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21GYXN0QnVmZmVyKHdvcmtlcnNSZXN1bHQucmVzYnVmKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSByZWNvdmVyeSBmYWN0b3IsIGFuZCBtdXRhdGVzIHNpZyBzbyB0aGF0IGl0IG5vdyBjb250YWluc1xuICAgICAqIHRoZSByZWNvdmVyeSBmYWN0b3IgYW5kIHRoZSBcImNvbXByZXNzZWRcIiB2YXJpYWJsZS4gVGhyb3dzIGFuIGV4Y2VwdGlvbiBvblxuICAgICAqIGZhaWx1cmUuXG4gICAgICovXG4gICAgc3RhdGljIGNhbGNyZWNvdmVyeSAoc2lnLCBwdWJLZXksIGhhc2hCdWYpIHtcbiAgICAgIGxldCBlY2RzYSA9IG5ldyBFY2RzYSgpLmZyb21PYmplY3Qoe1xuICAgICAgICBzaWc6IHNpZyxcbiAgICAgICAga2V5UGFpcjogbmV3IEtleVBhaXIoKS5mcm9tT2JqZWN0KHtwdWJLZXk6IHB1YktleX0pLFxuICAgICAgICBoYXNoQnVmOiBoYXNoQnVmXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGVjZHNhLmNhbGNyZWNvdmVyeSgpLnNpZ1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luY0NhbGNyZWNvdmVyeSAoc2lnLCBwdWJLZXksIGhhc2hCdWYpIHtcbiAgICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgbGV0IHdvcmtlcnNSZXN1bHQgPSB5aWVsZCBXb3JrZXJzLmFzeW5jQ2xhc3NNZXRob2QoJ0VjZHNhJywgJ2NhbGNyZWNvdmVyeScsIFtzaWcsIHB1YktleSwgaGFzaEJ1Zl0pXG4gICAgICAgIHJldHVybiBuZXcgU2lnKCkuZnJvbUZhc3RCdWZmZXIod29ya2Vyc1Jlc3VsdC5yZXNidWYpXG4gICAgICB9LCB0aGlzKVxuICAgIH1cblxuICAgIGZyb21TdHJpbmcgKHN0cikge1xuICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2Uoc3RyKVxuICAgICAgaWYgKG9iai5oYXNoQnVmKSB7XG4gICAgICAgIHRoaXMuaGFzaEJ1ZiA9IG5ldyBCdWZmZXIob2JqLmhhc2hCdWYsICdoZXgnKVxuICAgICAgfVxuICAgICAgaWYgKG9iai5rZXlQYWlyKSB7XG4gICAgICAgIHRoaXMua2V5UGFpciA9IG5ldyBLZXlQYWlyKCkuZnJvbVN0cmluZyhvYmoua2V5UGFpcilcbiAgICAgIH1cbiAgICAgIGlmIChvYmouc2lnKSB7XG4gICAgICAgIHRoaXMuc2lnID0gbmV3IFNpZygpLmZyb21TdHJpbmcob2JqLnNpZylcbiAgICAgIH1cbiAgICAgIGlmIChvYmouaykge1xuICAgICAgICB0aGlzLmsgPSBuZXcgQm4ob2JqLmssIDEwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICByYW5kb21LICgpIHtcbiAgICAgIGxldCBOID0gUG9pbnQuZ2V0TigpXG4gICAgICBsZXQga1xuICAgICAgZG8ge1xuICAgICAgICBrID0gbmV3IEJuKCkuZnJvbUJ1ZmZlcihSYW5kb20uZ2V0UmFuZG9tQnVmZmVyKDMyKSlcbiAgICAgIH0gd2hpbGUgKCEoay5sdChOKSAmJiBrLmd0KDApKSlcbiAgICAgIHRoaXMuayA9IGtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHRyYWRpdGlvbmFsIEVjZHNhIGFsZ29yaXRobSB1c2VzIGEgcHVyZWx5IHJhbmRvbSB2YWx1ZSBvZiBrLiBUaGlzIGhhc1xuICAgICAqIHRoZSBuZWdhdGl2ZSB0aGF0IHdoZW4gc2lnbkluZywgeW91ciBlbnRyb3B5IG11c3QgYmUgZ29vZCwgb3IgdGhlIHByaXZhdGVcbiAgICAgKiBrZXkgY2FuIGJlIHJlY292ZXJlZCBpZiB0d28gc2lnbmF0dXJlcyB1c2UgdGhlIHNhbWUgdmFsdWUgb2Ygay4gSXQgdHVybnMgb3V0XG4gICAgICogdGhhdCBrIGRvZXMgbm90IGhhdmUgdG8gYmUgcHVyZWx5IHJhbmRvbS4gSXQgY2FuIGJlIGRldGVybWluaXN0aWMsIHNvIGxvbmdcbiAgICAgKiBhcyBhbiBhdHRhY2tlciBjYW4ndCBndWVzcyBpdC4gUkZDIDY5Nzkgc3BlY2lmaWVzIGhvdyB0byBkbyB0aGlzIHVzaW5nIGFcbiAgICAgKiBjb21iaW5hdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXkgYW5kIHRoZSBoYXNoIG9mIHRoZSB0aGluZyB0byBiZSBzaWduZWQuIEl0IGlzXG4gICAgICogYmVzdCBwcmFjdGljZSB0byB1c2UgdGhpcyB2YWx1ZSwgd2hpY2ggY2FuIGJlIHRlc3RlZCBmb3IgYnl0ZS1mb3ItYnl0ZVxuICAgICAqIGFjY3VyYWN5LCBhbmQgaXMgcmVzaXN0YW50IHRvIGEgYnJva2VuIFJORy4gTm90ZSB0aGF0IGl0IGlzIGFjdHVhbGx5IHRoZVxuICAgICAqIGNhc2UgdGhhdCBiaXRjb2luIHByaXZhdGUga2V5cyBoYXZlIGJlZW4gY29tcHJvbWlzZWQgdGhyb3VnaCB0aGF0IGF0dGFjay5cbiAgICAgKiBEZXRlcm1pbmlzdGljIGsgaXMgYSBiZXN0IHByYWN0aWNlLlxuICAgICAqXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5Nzkjc2VjdGlvbi0zLjJcbiAgICAgKi9cbiAgICBkZXRlcm1pbmlzdGljSyAoYmFkcnMpIHtcbiAgICAgIGxldCB2ID0gbmV3IEJ1ZmZlcigzMilcbiAgICAgIHYuZmlsbCgweDAxKVxuICAgICAgbGV0IGsgPSBuZXcgQnVmZmVyKDMyKVxuICAgICAgay5maWxsKDB4MDApXG4gICAgICBsZXQgeCA9IHRoaXMua2V5UGFpci5wcml2S2V5LmJuLnRvQnVmZmVyKHtzaXplOiAzMn0pXG4gICAgICBrID0gSGFzaC5zaGEyNTZIbWFjKEJ1ZmZlci5jb25jYXQoW3YsIG5ldyBCdWZmZXIoWzB4MDBdKSwgeCwgdGhpcy5oYXNoQnVmXSksIGspXG4gICAgICB2ID0gSGFzaC5zaGEyNTZIbWFjKHYsIGspXG4gICAgICBrID0gSGFzaC5zaGEyNTZIbWFjKEJ1ZmZlci5jb25jYXQoW3YsIG5ldyBCdWZmZXIoWzB4MDFdKSwgeCwgdGhpcy5oYXNoQnVmXSksIGspXG4gICAgICB2ID0gSGFzaC5zaGEyNTZIbWFjKHYsIGspXG4gICAgICB2ID0gSGFzaC5zaGEyNTZIbWFjKHYsIGspXG4gICAgICBsZXQgVCA9IG5ldyBCbigpLmZyb21CdWZmZXIodilcbiAgICAgIGxldCBOID0gUG9pbnQuZ2V0TigpXG5cbiAgICAgIC8vIGlmIHIgb3IgcyB3ZXJlIGludmFsaWQgd2hlbiB0aGlzIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHNpZ25JbmcsXG4gICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBhY3R1YWxseSBjb21wdXRlIHIsIHMgaGVyZSBmb3IgZWZmaWNpZW5jeSwgc28sXG4gICAgICAvLyB3ZSBjYW4gaW5jcmVtZW50IGJhZHJzLiBleHBsYWluZWQgYXQgZW5kIG9mIFJGQyA2OTc5IHNlY3Rpb24gMy4yXG4gICAgICBpZiAoYmFkcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiYWRycyA9IDBcbiAgICAgIH1cbiAgICAgIC8vIGFsc28gZXhwbGFpbmVkIGluIDMuMiwgd2UgbXVzdCBlbnN1cmUgVCBpcyBpbiB0aGUgcHJvcGVyIHJhbmdlICgwLCBOKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYWRycyB8fCAhKFQubHQoTikgJiYgVC5ndCgwKSk7IGkrKykge1xuICAgICAgICBrID0gSGFzaC5zaGEyNTZIbWFjKEJ1ZmZlci5jb25jYXQoW3YsIG5ldyBCdWZmZXIoWzB4MDBdKV0pLCBrKVxuICAgICAgICB2ID0gSGFzaC5zaGEyNTZIbWFjKHYsIGspXG4gICAgICAgIHYgPSBIYXNoLnNoYTI1NkhtYWModiwgaylcbiAgICAgICAgVCA9IG5ldyBCbigpLmZyb21CdWZmZXIodilcbiAgICAgIH1cblxuICAgICAgdGhpcy5rID0gVFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmZvcm1hdGlvbiBhYm91dCBwdWJsaWMga2V5IHJlY292ZXJ5OlxuICAgICAqIGh0dHBzOi8vYml0Y29pbnRhbGsub3JnL2luZGV4LnBocD90b3BpYz02NDMwLjBcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5NjY1NDkxL2hvdy1kby1pLWdldC1hbi1lY2RzYS1wdWJsaWMta2V5LWZyb20tanVzdC1hLWJpdGNvaW4tc2lnbmF0dXJlLXNlYzEtNC0xLTYta1xuICAgICAqIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSB0YWtlbiBmcm9tIEJpdGNvaW5KU1xuICAgICAqL1xuICAgIHNpZzJQdWJLZXkgKCkge1xuICAgICAgbGV0IHJlY292ZXJ5ID0gdGhpcy5zaWcucmVjb3ZlcnlcbiAgICAgIGlmICghKHJlY292ZXJ5ID09PSAwIHx8IHJlY292ZXJ5ID09PSAxIHx8IHJlY292ZXJ5ID09PSAyIHx8IHJlY292ZXJ5ID09PSAzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2kgbXVzdCBiZSBlcXVhbCB0byAwLCAxLCAyLCBvciAzJylcbiAgICAgIH1cblxuICAgICAgbGV0IGUgPSBuZXcgQm4oKS5mcm9tQnVmZmVyKHRoaXMuaGFzaEJ1ZilcbiAgICAgIGxldCByID0gdGhpcy5zaWcuclxuICAgICAgbGV0IHMgPSB0aGlzLnNpZy5zXG5cbiAgICAgIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICAgICAgbGV0IGlzWU9kZCA9IHJlY292ZXJ5ICYgMVxuXG4gICAgICAvLyBUaGUgbW9yZSBzaWduaWZpY2FudCBiaXQgc3BlY2lmaWVzIHdoZXRoZXIgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICAgIC8vIGZpcnN0IG9yIHNlY29uZCBjYW5kaWRhdGUga2V5LlxuICAgICAgbGV0IGlzU2Vjb25kS2V5ID0gcmVjb3ZlcnkgPj4gMVxuXG4gICAgICBsZXQgbiA9IFBvaW50LmdldE4oKVxuICAgICAgbGV0IEcgPSBQb2ludC5nZXRHKClcblxuICAgICAgLy8gMS4xIExFdCB4ID0gciArIGpuXG4gICAgICBsZXQgeCA9IGlzU2Vjb25kS2V5ID8gci5hZGQobikgOiByXG4gICAgICBsZXQgUiA9IFBvaW50LmZyb21YKGlzWU9kZCwgeClcblxuICAgICAgLy8gMS40IENoZWNrIHRoYXQgblIgaXMgYXQgaW5maW5pdHlcbiAgICAgIGxldCBuUiA9IFIubXVsKG4pXG5cbiAgICAgIGlmICghblIuaXNJbmZpbml0eSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignblIgaXMgbm90IGEgdmFsaWQgY3VydmUgcG9pbnQnKVxuICAgICAgfVxuXG4gICAgICAvLyBDb21wdXRlIC1lIGZyb20gZVxuICAgICAgbGV0IGVOZWcgPSBlLm5lZygpLnVtb2QobilcblxuICAgICAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSBlRylcbiAgICAgIC8vIFEgPSByXi0xIChzUiArIC1lRylcbiAgICAgIGxldCBySW52ID0gci5pbnZtKG4pXG5cbiAgICAgIC8vIGxldCBRID0gUi5tdWx0aXBseVR3byhzLCBHLCBlTmVnKS5tdWwockludilcbiAgICAgIGxldCBRID0gUi5tdWwocykuYWRkKEcubXVsKGVOZWcpKS5tdWwockludilcblxuICAgICAgbGV0IHB1YktleSA9IG5ldyBQdWJLZXkoUSlcbiAgICAgIHB1YktleS5jb21wcmVzc2VkID0gdGhpcy5zaWcuY29tcHJlc3NlZFxuICAgICAgcHViS2V5LnZhbGlkYXRlKClcblxuICAgICAgcmV0dXJuIHB1YktleVxuICAgIH1cblxuICAgIGFzeW5jU2lnMlB1YktleSAoKSB7XG4gICAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCB3b3JrZXJzUmVzdWx0ID0geWllbGQgV29ya2Vycy5hc3luY09iamVjdE1ldGhvZCh0aGlzLCAnc2lnMlB1YktleScsIFtdKVxuICAgICAgICByZXR1cm4gUHViS2V5LmZyb21GYXN0QnVmZmVyKHdvcmtlcnNSZXN1bHQucmVzYnVmKVxuICAgICAgfSwgdGhpcylcbiAgICB9XG5cbiAgICBzdGF0aWMgc2lnMlB1YktleSAoc2lnLCBoYXNoQnVmKSB7XG4gICAgICBsZXQgZWNkc2EgPSBuZXcgRWNkc2EoKS5mcm9tT2JqZWN0KHtcbiAgICAgICAgc2lnOiBzaWcsXG4gICAgICAgIGhhc2hCdWY6IGhhc2hCdWZcbiAgICAgIH0pXG4gICAgICByZXR1cm4gZWNkc2Euc2lnMlB1YktleSgpXG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jU2lnMlB1YktleSAoc2lnLCBoYXNoQnVmKSB7XG4gICAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCBlY2RzYSA9IG5ldyBFY2RzYSgpLmZyb21PYmplY3Qoe1xuICAgICAgICAgIHNpZzogc2lnLFxuICAgICAgICAgIGhhc2hCdWY6IGhhc2hCdWZcbiAgICAgICAgfSlcbiAgICAgICAgbGV0IHB1YktleSA9IHlpZWxkIGVjZHNhLmFzeW5jU2lnMlB1YktleSgpXG4gICAgICAgIHJldHVybiBwdWJLZXlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuXG4gICAgdmVyaWZ5U3RyICgpIHtcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMuaGFzaEJ1ZikgfHwgdGhpcy5oYXNoQnVmLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgcmV0dXJuICdoYXNoQnVmIG11c3QgYmUgYSAzMiBieXRlIGJ1ZmZlcidcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5rZXlQYWlyLnB1YktleS52YWxpZGF0ZSgpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAnSW52YWxpZCBwdWJLZXk6ICcgKyBlXG4gICAgICB9XG5cbiAgICAgIGxldCByID0gdGhpcy5zaWcuclxuICAgICAgbGV0IHMgPSB0aGlzLnNpZy5zXG4gICAgICBpZiAoIShyLmd0KDApICYmIHIubHQoUG9pbnQuZ2V0TigpKSkgfHxcbiAgICAgICAgIShzLmd0KDApICYmIHMubHQoUG9pbnQuZ2V0TigpKSkpIHtcbiAgICAgICAgcmV0dXJuICdyIGFuZCBzIG5vdCBpbiByYW5nZSdcbiAgICAgIH1cblxuICAgICAgbGV0IGUgPSBuZXcgQm4oKS5mcm9tQnVmZmVyKHRoaXMuaGFzaEJ1ZiwgdGhpcy5lbmRpYW4gPyB7ZW5kaWFuOiB0aGlzLmVuZGlhbn0gOiB1bmRlZmluZWQpXG4gICAgICBsZXQgbiA9IFBvaW50LmdldE4oKVxuICAgICAgbGV0IHNpbnYgPSBzLmludm0obilcbiAgICAgIGxldCB1MSA9IHNpbnYubXVsKGUpLm1vZChuKVxuICAgICAgbGV0IHUyID0gc2ludi5tdWwocikubW9kKG4pXG5cbiAgICAgIGxldCBwID0gUG9pbnQuZ2V0RygpLm11bEFkZCh1MSwgdGhpcy5rZXlQYWlyLnB1YktleS5wb2ludCwgdTIpXG4gICAgICAvLyBsZXQgcCA9IFBvaW50LmdldEcoKS5tdWxBZGQodTEsIHRoaXMua2V5UGFpci5wdWJLZXkucG9pbnQsIHUyKVxuICAgICAgaWYgKHAuaXNJbmZpbml0eSgpKSB7XG4gICAgICAgIHJldHVybiAncCBpcyBpbmZpbml0eSdcbiAgICAgIH1cblxuICAgICAgaWYgKCEocC5nZXRYKCkubW9kKG4pLmNtcChyKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuICdJbnZhbGlkIHNpZ25hdHVyZSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHNpZ24gKCkge1xuICAgICAgbGV0IGhhc2hCdWYgPSB0aGlzLmhhc2hCdWZcbiAgICAgIGxldCBwcml2S2V5ID0gdGhpcy5rZXlQYWlyLnByaXZLZXlcblxuICAgICAgbGV0IGQgPSBwcml2S2V5LmJuXG5cbiAgICAgIGlmICghaGFzaEJ1ZiB8fCAhcHJpdktleSB8fCAhZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGFyYW1ldGVycycpXG4gICAgICB9XG5cbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGhhc2hCdWYpIHx8IGhhc2hCdWYubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hCdWYgbXVzdCBiZSBhIDMyIGJ5dGUgYnVmZmVyJylcbiAgICAgIH1cblxuICAgICAgbGV0IE4gPSBQb2ludC5nZXROKClcbiAgICAgIGxldCBHID0gUG9pbnQuZ2V0RygpXG4gICAgICBsZXQgZSA9IG5ldyBCbigpLmZyb21CdWZmZXIoaGFzaEJ1ZiwgdGhpcy5lbmRpYW4gPyB7ZW5kaWFuOiB0aGlzLmVuZGlhbn0gOiB1bmRlZmluZWQpXG5cbiAgICAgIC8vIHRyeSBkaWZmZXJlbnQgdmFsdWVzIG9mIGsgdW50aWwgciwgcyBhcmUgdmFsaWRcbiAgICAgIGxldCBiYWRycyA9IDBcbiAgICAgIGxldCBrLCBRLCByLCBzXG4gICAgICBkbyB7XG4gICAgICAgIGlmICghdGhpcy5rIHx8IGJhZHJzID4gMCkge1xuICAgICAgICAgIHRoaXMuZGV0ZXJtaW5pc3RpY0soYmFkcnMpXG4gICAgICAgIH1cbiAgICAgICAgYmFkcnMrK1xuICAgICAgICBrID0gdGhpcy5rXG4gICAgICAgIFEgPSBHLm11bChrKVxuICAgICAgICByID0gUS5nZXRYKCkubW9kKE4pXG4gICAgICAgIHMgPSBrLmludm0oTikubXVsKGUuYWRkKGQubXVsKHIpKSkubW9kKE4pXG4gICAgICB9IHdoaWxlIChyLmNtcCgwKSA8PSAwIHx8IHMuY21wKDApIDw9IDApXG5cbiAgICAgIC8vIGVuZm9yY2UgbG93IHNcbiAgICAgIC8vIHNlZSBCaXAgNjIsIFwibG93IFMgdmFsdWVzIGluIHNpZ25hdHVyZXNcIlxuICAgICAgaWYgKHMuZ3QobmV3IEJuKCkuZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKCc3RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjVENTc2RTczNTdBNDUwMURERkU5MkY0NjY4MUIyMEEwJywgJ2hleCcpKSkpIHtcbiAgICAgICAgcyA9IFBvaW50LmdldE4oKS5zdWIocylcbiAgICAgIH1cbiAgICAgIHRoaXMuc2lnID0gU2lnLmZyb21PYmplY3Qoe3I6IHIsIHM6IHMsIGNvbXByZXNzZWQ6IHRoaXMua2V5UGFpci5wdWJLZXkuY29tcHJlc3NlZH0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGFzeW5jU2lnbiAoKSB7XG4gICAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCB3b3JrZXJzUmVzdWx0ID0geWllbGQgV29ya2Vycy5hc3luY09iamVjdE1ldGhvZCh0aGlzLCAnc2lnbicsIFtdKVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tRmFzdEJ1ZmZlcih3b3JrZXJzUmVzdWx0LnJlc2J1ZilcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuXG4gICAgc2lnblJhbmRvbUsgKCkge1xuICAgICAgdGhpcy5yYW5kb21LKClcbiAgICAgIHJldHVybiB0aGlzLnNpZ24oKVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIGxldCBvYmogPSB7fVxuICAgICAgaWYgKHRoaXMuaGFzaEJ1Zikge1xuICAgICAgICBvYmouaGFzaEJ1ZiA9IHRoaXMuaGFzaEJ1Zi50b1N0cmluZygnaGV4JylcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmtleVBhaXIpIHtcbiAgICAgICAgb2JqLmtleVBhaXIgPSB0aGlzLmtleVBhaXIudG9TdHJpbmcoKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2lnKSB7XG4gICAgICAgIG9iai5zaWcgPSB0aGlzLnNpZy50b1N0cmluZygpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5rKSB7XG4gICAgICAgIG9iai5rID0gdGhpcy5rLnRvU3RyaW5nKClcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopXG4gICAgfVxuXG4gICAgdmVyaWZ5ICgpIHtcbiAgICAgIGlmICghdGhpcy52ZXJpZnlTdHIoKSkge1xuICAgICAgICB0aGlzLnZlcmlmaWVkID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy52ZXJpZmllZCA9IGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGFzeW5jVmVyaWZ5ICgpIHtcbiAgICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgbGV0IHdvcmtlcnNSZXN1bHQgPSB5aWVsZCBXb3JrZXJzLmFzeW5jT2JqZWN0TWV0aG9kKHRoaXMsICd2ZXJpZnknLCBbXSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUZhc3RCdWZmZXIod29ya2Vyc1Jlc3VsdC5yZXNidWYpXG4gICAgICB9LCB0aGlzKVxuICAgIH1cblxuICAgIHN0YXRpYyBzaWduIChoYXNoQnVmLCBrZXlQYWlyLCBlbmRpYW4pIHtcbiAgICAgIHJldHVybiBuZXcgRWNkc2EoKS5mcm9tT2JqZWN0KHtcbiAgICAgICAgaGFzaEJ1ZjogaGFzaEJ1ZixcbiAgICAgICAgZW5kaWFuOiBlbmRpYW4sXG4gICAgICAgIGtleVBhaXI6IGtleVBhaXJcbiAgICAgIH0pLnNpZ24oKS5zaWdcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmNTaWduIChoYXNoQnVmLCBrZXlQYWlyLCBlbmRpYW4pIHtcbiAgICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgbGV0IGVjZHNhID0gbmV3IEVjZHNhKCkuZnJvbU9iamVjdCh7XG4gICAgICAgICAgaGFzaEJ1ZjogaGFzaEJ1ZixcbiAgICAgICAgICBlbmRpYW46IGVuZGlhbixcbiAgICAgICAgICBrZXlQYWlyOiBrZXlQYWlyXG4gICAgICAgIH0pXG4gICAgICAgIHlpZWxkIGVjZHNhLmFzeW5jU2lnbigpXG4gICAgICAgIHJldHVybiBlY2RzYS5zaWdcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuXG4gICAgc3RhdGljIHZlcmlmeSAoaGFzaEJ1Ziwgc2lnLCBwdWJLZXksIGVuZGlhbikge1xuICAgICAgcmV0dXJuIG5ldyBFY2RzYSgpLmZyb21PYmplY3Qoe1xuICAgICAgICBoYXNoQnVmOiBoYXNoQnVmLFxuICAgICAgICBlbmRpYW46IGVuZGlhbixcbiAgICAgICAgc2lnOiBzaWcsXG4gICAgICAgIGtleVBhaXI6IG5ldyBLZXlQYWlyKCkuZnJvbU9iamVjdCh7cHViS2V5OiBwdWJLZXl9KVxuICAgICAgfSkudmVyaWZ5KCkudmVyaWZpZWRcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmNWZXJpZnkgKGhhc2hCdWYsIHNpZywgcHViS2V5LCBlbmRpYW4pIHtcbiAgICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgbGV0IGVjZHNhID0gbmV3IEVjZHNhKCkuZnJvbU9iamVjdCh7XG4gICAgICAgICAgaGFzaEJ1ZjogaGFzaEJ1ZixcbiAgICAgICAgICBlbmRpYW46IGVuZGlhbixcbiAgICAgICAgICBzaWc6IHNpZyxcbiAgICAgICAgICBrZXlQYWlyOiBuZXcgS2V5UGFpcigpLmZyb21PYmplY3Qoe3B1YktleTogcHViS2V5fSlcbiAgICAgICAgfSlcbiAgICAgICAgeWllbGQgZWNkc2EuYXN5bmNWZXJpZnkoKVxuICAgICAgICByZXR1cm4gZWNkc2EudmVyaWZpZWRcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEVjZHNhXG59XG5cbmluamVjdCA9IHJlcXVpcmUoJ2luamVjdGVyJykoaW5qZWN0LCBkZXBlbmRlbmNpZXMpXG5sZXQgRWNkc2EgPSBpbmplY3QoKVxuRWNkc2EuTWFpbm5ldCA9IGluamVjdCh7XG4gIEtleVBhaXI6IHJlcXVpcmUoJy4va2V5LXBhaXInKS5NYWlubmV0XG59KVxuRWNkc2EuVGVzdG5ldCA9IGluamVjdCh7XG4gIEtleVBhaXI6IHJlcXVpcmUoJy4va2V5LXBhaXInKS5UZXN0bmV0XG59KVxubW9kdWxlLmV4cG9ydHMgPSBFY2RzYVxuIiwiLyoqXG4gKiBIYXNoXG4gKiA9PT09XG4gKlxuICogU29tZSBoYXNoIGZ1bmN0aW9ucyBhcmUgdXNlZCB0aHJvdWdoIG91dCBiaXRjb2luLiBXZSBleHBvc2UgdGhlbSBoZXJlIGFzIGFcbiAqIGNvbnZlbmllbmNlLlxuICovXG4ndXNlIHN0cmljdCdcbmxldCBkZXBlbmRlbmNpZXMgPSB7XG4gIFdvcmtlcnM6IHJlcXVpcmUoJy4vd29ya2VycycpLFxuICBhc2luazogcmVxdWlyZSgnYXNpbmsnKSxcbiAgaGFzaGpzOiByZXF1aXJlKCdoYXNoLmpzJylcbn1cblxubGV0IGluamVjdCA9IGZ1bmN0aW9uIChkZXBzKSB7XG4gIGxldCBXb3JrZXJzID0gZGVwcy5Xb3JrZXJzXG4gIGxldCBhc2luayA9IGRlcHMuYXNpbmtcbiAgbGV0IGhhc2hqcyA9IGRlcHMuaGFzaGpzXG5cbiAgbGV0IEhhc2ggPSB7fVxuXG4gIEhhc2guc2hhMSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYTEgaGFzaCBtdXN0IGJlIG9mIGEgYnVmZmVyJylcbiAgICB9XG4gICAgbGV0IFNoYTEgPSBoYXNoanMuc2hhMVxuICAgIGxldCBoYXNoID0gKG5ldyBTaGExKCkpLnVwZGF0ZShidWYpLmRpZ2VzdCgpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoaGFzaClcbiAgfVxuXG4gIEhhc2guc2hhMS5ibG9ja1NpemUgPSA1MTJcblxuICBIYXNoLmFzeW5jU2hhMSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBsZXQgYXJncyA9IFtidWZdXG4gICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNDbGFzc01ldGhvZCgnSGFzaCcsICdzaGExJywgYXJncylcbiAgICAgIHJldHVybiB3b3JrZXJzUmVzdWx0LnJlc2J1ZlxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBIYXNoLnNoYTI1NiA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYTI1NiBoYXNoIG11c3QgYmUgb2YgYSBidWZmZXInKVxuICAgIH1cbiAgICBsZXQgU2hhMjU2ID0gaGFzaGpzLnNoYTI1NlxuICAgIGxldCBoYXNoID0gKG5ldyBTaGEyNTYoKSkudXBkYXRlKGJ1ZikuZGlnZXN0KClcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihoYXNoKVxuICB9XG5cbiAgSGFzaC5zaGEyNTYuYmxvY2tTaXplID0gNTEyXG5cbiAgSGFzaC5hc3luY1NoYTI1NiA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBsZXQgYXJncyA9IFtidWZdXG4gICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNDbGFzc01ldGhvZCgnSGFzaCcsICdzaGEyNTYnLCBhcmdzKVxuICAgICAgcmV0dXJuIHdvcmtlcnNSZXN1bHQucmVzYnVmXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIEhhc2guc2hhMjU2U2hhMjU2ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSGFzaC5zaGEyNTYoSGFzaC5zaGEyNTYoYnVmKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYTI1NlNoYTI1NiBoYXNoIG11c3QgYmUgb2YgYSBidWZmZXI6ICcgKyBlKVxuICAgIH1cbiAgfVxuXG4gIEhhc2guYXN5bmNTaGEyNTZTaGEyNTYgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgbGV0IGFyZ3MgPSBbYnVmXVxuICAgICAgbGV0IHdvcmtlcnNSZXN1bHQgPSB5aWVsZCBXb3JrZXJzLmFzeW5jQ2xhc3NNZXRob2QoJ0hhc2gnLCAnc2hhMjU2U2hhMjU2JywgYXJncylcbiAgICAgIHJldHVybiB3b3JrZXJzUmVzdWx0LnJlc2J1ZlxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBIYXNoLnJpcGVtZDE2MCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JpcGVtZDE2MCBoYXNoIG11c3QgYmUgb2YgYSBidWZmZXInKVxuICAgIH1cbiAgICBsZXQgUmlwZW1kMTYwID0gaGFzaGpzLnJpcGVtZDE2MFxuICAgIGxldCBoYXNoID0gKG5ldyBSaXBlbWQxNjAoKSkudXBkYXRlKGJ1ZikuZGlnZXN0KClcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihoYXNoKVxuICB9XG5cbiAgSGFzaC5hc3luY1JpcGVtZDE2MCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBsZXQgYXJncyA9IFtidWZdXG4gICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNDbGFzc01ldGhvZCgnSGFzaCcsICdyaXBlbWQxNjAnLCBhcmdzKVxuICAgICAgcmV0dXJuIHdvcmtlcnNSZXN1bHQucmVzYnVmXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIEhhc2guc2hhMjU2UmlwZW1kMTYwID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSGFzaC5yaXBlbWQxNjAoSGFzaC5zaGEyNTYoYnVmKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYTI1NlJpcGVtZDE2MCBoYXNoIG11c3QgYmUgb2YgYSBidWZmZXI6ICcgKyBlKVxuICAgIH1cbiAgfVxuXG4gIEhhc2guYXN5bmNTaGEyNTZSaXBlbWQxNjAgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgbGV0IGFyZ3MgPSBbYnVmXVxuICAgICAgbGV0IHdvcmtlcnNSZXN1bHQgPSB5aWVsZCBXb3JrZXJzLmFzeW5jQ2xhc3NNZXRob2QoJ0hhc2gnLCAnc2hhMjU2UmlwZW1kMTYwJywgYXJncylcbiAgICAgIHJldHVybiB3b3JrZXJzUmVzdWx0LnJlc2J1ZlxuICAgIH0sIHRoaXMpXG4gIH1cblxuICBIYXNoLnNoYTUxMiA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYTUxMiBoYXNoIG11c3QgYmUgb2YgYSBidWZmZXInKVxuICAgIH1cbiAgICBsZXQgU2hhNTEyID0gaGFzaGpzLnNoYTUxMlxuICAgIGxldCBoYXNoID0gKG5ldyBTaGE1MTIoKSkudXBkYXRlKGJ1ZikuZGlnZXN0KClcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihoYXNoKVxuICB9XG5cbiAgSGFzaC5hc3luY1NoYTUxMiA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBsZXQgYXJncyA9IFtidWZdXG4gICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNDbGFzc01ldGhvZCgnSGFzaCcsICdzaGE1MTInLCBhcmdzKVxuICAgICAgcmV0dXJuIHdvcmtlcnNSZXN1bHQucmVzYnVmXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIEhhc2guc2hhNTEyLmJsb2NrU2l6ZSA9IDEwMjRcblxuICBIYXNoLmhtYWMgPSBmdW5jdGlvbiAoaGFzaEZTdHIsIGRhdGEsIGtleSkge1xuICAgIGlmIChoYXNoRlN0ciAhPT0gJ3NoYTEnICYmIGhhc2hGU3RyICE9PSAnc2hhMjU2JyAmJiBoYXNoRlN0ciAhPT0gJ3NoYTUxMicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaG9pY2Ugb2YgaGFzaCBmdW5jdGlvbicpXG4gICAgfVxuXG4gICAgbGV0IGhhc2hmID0gSGFzaFtoYXNoRlN0cl1cblxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIGFuZCBrZXkgbXVzdCBiZSBidWZmZXJzJylcbiAgICB9XG5cbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhc2gtYmFzZWRfbWVzc2FnZV9hdXRoZW50aWNhdGlvbl9jb2RlXG4gICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDg2OCNzZWN0aW9uLTJcbiAgICBsZXQgYmxvY2tTaXplID0gaGFzaGYuYmxvY2tTaXplIC8gOFxuXG4gICAgaWYgKGtleS5sZW5ndGggPiBibG9ja1NpemUpIHtcbiAgICAgIGtleSA9IGhhc2hmKGtleSlcbiAgICB9XG5cbiAgICBpZiAoa2V5Lmxlbmd0aCA8IGJsb2NrU2l6ZSkge1xuICAgICAgbGV0IGZpbGwgPSBuZXcgQnVmZmVyKGJsb2NrU2l6ZSlcbiAgICAgIGZpbGwuZmlsbCgwLCBrZXkubGVuZ3RoKVxuICAgICAga2V5LmNvcHkoZmlsbClcbiAgICAgIGtleSA9IGZpbGxcbiAgICB9XG5cbiAgICBsZXQgb0tleVBhZCA9IG5ldyBCdWZmZXIoYmxvY2tTaXplKVxuICAgIGxldCBpS2V5UGFkID0gbmV3IEJ1ZmZlcihibG9ja1NpemUpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuICAgICAgb0tleVBhZFtpXSA9IDB4NWMgXiBrZXlbaV1cbiAgICAgIGlLZXlQYWRbaV0gPSAweDM2IF4ga2V5W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2hmKEJ1ZmZlci5jb25jYXQoW29LZXlQYWQsIGhhc2hmKEJ1ZmZlci5jb25jYXQoW2lLZXlQYWQsIGRhdGFdKSldKSlcbiAgfVxuXG4gIEhhc2guc2hhMUhtYWMgPSBmdW5jdGlvbiAoZGF0YSwga2V5KSB7XG4gICAgcmV0dXJuIEhhc2guaG1hYygnc2hhMScsIGRhdGEsIGtleSlcbiAgfVxuXG4gIEhhc2guYXN5bmNTaGExSG1hYyA9IGZ1bmN0aW9uIChkYXRhLCBrZXkpIHtcbiAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICBsZXQgYXJncyA9IFtkYXRhLCBrZXldXG4gICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNDbGFzc01ldGhvZCgnSGFzaCcsICdzaGExSG1hYycsIGFyZ3MpXG4gICAgICByZXR1cm4gd29ya2Vyc1Jlc3VsdC5yZXNidWZcbiAgICB9LCB0aGlzKVxuICB9XG5cbiAgSGFzaC5zaGExSG1hYy5iaXRzaXplID0gMTYwXG5cbiAgSGFzaC5zaGEyNTZIbWFjID0gZnVuY3Rpb24gKGRhdGEsIGtleSkge1xuICAgIHJldHVybiBIYXNoLmhtYWMoJ3NoYTI1NicsIGRhdGEsIGtleSlcbiAgfVxuXG4gIEhhc2guYXN5bmNTaGEyNTZIbWFjID0gZnVuY3Rpb24gKGRhdGEsIGtleSkge1xuICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgIGxldCBhcmdzID0gW2RhdGEsIGtleV1cbiAgICAgIGxldCB3b3JrZXJzUmVzdWx0ID0geWllbGQgV29ya2Vycy5hc3luY0NsYXNzTWV0aG9kKCdIYXNoJywgJ3NoYTI1NkhtYWMnLCBhcmdzKVxuICAgICAgcmV0dXJuIHdvcmtlcnNSZXN1bHQucmVzYnVmXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIEhhc2guc2hhMjU2SG1hYy5iaXRzaXplID0gMjU2XG5cbiAgSGFzaC5zaGE1MTJIbWFjID0gZnVuY3Rpb24gKGRhdGEsIGtleSkge1xuICAgIHJldHVybiBIYXNoLmhtYWMoJ3NoYTUxMicsIGRhdGEsIGtleSlcbiAgfVxuXG4gIEhhc2guYXN5bmNTaGE1MTJIbWFjID0gZnVuY3Rpb24gKGRhdGEsIGtleSkge1xuICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgIGxldCBhcmdzID0gW2RhdGEsIGtleV1cbiAgICAgIGxldCB3b3JrZXJzUmVzdWx0ID0geWllbGQgV29ya2Vycy5hc3luY0NsYXNzTWV0aG9kKCdIYXNoJywgJ3NoYTUxMkhtYWMnLCBhcmdzKVxuICAgICAgcmV0dXJuIHdvcmtlcnNSZXN1bHQucmVzYnVmXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIEhhc2guc2hhNTEySG1hYy5iaXRzaXplID0gNTEyXG5cbiAgcmV0dXJuIEhhc2hcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBIYXNoID0gaW5qZWN0KClcbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuIiwiLyoqXG4gKiBLZXlQYWlyXG4gKiA9PT09PT09XG4gKlxuICogQSBrZXlQYWlyIGlzIGEgY29sbGVjdGlvbiBvZiBhIHByaXZhdGUga2V5IGFuZCBhIHB1YmxpYyBrZXkuXG4gKiBsZXQga2V5UGFpciA9IG5ldyBLZXlQYWlyKCkuZnJvbVJhbmRvbSgpXG4gKiBsZXQga2V5UGFpciA9IG5ldyBLZXlQYWlyKCkuZnJvbVByaXZLZXkocHJpdktleSlcbiAqIGxldCBwcml2S2V5ID0ga2V5UGFpci5wcml2S2V5XG4gKiBsZXQgcHViS2V5ID0ga2V5UGFpci5wdWJLZXlcbiAqL1xuJ3VzZSBzdHJpY3QnXG5sZXQgZGVwZW5kZW5jaWVzID0ge1xuICBQcml2S2V5OiByZXF1aXJlKCcuL3ByaXYta2V5JyksXG4gIFB1YktleTogcmVxdWlyZSgnLi9wdWIta2V5JyksXG4gIFN0cnVjdDogcmVxdWlyZSgnLi9zdHJ1Y3QnKSxcbiAgQnc6IHJlcXVpcmUoJy4vYncnKSxcbiAgYXNpbms6IHJlcXVpcmUoJ2FzaW5rJylcbn1cblxubGV0IGluamVjdCA9IGZ1bmN0aW9uIChkZXBzKSB7XG4gIGxldCBQcml2S2V5ID0gZGVwcy5Qcml2S2V5XG4gIGxldCBQdWJLZXkgPSBkZXBzLlB1YktleVxuICBsZXQgU3RydWN0ID0gZGVwcy5TdHJ1Y3RcbiAgbGV0IEJ3ID0gZGVwcy5Cd1xuICBsZXQgYXNpbmsgPSBkZXBzLmFzaW5rXG5cbiAgY2xhc3MgS2V5UGFpciBleHRlbmRzIFN0cnVjdCB7XG4gICAgY29uc3RydWN0b3IgKHByaXZLZXksIHB1YktleSkge1xuICAgICAgc3VwZXIoe3ByaXZLZXksIHB1YktleX0pXG4gICAgfVxuXG4gICAgZnJvbUpTT04gKGpzb24pIHtcbiAgICAgIGlmIChqc29uLnByaXZLZXkpIHtcbiAgICAgICAgdGhpcy5wcml2S2V5ID0gUHJpdktleS5mcm9tSlNPTihqc29uLnByaXZLZXkpXG4gICAgICB9XG4gICAgICBpZiAoanNvbi5wdWJLZXkpIHtcbiAgICAgICAgdGhpcy5wdWJLZXkgPSBQdWJLZXkuZnJvbUpTT04oanNvbi5wdWJLZXkpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbi8qXG4gICAgdG9KU09OICgpIHtcbiAgICAgIGxldCBqc29uID0ge31cbiAgICAgIGlmICh0aGlzLnByaXZLZXkgJiYgdGhpcy5wcml2S2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAganNvbi5wcml2S2V5ID0gdGhpcy5wcml2S2V5LnRvSlNPTigpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wdWJLZXkgJiYgdGhpcy5wdWJLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBqc29uLnB1YktleSA9IHRoaXMucHViS2V5LnRvSlNPTigpXG4gICAgICB9XG4gICAgICByZXR1cm4ganNvblxuICAgIH1cbiovXG4gICAgZnJvbUJyIChicikge1xuICAgICAgbGV0IGJ1ZmxlbjEgPSBici5yZWFkVUludDgoKVxuICAgICAgaWYgKGJ1ZmxlbjEgPiAwKSB7XG4gICAgICAgIHRoaXMucHJpdktleSA9IG5ldyBQcml2S2V5KCkuZnJvbUZhc3RCdWZmZXIoYnIucmVhZChidWZsZW4xKSlcbiAgICAgIH1cbiAgICAgIGxldCBidWZsZW4yID0gYnIucmVhZFVJbnQ4KClcbiAgICAgIGlmIChidWZsZW4yID4gMCkge1xuICAgICAgICB0aGlzLnB1YktleSA9IG5ldyBQdWJLZXkoKS5mcm9tRmFzdEJ1ZmZlcihici5yZWFkKGJ1ZmxlbjIpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0b0J3IChidykge1xuICAgICAgaWYgKCFidykge1xuICAgICAgICBidyA9IG5ldyBCdygpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcml2S2V5KSB7XG4gICAgICAgIGxldCBwcml2S2V5YnVmID0gdGhpcy5wcml2S2V5LnRvRmFzdEJ1ZmZlcigpXG4gICAgICAgIGJ3LndyaXRlVUludDgocHJpdktleWJ1Zi5sZW5ndGgpXG4gICAgICAgIGJ3LndyaXRlKHByaXZLZXlidWYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidy53cml0ZVVJbnQ4KDApXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wdWJLZXkpIHtcbiAgICAgICAgbGV0IHB1YktleWJ1ZiA9IHRoaXMucHViS2V5LnRvRmFzdEJ1ZmZlcigpXG4gICAgICAgIGJ3LndyaXRlVUludDgocHViS2V5YnVmLmxlbmd0aClcbiAgICAgICAgYncud3JpdGUocHViS2V5YnVmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYncud3JpdGVVSW50OCgwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ3XG4gICAgfVxuXG4gICAgZnJvbVN0cmluZyAoc3RyKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcm9tSlNPTihKU09OLnBhcnNlKHN0cikpXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpXG4gICAgfVxuXG4gICAgdG9QdWJsaWMgKCkge1xuICAgICAgbGV0IGtleVBhaXIgPSBuZXcgS2V5UGFpcigpLmZyb21PYmplY3QodGhpcylcbiAgICAgIGtleVBhaXIucHJpdktleSA9IHVuZGVmaW5lZFxuICAgICAgcmV0dXJuIGtleVBhaXJcbiAgICB9XG5cbiAgICBmcm9tUHJpdktleSAocHJpdktleSkge1xuICAgICAgdGhpcy5wcml2S2V5ID0gcHJpdktleVxuICAgICAgdGhpcy5wdWJLZXkgPSBuZXcgUHViS2V5KCkuZnJvbVByaXZLZXkocHJpdktleSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21Qcml2S2V5IChwcml2S2V5KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tUHJpdktleShwcml2S2V5KVxuICAgIH1cblxuICAgIGFzeW5jRnJvbVByaXZLZXkgKHByaXZLZXkpIHtcbiAgICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgdGhpcy5wcml2S2V5ID0gcHJpdktleVxuICAgICAgICB0aGlzLnB1YktleSA9IHlpZWxkIG5ldyBQdWJLZXkoKS5hc3luY0Zyb21Qcml2S2V5KHByaXZLZXkpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LCB0aGlzKVxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luY0Zyb21Qcml2S2V5IChwcml2S2V5KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5hc3luY0Zyb21Qcml2S2V5KHByaXZLZXkpXG4gICAgfVxuXG4gICAgZnJvbVJhbmRvbSAoKSB7XG4gICAgICB0aGlzLnByaXZLZXkgPSBuZXcgUHJpdktleSgpLmZyb21SYW5kb20oKVxuICAgICAgdGhpcy5wdWJLZXkgPSBuZXcgUHViS2V5KCkuZnJvbVByaXZLZXkodGhpcy5wcml2S2V5KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVJhbmRvbSAoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tUmFuZG9tKClcbiAgICB9XG5cbiAgICBhc3luY0Zyb21SYW5kb20gKCkge1xuICAgICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgICB0aGlzLnByaXZLZXkgPSBuZXcgUHJpdktleSgpLmZyb21SYW5kb20oKVxuICAgICAgICByZXR1cm4gdGhpcy5hc3luY0Zyb21Qcml2S2V5KHRoaXMucHJpdktleSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jRnJvbVJhbmRvbSAoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5hc3luY0Zyb21SYW5kb20oKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBLZXlQYWlyXG59XG5cbmluamVjdCA9IHJlcXVpcmUoJ2luamVjdGVyJykoaW5qZWN0LCBkZXBlbmRlbmNpZXMpXG5sZXQgS2V5UGFpciA9IGluamVjdCgpXG5LZXlQYWlyLk1haW5uZXQgPSBpbmplY3Qoe1xuICBQcml2S2V5OiByZXF1aXJlKCcuL3ByaXYta2V5JykuTWFpbm5ldFxufSlcbktleVBhaXIuVGVzdG5ldCA9IGluamVjdCh7XG4gIFByaXZLZXk6IHJlcXVpcmUoJy4vcHJpdi1rZXknKS5UZXN0bmV0XG59KVxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyXG4iLCIvKlxuICogT3BDb2RlXG4gKiA9PT09PT1cbiAqXG4gKiBBbiBvcENvZGUgaXMgb25lIG9mIHRoZSBvcGVyYXRpb25zIGluIHRoZSBiaXRjb2luIHNjcmlwdGluZyBsYW5ndWFnZS4gRWFjaFxuICogb3BlcmF0aW9uIGlzIGp1c3QgYSBudW1iZXIgZnJvbSAwLTI1NSwgYW5kIGl0IGhhcyBhIGNvcnJlc3BvbmRpbmcgc3RyaW5nLFxuICogZS5nLiBcIk9QX1JFVFVSTlwiLCB3aGljaCBjb21lcyBmcm9tIHRoZSBuYW1lIG9mIHRoYXQgY29uc3RhbnQgaW4gdGhlIGJpdGNvaW5kXG4gKiBzb3VyY2UgY29kZS4gVGhlIHdheSB5b3UgcHJvYmFibHkgd2FudCB0byB1c2UgdGhpcyBpcyB3aXRoXG4gKiBuZXcgT3BDb2RlKHN0cikudG9OdW1iZXIoKSBvciBuZXcgT3BDb2RlKG51bSkudG9TdHJpbmcoKVxuICovXG4ndXNlIHN0cmljdCdcbmxldCBkZXBlbmRlbmNpZXMgPSB7XG4gIFN0cnVjdDogcmVxdWlyZSgnLi9zdHJ1Y3QnKVxufVxuXG5sZXQgaW5qZWN0ID0gZnVuY3Rpb24gKGRlcHMpIHtcbiAgbGV0IFN0cnVjdCA9IGRlcHMuU3RydWN0XG4gIGxldCBtYXBcblxuICBjbGFzcyBPcENvZGUgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yIChudW0pIHtcbiAgICAgIHN1cGVyKHtudW19KVxuICAgIH1cblxuICAgIGZyb21OdW1iZXIgKG51bSkge1xuICAgICAgdGhpcy5udW0gPSBudW1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21OdW1iZXIgKG51bSkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbU51bWJlcihudW0pXG4gICAgfVxuXG4gICAgdG9OdW1iZXIgKCkge1xuICAgICAgcmV0dXJuIHRoaXMubnVtXG4gICAgfVxuXG4gICAgZnJvbVN0cmluZyAoc3RyKSB7XG4gICAgICBsZXQgbnVtID0gbWFwW3N0cl1cbiAgICAgIGlmIChudW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BDb2RlU3RyJylcbiAgICAgIH1cbiAgICAgIHRoaXMubnVtID0gbnVtXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tU3RyaW5nIChzdHIpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmZyb21TdHJpbmcoc3RyKVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIGxldCBzdHIgPSBPcENvZGUuc3RyW3RoaXMubnVtXVxuICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLm51bSA+IDAgJiYgdGhpcy5udW0gPCBPcENvZGUuT1BfUFVTSERBVEExKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubnVtLnRvU3RyaW5nKClcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wQ29kZSBkb2VzIG5vdCBoYXZlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJcbiAgICB9XG4gIH1cblxuICBtYXAgPSB7XG4gICAgLy8gcHVzaCB2YWx1ZVxuICAgIE9QX0ZBTFNFOiAweDAwLFxuICAgIE9QXzA6IDB4MDAsXG4gICAgT1BfUFVTSERBVEExOiAweDRjLFxuICAgIE9QX1BVU0hEQVRBMjogMHg0ZCxcbiAgICBPUF9QVVNIREFUQTQ6IDB4NGUsXG4gICAgT1BfMU5FR0FURTogMHg0ZixcbiAgICBPUF9SRVNFUlZFRDogMHg1MCxcbiAgICBPUF9UUlVFOiAweDUxLFxuICAgIE9QXzE6IDB4NTEsXG4gICAgT1BfMjogMHg1MixcbiAgICBPUF8zOiAweDUzLFxuICAgIE9QXzQ6IDB4NTQsXG4gICAgT1BfNTogMHg1NSxcbiAgICBPUF82OiAweDU2LFxuICAgIE9QXzc6IDB4NTcsXG4gICAgT1BfODogMHg1OCxcbiAgICBPUF85OiAweDU5LFxuICAgIE9QXzEwOiAweDVhLFxuICAgIE9QXzExOiAweDViLFxuICAgIE9QXzEyOiAweDVjLFxuICAgIE9QXzEzOiAweDVkLFxuICAgIE9QXzE0OiAweDVlLFxuICAgIE9QXzE1OiAweDVmLFxuICAgIE9QXzE2OiAweDYwLFxuXG4gICAgLy8gY29udHJvbFxuICAgIE9QX05PUDogMHg2MSxcbiAgICBPUF9WRVI6IDB4NjIsXG4gICAgT1BfSUY6IDB4NjMsXG4gICAgT1BfTk9USUY6IDB4NjQsXG4gICAgT1BfVkVSSUY6IDB4NjUsXG4gICAgT1BfVkVSTk9USUY6IDB4NjYsXG4gICAgT1BfRUxTRTogMHg2NyxcbiAgICBPUF9FTkRJRjogMHg2OCxcbiAgICBPUF9WRVJJRlk6IDB4NjksXG4gICAgT1BfUkVUVVJOOiAweDZhLFxuXG4gICAgLy8gc3RhY2sgb3BzXG4gICAgT1BfVE9BTFRTVEFDSzogMHg2YixcbiAgICBPUF9GUk9NQUxUU1RBQ0s6IDB4NmMsXG4gICAgT1BfMkRST1A6IDB4NmQsXG4gICAgT1BfMkRVUDogMHg2ZSxcbiAgICBPUF8zRFVQOiAweDZmLFxuICAgIE9QXzJPVkVSOiAweDcwLFxuICAgIE9QXzJST1Q6IDB4NzEsXG4gICAgT1BfMlNXQVA6IDB4NzIsXG4gICAgT1BfSUZEVVA6IDB4NzMsXG4gICAgT1BfREVQVEg6IDB4NzQsXG4gICAgT1BfRFJPUDogMHg3NSxcbiAgICBPUF9EVVA6IDB4NzYsXG4gICAgT1BfTklQOiAweDc3LFxuICAgIE9QX09WRVI6IDB4NzgsXG4gICAgT1BfUElDSzogMHg3OSxcbiAgICBPUF9ST0xMOiAweDdhLFxuICAgIE9QX1JPVDogMHg3YixcbiAgICBPUF9TV0FQOiAweDdjLFxuICAgIE9QX1RVQ0s6IDB4N2QsXG5cbiAgICAvLyBzcGxpY2Ugb3BzXG4gICAgT1BfQ0FUOiAweDdlLFxuICAgIE9QX1NVQlNUUjogMHg3ZixcbiAgICBPUF9MRUZUOiAweDgwLFxuICAgIE9QX1JJR0hUOiAweDgxLFxuICAgIE9QX1NJWkU6IDB4ODIsXG5cbiAgICAvLyBiaXQgbG9naWNcbiAgICBPUF9JTlZFUlQ6IDB4ODMsXG4gICAgT1BfQU5EOiAweDg0LFxuICAgIE9QX09SOiAweDg1LFxuICAgIE9QX1hPUjogMHg4NixcbiAgICBPUF9FUVVBTDogMHg4NyxcbiAgICBPUF9FUVVBTFZFUklGWTogMHg4OCxcbiAgICBPUF9SRVNFUlZFRDE6IDB4ODksXG4gICAgT1BfUkVTRVJWRUQyOiAweDhhLFxuXG4gICAgLy8gbnVtZXJpY1xuICAgIE9QXzFBREQ6IDB4OGIsXG4gICAgT1BfMVNVQjogMHg4YyxcbiAgICBPUF8yTVVMOiAweDhkLFxuICAgIE9QXzJESVY6IDB4OGUsXG4gICAgT1BfTkVHQVRFOiAweDhmLFxuICAgIE9QX0FCUzogMHg5MCxcbiAgICBPUF9OT1Q6IDB4OTEsXG4gICAgT1BfME5PVEVRVUFMOiAweDkyLFxuXG4gICAgT1BfQUREOiAweDkzLFxuICAgIE9QX1NVQjogMHg5NCxcbiAgICBPUF9NVUw6IDB4OTUsXG4gICAgT1BfRElWOiAweDk2LFxuICAgIE9QX01PRDogMHg5NyxcbiAgICBPUF9MU0hJRlQ6IDB4OTgsXG4gICAgT1BfUlNISUZUOiAweDk5LFxuXG4gICAgT1BfQk9PTEFORDogMHg5YSxcbiAgICBPUF9CT09MT1I6IDB4OWIsXG4gICAgT1BfTlVNRVFVQUw6IDB4OWMsXG4gICAgT1BfTlVNRVFVQUxWRVJJRlk6IDB4OWQsXG4gICAgT1BfTlVNTk9URVFVQUw6IDB4OWUsXG4gICAgT1BfTEVTU1RIQU46IDB4OWYsXG4gICAgT1BfR1JFQVRFUlRIQU46IDB4YTAsXG4gICAgT1BfTEVTU1RIQU5PUkVRVUFMOiAweGExLFxuICAgIE9QX0dSRUFURVJUSEFOT1JFUVVBTDogMHhhMixcbiAgICBPUF9NSU46IDB4YTMsXG4gICAgT1BfTUFYOiAweGE0LFxuXG4gICAgT1BfV0lUSElOOiAweGE1LFxuXG4gICAgLy8gY3J5cHRvXG4gICAgT1BfUklQRU1EMTYwOiAweGE2LFxuICAgIE9QX1NIQTE6IDB4YTcsXG4gICAgT1BfU0hBMjU2OiAweGE4LFxuICAgIE9QX0hBU0gxNjA6IDB4YTksXG4gICAgT1BfSEFTSDI1NjogMHhhYSxcbiAgICBPUF9DT0RFU0VQQVJBVE9SOiAweGFiLFxuICAgIE9QX0NIRUNLU0lHOiAweGFjLFxuICAgIE9QX0NIRUNLU0lHVkVSSUZZOiAweGFkLFxuICAgIE9QX0NIRUNLTVVMVElTSUc6IDB4YWUsXG4gICAgT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWTogMHhhZixcblxuICAgIC8vIGV4cGFuc2lvblxuICAgIE9QX05PUDE6IDB4YjAsXG4gICAgT1BfTk9QMjogMHhiMSxcbiAgICBPUF9DSEVDS0xPQ0tUSU1FVkVSSUZZOiAweGIxLFxuICAgIE9QX05PUDM6IDB4YjIsXG4gICAgT1BfQ0hFQ0tTRVFVRU5DRVZFUklGWTogMHhiMixcbiAgICBPUF9OT1A0OiAweGIzLFxuICAgIE9QX05PUDU6IDB4YjQsXG4gICAgT1BfTk9QNjogMHhiNSxcbiAgICBPUF9OT1A3OiAweGI2LFxuICAgIE9QX05PUDg6IDB4YjcsXG4gICAgT1BfTk9QOTogMHhiOCxcbiAgICBPUF9OT1AxMDogMHhiOSxcblxuICAgIC8vIHRlbXBsYXRlIG1hdGNoaW5nIHBhcmFtc1xuICAgIE9QX1NNQUxMREFUQTogMHhmOSxcbiAgICBPUF9TTUFMTElOVEVHRVI6IDB4ZmEsXG4gICAgT1BfUFVCS0VZUzogMHhmYixcbiAgICBPUF9QVUJLRVlIQVNIOiAweGZkLFxuICAgIE9QX1BVQktFWTogMHhmZSxcblxuICAgIE9QX0lOVkFMSURPUENPREU6IDB4ZmZcbiAgfVxuXG4gIE9wQ29kZS5zdHIgPSB7fVxuXG4gIGZvciAobGV0IGsgaW4gbWFwKSB7XG4gICAgT3BDb2RlW2tdID0gbWFwW2tdXG4gICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgT3BDb2RlLnN0clttYXBba11dID0ga1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPcENvZGVcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBPcENvZGUgPSBpbmplY3QoKVxubW9kdWxlLmV4cG9ydHMgPSBPcENvZGVcbiIsIi8qKlxuICogUG9pbnQgKG9uIHNlY3AyNTZrMSlcbiAqID09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQSBwb2ludCBpcyBhIHBvaW50IG9uIHRoZSBzZWNwMjU2azEgY3VydmUgd2hpY2ggaXMgdGhlIGVsbGlwdGljIGN1cnZlIHVzZWRcbiAqIGJ5IGJpdGNvaW4uIFRoaXMgY29kZSBpcyBhIHdyYXBwZXIgZm9yIEZlZG9yIEluZHV0bnkncyBQb2ludCBjbGFzcyBmcm9tIGhpc1xuICogZWxsaXB0aWMgbGlicmFyeS4gVGhpcyBjb2RlIGFkZHMgYSBmZXcgbWlub3IgY29udmVuaWVuY2VzLCBidXQgaXMgbW9zdGx5IHRoZVxuICogc2FtZS4gU2luY2UgRmVkb3IncyBjb2RlIHJldHVybnMgcG9pbnRzIGFuZCBiaWcgbnVtYmVycyB0aGF0IGFyZSBpbnN0YW5jZXNcbiAqIG9mIGhpcyBwb2ludCBhbmQgYmlnIG51bWJlciBjbGFzc2VzLCB3ZSBoYXZlIHRvIHdyYXAgYWxsIHRoZSBtZXRob2RzIHN1Y2ggYXNcbiAqIGdldFgoKSB0byByZXR1cm4gdGhlIFlvdXJzIEJpdGNvaW4gcG9pbnQgYW5kIGJpZyBudW1iZXIgdHlwZXMuXG4gKi9cbid1c2Ugc3RyaWN0J1xubGV0IGRlcGVuZGVuY2llcyA9IHtcbiAgQm46IHJlcXVpcmUoJy4vYm4nKSxcbiAgZWxsaXB0aWM6IHJlcXVpcmUoJ2VsbGlwdGljJylcbn1cblxubGV0IGluamVjdCA9IGZ1bmN0aW9uIChkZXBzKSB7XG4gIGxldCBCbiA9IGRlcHMuQm5cbiAgbGV0IGVsbGlwdGljID0gZGVwcy5lbGxpcHRpY1xuXG4gIGxldCBlYyA9IGVsbGlwdGljLmN1cnZlcy5zZWNwMjU2azFcbiAgbGV0IF9wb2ludCA9IGVjLmN1cnZlLnBvaW50KClcbiAgbGV0IF9Qb2ludCA9IF9wb2ludC5jb25zdHJ1Y3RvclxuXG4gIGNsYXNzIFBvaW50IGV4dGVuZHMgX1BvaW50IHtcbiAgICBjb25zdHJ1Y3RvciAoeCwgeSwgaXNSZWQpIHtcbiAgICAgIHN1cGVyKGVjLmN1cnZlLCB4LCB5LCBpc1JlZClcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVggKGlzT2RkLCB4KSB7XG4gICAgICBsZXQgX3BvaW50ID0gZWMuY3VydmUucG9pbnRGcm9tWCh4LCBpc09kZClcbiAgICAgIGxldCBwb2ludCA9IE9iamVjdC5jcmVhdGUoUG9pbnQucHJvdG90eXBlKVxuICAgICAgcmV0dXJuIHBvaW50LmNvcHlGcm9tKF9wb2ludClcbiAgICB9XG5cbiAgICBjb3B5RnJvbSAocG9pbnQpIHtcbiAgICAgIGlmICghKHBvaW50IGluc3RhbmNlb2YgX1BvaW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IHNob3VsZCBiZSBhbiBleHRlcm5hbCBwb2ludCcpXG4gICAgICB9XG4gICAgICBPYmplY3Qua2V5cyhwb2ludCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXNba2V5XSA9IHBvaW50W2tleV1cbiAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgYWRkIChwKSB7XG4gICAgICBwID0gX1BvaW50LnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBwKVxuICAgICAgbGV0IHBvaW50ID0gT2JqZWN0LmNyZWF0ZShQb2ludC5wcm90b3R5cGUpXG4gICAgICByZXR1cm4gcG9pbnQuY29weUZyb20ocClcbiAgICB9XG5cbiAgICBtdWwgKGJuKSB7XG4gICAgICBsZXQgcCA9IF9Qb2ludC5wcm90b3R5cGUubXVsLmNhbGwodGhpcywgYm4pXG4gICAgICBsZXQgcG9pbnQgPSBPYmplY3QuY3JlYXRlKFBvaW50LnByb3RvdHlwZSlcbiAgICAgIHJldHVybiBwb2ludC5jb3B5RnJvbShwKVxuICAgIH1cblxuICAgIG11bEFkZCAoYm4xLCBwb2ludCwgYm4yKSB7XG4gICAgICBsZXQgcCA9IF9Qb2ludC5wcm90b3R5cGUubXVsQWRkLmNhbGwodGhpcywgYm4xLCBwb2ludCwgYm4yKVxuICAgICAgcG9pbnQgPSBPYmplY3QuY3JlYXRlKFBvaW50LnByb3RvdHlwZSlcbiAgICAgIHJldHVybiBwb2ludC5jb3B5RnJvbShwKVxuICAgIH1cblxuICAgIGdldFggKCkge1xuICAgICAgbGV0IF94ID0gX1BvaW50LnByb3RvdHlwZS5nZXRYLmNhbGwodGhpcylcbiAgICAgIGxldCB4ID0gT2JqZWN0LmNyZWF0ZShCbi5wcm90b3R5cGUpXG4gICAgICBfeC5jb3B5KHgpXG4gICAgICByZXR1cm4geFxuICAgIH1cblxuICAgIGdldFkgKCkge1xuICAgICAgbGV0IF95ID0gX1BvaW50LnByb3RvdHlwZS5nZXRZLmNhbGwodGhpcylcbiAgICAgIGxldCB5ID0gT2JqZWN0LmNyZWF0ZShCbi5wcm90b3R5cGUpXG4gICAgICBfeS5jb3B5KHkpXG4gICAgICByZXR1cm4geVxuICAgIH1cblxuICAgIGZyb21YIChpc09kZCwgeCkge1xuICAgICAgbGV0IHBvaW50ID0gUG9pbnQuZnJvbVgoaXNPZGQsIHgpXG4gICAgICByZXR1cm4gdGhpcy5jb3B5RnJvbShwb2ludClcbiAgICB9XG5cbiAgICB0b0pTT04gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5nZXRYKCkudG9TdHJpbmcoKSxcbiAgICAgICAgeTogdGhpcy5nZXRZKCkudG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZyb21KU09OIChqc29uKSB7XG4gICAgICBsZXQgeCA9IG5ldyBCbigpLmZyb21TdHJpbmcoanNvbi54KVxuICAgICAgbGV0IHkgPSBuZXcgQm4oKS5mcm9tU3RyaW5nKGpzb24ueSlcbiAgICAgIGxldCBwb2ludCA9IG5ldyBQb2ludCh4LCB5KVxuICAgICAgcmV0dXJuIHRoaXMuY29weUZyb20ocG9pbnQpXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpXG4gICAgfVxuXG4gICAgZnJvbVN0cmluZyAoc3RyKSB7XG4gICAgICBsZXQganNvbiA9IEpTT04ucGFyc2Uoc3RyKVxuICAgICAgbGV0IHAgPSBuZXcgUG9pbnQoKS5mcm9tSlNPTihqc29uKVxuICAgICAgcmV0dXJuIHRoaXMuY29weUZyb20ocClcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0RyAoKSB7XG4gICAgICBsZXQgX2cgPSBlYy5jdXJ2ZS5nXG4gICAgICBsZXQgZyA9IE9iamVjdC5jcmVhdGUoUG9pbnQucHJvdG90eXBlKVxuICAgICAgcmV0dXJuIGcuY29weUZyb20oX2cpXG4gICAgfVxuXG4gICAgc3RhdGljIGdldE4gKCkge1xuICAgICAgcmV0dXJuIG5ldyBCbihlYy5jdXJ2ZS5uLnRvQXJyYXkoKSlcbiAgICB9XG5cbiAgICAvLyBodHRwczovL3d3dy5pYWNyLm9yZy9hcmNoaXZlL3BrYzIwMDMvMjU2NzAyMTEvMjU2NzAyMTEucGRmXG4gICAgdmFsaWRhdGUgKCkge1xuICAgICAgbGV0IHAyID0gUG9pbnQuZnJvbVgodGhpcy5nZXRZKCkuaXNPZGQoKSwgdGhpcy5nZXRYKCkpXG4gICAgICBpZiAoIShwMi5nZXRZKCkuY21wKHRoaXMuZ2V0WSgpKSA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHkgdmFsdWUgb2YgcHVibGljIGtleScpXG4gICAgICB9XG4gICAgICBpZiAoISh0aGlzLmdldFgoKS5ndCgtMSkgJiYgdGhpcy5nZXRYKCkubHQoUG9pbnQuZ2V0TigpKSkgfHxcbiAgICAgICAgISh0aGlzLmdldFkoKS5ndCgtMSkgJiYgdGhpcy5nZXRZKCkubHQoUG9pbnQuZ2V0TigpKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBkb2VzIG5vdCBsaWUgb24gdGhlIGN1cnZlJylcbiAgICAgIH1cbiAgICAgIGlmICghKHRoaXMubXVsKFBvaW50LmdldE4oKSkuaXNJbmZpbml0eSgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IHRpbWVzIE4gbXVzdCBiZSBpbmZpbml0eScpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQb2ludFxufVxuXG5pbmplY3QgPSByZXF1aXJlKCdpbmplY3RlcicpKGluamVjdCwgZGVwZW5kZW5jaWVzKVxubGV0IFBvaW50ID0gaW5qZWN0KClcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRcbiIsIi8qKlxuICogUHJpdmF0ZSBLZXlcbiAqID09PT09PT09PT09XG4gKlxuICogQSBwcml2YXRlIGtleSBpcyB1c2VkIGZvciBzaWduSW5nIHRyYW5zYWN0aW9ucyAob3IgbWVzc2FnZXMpLiBUaGUgcHJpbWFyeVxuICogd2F5IHRvIHVzZSB0aGlzIGlzIG5ldyBQcml2S2V5KCkuZnJvbVJhbmRvbSgpLCBvciBuZXcgUHJpdktleSgpLmZyb21CdWZmZXIoYnVmKS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5sZXQgZGVwZW5kZW5jaWVzID0ge1xuICBCbjogcmVxdWlyZSgnLi9ibicpLFxuICBQb2ludDogcmVxdWlyZSgnLi9wb2ludCcpLFxuICBDb25zdGFudHM6IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuRGVmYXVsdC5Qcml2S2V5LFxuICBCYXNlNThDaGVjazogcmVxdWlyZSgnLi9iYXNlLTU4LWNoZWNrJyksXG4gIFJhbmRvbTogcmVxdWlyZSgnLi9yYW5kb20nKSxcbiAgU3RydWN0OiByZXF1aXJlKCcuL3N0cnVjdCcpXG59XG5cbmxldCBpbmplY3QgPSBmdW5jdGlvbiAoZGVwcykge1xuICBsZXQgQm4gPSBkZXBzLkJuXG4gIGxldCBQb2ludCA9IGRlcHMuUG9pbnRcbiAgbGV0IENvbnN0YW50cyA9IGRlcHMuQ29uc3RhbnRzXG4gIGxldCBCYXNlNThDaGVjayA9IGRlcHMuQmFzZTU4Q2hlY2tcbiAgbGV0IFJhbmRvbSA9IGRlcHMuUmFuZG9tXG4gIGxldCBTdHJ1Y3QgPSBkZXBzLlN0cnVjdFxuXG4gIGNsYXNzIFByaXZLZXkgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yIChibiwgY29tcHJlc3NlZCkge1xuICAgICAgc3VwZXIoe2JuLCBjb21wcmVzc2VkfSlcbiAgICB9XG5cbiAgICBmcm9tSlNPTiAoanNvbikge1xuICAgICAgdGhpcy5mcm9tSGV4KGpzb24pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRvSlNPTiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0hleCgpXG4gICAgfVxuXG4gICAgZnJvbVJhbmRvbSAoKSB7XG4gICAgICBsZXQgcHJpdkJ1ZiwgYm4sIGNvbmRpdGlvblxuXG4gICAgICBkbyB7XG4gICAgICAgIHByaXZCdWYgPSBSYW5kb20uZ2V0UmFuZG9tQnVmZmVyKDMyKVxuICAgICAgICBibiA9IG5ldyBCbigpLmZyb21CdWZmZXIocHJpdkJ1ZilcbiAgICAgICAgY29uZGl0aW9uID0gYm4ubHQoUG9pbnQuZ2V0TigpKVxuICAgICAgfSB3aGlsZSAoIWNvbmRpdGlvbilcblxuICAgICAgdGhpcy5mcm9tT2JqZWN0KHtcbiAgICAgICAgYm46IGJuLFxuICAgICAgICBjb21wcmVzc2VkOiB0cnVlXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVJhbmRvbSAoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tUmFuZG9tKClcbiAgICB9XG5cbiAgICB0b0J1ZmZlciAoKSB7XG4gICAgICBsZXQgY29tcHJlc3NlZCA9IHRoaXMuY29tcHJlc3NlZFxuXG4gICAgICBpZiAoY29tcHJlc3NlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXByZXNzZWQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGxldCBwcml2QnVmID0gdGhpcy5ibi50b0J1ZmZlcih7c2l6ZTogMzJ9KVxuICAgICAgbGV0IGJ1ZlxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbQ29uc3RhbnRzLnZlcnNpb25CeXRlTnVtXSksIHByaXZCdWYsIG5ldyBCdWZmZXIoWzB4MDFdKV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKFtDb25zdGFudHMudmVyc2lvbkJ5dGVOdW1dKSwgcHJpdkJ1Zl0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBmcm9tQnVmZmVyIChidWYpIHtcbiAgICAgIGlmIChidWYubGVuZ3RoID09PSAxICsgMzIgKyAxICYmIGJ1ZlsxICsgMzIgKyAxIC0gMV0gPT09IDEpIHtcbiAgICAgICAgdGhpcy5jb21wcmVzc2VkID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChidWYubGVuZ3RoID09PSAxICsgMzIpIHtcbiAgICAgICAgdGhpcy5jb21wcmVzc2VkID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTEVuZ3RoIG9mIHByaXZLZXkgYnVmZmVyIG11c3QgYmUgMzMgKHVuY29tcHJlc3NlZCBwdWJLZXkpIG9yIDM0IChjb21wcmVzc2VkIHB1YktleSknKVxuICAgICAgfVxuXG4gICAgICBpZiAoYnVmWzBdICE9PSBDb25zdGFudHMudmVyc2lvbkJ5dGVOdW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnNpb25CeXRlTnVtIGJ5dGUnKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5mcm9tQm4obmV3IEJuKCkuZnJvbUJ1ZmZlcihidWYuc2xpY2UoMSwgMSArIDMyKSkpXG4gICAgfVxuXG4gICAgdG9CbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iblxuICAgIH1cblxuICAgIGZyb21CbiAoYm4pIHtcbiAgICAgIHRoaXMuYm4gPSBiblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUJuIChibikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbUJuKGJuKVxuICAgIH1cblxuICAgIHZhbGlkYXRlICgpIHtcbiAgICAgIGlmICghdGhpcy5ibi5sdChQb2ludC5nZXROKCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIG11c3QgYmUgbGVzcyB0aGFuIE4nKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbXByZXNzZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSB3aGV0aGVyIHRoZSBjb3JyZXNwb25kaW5nIHB1YmxpYyBrZXkgaXMgY29tcHJlc3NlZCBvciBub3QgKHRydWUgb3IgZmFsc2UpJylcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3V0cHV0IHRoZSBwcml2YXRlIGtleSBhIFdhbGxldCBJbXBvcnQgRm9ybWF0IChXaWYpIHN0cmluZy5cbiAgICAgKi9cbiAgICB0b1dpZiAoKSB7XG4gICAgICByZXR1cm4gQmFzZTU4Q2hlY2suZW5jb2RlKHRoaXMudG9CdWZmZXIoKSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCB0aGUgcHJpdmF0ZSBrZXkgZnJvbSBhIFdhbGxldCBJbXBvcnQgRm9ybWF0IChXaWYpIHN0cmluZy5cbiAgICAgKi9cbiAgICBmcm9tV2lmIChzdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoQmFzZTU4Q2hlY2suZGVjb2RlKHN0cikpXG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21XaWYgKHN0cikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbVdpZihzdHIpXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9XaWYoKVxuICAgIH1cblxuICAgIGZyb21TdHJpbmcgKHN0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpZihzdHIpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFByaXZLZXlcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBQcml2S2V5ID0gaW5qZWN0KClcblByaXZLZXkuTWFpbm5ldCA9IGluamVjdCh7XG4gIENvbnN0YW50czogcmVxdWlyZSgnLi9jb25zdGFudHMnKS5NYWlubmV0LlByaXZLZXlcbn0pXG5Qcml2S2V5LlRlc3RuZXQgPSBpbmplY3Qoe1xuICBDb25zdGFudHM6IHJlcXVpcmUoJy4vY29uc3RhbnRzJykuVGVzdG5ldC5Qcml2S2V5XG59KVxubW9kdWxlLmV4cG9ydHMgPSBQcml2S2V5XG4iLCIvKipcbiAqIFB1YmxpYyBLZXlcbiAqID09PT09PT09PT1cbiAqXG4gKiBBIHB1YmxpYyBrZXkgY29ycmVzcG9uZHMgdG8gYSBwcml2YXRlIGtleS4gSWYgeW91IGhhdmUgYSBwcml2YXRlIGtleSwgeW91XG4gKiBjYW4gZmluZCB0aGUgY29ycmVzcG9uZGluZyBwdWJsaWMga2V5IHdpdGggbmV3IFB1YktleSgpLmZyb21Qcml2S2V5KHByaXZLZXkpLlxuICovXG4ndXNlIHN0cmljdCdcbmxldCBkZXBlbmRlbmNpZXMgPSB7XG4gIFBvaW50OiByZXF1aXJlKCcuL3BvaW50JyksXG4gIEJuOiByZXF1aXJlKCcuL2JuJyksXG4gIEJ3OiByZXF1aXJlKCcuL2J3JyksXG4gIFN0cnVjdDogcmVxdWlyZSgnLi9zdHJ1Y3QnKSxcbiAgV29ya2VyczogcmVxdWlyZSgnLi93b3JrZXJzJyksXG4gIGFzaW5rOiByZXF1aXJlKCdhc2luaycpXG59XG5cbmxldCBpbmplY3QgPSBmdW5jdGlvbiAoZGVwcykge1xuICBsZXQgUG9pbnQgPSBkZXBzLlBvaW50XG4gIGxldCBCbiA9IGRlcHMuQm5cbiAgbGV0IEJ3ID0gZGVwcy5Cd1xuICBsZXQgU3RydWN0ID0gZGVwcy5TdHJ1Y3RcbiAgbGV0IFdvcmtlcnMgPSBkZXBzLldvcmtlcnNcbiAgbGV0IGFzaW5rID0gZGVwcy5hc2lua1xuXG4gIGNsYXNzIFB1YktleSBleHRlbmRzIFN0cnVjdCB7XG4gICAgY29uc3RydWN0b3IgKHBvaW50KSB7XG4gICAgICBzdXBlcih7cG9pbnR9KVxuICAgIH1cblxuICAgIGZyb21KU09OIChqc29uKSB7XG4gICAgICB0aGlzLmZyb21GYXN0SGV4KGpzb24pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRvSlNPTiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0Zhc3RIZXgoKVxuICAgIH1cblxuICAgIGZyb21Qcml2S2V5IChwcml2S2V5KSB7XG4gICAgICB0aGlzLmZyb21PYmplY3Qoe1xuICAgICAgICBwb2ludDogUG9pbnQuZ2V0RygpLm11bChwcml2S2V5LmJuKSxcbiAgICAgICAgY29tcHJlc3NlZDogcHJpdktleS5jb21wcmVzc2VkXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVByaXZLZXkgKHByaXZLZXkpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmZyb21Qcml2S2V5KHByaXZLZXkpXG4gICAgfVxuXG4gICAgYXN5bmNGcm9tUHJpdktleSAocHJpdktleSkge1xuICAgICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNPYmplY3RNZXRob2QodGhpcywgJ2Zyb21Qcml2S2V5JywgW3ByaXZLZXldKVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tRmFzdEJ1ZmZlcih3b3JrZXJzUmVzdWx0LnJlc2J1ZilcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jRnJvbVByaXZLZXkgKHByaXZLZXkpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmFzeW5jRnJvbVByaXZLZXkocHJpdktleSlcbiAgICB9XG5cbiAgICBmcm9tQnVmZmVyIChidWYsIHN0cmljdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJvbURlcihidWYsIHN0cmljdClcbiAgICB9XG5cbiAgICBhc3luY0Zyb21CdWZmZXIgKGJ1Ziwgc3RyaWN0KSB7XG4gICAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCBhcmdzID0gW2J1Ziwgc3RyaWN0XVxuICAgICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNPYmplY3RNZXRob2QodGhpcywgJ2Zyb21CdWZmZXInLCBhcmdzKVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tRmFzdEJ1ZmZlcih3b3JrZXJzUmVzdWx0LnJlc2J1ZilcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuXG4gICAgZnJvbUZhc3RCdWZmZXIgKGJ1Zikge1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIGxldCBjb21wcmVzc2VkID0gQm9vbGVhbihidWZbMF0pXG4gICAgICBidWYgPSBidWYuc2xpY2UoMSlcbiAgICAgIHRoaXMuZnJvbURlcihidWYpXG4gICAgICB0aGlzLmNvbXByZXNzZWQgPSBjb21wcmVzc2VkXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluIG9yZGVyIHRvIG1pbWljIHRoZSBub24tc3RyaWN0IHN0eWxlIG9mIE9wZW5TU0wsIHNldCBzdHJpY3QgPSBmYWxzZS4gRm9yXG4gICAgICogaW5mb3JtYXRpb24gYW5kIHdoYXQgcHJlZml4ZXMgMHgwNiBhbmQgMHgwNyBtZWFuLCBpbiBhZGRpdGlvbiB0byB0aGUgbm9ybWFsXG4gICAgICogY29tcHJlc3NlZCBhbmQgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlzLCBzZWUgdGhlIG1lc3NhZ2UgYnkgUGV0ZXIgV3VpbGxlXG4gICAgICogd2hlcmUgaGUgZGlzY292ZXJlZCB0aGVzZSBcImh5YnJpZCBwdWJLZXlzXCIgb24gdGhlIG1haWxpbmcgbGlzdDpcbiAgICAgKiBodHRwOi8vc291cmNlZm9yZ2UubmV0L3AvYml0Y29pbi9tYWlsbWFuL21lc3NhZ2UvMjk0MTYxMzMvXG4gICAgICovXG4gICAgZnJvbURlciAoYnVmLCBzdHJpY3QpIHtcbiAgICAgIGlmIChzdHJpY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHJpY3QgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpY3QgPSBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKGJ1ZlswXSA9PT0gMHgwNCB8fCAoIXN0cmljdCAmJiAoYnVmWzBdID09PSAweDA2IHx8IGJ1ZlswXSA9PT0gMHgwNykpKSB7XG4gICAgICAgIGxldCB4YnVmID0gYnVmLnNsaWNlKDEsIDMzKVxuICAgICAgICBsZXQgeWJ1ZiA9IGJ1Zi5zbGljZSgzMywgNjUpXG4gICAgICAgIGlmICh4YnVmLmxlbmd0aCAhPT0gMzIgfHwgeWJ1Zi5sZW5ndGggIT09IDMyIHx8IGJ1Zi5sZW5ndGggIT09IDY1KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMRW5ndGggb2YgeCBhbmQgeSBtdXN0IGJlIDMyIGJ5dGVzJylcbiAgICAgICAgfVxuICAgICAgICBsZXQgeCA9IG5ldyBCbih4YnVmKVxuICAgICAgICBsZXQgeSA9IG5ldyBCbih5YnVmKVxuICAgICAgICB0aGlzLnBvaW50ID0gbmV3IFBvaW50KHgsIHkpXG4gICAgICAgIHRoaXMuY29tcHJlc3NlZCA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHgwMykge1xuICAgICAgICBsZXQgeGJ1ZiA9IGJ1Zi5zbGljZSgxKVxuICAgICAgICBsZXQgeCA9IG5ldyBCbih4YnVmKVxuICAgICAgICB0aGlzLmZyb21YKHRydWUsIHgpXG4gICAgICAgIHRoaXMuY29tcHJlc3NlZCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoYnVmWzBdID09PSAweDAyKSB7XG4gICAgICAgIGxldCB4YnVmID0gYnVmLnNsaWNlKDEpXG4gICAgICAgIGxldCB4ID0gbmV3IEJuKHhidWYpXG4gICAgICAgIHRoaXMuZnJvbVgoZmFsc2UsIHgpXG4gICAgICAgIHRoaXMuY29tcHJlc3NlZCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBERVIgZm9ybWF0IHB1YktleScpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tRGVyIChidWYsIHN0cmljdCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbURlcihidWYsIHN0cmljdClcbiAgICB9XG5cbiAgICBmcm9tU3RyaW5nIChzdHIpIHtcbiAgICAgIHRoaXMuZnJvbURlcihuZXcgQnVmZmVyKHN0ciwgJ2hleCcpKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBmcm9tWCAob2RkLCB4KSB7XG4gICAgICBpZiAodHlwZW9mIG9kZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHdoZXRoZXIgeSBpcyBvZGQgb3Igbm90ICh0cnVlIG9yIGZhbHNlKScpXG4gICAgICB9XG4gICAgICB0aGlzLnBvaW50ID0gUG9pbnQuZnJvbVgob2RkLCB4KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVggKG9kZCwgeCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbVgob2RkLCB4KVxuICAgIH1cblxuICAgIHRvQnVmZmVyICgpIHtcbiAgICAgIGxldCBjb21wcmVzc2VkID0gdGhpcy5jb21wcmVzc2VkID09PSB1bmRlZmluZWQgPyB0cnVlIDogdGhpcy5jb21wcmVzc2VkXG4gICAgICByZXR1cm4gdGhpcy50b0Rlcihjb21wcmVzc2VkKVxuICAgIH1cblxuICAgIHRvRmFzdEJ1ZmZlciAoKSB7XG4gICAgICBpZiAoIXRoaXMucG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgICAgIH1cbiAgICAgIGxldCBidyA9IG5ldyBCdygpXG4gICAgICBsZXQgY29tcHJlc3NlZCA9IHRoaXMuY29tcHJlc3NlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IEJvb2xlYW4odGhpcy5jb21wcmVzc2VkKVxuICAgICAgYncud3JpdGVVSW50OChOdW1iZXIoY29tcHJlc3NlZCkpXG4gICAgICBidy53cml0ZSh0aGlzLnRvRGVyKGZhbHNlKSlcbiAgICAgIHJldHVybiBidy50b0J1ZmZlcigpXG4gICAgfVxuXG4gICAgdG9EZXIgKGNvbXByZXNzZWQpIHtcbiAgICAgIGNvbXByZXNzZWQgPSBjb21wcmVzc2VkID09PSB1bmRlZmluZWQgPyB0aGlzLmNvbXByZXNzZWQgOiBjb21wcmVzc2VkXG4gICAgICBpZiAodHlwZW9mIGNvbXByZXNzZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSB3aGV0aGVyIHRoZSBwdWJsaWMga2V5IGlzIGNvbXByZXNzZWQgb3Igbm90ICh0cnVlIG9yIGZhbHNlKScpXG4gICAgICB9XG5cbiAgICAgIGxldCB4ID0gdGhpcy5wb2ludC5nZXRYKClcbiAgICAgIGxldCB5ID0gdGhpcy5wb2ludC5nZXRZKClcblxuICAgICAgbGV0IHhidWYgPSB4LnRvQnVmZmVyKHtzaXplOiAzMn0pXG4gICAgICBsZXQgeWJ1ZiA9IHkudG9CdWZmZXIoe3NpemU6IDMyfSlcblxuICAgICAgbGV0IHByZWZpeFxuICAgICAgaWYgKCFjb21wcmVzc2VkKSB7XG4gICAgICAgIHByZWZpeCA9IG5ldyBCdWZmZXIoWzB4MDRdKVxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbcHJlZml4LCB4YnVmLCB5YnVmXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBvZGQgPSB5YnVmW3lidWYubGVuZ3RoIC0gMV0gJSAyXG4gICAgICAgIGlmIChvZGQpIHtcbiAgICAgICAgICBwcmVmaXggPSBuZXcgQnVmZmVyKFsweDAzXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmVmaXggPSBuZXcgQnVmZmVyKFsweDAyXSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbcHJlZml4LCB4YnVmXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICBsZXQgY29tcHJlc3NlZCA9IHRoaXMuY29tcHJlc3NlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHRoaXMuY29tcHJlc3NlZFxuICAgICAgcmV0dXJuIHRoaXMudG9EZXIoY29tcHJlc3NlZCkudG9TdHJpbmcoJ2hleCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlZCBmcm9tIGJpdGNvaW5kJ3MgSXNDb21wcmVzc2VkT3JVbmNvbXByZXNzZWRQdWJLZXlcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNDb21wcmVzc2VkT3JVbmNvbXByZXNzZWQgKGJ1Zikge1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPCAzMykge1xuICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBwdWJsaWMga2V5OiB0b28gc2hvcnRcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAoYnVmWzBdID09PSAweDA0KSB7XG4gICAgICAgIGlmIChidWYubGVuZ3RoICE9PSA2NSkge1xuICAgICAgICAgIC8vICBOb24tY2Fub25pY2FsIHB1YmxpYyBrZXk6IGludmFsaWQgbGVuZ3RoIGZvciB1bmNvbXByZXNzZWQga2V5XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnVmWzBdID09PSAweDAyIHx8IGJ1ZlswXSA9PT0gMHgwMykge1xuICAgICAgICBpZiAoYnVmLmxlbmd0aCAhPT0gMzMpIHtcbiAgICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBwdWJsaWMga2V5OiBpbnZhbGlkIGxlbmd0aCBmb3IgY29tcHJlc3NlZCBrZXlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gIE5vbi1jYW5vbmljYWwgcHVibGljIGtleTogbmVpdGhlciBjb21wcmVzc2VkIG5vciB1bmNvbXByZXNzZWRcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vd3d3LmlhY3Iub3JnL2FyY2hpdmUvcGtjMjAwMy8yNTY3MDIxMS8yNTY3MDIxMS5wZGZcbiAgICB2YWxpZGF0ZSAoKSB7XG4gICAgICBpZiAodGhpcy5wb2ludC5pc0luZmluaXR5KCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludDogUG9pbnQgY2Fubm90IGJlIGVxdWFsIHRvIEluZmluaXR5JylcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBvaW50LmVxKG5ldyBQb2ludChuZXcgQm4oMCksIG5ldyBCbigwKSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQ6IFBvaW50IGNhbm5vdCBiZSBlcXVhbCB0byAwLCAwJylcbiAgICAgIH1cbiAgICAgIHRoaXMucG9pbnQudmFsaWRhdGUoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUHViS2V5XG59XG5cbmluamVjdCA9IHJlcXVpcmUoJ2luamVjdGVyJykoaW5qZWN0LCBkZXBlbmRlbmNpZXMpXG5sZXQgUHViS2V5ID0gaW5qZWN0KClcbm1vZHVsZS5leHBvcnRzID0gUHViS2V5XG4iLCIvKipcbiAqIFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIFJhbmRvbSBudW1iZXJzIGFyZSBpbXBvcnRhbnQgaW4gYml0Y29pbiBwcmltYXJpbHkgZm9yIGdlbmVyYXRpbmcgcHJpdmF0ZVxuICoga2V5cy4gSXQgaXMgYWxzbyBpbXBvcnRhbnQgZm9yIGNyZWF0aW5nIHNpZ25hdHVyZXMgaWYgeW91IGFyZSB1c2luZyBhIHJhbmRvbVxuICogdmFsdWUgb2YgaywgYnV0IFlvdXJzIEJpdGNvaW4gZGVmYXVsdHMgdG8gdXNpbmcgZGV0ZXJtaW5pc3RpYyBrLiBUaGF0IG1lYW5zXG4gKiBjb21wdXRpbmcgYSByYW5kb20gcHJpdmF0ZSBrZXksIG9yIGEgcmFuZG9tIHNlZWQgZm9yIHVzZSBpbiBCaXAzOSBvciBCaXAzMixcbiAqIGlzIHRoZSBwcmltYXJ5IHVzZSBvZiB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IuICBOb3RlIHRoYXQgdGhlIHNpbXBsaWNpdHlcbiAqIG9mIHRoaXMgY2xhc3MgaXMgZXh0cmVtZWx5IGNhcmVmdWxseSBjb25zaWRlcmVkLiBJdCBpcyBlYXN5IHRvIGF1ZGl0IHRoYXRcbiAqIHRoaXMgY29kZSBydW5zIG5vZGUncyByYW5kb21CeXRlcyBmdW5jdGlvbi4gSXQgaXMgYWxzbyBlYXN5IHRvIGF1ZGl0IHRoYXRcbiAqIHRoZSByYW5kb21CeXRlcyBtZXRob2QgaXMgY29ycmVjdGx5IGludGVycHJldGVkIGFzXG4gKiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB3aGVuIHRoaXMgY29kZSBpcyBicm93c2VyaWZpZWQgYnkgYnJvd3NlcmlmeSxcbiAqIGFuZCB0aHVzIGFsc28gd29ya3MgY29ycmVjdGx5IGluIHRoZSBicm93c2VyLiBXZSBkZWxpYmVyYXRlbHkgZG8gbm90IGRvXG4gKiBhbnl0aGluZyBlbHNlIHRvIHRoaXMgcmFuZG9tIG51bWJlciBpbiBvcmRlciB0byBtaW5pbWl6ZSBwb3NzaWJsZSBlcnJvcnMgaW5cbiAqIHRoaXMgYWJzb2x1dGVseSBjcml0aWNhbCBjb2RlLlxuICovXG4ndXNlIHN0cmljdCdcbmxldCBkZXBlbmRlbmNpZXMgPSB7XG4gIHJhbmRvbUJ5dGVzOiByZXF1aXJlKCdyYW5kb21ieXRlcycpXG59XG5cbmxldCBpbmplY3QgPSBmdW5jdGlvbiAoZGVwcykge1xuICBsZXQgcmFuZG9tQnl0ZXMgPSBkZXBzLnJhbmRvbUJ5dGVzXG5cbiAgbGV0IFJhbmRvbSA9IHt9XG5cbiAgUmFuZG9tLmdldFJhbmRvbUJ1ZmZlciA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKHNpemUpXG4gIH1cblxuICByZXR1cm4gUmFuZG9tXG59XG5cbmluamVjdCA9IHJlcXVpcmUoJ2luamVjdGVyJykoaW5qZWN0LCBkZXBlbmRlbmNpZXMpXG5sZXQgUmFuZG9tID0gaW5qZWN0KClcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tXG4iLCIvKlxuICogU2NyaXB0XG4gKiA9PT09PT1cbiAqXG4gKiBTY3JpcHQgaXMgdGhlIHNjcmlwdGluZyBsYW5ndWFnZSBidWlsdCBpbnRvIGJpdGNvaW4uIFRoZSBTY3JpcHQgY2xhc3MgbGV0c1xuICogeW91IGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhIHNjcmlwdCwgZS5nLiBmb3IgYSBzY3JpcHRTaWcgb3IgYSBzY3JpcHRQdWJLZXkuXG4gKiBJdCB1bmRlcnN0YW5kcyBib3RoIHRoZSBiaW5hcnkgZm9ybWF0LCBhcyB3ZWxsIGFzIHR3byBkaWZmZXJlbnQgc3RyaW5nXG4gKiBmb3JtYXRzLiBUaGUgZGVmYXVsdCBzdHJpbmcgZm9ybWF0LCB0by9mcm9tU3RyaW5nLCBpcyBhIGN1c3RvbSBmb3JtYXQgb25seVxuICogdXNlZCBieSBZb3VycyBCaXRjb2luIGJlY2F1c2UgaXQgaXMgaXNvbW9ycGhpYyB0byB0aGUgYmluYXJ5IGZvcm1hdCAob3IgYXNcbiAqIGlzb21vcnBoaWMgYXMgaXQgY2FuIGJlIC4uLiBzaW5jZSBPUF8wIGFuZCBPUF9GQUxTRSBoYXZlIHRoZSBzYW1lIGJ5dGVcbiAqIHZhbHVlLCBhbmQgc28gZG8gT1BfMSBhbmQgT1BfVFJVRSkuIFRoZSBiaXRjb2luZCBzdHJpbmcgZm9ybWF0IGlzIGFsc29cbiAqIHN1cHBvcnQsIGJ1dCB0aGF0IGZvcm1hdCBpcyBub3QgaXNvbW9ycGhpYyAoaS5lLiwgaWYgeW91IHB1bGwgaW4gYSBzdHJpbmdcbiAqIGFuZCB0aGVuIHdyaXRlIGl0IGFnYWluLCB5b3UgYXJlIGxpa2VseSB0byBnZXQgYmFjayBhIGRpZmZlcmVudCBzdHJpbmcsIGV2ZW5cbiAqIGlmIHlvdSBkb24ndCB1c2UgT1BfMCwgT1BfRkFMU0UsIE9QXzEsIG9yIE9QX1RSVUUpLlxuICovXG4ndXNlIHN0cmljdCdcbmxldCBkZXBlbmRlbmNpZXMgPSB7XG4gIEJuOiByZXF1aXJlKCcuL2JuJyksXG4gIEJyOiByZXF1aXJlKCcuL2JyJyksXG4gIEJ3OiByZXF1aXJlKCcuL2J3JyksXG4gIGNtcDogcmVxdWlyZSgnLi9jbXAnKSxcbiAgT3BDb2RlOiByZXF1aXJlKCcuL29wLWNvZGUnKSxcbiAgUHViS2V5OiByZXF1aXJlKCcuL3B1Yi1rZXknKSxcbiAgU2lnOiByZXF1aXJlKCcuL3NpZycpLFxuICBTdHJ1Y3Q6IHJlcXVpcmUoJy4vc3RydWN0Jylcbn1cblxubGV0IGluamVjdCA9IGZ1bmN0aW9uIChkZXBzKSB7XG4gIGxldCBCbiA9IGRlcHMuQm5cbiAgbGV0IEJyID0gZGVwcy5CclxuICBsZXQgQncgPSBkZXBzLkJ3XG4gIGxldCBjbXAgPSBkZXBzLmNtcFxuICBsZXQgT3BDb2RlID0gZGVwcy5PcENvZGVcbiAgbGV0IFB1YktleSA9IGRlcHMuUHViS2V5XG4gIGxldCBTaWcgPSBkZXBzLlNpZ1xuICBsZXQgU3RydWN0ID0gZGVwcy5TdHJ1Y3RcblxuICBjbGFzcyBTY3JpcHQgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yIChjaHVua3MgPSBbXSkge1xuICAgICAgc3VwZXIoe2NodW5rc30pXG4gICAgfVxuXG4gICAgZnJvbUpTT04gKGpzb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmZyb21TdHJpbmcoanNvbilcbiAgICB9XG5cbiAgICB0b0pTT04gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIGZyb21CdWZmZXIgKGJ1Zikge1xuICAgICAgdGhpcy5jaHVua3MgPSBbXVxuXG4gICAgICBsZXQgYnIgPSBuZXcgQnIoYnVmKVxuICAgICAgd2hpbGUgKCFici5lb2YoKSkge1xuICAgICAgICBsZXQgb3BDb2RlTnVtID0gYnIucmVhZFVJbnQ4KClcblxuICAgICAgICBsZXQgbGVuLCBidWZcbiAgICAgICAgaWYgKG9wQ29kZU51bSA+IDAgJiYgb3BDb2RlTnVtIDwgT3BDb2RlLk9QX1BVU0hEQVRBMSkge1xuICAgICAgICAgIGxlbiA9IG9wQ29kZU51bVxuICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2goe1xuICAgICAgICAgICAgYnVmOiBici5yZWFkKGxlbiksXG4gICAgICAgICAgICBsZW46IGxlbixcbiAgICAgICAgICAgIG9wQ29kZU51bTogb3BDb2RlTnVtXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChvcENvZGVOdW0gPT09IE9wQ29kZS5PUF9QVVNIREFUQTEpIHtcbiAgICAgICAgICBsZW4gPSBici5yZWFkVUludDgoKVxuICAgICAgICAgIGxldCBidWYgPSBici5yZWFkKGxlbilcbiAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgICAgIGJ1ZjogYnVmLFxuICAgICAgICAgICAgbGVuOiBsZW4sXG4gICAgICAgICAgICBvcENvZGVOdW06IG9wQ29kZU51bVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAob3BDb2RlTnVtID09PSBPcENvZGUuT1BfUFVTSERBVEEyKSB7XG4gICAgICAgICAgbGVuID0gYnIucmVhZFVJbnQxNkxFKClcbiAgICAgICAgICBidWYgPSBici5yZWFkKGxlbilcbiAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgICAgIGJ1ZjogYnVmLFxuICAgICAgICAgICAgbGVuOiBsZW4sXG4gICAgICAgICAgICBvcENvZGVOdW06IG9wQ29kZU51bVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAob3BDb2RlTnVtID09PSBPcENvZGUuT1BfUFVTSERBVEE0KSB7XG4gICAgICAgICAgbGVuID0gYnIucmVhZFVJbnQzMkxFKClcbiAgICAgICAgICBidWYgPSBici5yZWFkKGxlbilcbiAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgICAgIGJ1ZjogYnVmLFxuICAgICAgICAgICAgbGVuOiBsZW4sXG4gICAgICAgICAgICBvcENvZGVOdW06IG9wQ29kZU51bVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jaHVua3MucHVzaCh7XG4gICAgICAgICAgICBvcENvZGVOdW06IG9wQ29kZU51bVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0b0J1ZmZlciAoKSB7XG4gICAgICBsZXQgYncgPSBuZXcgQncoKVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuY2h1bmtzW2ldXG4gICAgICAgIGxldCBvcENvZGVOdW0gPSBjaHVuay5vcENvZGVOdW1cbiAgICAgICAgYncud3JpdGVVSW50OChvcENvZGVOdW0pXG4gICAgICAgIGlmIChjaHVuay5idWYpIHtcbiAgICAgICAgICBpZiAob3BDb2RlTnVtIDwgT3BDb2RlLk9QX1BVU0hEQVRBMSkge1xuICAgICAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKVxuICAgICAgICAgIH0gZWxzZSBpZiAob3BDb2RlTnVtID09PSBPcENvZGUuT1BfUFVTSERBVEExKSB7XG4gICAgICAgICAgICBidy53cml0ZVVJbnQ4KGNodW5rLmxlbilcbiAgICAgICAgICAgIGJ3LndyaXRlKGNodW5rLmJ1ZilcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wQ29kZU51bSA9PT0gT3BDb2RlLk9QX1BVU0hEQVRBMikge1xuICAgICAgICAgICAgYncud3JpdGVVSW50MTZMRShjaHVuay5sZW4pXG4gICAgICAgICAgICBidy53cml0ZShjaHVuay5idWYpXG4gICAgICAgICAgfSBlbHNlIGlmIChvcENvZGVOdW0gPT09IE9wQ29kZS5PUF9QVVNIREFUQTQpIHtcbiAgICAgICAgICAgIGJ3LndyaXRlVUludDMyTEUoY2h1bmsubGVuKVxuICAgICAgICAgICAgYncud3JpdGUoY2h1bmsuYnVmKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYncudG9CdWZmZXIoKVxuICAgIH1cblxuICAgIGZyb21TdHJpbmcgKHN0cikge1xuICAgICAgdGhpcy5jaHVua3MgPSBbXVxuICAgICAgaWYgKHN0ciA9PT0gJycgfHwgc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cblxuICAgICAgbGV0IHRva2VucyA9IHN0ci5zcGxpdCgnICcpXG4gICAgICBsZXQgaSA9IDBcbiAgICAgIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICAgICAgbGV0IG9wQ29kZU51bVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBvcENvZGUgPSBuZXcgT3BDb2RlKCkuZnJvbVN0cmluZyh0b2tlbilcbiAgICAgICAgICBvcENvZGVOdW0gPSBvcENvZGUudG9OdW1iZXIoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcENvZGVOdW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG9wQ29kZU51bSA9IHBhcnNlSW50KHRva2VuLCAxMClcbiAgICAgICAgICBpZiAob3BDb2RlTnVtID4gMCAmJiBvcENvZGVOdW0gPCBPcENvZGUuT1BfUFVTSERBVEExKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgYnVmOiBuZXcgQnVmZmVyKHRva2Vuc1tpICsgMV0uc2xpY2UoMiksICdoZXgnKSxcbiAgICAgICAgICAgICAgbGVuOiBvcENvZGVOdW0sXG4gICAgICAgICAgICAgIG9wQ29kZU51bTogb3BDb2RlTnVtXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgaSA9IGkgKyAyXG4gICAgICAgICAgfSBlbHNlIGlmIChvcENvZGVOdW0gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2goe1xuICAgICAgICAgICAgICBvcENvZGVOdW06IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBpID0gaSArIDFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNjcmlwdCcpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wQ29kZU51bSA9PT0gT3BDb2RlLk9QX1BVU0hEQVRBMSB8fCBvcENvZGVOdW0gPT09IE9wQ29kZS5PUF9QVVNIREFUQTIgfHwgb3BDb2RlTnVtID09PSBPcENvZGUuT1BfUFVTSERBVEE0KSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tpICsgMl0uc2xpY2UoMCwgMikgIT09ICcweCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHVzaGRhdGEgZGF0YSBtdXN0IHN0YXJ0IHdpdGggMHgnKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgICAgIGJ1ZjogbmV3IEJ1ZmZlcih0b2tlbnNbaSArIDJdLnNsaWNlKDIpLCAnaGV4JyksXG4gICAgICAgICAgICBsZW46IHBhcnNlSW50KHRva2Vuc1tpICsgMV0sIDEwKSxcbiAgICAgICAgICAgIG9wQ29kZU51bTogb3BDb2RlTnVtXG4gICAgICAgICAgfSlcbiAgICAgICAgICBpID0gaSArIDNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgICAgIG9wQ29kZU51bTogb3BDb2RlTnVtXG4gICAgICAgICAgfSlcbiAgICAgICAgICBpID0gaSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICBsZXQgc3RyID0gJydcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLmNodW5rc1tpXVxuICAgICAgICBsZXQgb3BDb2RlTnVtID0gY2h1bmsub3BDb2RlTnVtXG4gICAgICAgIGlmICghY2h1bmsuYnVmKSB7XG4gICAgICAgICAgaWYgKE9wQ29kZS5zdHJbb3BDb2RlTnVtXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIgKyAnICcgKyBuZXcgT3BDb2RlKG9wQ29kZU51bSkudG9TdHJpbmcoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIgKyAnICcgKyAnMHgnICsgb3BDb2RlTnVtLnRvU3RyaW5nKDE2KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3BDb2RlTnVtID09PSBPcENvZGUuT1BfUFVTSERBVEExIHx8IG9wQ29kZU51bSA9PT0gT3BDb2RlLk9QX1BVU0hEQVRBMiB8fCBvcENvZGVOdW0gPT09IE9wQ29kZS5PUF9QVVNIREFUQTQpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ciArICcgJyArIG5ldyBPcENvZGUob3BDb2RlTnVtKS50b1N0cmluZygpXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciA9IHN0ciArICcgJyArIGNodW5rLmxlblxuICAgICAgICAgIHN0ciA9IHN0ciArICcgJyArICcweCcgKyBjaHVuay5idWYudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCB0aGUgc2NyaXB0IGZyb20gdGhlIHNjcmlwdCBzdHJpbmcgZm9ybWF0IHVzZWQgaW4gYml0Y29pbmQgZGF0YSB0ZXN0c1xuICAgICAqL1xuICAgIGZyb21CaXRjb2luZFN0cmluZyAoc3RyKSB7XG4gICAgICBsZXQgYncgPSBuZXcgQncoKVxuICAgICAgbGV0IHRva2VucyA9IHN0ci5zcGxpdCgnICcpXG4gICAgICBsZXQgaVxuICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICAgICAgaWYgKHRva2VuID09PSAnJykge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuWzBdID09PSAnMCcgJiYgdG9rZW5bMV0gPT09ICd4Jykge1xuICAgICAgICAgIGxldCBoZXggPSB0b2tlbi5zbGljZSgyKVxuICAgICAgICAgIGJ3LndyaXRlKG5ldyBCdWZmZXIoaGV4LCAnaGV4JykpXG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5bMF0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgbGV0IHRzdHIgPSB0b2tlbi5zbGljZSgxLCB0b2tlbi5sZW5ndGggLSAxKVxuICAgICAgICAgIGxldCBjYnVmID0gbmV3IEJ1ZmZlcih0c3RyKVxuICAgICAgICAgIGxldCB0YnVmID0gbmV3IFNjcmlwdCgpLndyaXRlQnVmZmVyKGNidWYpLnRvQnVmZmVyKClcbiAgICAgICAgICBidy53cml0ZSh0YnVmKVxuICAgICAgICB9IGVsc2UgaWYgKE9wQ29kZVsnT1BfJyArIHRva2VuXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV0IG9wc3RyID0gJ09QXycgKyB0b2tlblxuICAgICAgICAgIGxldCBvcENvZGVOdW0gPSBPcENvZGVbb3BzdHJdXG4gICAgICAgICAgYncud3JpdGVVSW50OChvcENvZGVOdW0pXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIE9wQ29kZVt0b2tlbl0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbGV0IG9wc3RyID0gdG9rZW5cbiAgICAgICAgICBsZXQgb3BDb2RlTnVtID0gT3BDb2RlW29wc3RyXVxuICAgICAgICAgIGJ3LndyaXRlVUludDgob3BDb2RlTnVtKVxuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihwYXJzZUludCh0b2tlbiwgMTApKSkge1xuICAgICAgICAgIGxldCBibiA9IG5ldyBCbih0b2tlbilcbiAgICAgICAgICBsZXQgc2NyaXB0ID0gbmV3IFNjcmlwdCgpLndyaXRlQm4oYm4pXG4gICAgICAgICAgbGV0IHRidWYgPSBzY3JpcHQudG9CdWZmZXIoKVxuICAgICAgICAgIGJ3LndyaXRlKHRidWYpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIHR5cGUgb2Ygc2NyaXB0IHZhbHVlJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGJ1ZiA9IGJ3LnRvQnVmZmVyKClcbiAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmKVxuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tQml0Y29pbmRTdHJpbmcgKHN0cikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbUJpdGNvaW5kU3RyaW5nKHN0cilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdXRwdXQgdGhlIHNjcmlwdCB0byB0aGUgc2NyaXB0IHN0cmluZyBmb3JtYXQgdXNlZCBpbiBiaXRjb2luZCBkYXRhIHRlc3RzLlxuICAgICAqL1xuICAgIHRvQml0Y29pbmRTdHJpbmcgKCkge1xuICAgICAgbGV0IHN0ciA9ICcnXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuY2h1bmtzW2ldXG4gICAgICAgIGlmIChjaHVuay5idWYpIHtcbiAgICAgICAgICBsZXQgYnVmID0gbmV3IFNjcmlwdChbY2h1bmtdKS50b0J1ZmZlcigpXG4gICAgICAgICAgbGV0IGhleCA9IGJ1Zi50b1N0cmluZygnaGV4JylcbiAgICAgICAgICBzdHIgPSBzdHIgKyAnICcgKyAnMHgnICsgaGV4XG4gICAgICAgIH0gZWxzZSBpZiAoT3BDb2RlLnN0cltjaHVuay5vcENvZGVOdW1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsZXQgb3N0ciA9IG5ldyBPcENvZGUoY2h1bmsub3BDb2RlTnVtKS50b1N0cmluZygpXG4gICAgICAgICAgc3RyID0gc3RyICsgJyAnICsgb3N0ci5zbGljZSgzKSAvLyByZW1vdmUgT1BfXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gc3RyICsgJyAnICsgJzB4JyArIGNodW5rLm9wQ29kZU51bS50b1N0cmluZygxNilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUdXJuIHNjcmlwdCBpbnRvIGEgc3RhbmRhcmQgcHViS2V5SGFzaCBvdXRwdXQgc2NyaXB0XG4gICAgICovXG4gICAgZnJvbVB1YktleUhhc2ggKGhhc2hCdWYpIHtcbiAgICAgIGlmIChoYXNoQnVmLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoQnVmIG11c3QgYmUgYSAyMCBieXRlIGJ1ZmZlcicpXG4gICAgICB9XG4gICAgICB0aGlzLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9EVVApXG4gICAgICB0aGlzLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9IQVNIMTYwKVxuICAgICAgdGhpcy53cml0ZUJ1ZmZlcihoYXNoQnVmKVxuICAgICAgdGhpcy53cml0ZU9wQ29kZShPcENvZGUuT1BfRVFVQUxWRVJJRlkpXG4gICAgICB0aGlzLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9DSEVDS1NJRylcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21QdWJLZXlIYXNoIChoYXNoQnVmKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tUHViS2V5SGFzaChoYXNoQnVmKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFR1cm4gc2NyaXB0IGludG8gYSBzdGFuZGFyZCBzY3JpcHRIYXNoIChwMnNoKSBvdXRwdXQgc2NyaXB0XG4gICAgICovXG4gICAgZnJvbVNjcmlwdEhhc2ggKGhhc2hCdWYpIHtcbiAgICAgIGlmIChoYXNoQnVmLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoQnVmIG11c3QgYmUgYSAyMCBieXRlIGJ1ZmZlcicpXG4gICAgICB9XG4gICAgICB0aGlzLndyaXRlT3BDb2RlKE9wQ29kZS5PUF9IQVNIMTYwKVxuICAgICAgdGhpcy53cml0ZUJ1ZmZlcihoYXNoQnVmKVxuICAgICAgdGhpcy53cml0ZU9wQ29kZShPcENvZGUuT1BfRVFVQUwpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tU2NyaXB0SGFzaCAoaGFzaEJ1Zikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbVNjcmlwdEhhc2goaGFzaEJ1ZilcbiAgICB9XG5cbiAgICBzdGF0aWMgc29ydFB1YktleXMgKHB1YktleXMpIHtcbiAgICAgIHJldHVybiBwdWJLZXlzLnNsaWNlKCkuc29ydCgocHViS2V5MSwgcHViS2V5MikgPT4ge1xuICAgICAgICBsZXQgYnVmMSA9IHB1YktleTEudG9CdWZmZXIoKVxuICAgICAgICBsZXQgYnVmMiA9IHB1YktleTIudG9CdWZmZXIoKVxuICAgICAgICBsZXQgbGVuID0gYnVmMS5sZW5ndGggPiBidWYxLmxlbmd0aCA/IGJ1ZjEubGVuZ3RoIDogYnVmMi5sZW5ndGhcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoYnVmMVtpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gLTEgLy8gc2hvcnRlciBzdHJpbmdzIGNvbWUgZmlyc3RcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ1ZjJbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ1ZjFbaV0gPCBidWYyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ1ZjFbaV0gPiBidWYyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIG11bHRpc2lnIG91dHB1dCBzY3JpcHQgZnJvbSBhIGxpc3Qgb2YgcHVibGljIGtleXMuIHNvcnRcbiAgICAgKiBkZWZhdWx0cyB0byB0cnVlLiBJZiBzb3J0IGlzIHRydWUsIHRoZSBwdWJLZXlzIGFyZSBzb3J0ZWRcbiAgICAgKiBsZXhpY29ncmFwaGljYWxseS5cbiAgICAqL1xuICAgIGZyb21QdWJLZXlzIChtLCBwdWJLZXlzLCBzb3J0ID0gdHJ1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBtICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ20gbXVzdCBiZSBhIG51bWJlcicpXG4gICAgICB9XG4gICAgICBpZiAoc29ydCA9PT0gdHJ1ZSkge1xuICAgICAgICBwdWJLZXlzID0gU2NyaXB0LnNvcnRQdWJLZXlzKHB1YktleXMpXG4gICAgICB9XG4gICAgICB0aGlzLndyaXRlT3BDb2RlKG0gKyBPcENvZGUuT1BfMSAtIDEpXG4gICAgICBmb3IgKGxldCBpIGluIHB1YktleXMpIHtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihwdWJLZXlzW2ldLnRvQnVmZmVyKCkpXG4gICAgICB9XG4gICAgICB0aGlzLndyaXRlT3BDb2RlKHB1YktleXMubGVuZ3RoICsgT3BDb2RlLk9QXzEgLSAxKVxuICAgICAgdGhpcy53cml0ZU9wQ29kZShPcENvZGUuT1BfQ0hFQ0tNVUxUSVNJRylcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21QdWJLZXlzIChtLCBwdWJLZXlzLCBzb3J0KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tUHViS2V5cyhtLCBwdWJLZXlzLCBzb3J0KVxuICAgIH1cblxuICAgIHJlbW92ZUNvZGVzZXBhcmF0b3JzICgpIHtcbiAgICAgIGxldCBjaHVua3MgPSBbXVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5jaHVua3NbaV0ub3BDb2RlTnVtICE9PSBPcENvZGUuT1BfQ09ERVNFUEFSQVRPUikge1xuICAgICAgICAgIGNodW5rcy5wdXNoKHRoaXMuY2h1bmtzW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmNodW5rcyA9IGNodW5rc1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBpc1B1c2hPbmx5ICgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy5jaHVua3NbaV1cbiAgICAgICAgbGV0IG9wQ29kZU51bSA9IGNodW5rLm9wQ29kZU51bVxuICAgICAgICBpZiAob3BDb2RlTnVtID4gT3BDb2RlLk9QXzE2KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaXNPcFJldHVybiAoKSB7XG4gICAgICBpZiAodGhpcy5jaHVua3NbMF0ub3BDb2RlTnVtID09PSBPcENvZGUuT1BfUkVUVVJOICYmXG4gICAgICAgICh0aGlzLmNodW5rcy5sZW5ndGggPT09IDEgfHxcbiAgICAgICAgICAodGhpcy5jaHVua3MubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgdGhpcy5jaHVua3NbMV0uYnVmICYmXG4gICAgICAgICAgdGhpcy5jaHVua3NbMV0uYnVmLmxlbmd0aCA8PSA0MCAmJlxuICAgICAgICAgIHRoaXMuY2h1bmtzWzFdLmxlbmd0aCA9PT0gdGhpcy5jaHVua3MubGVuKVxuICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1B1YktleUhhc2hPdXQgKCkge1xuICAgICAgaWYgKHRoaXMuY2h1bmtzWzBdICYmIHRoaXMuY2h1bmtzWzBdLm9wQ29kZU51bSA9PT0gT3BDb2RlLk9QX0RVUCAmJlxuICAgICAgICB0aGlzLmNodW5rc1sxXSAmJiB0aGlzLmNodW5rc1sxXS5vcENvZGVOdW0gPT09IE9wQ29kZS5PUF9IQVNIMTYwICYmXG4gICAgICAgIHRoaXMuY2h1bmtzWzJdLmJ1ZiAmJlxuICAgICAgICB0aGlzLmNodW5rc1szXSAmJiB0aGlzLmNodW5rc1szXS5vcENvZGVOdW0gPT09IE9wQ29kZS5PUF9FUVVBTFZFUklGWSAmJlxuICAgICAgICB0aGlzLmNodW5rc1s0XSAmJiB0aGlzLmNodW5rc1s0XS5vcENvZGVOdW0gPT09IE9wQ29kZS5PUF9DSEVDS1NJRykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBwdWJLZXlIYXNoIGlucHV0IHNob3VsZCBjb25zaXN0IG9mIHR3byBwdXNoIG9wZXJhdGlvbnMuIFRoZSBmaXJzdCBwdXNoXG4gICAgICogb3BlcmF0aW9uIG1heSBiZSBPUF8wLCB3aGljaCBtZWFucyB0aGUgc2lnbmF0dXJlIGlzIG1pc3NpbmcsIHdoaWNoIGlzIHRydWVcbiAgICAgKiBmb3Igc29tZSBwYXJ0aWFsbHkgc2lnbmVkIChhbmQgaW52YWxpZCkgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGlzUHViS2V5SGFzaEluICgpIHtcbiAgICAgIGlmICh0aGlzLmNodW5rcy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKHRoaXMuY2h1bmtzWzBdLmJ1ZiB8fCB0aGlzLmNodW5rc1swXS5vcENvZGVOdW0gPT09IE9wQ29kZS5PUF8wKSAmJlxuICAgICAgICB0aGlzLmNodW5rc1sxXS5idWYpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzU2NyaXB0SGFzaE91dCAoKSB7XG4gICAgICBsZXQgYnVmID0gdGhpcy50b0J1ZmZlcigpXG4gICAgICByZXR1cm4gKGJ1Zi5sZW5ndGggPT09IDIzICYmXG4gICAgICAgIGJ1ZlswXSA9PT0gT3BDb2RlLk9QX0hBU0gxNjAgJiZcbiAgICAgICAgYnVmWzFdID09PSAweDE0ICYmXG4gICAgICAgIGJ1ZlsyMl0gPT09IE9wQ29kZS5PUF9FUVVBTClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RlIHRoYXQgdGhlc2UgYXJlIGZyZXF1ZW50bHkgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBwdWJLZXlIYXNoaW5cbiAgICAgKi9cbiAgICBpc1NjcmlwdEhhc2hJbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNQdXNoT25seSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IFNjcmlwdCgpLmZyb21CdWZmZXIodGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoIC0gMV0uYnVmKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gY2hlY2sgaWYgYSBzY3JpcHQgaXMgYm90aCBzY3JpcHRIYXNoIChwMnNoKSBhbmQgaWZcbiAgICAgKiB0aGUgcmVkZWVtU2NyaXB0IGluc2lkZSBpcyBhIG11bHRpc2lnIG91dHB1dC4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgZm9ybWF0XG4gICAgICogZm9yIGlucHV0cyBvZiBtb3N0IG11bHRpc2lnIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBpc1NjcmlwdEhhc2hNdWx0aVNpZ0luICgpIHtcbiAgICAgIGlmICghdGhpcy5pc1NjcmlwdEhhc2hJbigpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgbGV0IHJlZGVlbVNjcmlwdFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVkZWVtU2NyaXB0ID0gbmV3IFNjcmlwdCgpLmZyb21CdWZmZXIodGhpcy5jaHVua3NbdGhpcy5jaHVua3MubGVuZ3RoIC0gMV0uYnVmKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZGVlbVNjcmlwdC5pc011bHRpU2lnT3V0KClcbiAgICB9XG5cbiAgICBpc011bHRpU2lnT3V0ICgpIHtcbiAgICAgIGxldCBtID0gdGhpcy5jaHVua3NbMF0ub3BDb2RlTnVtIC0gT3BDb2RlLk9QXzEgKyAxXG4gICAgICBpZiAoIShtID49IDEgJiYgbSA8PSAxNikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBsZXQgcHViS2V5Y2h1bmtzID0gdGhpcy5jaHVua3Muc2xpY2UoMSwgdGhpcy5jaHVua3MubGVuZ3RoIC0gMilcbiAgICAgIGlmICghcHViS2V5Y2h1bmtzLmV2ZXJ5KChjaHVuaykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBidWYgPSBjaHVuay5idWZcbiAgICAgICAgICBsZXQgcHViS2V5ID0gbmV3IFB1YktleSgpLmZyb21EZXIoYnVmKVxuICAgICAgICAgIHB1YktleS52YWxpZGF0ZSgpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgbGV0IG4gPSB0aGlzLmNodW5rc1t0aGlzLmNodW5rcy5sZW5ndGggLSAyXS5vcENvZGVOdW0gLSBPcENvZGUuT1BfMSArIDFcbiAgICAgIGlmICghKG4gPj0gbSAmJiBuIDw9IDE2KSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNodW5rc1sxICsgbiArIDFdLm9wQ29kZU51bSAhPT0gT3BDb2RlLk9QX0NIRUNLTVVMVElTSUcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlzTXVsdGlTaWdJbiAoKSB7XG4gICAgICBpZiAodGhpcy5jaHVua3NbMF0ub3BDb2RlTnVtICE9PSBPcENvZGUuT1BfMCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGxldCByZW1haW5JbmcgPSB0aGlzLmNodW5rcy5zbGljZSgxKVxuICAgICAgaWYgKHJlbWFpbkluZy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbWFpbkluZy5ldmVyeSgoY2h1bmspID0+IEJ1ZmZlci5pc0J1ZmZlcihjaHVuay5idWYpICYmIFNpZy5Jc1R4RGVyKGNodW5rLmJ1ZikpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5hbGFnb3VzIHRvIGJpdGNvaW5kJ3MgRmluZEFuZERlbGV0ZS4gRmluZCBhbmQgZGVsZXRlIGVxdWl2YWxlbnQgY2h1bmtzLFxuICAgICAqIHR5cGljYWxseSB1c2VkIHdpdGggcHVzaCBkYXRhIGNodW5rcy4gIE5vdGUgdGhhdCB0aGlzIHdpbGwgZmluZCBhbmQgZGVsZXRlXG4gICAgICogbm90IGp1c3QgdGhlIHNhbWUgZGF0YSwgYnV0IHRoZSBzYW1lIGRhdGEgd2l0aCB0aGUgc2FtZSBwdXNoIGRhdGEgb3AgYXNcbiAgICAgKiBwcm9kdWNlZCBieSBkZWZhdWx0LiBpLmUuLCBpZiBhIHB1c2hkYXRhIGluIGEgdHggZG9lcyBub3QgdXNlIHRoZSBtaW5pbWFsXG4gICAgICogcHVzaGRhdGEgb3AsIHRoZW4gd2hlbiB5b3UgdHJ5IHRvIHJlbW92ZSB0aGUgZGF0YSBpdCBpcyBwdXNoaW5nLCBpdCB3aWxsIG5vdFxuICAgICAqIGJlIHJlbW92ZWQsIGJlY2F1c2UgdGhleSBkbyBub3QgdXNlIHRoZSBzYW1lIHB1c2hkYXRhIG9wLlxuICAgICAqL1xuICAgIGZpbmRBbmREZWxldGUgKHNjcmlwdCkge1xuICAgICAgbGV0IGJ1ZiA9IHNjcmlwdC50b0J1ZmZlcigpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzY3JpcHQyID0gbmV3IFNjcmlwdChbdGhpcy5jaHVua3NbaV1dKVxuICAgICAgICBsZXQgYnVmMiA9IHNjcmlwdDIudG9CdWZmZXIoKVxuICAgICAgICBpZiAoY21wKGJ1ZiwgYnVmMikpIHtcbiAgICAgICAgICB0aGlzLmNodW5rcy5zcGxpY2UoaSwgMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB3cml0ZVNjcmlwdCAoc2NyaXB0KSB7XG4gICAgICB0aGlzLmNodW5rcyA9IHRoaXMuY2h1bmtzLmNvbmNhdChzY3JpcHQuY2h1bmtzKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgd3JpdGVTY3JpcHQgKHNjcmlwdCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkud3JpdGVTY3JpcHQoc2NyaXB0KVxuICAgIH1cblxuICAgIHdyaXRlU3RyaW5nIChzdHIpIHtcbiAgICAgIGxldCBzY3JpcHQgPSBuZXcgU2NyaXB0KCkuZnJvbVN0cmluZyhzdHIpXG4gICAgICB0aGlzLmNodW5rcyA9IHRoaXMuY2h1bmtzLmNvbmNhdChzY3JpcHQuY2h1bmtzKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgd3JpdGVTdHJpbmcgKHN0cikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkud3JpdGVTdHJpbmcoc3RyKVxuICAgIH1cblxuICAgIHdyaXRlT3BDb2RlIChvcENvZGVOdW0pIHtcbiAgICAgIHRoaXMuY2h1bmtzLnB1c2goe29wQ29kZU51bX0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHN0YXRpYyB3cml0ZU9wQ29kZSAob3BDb2RlTnVtKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS53cml0ZU9wQ29kZShvcENvZGVOdW0pXG4gICAgfVxuXG4gICAgc2V0Q2h1bmtPcENvZGUgKGksIG9wQ29kZU51bSkge1xuICAgICAgdGhpcy5jaHVua3NbaV0gPSB7b3BDb2RlTnVtfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyB3cml0ZSBhIGJpZyBudW1iZXIgaW4gdGhlIG1pbmltYWwgd2F5XG4gICAgd3JpdGVCbiAoYm4pIHtcbiAgICAgIGlmIChibi5jbXAoMCkgPT09IE9wQ29kZS5PUF8wKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goe1xuICAgICAgICAgIG9wQ29kZU51bTogT3BDb2RlLk9QXzBcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoYm4uY21wKC0xKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgICBvcENvZGVOdW06IE9wQ29kZS5PUF8xTkVHQVRFXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGJuLmNtcCgxKSA+PSAwICYmIGJuLmNtcCgxNikgPD0gMCkgeyAvLyBzZWUgT1BfMSAtIE9QXzE2XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goe1xuICAgICAgICAgIG9wQ29kZU51bTogYm4udG9OdW1iZXIoKSArIE9wQ29kZS5PUF8xIC0gMVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGJ1ZiA9IGJuLnRvU20oe2VuZGlhbjogJ2xpdHRsZSd9KVxuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKGJ1ZilcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIHdyaXRlQm4gKGJuKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS53cml0ZUJuKGJuKVxuICAgIH1cblxuICAgIHNldENodW5rQm4gKGksIGJuKSB7XG4gICAgICB0aGlzLmNodW5rc1tpXSA9IG5ldyBTY3JpcHQoKS53cml0ZUJuKGJuKS5jaHVua3NbMF1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gbm90ZTogdGhpcyBkb2VzIG5vdCBuZWNlc3NhcmlseSB3cml0ZSBidWZmZXJzIGluIHRoZSBtaW5pbWFsIHdheVxuICAgIC8vIHRvIHdyaXRlIG51bWJlcnMgaW4gdGhlIG1pbmltYWwgd2F5LCBzZWUgd3JpdGVCblxuICAgIHdyaXRlQnVmZmVyIChidWYpIHtcbiAgICAgIGxldCBvcENvZGVOdW1cbiAgICAgIGxldCBsZW4gPSBidWYubGVuZ3RoXG4gICAgICBpZiAoYnVmLmxlbmd0aCA+IDAgJiYgYnVmLmxlbmd0aCA8IE9wQ29kZS5PUF9QVVNIREFUQTEpIHtcbiAgICAgICAgb3BDb2RlTnVtID0gYnVmLmxlbmd0aFxuICAgICAgfSBlbHNlIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG9wQ29kZU51bSA9IE9wQ29kZS5PUF8wXG4gICAgICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPCBNYXRoLnBvdygyLCA4KSkge1xuICAgICAgICBvcENvZGVOdW0gPSBPcENvZGUuT1BfUFVTSERBVEExXG4gICAgICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPCBNYXRoLnBvdygyLCAxNikpIHtcbiAgICAgICAgb3BDb2RlTnVtID0gT3BDb2RlLk9QX1BVU0hEQVRBMlxuICAgICAgfSBlbHNlIGlmIChidWYubGVuZ3RoIDwgTWF0aC5wb3coMiwgMzIpKSB7XG4gICAgICAgIG9wQ29kZU51bSA9IE9wQ29kZS5PUF9QVVNIREFUQTRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4ndCBwdXNoIHRoYXQgbXVjaCBkYXRhXCIpXG4gICAgICB9XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgYnVmOiBidWYsXG4gICAgICAgIGxlbjogbGVuLFxuICAgICAgICBvcENvZGVOdW06IG9wQ29kZU51bVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIHdyaXRlQnVmZmVyIChidWYpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLndyaXRlQnVmZmVyKGJ1ZilcbiAgICB9XG5cbiAgICBzZXRDaHVua0J1ZmZlciAoaSwgYnVmKSB7XG4gICAgICB0aGlzLmNodW5rc1tpXSA9IG5ldyBTY3JpcHQoKS53cml0ZUJ1ZmZlcihidWYpLmNodW5rc1swXVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgYSBwdXNoIGlzIHRoZSBzbWFsbGVzdCB3YXkgdG8gcHVzaCB0aGF0IHBhcnRpY3VsYXIgZGF0YVxuICAgIC8vIGNvbWVzIGZyb20gYml0Y29pbmQncyBzY3JpcHQgaW50ZXJwcmV0ZXIgQ2hlY2tNaW5pbWFsUHVzaCBmdW5jdGlvblxuICAgIGNoZWNrTWluaW1hbFB1c2ggKGkpIHtcbiAgICAgIGxldCBjaHVuayA9IHRoaXMuY2h1bmtzW2ldXG4gICAgICBsZXQgYnVmID0gY2h1bmsuYnVmXG4gICAgICBsZXQgb3BDb2RlTnVtID0gY2h1bmsub3BDb2RlTnVtXG4gICAgICBpZiAoIWJ1Zikge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gQ291bGQgaGF2ZSB1c2VkIE9QXzAuXG4gICAgICAgIHJldHVybiBvcENvZGVOdW0gPT09IE9wQ29kZS5PUF8wXG4gICAgICB9IGVsc2UgaWYgKGJ1Zi5sZW5ndGggPT09IDEgJiYgYnVmWzBdID49IDEgJiYgYnVmWzBdIDw9IDE2KSB7XG4gICAgICAgIC8vIENvdWxkIGhhdmUgdXNlZCBPUF8xIC4uIE9QXzE2LlxuICAgICAgICByZXR1cm4gb3BDb2RlTnVtID09PSBPcENvZGUuT1BfMSArIChidWZbMF0gLSAxKVxuICAgICAgfSBlbHNlIGlmIChidWYubGVuZ3RoID09PSAxICYmIGJ1ZlswXSA9PT0gMHg4MSkge1xuICAgICAgICAvLyBDb3VsZCBoYXZlIHVzZWQgT1BfMU5FR0FURS5cbiAgICAgICAgcmV0dXJuIG9wQ29kZU51bSA9PT0gT3BDb2RlLk9QXzFORUdBVEVcbiAgICAgIH0gZWxzZSBpZiAoYnVmLmxlbmd0aCA8PSA3NSkge1xuICAgICAgICAvLyBDb3VsZCBoYXZlIHVzZWQgYSBkaXJlY3QgcHVzaCAob3BDb2RlIGluZGljYXRpbmcgbnVtYmVyIG9mIGJ5dGVzIHB1c2hlZCArIHRob3NlIGJ5dGVzKS5cbiAgICAgICAgcmV0dXJuIG9wQ29kZU51bSA9PT0gYnVmLmxlbmd0aFxuICAgICAgfSBlbHNlIGlmIChidWYubGVuZ3RoIDw9IDI1NSkge1xuICAgICAgICAvLyBDb3VsZCBoYXZlIHVzZWQgT1BfUFVTSERBVEEuXG4gICAgICAgIHJldHVybiBvcENvZGVOdW0gPT09IE9wQ29kZS5PUF9QVVNIREFUQTFcbiAgICAgIH0gZWxzZSBpZiAoYnVmLmxlbmd0aCA8PSA2NTUzNSkge1xuICAgICAgICAvLyBDb3VsZCBoYXZlIHVzZWQgT1BfUFVTSERBVEEyLlxuICAgICAgICByZXR1cm4gb3BDb2RlTnVtID09PSBPcENvZGUuT1BfUFVTSERBVEEyXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTY3JpcHRcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBTY3JpcHQgPSBpbmplY3QoKVxubW9kdWxlLmV4cG9ydHMgPSBTY3JpcHRcbiIsIi8qKlxuICogU2lnbmF0dXJlXG4gKiA9PT09PT09PT1cbiAqXG4gKiBBIHNpZ25hdHVyZSBpcyB0aGUgdGhpbmcgeW91IG1ha2Ugd2hlbiB5b3Ugd2FudCB0byBzaWduIGEgdHJhbnNhY3Rpb24sIG9yXG4gKiB0aGUgdGhpbmcgeW91IHdhbnQgdG8gdmVyaWZ5IGlmIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IHNvbWVvbmUgc2lnbmVkIGFcbiAqIHRyYW5zYWN0aW9uLiBJdCBoYXMgYW4gciBhbmQgcyB2YWx1ZSwgd2hpY2ggYXJlIHRoZSBjcnlwdG9ncmFwaGljIGJpZ1xuICogbnVtYmVycyB0aGF0IGRlZmluZSBhIHNpZ25hdHVyZS4gQW5kIHNpbmNlIHRoaXMgaXMgYSBiaXRjb2luIGxpYnJhcnksIGl0XG4gKiBhbHNvIGhhcyBuSGFzaFR5cGUsIHdoaWNoIGlzIHRoZSB3YXkgdG8gaGFzaCBhIHRyYW5zYWN0aW9uIGFuZCBpcyB1c2VkIGluXG4gKiB0aGUgYmluYXJ5IGZvcm1hdCBvZiBhIHNpZ25hdHVyZSB3aGVuIGl0IGlzIGluIGEgdHJhbnNhY3Rpb24uIFdlIGFsc29cbiAqIHN1cHBvcnQgYSBwdWJsaWMga2V5IHJlY292ZXIgdmFsdWUsIHJlY292ZXJ5LCBhbGxvd2luZyBvbmUgdG8gY29tcHV0ZSB0aGVcbiAqIHB1YmxpYyBrZXkgZnJvbSBhIHNpZ25hdHVyZS4gVGhlIFwiY29tcHJlc3NlZFwiIHZhbHVlIGlzIGFsc28gbmVjZXNzYXJ5IHRvXG4gKiBhY2N1cmF0ZWx5IGNvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZnJvbSBhIHNpZ25hdHVyZS5cbiAqXG4gKiBUaGVyZSBhcmUgYSBmZXcgZGlmZmVyZW50IGZvcm1hdHMgb2YgYSBzaWduYXR1cmUgaW4gYml0Y29pbi4gT25lIGlzIERFUiwgdGhlXG4gKiBvdGhlciBpcyB0aGUgVHhGb3JtYXQgd2hpY2ggaXMgdGhlIHNhbWUgYXMgREVSIGJ1dCB3aXRoIHRoZSBuSGFzaFR5cGUgYnl0ZVxuICogYXBwZW5kZWQsIGFuZCB0aGUgZmluYWwgb25lIGlzIENvbXBhY3QsIHdoaWNoIGlzIHVzZWQgYnkgQml0Y29pbiBTaWduZWRcbiAqIE1lc3NhZ2UgKEJzbSkuXG4gKi9cbid1c2Ugc3RyaWN0J1xubGV0IGRlcGVuZGVuY2llcyA9IHtcbiAgQm46IHJlcXVpcmUoJy4vYm4nKSxcbiAgU3RydWN0OiByZXF1aXJlKCcuL3N0cnVjdCcpXG59XG5cbmxldCBpbmplY3QgPSBmdW5jdGlvbiAoZGVwcykge1xuICBsZXQgQm4gPSBkZXBzLkJuXG4gIGxldCBTdHJ1Y3QgPSBkZXBzLlN0cnVjdFxuXG4gIC8qKlxuICAgKiByLCBzOiBiaWcgbnVtYmVycyBjb25zdGl0aW5nIGEgY3J5cHRvZ3JhcGhpYyBzaWduYXR1cmVcbiAgICogbkhhc2hUeXBlOiBmb3VuZCBhdCB0aGUgZW5kIG9mIGEgc2lnbmF0dXJlIGluIGEgdHJhbnNhY3Rpb25cbiAgICogcmVjb3Zlcnk6IHB1YmxpYyBrZXkgcmVjb3ZlcnkgbnVtYmVyXG4gICAqIGNvbXByZXNzZWQ6IHdoZXRoZXIgdGhlIHJlY292ZXJlZCBwdWJLZXkgaXMgY29tcHJlc3NlZFxuICAgKi9cbiAgY2xhc3MgU2lnIGV4dGVuZHMgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3RvciAociwgcywgbkhhc2hUeXBlLCByZWNvdmVyeSwgY29tcHJlc3NlZCkge1xuICAgICAgc3VwZXIoe3IsIHMsIG5IYXNoVHlwZSwgcmVjb3ZlcnksIGNvbXByZXNzZWR9KVxuICAgIH1cblxuICAgIGZyb21CdWZmZXIgKGJ1Zikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbURlcihidWYsIHRydWUpXG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUNvbXBhY3QoYnVmKVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIHJldHVybiB0aGlzLmZyb21UeEZvcm1hdChidWYpXG4gICAgfVxuXG4gICAgdG9CdWZmZXIgKCkge1xuICAgICAgaWYgKHRoaXMubkhhc2hUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9UeEZvcm1hdCgpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVjb3ZlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0NvbXBhY3QoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudG9EZXIoKVxuICAgIH1cblxuICAgIC8vIFRoZSBmb3JtYXQgdXNlZCBieSBcIm1lc3NhZ2VcIlxuICAgIGZyb21Db21wYWN0IChidWYpIHtcbiAgICAgIGxldCBjb21wcmVzc2VkID0gdHJ1ZVxuICAgICAgbGV0IHJlY292ZXJ5ID0gYnVmLnNsaWNlKDAsIDEpWzBdIC0gMjcgLSA0XG4gICAgICBpZiAocmVjb3ZlcnkgPCAwKSB7XG4gICAgICAgIGNvbXByZXNzZWQgPSBmYWxzZVxuICAgICAgICByZWNvdmVyeSA9IHJlY292ZXJ5ICsgNFxuICAgICAgfVxuXG4gICAgICBsZXQgYjIgPSBidWYuc2xpY2UoMSwgMzMpXG4gICAgICBsZXQgYjMgPSBidWYuc2xpY2UoMzMsIDY1KVxuXG4gICAgICBpZiAoIShyZWNvdmVyeSA9PT0gMCB8fCByZWNvdmVyeSA9PT0gMSB8fCByZWNvdmVyeSA9PT0gMiB8fCByZWNvdmVyeSA9PT0gMykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpIG11c3QgYmUgMCwgMSwgMiwgb3IgMycpXG4gICAgICB9XG4gICAgICBpZiAoYjIubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAzMiBieXRlcycpXG4gICAgICB9XG4gICAgICBpZiAoYjMubGVuZ3RoICE9PSAzMiB8fCBidWYubGVuZ3RoID4gNjUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzIG11c3QgYmUgMzIgYnl0ZXMnKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXByZXNzZWQgPSBjb21wcmVzc2VkXG4gICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3ZlcnlcbiAgICAgIHRoaXMuciA9IG5ldyBCbigpLmZyb21CdWZmZXIoYjIpXG4gICAgICB0aGlzLnMgPSBuZXcgQm4oKS5mcm9tQnVmZmVyKGIzKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tQ29tcGFjdCAoYnVmKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tQ29tcGFjdChidWYpXG4gICAgfVxuXG4gICAgLy8gVGhlIGZvcm1hdCB1c2VkIGluIGEgdHgsIGV4Y2VwdCB3aXRob3V0IHRoZSBuSGFzaFR5cGUgYXQgdGhlIGVuZFxuICAgIGZyb21EZXIgKGJ1Ziwgc3RyaWN0KSB7XG4gICAgICBsZXQgb2JqID0gU2lnLnBhcnNlRGVyKGJ1Ziwgc3RyaWN0KVxuICAgICAgdGhpcy5yID0gb2JqLnJcbiAgICAgIHRoaXMucyA9IG9iai5zXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21EZXIgKGJ1Ziwgc3RyaWN0KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tRGVyKGJ1Ziwgc3RyaWN0KVxuICAgIH1cblxuICAgIC8vIFRoZSBmb3JtYXQgdXNlZCBpbiBhIHR4XG4gICAgZnJvbVR4Rm9ybWF0IChidWYpIHtcbiAgICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGFsbG93IHNldHRpbmcgYSBcImJsYW5rXCIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuciA9IG5ldyBCbigxKVxuICAgICAgICB0aGlzLnMgPSBuZXcgQm4oMSlcbiAgICAgICAgdGhpcy5uSGFzaFR5cGUgPSAxXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICBsZXQgbkhhc2hUeXBlID0gYnVmLnJlYWRVSW50OChidWYubGVuZ3RoIC0gMSlcbiAgICAgIGxldCBkZXJidWYgPSBidWYuc2xpY2UoMCwgYnVmLmxlbmd0aCAtIDEpXG4gICAgICB0aGlzLmZyb21EZXIoZGVyYnVmLCBmYWxzZSlcbiAgICAgIHRoaXMubkhhc2hUeXBlID0gbkhhc2hUeXBlXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tVHhGb3JtYXQgKGJ1Zikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbVR4Rm9ybWF0KGJ1ZilcbiAgICB9XG5cbiAgICBmcm9tU3RyaW5nIChzdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyb21IZXgoc3RyKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluIG9yZGVyIHRvIG1pbWljIHRoZSBub24tc3RyaWN0IERFUiBlbmNvZGluZyBvZiBPcGVuU1NMLCBzZXQgc3RyaWN0ID0gZmFsc2UuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlRGVyIChidWYsIHN0cmljdCkge1xuICAgICAgaWYgKHN0cmljdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0cmljdCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RFUiBmb3JtYXR0ZWQgc2lnbmF0dXJlIHNob3VsZCBiZSBhIGJ1ZmZlcicpXG4gICAgICB9XG5cbiAgICAgIGxldCBoZWFkZXIgPSBidWZbMF1cblxuICAgICAgaWYgKGhlYWRlciAhPT0gMHgzMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hlYWRlciBieXRlIHNob3VsZCBiZSAweDMwJylcbiAgICAgIH1cblxuICAgICAgbGV0IGxlbmd0aCA9IGJ1ZlsxXVxuICAgICAgbGV0IGJ1Zmxlbmd0aCA9IGJ1Zi5zbGljZSgyKS5sZW5ndGhcbiAgICAgIGlmIChzdHJpY3QgJiYgbGVuZ3RoICE9PSBidWZsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMRW5ndGggYnl0ZSBzaG91bGQgbGVuZ3RoIG9mIHdoYXQgZm9sbG93cycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW5ndGggPSBsZW5ndGggPCBidWZsZW5ndGggPyBsZW5ndGggOiBidWZsZW5ndGhcbiAgICAgIH1cblxuICAgICAgbGV0IHJoZWFkZXIgPSBidWZbMiArIDBdXG4gICAgICBpZiAocmhlYWRlciAhPT0gMHgwMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXIgYnl0ZSBmb3IgciBzaG91bGQgYmUgMHgwMicpXG4gICAgICB9XG5cbiAgICAgIGxldCBybGVuZ3RoID0gYnVmWzIgKyAxXVxuICAgICAgbGV0IHJidWYgPSBidWYuc2xpY2UoMiArIDIsIDIgKyAyICsgcmxlbmd0aClcbiAgICAgIGxldCByID0gbmV3IEJuKCkuZnJvbUJ1ZmZlcihyYnVmKVxuICAgICAgbGV0IHJuZWcgPSBidWZbMiArIDEgKyAxXSA9PT0gMHgwMFxuICAgICAgaWYgKHJsZW5ndGggIT09IHJidWYubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTEVuZ3RoIG9mIHIgaW5jb3JyZWN0JylcbiAgICAgIH1cblxuICAgICAgbGV0IHNoZWFkZXIgPSBidWZbMiArIDIgKyBybGVuZ3RoICsgMF1cbiAgICAgIGlmIChzaGVhZGVyICE9PSAweDAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlciBieXRlIGZvciBzIHNob3VsZCBiZSAweDAyJylcbiAgICAgIH1cblxuICAgICAgbGV0IHNsZW5ndGggPSBidWZbMiArIDIgKyBybGVuZ3RoICsgMV1cbiAgICAgIGxldCBzYnVmID0gYnVmLnNsaWNlKDIgKyAyICsgcmxlbmd0aCArIDIsIDIgKyAyICsgcmxlbmd0aCArIDIgKyBzbGVuZ3RoKVxuICAgICAgbGV0IHMgPSBuZXcgQm4oKS5mcm9tQnVmZmVyKHNidWYpXG4gICAgICBsZXQgc25lZyA9IGJ1ZlsyICsgMiArIHJsZW5ndGggKyAyICsgMl0gPT09IDB4MDBcbiAgICAgIGlmIChzbGVuZ3RoICE9PSBzYnVmLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xFbmd0aCBvZiBzIGluY29ycmVjdCcpXG4gICAgICB9XG5cbiAgICAgIGxldCBzdW1sZW5ndGggPSAyICsgMiArIHJsZW5ndGggKyAyICsgc2xlbmd0aFxuICAgICAgaWYgKGxlbmd0aCAhPT0gc3VtbGVuZ3RoIC0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xFbmd0aCBvZiBzaWduYXR1cmUgaW5jb3JyZWN0JylcbiAgICAgIH1cblxuICAgICAgbGV0IG9iaiA9IHtcbiAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICByaGVhZGVyOiByaGVhZGVyLFxuICAgICAgICBybGVuZ3RoOiBybGVuZ3RoLFxuICAgICAgICBybmVnOiBybmVnLFxuICAgICAgICByYnVmOiByYnVmLFxuICAgICAgICByOiByLFxuICAgICAgICBzaGVhZGVyOiBzaGVhZGVyLFxuICAgICAgICBzbGVuZ3RoOiBzbGVuZ3RoLFxuICAgICAgICBzbmVnOiBzbmVnLFxuICAgICAgICBzYnVmOiBzYnVmLFxuICAgICAgICBzOiBzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHRyYW5zbGF0ZWQgZnJvbSBiaXRjb2luZCdzIElzREVSU2lnbmF0dXJlIGFuZCBpcyB1c2VkIGluXG4gICAgICogdGhlIHNjcmlwdCBpbnRlcnByZXRlci4gIFRoaXMgXCJERVJcIiBmb3JtYXQgYWN0dWFsbHkgaW5jbHVkZXMgYW4gZXh0cmEgYnl0ZSxcbiAgICAgKiB0aGUgbkhhc2hUeXBlLCBhdCB0aGUgZW5kLiBJdCBpcyByZWFsbHkgdGhlIHR4IGZvcm1hdCwgbm90IERFUiBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBBIGNhbm9uaWNhbCBzaWduYXR1cmUgZXhpc3RzIG9mOiBbMzBdIFt0b3RhbCBsZW5dIFswMl0gW2xlbiBSXSBbUl0gWzAyXSBbbGVuIFNdIFtTXSBbaGFzaHR5cGVdXG4gICAgICogV2hlcmUgUiBhbmQgUyBhcmUgbm90IG5lZ2F0aXZlICh0aGVpciBmaXJzdCBieXRlIGhhcyBpdHMgaGlnaGVzdCBiaXQgbm90IHNldCksIGFuZCBub3RcbiAgICAgKiBleGNlc3NpdmVseSBwYWRkZWQgKGRvIG5vdCBzdGFydCB3aXRoIGEgMCBieXRlLCB1bmxlc3MgYW4gb3RoZXJ3aXNlIG5lZ2F0aXZlIG51bWJlciBmb2xsb3dzLFxuICAgICAqIGluIHdoaWNoIGNhc2UgYSBzaW5nbGUgMCBieXRlIGlzIG5lY2Vzc2FyeSBhbmQgZXZlbiByZXF1aXJlZCkuXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9iaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTgzOTIubXNnMTI3NjIzI21zZzEyNzYyM1xuICAgICAqL1xuICAgIHN0YXRpYyBJc1R4RGVyIChidWYpIHtcbiAgICAgIGlmIChidWYubGVuZ3RoIDwgOSkge1xuICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IHRvbyBzaG9ydFxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmIChidWYubGVuZ3RoID4gNzMpIHtcbiAgICAgICAgLy8gTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IHRvbyBsb25nXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKGJ1ZlswXSAhPT0gMHgzMCkge1xuICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IHdyb25nIHR5cGVcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAoYnVmWzFdICE9PSBidWYubGVuZ3RoIC0gMykge1xuICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IHdyb25nIGxlbmd0aCBtYXJrZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBsZXQgbkxFblIgPSBidWZbM11cbiAgICAgIGlmICg1ICsgbkxFblIgPj0gYnVmLmxlbmd0aCkge1xuICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IFMgbGVuZ3RoIG1pc3BsYWNlZFxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGxldCBuTEVuUyA9IGJ1Zls1ICsgbkxFblJdXG4gICAgICBpZiAoKG5MRW5SICsgbkxFblMgKyA3KSAhPT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IFIrUyBsZW5ndGggbWlzbWF0Y2hcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGxldCBSID0gYnVmLnNsaWNlKDQpXG4gICAgICBpZiAoYnVmWzQgLSAyXSAhPT0gMHgwMikge1xuICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IFIgdmFsdWUgdHlwZSBtaXNtYXRjaFxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmIChuTEVuUiA9PT0gMCkge1xuICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IFIgbGVuZ3RoIGlzIHplcm9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAoUlswXSAmIDB4ODApIHtcbiAgICAgICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBSIHZhbHVlIG5lZ2F0aXZlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKG5MRW5SID4gMSAmJiAoUlswXSA9PT0gMHgwMCkgJiYgIShSWzFdICYgMHg4MCkpIHtcbiAgICAgICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBSIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZFxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgbGV0IFMgPSBidWYuc2xpY2UoNiArIG5MRW5SKVxuICAgICAgaWYgKGJ1Zls2ICsgbkxFblIgLSAyXSAhPT0gMHgwMikge1xuICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IFMgdmFsdWUgdHlwZSBtaXNtYXRjaFxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmIChuTEVuUyA9PT0gMCkge1xuICAgICAgICAvLyAgTm9uLWNhbm9uaWNhbCBzaWduYXR1cmU6IFMgbGVuZ3RoIGlzIHplcm9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAoU1swXSAmIDB4ODApIHtcbiAgICAgICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBTIHZhbHVlIG5lZ2F0aXZlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKG5MRW5TID4gMSAmJiAoU1swXSA9PT0gMHgwMCkgJiYgIShTWzFdICYgMHg4MCkpIHtcbiAgICAgICAgLy8gIE5vbi1jYW5vbmljYWwgc2lnbmF0dXJlOiBTIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZFxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdG8gYml0Y29pbmQncyBJc0xvd0RFUlNpZ25hdHVyZVxuICAgICAqIFNlZSBhbHNvIEVjZHNhIHNpZ25hdHVyZSBhbGdvcml0aG0gd2hpY2ggZW5mb3JjZXMgdGhpcy5cbiAgICAgKiBTZWUgYWxzbyBCaXAgNjIsIFwibG93IFMgdmFsdWVzIGluIHNpZ25hdHVyZXNcIlxuICAgICAqL1xuICAgIGhhc0xvd1MgKCkge1xuICAgICAgaWYgKHRoaXMucy5sdCgxKSB8fCB0aGlzLnMuZ3QoQm4uZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKCc3RkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRjVENTc2RTczNTdBNDUwMURERkU5MkY0NjY4MUIyMEEwJywgJ2hleCcpKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhlIG5IYXNoVHlwZSBpcyBleGFjdGx5IGVxdWFsIHRvIG9uZSBvZiB0aGUgc3RhbmRhcmQgb3B0aW9ucyBvciBjb21iaW5hdGlvbnMgdGhlcmVvZi5cbiAgICAgKiBUcmFuc2xhdGVkIGZyb20gYml0Y29pbmQncyBJc0RlZmluZWRIYXNodHlwZVNpZ25hdHVyZVxuICAgICAqL1xuICAgIGhhc0RlZmluZWRIYXNoVHlwZSAoKSB7XG4gICAgICBpZiAodGhpcy5uSGFzaFR5cGUgPCBTaWcuU0lHSEFTSF9BTEwgfHwgdGhpcy5uSGFzaFR5cGUgPiBTaWcuU0lHSEFTSF9TSU5HTEUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHRvQ29tcGFjdCAocmVjb3ZlcnksIGNvbXByZXNzZWQpIHtcbiAgICAgIHJlY292ZXJ5ID0gdHlwZW9mIHJlY292ZXJ5ID09PSAnbnVtYmVyJyA/IHJlY292ZXJ5IDogdGhpcy5yZWNvdmVyeVxuICAgICAgY29tcHJlc3NlZCA9IHR5cGVvZiBjb21wcmVzc2VkID09PSAnYm9vbGVhbicgPyBjb21wcmVzc2VkIDogdGhpcy5jb21wcmVzc2VkXG5cbiAgICAgIGlmICghKHJlY292ZXJ5ID09PSAwIHx8IHJlY292ZXJ5ID09PSAxIHx8IHJlY292ZXJ5ID09PSAyIHx8IHJlY292ZXJ5ID09PSAzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IG11c3QgYmUgZXF1YWwgdG8gMCwgMSwgMiwgb3IgMycpXG4gICAgICB9XG5cbiAgICAgIGxldCB2YWwgPSByZWNvdmVyeSArIDI3ICsgNFxuICAgICAgaWYgKGNvbXByZXNzZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhbCA9IHZhbCAtIDRcbiAgICAgIH1cbiAgICAgIGxldCBiMSA9IG5ldyBCdWZmZXIoW3ZhbF0pXG4gICAgICBsZXQgYjIgPSB0aGlzLnIudG9CdWZmZXIoe3NpemU6IDMyfSlcbiAgICAgIGxldCBiMyA9IHRoaXMucy50b0J1ZmZlcih7c2l6ZTogMzJ9KVxuICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2IxLCBiMiwgYjNdKVxuICAgIH1cblxuICAgIHRvRGVyICgpIHtcbiAgICAgIGxldCBybmJ1ZiA9IHRoaXMuci50b0J1ZmZlcigpXG4gICAgICBsZXQgc25idWYgPSB0aGlzLnMudG9CdWZmZXIoKVxuXG4gICAgICBsZXQgcm5lZyA9IHJuYnVmWzBdICYgMHg4MFxuICAgICAgbGV0IHNuZWcgPSBzbmJ1ZlswXSAmIDB4ODBcblxuICAgICAgbGV0IHJidWYgPSBybmVnID8gQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMHgwMF0pLCBybmJ1Zl0pIDogcm5idWZcbiAgICAgIGxldCBzYnVmID0gc25lZyA/IEJ1ZmZlci5jb25jYXQoW25ldyBCdWZmZXIoWzB4MDBdKSwgc25idWZdKSA6IHNuYnVmXG5cbiAgICAgIGxldCBsZW5ndGggPSAyICsgcmJ1Zi5sZW5ndGggKyAyICsgc2J1Zi5sZW5ndGhcbiAgICAgIGxldCBybGVuZ3RoID0gcmJ1Zi5sZW5ndGhcbiAgICAgIGxldCBzbGVuZ3RoID0gc2J1Zi5sZW5ndGhcbiAgICAgIGxldCByaGVhZGVyID0gMHgwMlxuICAgICAgbGV0IHNoZWFkZXIgPSAweDAyXG4gICAgICBsZXQgaGVhZGVyID0gMHgzMFxuXG4gICAgICBsZXQgZGVyID0gQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbaGVhZGVyLCBsZW5ndGgsIHJoZWFkZXIsIHJsZW5ndGhdKSwgcmJ1ZiwgbmV3IEJ1ZmZlcihbc2hlYWRlciwgc2xlbmd0aF0pLCBzYnVmXSlcbiAgICAgIHJldHVybiBkZXJcbiAgICB9XG5cbiAgICB0b1R4Rm9ybWF0ICgpIHtcbiAgICAgIGxldCBkZXJidWYgPSB0aGlzLnRvRGVyKClcbiAgICAgIGxldCBidWYgPSBuZXcgQnVmZmVyKDEpXG4gICAgICBidWYud3JpdGVVSW50OCh0aGlzLm5IYXNoVHlwZSwgMClcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtkZXJidWYsIGJ1Zl0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKVxuICAgIH1cbiAgfVxuXG4gIFNpZy5TSUdIQVNIX0FMTCA9IDB4MDAwMDAwMDFcbiAgU2lnLlNJR0hBU0hfTk9ORSA9IDB4MDAwMDAwMDJcbiAgU2lnLlNJR0hBU0hfU0lOR0xFID0gMHgwMDAwMDAwM1xuICBTaWcuU0lHSEFTSF9BTllPTkVDQU5QQVkgPSAweDAwMDAwMDgwXG5cbiAgcmV0dXJuIFNpZ1xufVxuXG5pbmplY3QgPSByZXF1aXJlKCdpbmplY3RlcicpKGluamVjdCwgZGVwZW5kZW5jaWVzKVxubGV0IFNpZyA9IGluamVjdCgpXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ1xuIiwiLyoqXG4gKiBTdHJ1Y3R1cmVcbiAqID09PT09PT09PVxuICpcbiAqIEEgY29udmVuaWVudCBzdHJ1Y3R1cmUgdG8gZXh0ZW5kIG9iamVjdHMgZnJvbSB0aGF0IGNvbWVzIHdpdGggdmVyeSBjb21tb25cbiAqIGJvaWxlciBwbGF0ZSBpbnN0YW5jZSBtZXRob2RzOlxuICogLSBmcm9tT2JqZWN0XG4gKiAtIGZyb21CclxuICogLSB0b0J3XG4gKiAtIGZyb21CdWZmZXJcbiAqIC0gZnJvbUZhc3RCdWZmZXJcbiAqIC0gdG9CdWZmZXJcbiAqIC0gdG9GYXN0QnVmZmVyXG4gKiAtIGZyb21IZXhcbiAqIC0gdG9IZXhcbiAqIC0gZnJvbVN0cmluZ1xuICogLSB0b1N0cmluZ1xuICogLSBmcm9tSlNPTlxuICogLSB0b0pTT05cbiAqIC0gY2xvbmVCeUJ1ZmZlclxuICogLSBjbG9uZUJ5RmFzdEJ1ZmZlclxuICogLSBjbG9uZUJ5SGV4XG4gKiAtIGNsb25lQnlTdHJpbmdcbiAqIC0gY2xvbmVCeUpTT05cbiAqXG4gKiBBcyB3ZWxsIGFzIHN0YXRpYyBtZXRob2RzIGZvcjpcbiAqIC0gZnJvbU9iamVjdFxuICogLSBmcm9tQnJcbiAqIC0gZnJvbUJ1ZmZlclxuICogLSBmcm9tRmFzdEJ1ZmZlclxuICogLSBmcm9tSGV4XG4gKiAtIGZyb21TdHJpbmdcbiAqIC0gZnJvbUpTT05cbiAqXG4gKiBUaGUgXCJleHBlY3RcIiBtZXRob2QgYWxzbyBmYWNpbGl0YXRlcyBkZXNlcmlhbGl6aW5nIGEgc2VxdWVuY2Ugb2YgYnVmZmVyc1xuICogaW50byBhbiBvYmplY3QuXG4gKi9cbid1c2Ugc3RyaWN0J1xubGV0IGRlcGVuZGVuY2llcyA9IHtcbiAgQnI6IHJlcXVpcmUoJy4vYnInKSxcbiAgQnc6IHJlcXVpcmUoJy4vYncnKVxufVxuXG5sZXQgaW5qZWN0ID0gZnVuY3Rpb24gKGRlcHMpIHtcbiAgbGV0IEJyID0gZGVwcy5CclxuICBsZXQgQncgPSBkZXBzLkJ3XG5cbiAgY2xhc3MgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3RvciAob2JqKSB7XG4gICAgICB0aGlzLmZyb21PYmplY3Qob2JqKVxuICAgIH1cblxuICAgIGZyb21PYmplY3QgKG9iaikge1xuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpc1trZXldID0gb2JqW2tleV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbU9iamVjdCAob2JqKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tT2JqZWN0KG9iailcbiAgICB9XG5cbiAgICBmcm9tQnIgKGJyKSB7XG4gICAgICBpZiAoIShiciBpbnN0YW5jZW9mIEJyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JyIG11c3QgYmUgYSBidWZmZXIgcmVhZGVyJylcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUJyIChicikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbUJyKGJyKVxuICAgIH1cblxuICAgIGFzeW5jRnJvbUJyIChicikge1xuICAgICAgaWYgKCEoYnIgaW5zdGFuY2VvZiBCcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiciBtdXN0IGJlIGEgYnVmZmVyIHJlYWRlcicpXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jRnJvbUJyIChicikge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuYXN5bmNGcm9tQnIoYnIpXG4gICAgfVxuXG4gICAgdG9CdyAoYncpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgICB9XG5cbiAgICBhc3luY1RvQncgKGJ3KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXQgaXMgdmVyeSBvZnRlbiB0aGUgY2FzZSB0aGF0IHlvdSB3YW50IHRvIGNyZWF0ZSBhIGJpdGNvaW4gb2JqZWN0IGZyb20gYVxuICAgICAqIHN0cmVhbSBvZiBzbWFsbCBidWZmZXJzIHJhdGhlciB0aGFuIGZyb20gYSBidWZmZXIgb2YgdGhlIGNvcnJlY3QgbGVuZ3RoLlxuICAgICAqIEZvciBpbnN0YW5jZSwgaWYgc3RyZWFtaW5nIGZyb20gdGhlIG5ldHdvcmsgb3IgZGlzay4gVGhlIGdlbkZyb21CdWZmZXJzXG4gICAgICogbWV0aG9kIGlzIGEgZ2VuZXJhdG9yIHdoaWNoIHByb2R1Y2VzIGFuIGl0ZXJhdG9yLiBVc2UgLm5leHQoYnVmKSB0byBwYXNzXG4gICAgICogaW4gYSBzbWFsbCBidWZmZXIuIFRoZSBpdGVyYXRvciB3aWxsIGVuZCB3aGVuIGl0IGhhcyByZWNlaXZlZCBlbm91Z2ggZGF0YVxuICAgICAqIHRvIHByb2R1Y2UgdGhlIG9iamVjdC4gSW4gc29tZSBjYXNlcyBpdCBpcyBhYmxlIHRvIHlpZWxkIHRoZSBudW1iZXIgb2ZcbiAgICAgKiBieXRlcyBpdCBpcyBleHBlY3RpbmcsIGJ1dCB0aGF0IGlzIG5vdCBhbHdheXMga25vd24uXG4gICAgICovXG4gICAgKiBnZW5Gcm9tQnVmZmVycyAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBjb252ZW5pZW5jZSBtZXRob2QgdXNlZCBieSBmcm9tIHRoZSBnZW5Gcm9tQnVmZmVycyogZ2VuZXJhdG9ycy5cbiAgICAgKiBCYXNpY2FsbHkgbGV0cyB5b3UgZXhwZWN0IGEgY2VydGFpbiBudW1iZXIgb2YgYnl0ZXMgKGxlbikgYW5kIGtlZXBzXG4gICAgICogeWllbGRpbmcgdW50aWwgeW91IGdpdmUgaXQgZW5vdWdoLiBJdCB5aWVsZHMgdGhlIGV4cGVjdGVkIGFtb3VudFxuICAgICAqIHJlbWFpbkluZywgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5JbmcgYSBidWZmZXIgb2YgdGhlIGV4cGVjdGVkXG4gICAgICogbGVuZ3RoLCBhbmQsIGlmIGFueSwgdGhlIHJlbWFpbmRlciBidWZmZXIuXG4gICAgICovXG4gICAgKiBleHBlY3QgKGxlbiwgc3RhcnRidWYpIHtcbiAgICAgIGxldCBidWYgPSBzdGFydGJ1ZlxuICAgICAgbGV0IGJ3ID0gbmV3IEJ3KClcbiAgICAgIGxldCBnb3RsZW4gPSAwXG4gICAgICBpZiAoc3RhcnRidWYpIHtcbiAgICAgICAgYncud3JpdGUoc3RhcnRidWYpXG4gICAgICAgIGdvdGxlbiArPSBzdGFydGJ1Zi5sZW5ndGhcbiAgICAgIH1cbiAgICAgIGxldCByZW1haW5kZXJidWZcbiAgICAgIHdoaWxlIChnb3RsZW4gPCBsZW4pIHtcbiAgICAgICAgbGV0IHJlbWFpbmRlcmxlbiA9IChsZW4gLSBnb3RsZW4pXG4gICAgICAgIGJ1ZiA9IHlpZWxkIHJlbWFpbmRlcmxlblxuICAgICAgICBpZiAoIWJ1Zikge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgYncud3JpdGUoYnVmKVxuICAgICAgICBnb3RsZW4gKz0gYnVmLmxlbmd0aFxuICAgICAgfVxuICAgICAgYnVmID0gYncudG9CdWZmZXIoKVxuICAgICAgbGV0IG92ZXJsZW4gPSBnb3RsZW4gLSBsZW5cbiAgICAgIHJlbWFpbmRlcmJ1ZiA9IGJ1Zi5zbGljZShidWYubGVuZ3RoIC0gb3ZlcmxlbiwgYnVmLmxlbmd0aClcbiAgICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBidWYubGVuZ3RoIC0gb3ZlcmxlbilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ1ZjogYnVmLFxuICAgICAgICByZW1haW5kZXJidWY6IHJlbWFpbmRlcmJ1ZlxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBidWZmZXIgaW50byBhbiBvYmplY3QsIGkuZS4gZGVzZXJpYWxpemUgdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBmcm9tQnVmZmVyIChidWYsIC4uLnJlc3QpIHtcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWYgbXVzdCBiZSBhIGJ1ZmZlcicpXG4gICAgICB9XG4gICAgICBsZXQgYnIgPSBuZXcgQnIoYnVmKVxuICAgICAgcmV0dXJuIHRoaXMuZnJvbUJyKGJyLCAuLi5yZXN0KVxuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tQnVmZmVyICguLi5yZXN0KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tQnVmZmVyKC4uLnJlc3QpXG4gICAgfVxuXG4gICAgYXN5bmNGcm9tQnVmZmVyIChidWYsIC4uLnJlc3QpIHtcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWYgbXVzdCBiZSBhIGJ1ZmZlcicpXG4gICAgICB9XG4gICAgICBsZXQgYnIgPSBuZXcgQnIoYnVmKVxuICAgICAgcmV0dXJuIHRoaXMuYXN5bmNGcm9tQnIoYnIsIC4uLnJlc3QpXG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jRnJvbUJ1ZmZlciAoYnVmLCAuLi5yZXN0KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5hc3luY0Zyb21CdWZmZXIoYnVmLCAuLi5yZXN0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb21wbGVtZW50IG9mIHRvRmFzdEJ1ZmZlciAtIHNlZSBkZXNjcmlwdGlvbiBmb3IgdG9GYXN0QnVmZmVyXG4gICAgICovXG4gICAgZnJvbUZhc3RCdWZmZXIgKGJ1ZiwgLi4ucmVzdCkge1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmLCAuLi5yZXN0KVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tRmFzdEJ1ZmZlciAoLi4ucmVzdCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbUZhc3RCdWZmZXIoLi4ucmVzdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBvYmplY3QgaW50byBhIGJ1ZmZlciwgaS5lLiBzZXJpYWxpemUgdGhlIG9iamVjdC4gVGhpcyBtZXRob2RcbiAgICAgKiBtYXkgYmxvY2sgdGhlIG1haW4gdGhyZWFkLlxuICAgICAqL1xuICAgIHRvQnVmZmVyICguLi5yZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy50b0J3KC4uLnJlc3QpLnRvQnVmZmVyKClcbiAgICB9XG5cbiAgICBhc3luY1RvQnVmZmVyICguLi5yZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3luY1RvQncoLi4ucmVzdCkudGhlbigoYncpID0+IGJ3LnRvQnVmZmVyKCkpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29tZXRpbWVzIHRoZSB0b0J1ZmZlciBtZXRob2QgaGFzIGNyeXB0b2dyYXBoeSBhbmQgYmxvY2tzIHRoZSBtYWluIHRocmVhZCxcbiAgICAgKiBhbmQgd2UgbmVlZCBhIG5vbi1ibG9ja2luZyB3YXkgdG8gc2VyaWFsaXplIGFuIG9iamVjdC4gVGhhdCBpcyB3aGF0XG4gICAgICogdG9GYXN0QnVmZmVyIGlzLiBPZiBjb3Vyc2UgaXQgZGVmYXVsdHMgdG8ganVzdCB1c2luZyB0b0J1ZmZlciBpZiBhbiBvYmplY3RcbiAgICAgKiBoYXNuJ3QgaW1wbGVtZW50ZWQgaXQuIElmIHlvdXIgcmVndWxhciB0b0J1ZmZlciBtZXRob2QgYmxvY2tzLCBsaWtlIHdpdGhcbiAgICAgKiBCaXAzMiwgdGhlbiB5b3Ugc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBiZSBub24tYmxvY2tpbmcuIFRoaXNcbiAgICAgKiBtZXRob2QgaXMgdXNlZCB0byBzZW5kIG9iamVjdHMgdG8gdGhlIHdvcmtlcnMuIGkuZS4sIGZvciBjb252ZXJ0aW5nIGFcbiAgICAgKiBCaXAzMiBvYmplY3QgdG8gYSBzdHJpbmcsIHdlIG5lZWQgdG8gZW5jb2RlIGl0IGFzIGEgYnVmZmVyIGluIGFcbiAgICAgKiBub24tYmxvY2tpbmcgbWFubmVyIHdpdGggdG9GYXN0QnVmZmVyLCBzZW5kIGl0IHRvIGEgd29ya2VyLCB0aGVuIHRoZVxuICAgICAqIHdvcmtlciBjb252ZXJ0cyBpdCB0byBhIHN0cmluZywgd2hpY2ggaXMgYSBibG9ja2luZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBJdCBpcyB2ZXJ5IGNvbW1vbiB0byB3YW50IHRvIGNvbnZlcnQgYSBibGFuayBvYmplY3QgdG8gYSB6ZXJvIGxlbmd0aFxuICAgICAqIGJ1ZmZlciwgc28gd2UgY2FuIHRyYW5zcG9ydCBhIGJsYW5rIG9iamVjdCB0byBhIHdvcmtlci4gU28gdGhhdCBiZWhhdmlvclxuICAgICAqIGlzIGluY2x1ZGVkIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgdG9GYXN0QnVmZmVyICguLi5yZXN0KSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J1ZmZlciguLi5yZXN0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGZyb21IZXggKGhleCwgLi4ucmVzdCkge1xuICAgICAgbGV0IGJ1ZlxuICAgICAgdHJ5IHtcbiAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKGJ1ZiwgLi4ucmVzdClcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUhleCAoaGV4LCAuLi5yZXN0KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tSGV4KGhleCwgLi4ucmVzdClcbiAgICB9XG5cbiAgICBhc3luY0Zyb21IZXggKGhleCwgLi4ucmVzdCkge1xuICAgICAgbGV0IGJ1ZlxuICAgICAgdHJ5IHtcbiAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hc3luY0Zyb21CdWZmZXIoYnVmLCAuLi5yZXN0KVxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luY0Zyb21IZXggKGhleCwgLi4ucmVzdCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuYXN5bmNGcm9tSGV4KGhleCwgLi4ucmVzdClcbiAgICB9XG5cbiAgICBmcm9tRmFzdEhleCAoaGV4LCAuLi5yZXN0KSB7XG4gICAgICBsZXQgYnVmXG4gICAgICB0cnkge1xuICAgICAgICBidWYgPSBuZXcgQnVmZmVyKGhleCwgJ2hleCcpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBoZXggc3RyaW5nJylcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZyb21GYXN0QnVmZmVyKGJ1ZiwgLi4ucmVzdClcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUZhc3RIZXggKGhleCwgLi4ucmVzdCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuZnJvbUZhc3RIZXgoaGV4LCAuLi5yZXN0KVxuICAgIH1cblxuICAgIHRvSGV4ICguLi5yZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy50b0J1ZmZlciguLi5yZXN0KS50b1N0cmluZygnaGV4JylcbiAgICB9XG5cbiAgICBhc3luY1RvSGV4ICguLi5yZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3luY1RvQnVmZmVyKC4uLnJlc3QpLnRoZW4oKGJ1ZikgPT4gYnVmLnRvU3RyaW5nKCdoZXgnKSlcbiAgICB9XG5cbiAgICB0b0Zhc3RIZXggKC4uLnJlc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvRmFzdEJ1ZmZlciguLi5yZXN0KS50b1N0cmluZygnaGV4JylcbiAgICB9XG5cbiAgICBmcm9tU3RyaW5nIChzdHIsIC4uLnJlc3QpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0ciBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZyb21IZXgoc3RyLCAuLi5yZXN0KVxuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tU3RyaW5nIChzdHIsIC4uLnJlc3QpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmZyb21TdHJpbmcoc3RyLCAuLi5yZXN0KVxuICAgIH1cblxuICAgIGFzeW5jRnJvbVN0cmluZyAoc3RyLCAuLi5yZXN0KSB7XG4gICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHIgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hc3luY0Zyb21IZXgoc3RyLCAuLi5yZXN0KVxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luY0Zyb21TdHJpbmcgKHN0ciwgLi4ucmVzdCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCkuYXN5bmNGcm9tU3RyaW5nKHN0ciwgLi4ucmVzdClcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoLi4ucmVzdCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9IZXgoLi4ucmVzdClcbiAgICB9XG5cbiAgICBhc3luY1RvU3RyaW5nICguLi5yZXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3luY1RvSGV4KC4uLnJlc3QpXG4gICAgfVxuXG4gICAgZnJvbUpTT04gKGpzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUpTT04gKGpzb24sIC4uLnJlc3QpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmZyb21KU09OKGpzb24sIC4uLnJlc3QpXG4gICAgfVxuXG4gICAgYXN5bmNGcm9tSlNPTiAoanNvbiwgLi4ucmVzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKVxuICAgIH1cblxuICAgIHN0YXRpYyBhc3luY0Zyb21KU09OIChqc29uLCAuLi5yZXN0KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5hc3luY0Zyb21KU09OKGpzb24sIC4uLnJlc3QpXG4gICAgfVxuXG4gICAgdG9KU09OICgpIHtcbiAgICAgIHZhciBqc29uID0ge31cbiAgICAgIGZvciAodmFyIHZhbCBpbiB0aGlzKSB7XG4gICAgICAgIC8vIGFycmF5c1xuICAgICAgICBpZiAodGhpc1t2YWxdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBsZXQgYXJyID0gW11cbiAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXNbdmFsXSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW3ZhbF1baV0udG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGFyci5wdXNoKHRoaXNbdmFsXVtpXS50b0pTT04oKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFyci5wdXNoKEpTT04uc3RyaW5naWZ5KHRoaXNbdmFsXVtpXSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGpzb25bdmFsXSA9IGFyclxuICAgICAgICAvLyBvYmplY3RzXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXNbdmFsXSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRoaXNbdmFsXS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBqc29uW3ZhbF0gPSB0aGlzW3ZhbF0udG9KU09OKClcbiAgICAgICAgLy8gYm9vbGVhbnMsIG51bWJlcnMsIGFuZCBzdHJpbmdzXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXNbdmFsXSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB0aGlzW3ZhbF0gPT09ICdudW1iZXInIHx8IHR5cGVvZiB0aGlzW3ZhbF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAganNvblt2YWxdID0gdGhpc1t2YWxdXG4gICAgICAgIC8vIHRocm93IGFuIGVycm9yIGZvciBvYmplY3RzIHRoYXQgZG8gbm90IGltcGxlbWVudCB0b0pTT05cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpc1t2YWxdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGpzb25cbiAgICAgIC8vIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgICB9XG5cbiAgICBhc3luY1RvSlNPTiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gICAgfVxuXG4gICAgY2xvbmUgKCkge1xuICAgICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYmUgbW9yZSBpbnRlbGxpZ2VudCBhYm91dCBwaWNraW5nIHdoaWNoIGNsb25lIG1ldGhvZFxuICAgICAgLy8gdG8gZGVmYXVsdCB0bz9cbiAgICAgIHJldHVybiB0aGlzLmNsb25lQnlKU09OKClcbiAgICB9XG5cbiAgICBjbG9uZUJ5QnVmZmVyICgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21CdWZmZXIodGhpcy50b0J1ZmZlcigpKVxuICAgIH1cblxuICAgIGNsb25lQnlGYXN0QnVmZmVyICgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21GYXN0QnVmZmVyKHRoaXMudG9GYXN0QnVmZmVyKCkpXG4gICAgfVxuXG4gICAgY2xvbmVCeUhleCAoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tSGV4KHRoaXMudG9IZXgoKSlcbiAgICB9XG5cbiAgICBjbG9uZUJ5U3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21TdHJpbmcodGhpcy50b1N0cmluZygpKVxuICAgIH1cblxuICAgIGNsb25lQnlKU09OICgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21KU09OKHRoaXMudG9KU09OKCkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFN0cnVjdFxufVxuXG5pbmplY3QgPSByZXF1aXJlKCdpbmplY3RlcicpKGluamVjdCwgZGVwZW5kZW5jaWVzKVxubGV0IFN0cnVjdCA9IGluamVjdCgpXG5tb2R1bGUuZXhwb3J0cyA9IFN0cnVjdFxuIiwiLyoqXG4gKiBUcmFuc2FjdGlvbiBCdWlsZGVyIChleHBlcmltZW50YWwpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogVHJhbnNhY3Rpb24gQnVpbGRlci4gVGhpcyBpcyBhLCB5ZXQgdW5maW5pc2hlZCwgY29udmVuaWVuY2UgY2xhc3MgZm9yXG4gKiBidWlsZGluZyBwdWJLZXlIYXNoIGFuZCBwMnNoIHRyYW5zYWN0aW9ucywgYW5kIGFsc28gZm9yIHZlcmlmeWluZyBhcmJpdHJhcnlcbiAqIHRyYW5zYWN0aW9ucyAoYW5kIHRoZWlyIGlucHV0cykuIFlvdSBjYW4gKG9yIHdpbGwgYmUgYWJsZSB0bykgcGF5IHRvXG4gKiBwdWJLZXlIYXNoIHRvIHAyc2ggYW5kIGNhbiBzcGVuZCBwdWJLZXlIYXNoIG9yIHAyc2gtcHViS2V5SGFzaCBvclxuICogcDJzaC1tdWx0aXNpZy5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5sZXQgZGVwZW5kZW5jaWVzID0ge1xuICBBZGRyZXNzOiByZXF1aXJlKCcuL2FkZHJlc3MnKSxcbiAgQ29uc3RhbnRzOiByZXF1aXJlKCcuL2NvbnN0YW50cycpLkRlZmF1bHQuVHhCdWlsZGVyLFxuICBCbjogcmVxdWlyZSgnLi9ibicpLFxuICBQdWJLZXk6IHJlcXVpcmUoJy4vcHViLWtleScpLFxuICBTY3JpcHQ6IHJlcXVpcmUoJy4vc2NyaXB0JyksXG4gIFNpZzogcmVxdWlyZSgnLi9zaWcnKSxcbiAgU3RydWN0OiByZXF1aXJlKCcuL3N0cnVjdCcpLFxuICBUeDogcmVxdWlyZSgnLi90eCcpLFxuICBUeEluOiByZXF1aXJlKCcuL3R4LWluJyksXG4gIFR4T3V0OiByZXF1aXJlKCcuL3R4LW91dCcpLFxuICBUeE91dE1hcDogcmVxdWlyZSgnLi90eC1vdXQtbWFwJyksXG4gIFZhckludDogcmVxdWlyZSgnLi92YXItaW50JyksXG4gIGFzaW5rOiByZXF1aXJlKCdhc2luaycpXG59XG5cbmxldCBpbmplY3QgPSBmdW5jdGlvbiAoZGVwcykge1xuICBsZXQgQWRkcmVzcyA9IGRlcHMuQWRkcmVzc1xuICBsZXQgQ29uc3RhbnRzID0gZGVwcy5Db25zdGFudHNcbiAgbGV0IEJuID0gZGVwcy5CblxuICBsZXQgUHViS2V5ID0gZGVwcy5QdWJLZXlcbiAgbGV0IFNjcmlwdCA9IGRlcHMuU2NyaXB0XG4gIGxldCBTaWcgPSBkZXBzLlNpZ1xuICBsZXQgU3RydWN0ID0gZGVwcy5TdHJ1Y3RcbiAgbGV0IFR4ID0gZGVwcy5UeFxuICBsZXQgVHhJbiA9IGRlcHMuVHhJblxuICBsZXQgVHhPdXQgPSBkZXBzLlR4T3V0XG4gIGxldCBUeE91dE1hcCA9IGRlcHMuVHhPdXRNYXBcbiAgbGV0IFZhckludCA9IGRlcHMuVmFySW50XG4gIGxldCBhc2luayA9IGRlcHMuYXNpbmtcblxuICBjbGFzcyBUeEJ1aWxkZXIgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yICh0eCA9IG5ldyBUeCgpLCB0eElucyA9IFtdLCB0eE91dHMgPSBbXSwgdVR4T3V0TWFwID0gbmV3IFR4T3V0TWFwKCksIGNoYW5nZVNjcmlwdCwgZmVlUGVyS2JOdW0gPSBDb25zdGFudHMuZmVlUGVyS2JOdW0sIG5Mb2NrVGltZSA9IDAsIHZlcnNpb25CeXRlc051bSA9IDEpIHtcbiAgICAgIHN1cGVyKHt0eCwgdHhJbnMsIHR4T3V0cywgdVR4T3V0TWFwLCBjaGFuZ2VTY3JpcHQsIGZlZVBlcktiTnVtLCBuTG9ja1RpbWUsIHZlcnNpb25CeXRlc051bX0pXG4gICAgfVxuXG4gICAgdG9KU09OICgpIHtcbiAgICAgIGxldCBqc29uID0ge31cbiAgICAgIGpzb24udHggPSB0aGlzLnR4LnRvSGV4KClcbiAgICAgIGpzb24udHhJbnMgPSB0aGlzLnR4SW5zLm1hcCgodHhJbikgPT4gdHhJbi50b0hleCgpKVxuICAgICAganNvbi50eE91dHMgPSB0aGlzLnR4T3V0cy5tYXAoKHR4T3V0KSA9PiB0eE91dC50b0hleCgpKVxuICAgICAganNvbi51VHhPdXRNYXAgPSB0aGlzLnVUeE91dE1hcC50b0pTT04oKVxuICAgICAgaWYgKHRoaXMuY2hhbmdlU2NyaXB0KSB7XG4gICAgICAgIGpzb24uY2hhbmdlU2NyaXB0ID0gdGhpcy5jaGFuZ2VTY3JpcHQudG9IZXgoKVxuICAgICAgfVxuICAgICAganNvbi5mZWVQZXJLYk51bSA9IHRoaXMuZmVlUGVyS2JOdW1cbiAgICAgIHJldHVybiBqc29uXG4gICAgfVxuXG4gICAgZnJvbUpTT04gKGpzb24pIHtcbiAgICAgIHRoaXMudHggPSBuZXcgVHgoKS5mcm9tSGV4KGpzb24udHgpXG4gICAgICB0aGlzLnR4SW5zID0ganNvbi50eElucy5tYXAoKHR4SW4pID0+IFR4SW4uZnJvbUhleCh0eEluKSlcbiAgICAgIHRoaXMudHhPdXRzID0ganNvbi50eE91dHMubWFwKCh0eE91dCkgPT4gVHhPdXQuZnJvbUhleCh0eE91dCkpXG4gICAgICB0aGlzLnVUeE91dE1hcCA9IG5ldyBUeE91dE1hcCgpLmZyb21KU09OKGpzb24udVR4T3V0TWFwKVxuICAgICAgaWYgKGpzb24uY2hhbmdlU2NyaXB0KSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU2NyaXB0ID0gbmV3IFNjcmlwdCgpLmZyb21IZXgoanNvbi5jaGFuZ2VTY3JpcHQpXG4gICAgICB9XG4gICAgICB0aGlzLmZlZVBlcktiTnVtID0ganNvbi5mZWVQZXJLYk51bVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzZXRGZWVQZXJLYk51bSAoZmVlUGVyS2JOdW0pIHtcbiAgICAgIHRoaXMuZmVlUGVyS2JOdW0gPSBmZWVQZXJLYk51bVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzZXRDaGFuZ2VBZGRyZXNzIChjaGFuZ2VBZGRyZXNzKSB7XG4gICAgICB0aGlzLmNoYW5nZVNjcmlwdCA9IGNoYW5nZUFkZHJlc3MudG9TY3JpcHQoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzZXRDaGFuZ2VTY3JpcHQgKGNoYW5nZVNjcmlwdCkge1xuICAgICAgdGhpcy5jaGFuZ2VTY3JpcHQgPSBjaGFuZ2VTY3JpcHRcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbkxvY2tUaW1lIGlzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAgICovXG4gICAgc2V0TkxvY2t0aW1lIChuTG9ja1RpbWUpIHtcbiAgICAgIHRoaXMubkxvY2tUaW1lID0gbkxvY2tUaW1lXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHNldFZlcnNpb24gKHZlcnNpb25CeXRlc051bSkge1xuICAgICAgdGhpcy52ZXJzaW9uQnl0ZXNOdW0gPSB2ZXJzaW9uQnl0ZXNOdW1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wb3J0IGEgdHJhbnNhY3Rpb24gcGFydGlhbGx5IHNpZ25lZCBieSBzb21lb25lIGVsc2UuIFRoZSBvbmx5IHRoaW5nIHlvdVxuICAgICAqIGNhbiBkbyBhZnRlciB0aGlzIGlzIHNpZ24gb25lIG9yIG1vcmUgaW5wdXRzLiBVc3VhbGx5IHVzZWQgZm9yIG11bHRpc2lnXG4gICAgICogdHJhbnNhY3Rpb25zLiB1VHhPdXRNYXAgaXMgb3B0aW9uYWwuIEl0IGlzIG5vdCBuZWNlc3Nhcnkgc28gbG9uZyBhcyB5b3VcbiAgICAgKiBwYXNzIGluIHRoZSB0eE91dCB3aGVuIHlvdSBzaWduLlxuICAgICAqL1xuICAgIGltcG9ydFBhcnRpYWxseVNpZ25lZFR4ICh0eCwgdVR4T3V0TWFwKSB7XG4gICAgICB0aGlzLnR4ID0gdHhcbiAgICAgIGlmICh1VHhPdXRNYXApIHtcbiAgICAgICAgdGhpcy51VHhPdXRNYXAgPSB1VHhPdXRNYXBcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF5IFwiZnJvbVwiIGEgc2NyaXB0IC0gaW4gb3RoZXIgd29yZHMsIGFkZCBhbiBpbnB1dCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgaW5wdXRGcm9tU2NyaXB0ICh0eEhhc2hCdWYsIHR4T3V0TnVtLCB0eE91dCwgc2NyaXB0LCBuU2VxdWVuY2UpIHtcbiAgICAgIGlmICghKEJ1ZmZlci5pc0J1ZmZlcih0eEhhc2hCdWYpKSB8fCAhKHR5cGVvZiB0eE91dE51bSA9PT0gJ251bWJlcicpIHx8ICEodHhPdXQgaW5zdGFuY2VvZiBUeE91dCkgfHwgIShzY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvbmUgb2Y6IHR4SGFzaEJ1ZiwgdHhPdXROdW0sIHR4T3V0LCBzY3JpcHQnKVxuICAgICAgfVxuICAgICAgdGhpcy50eElucy5wdXNoKFR4SW4uZnJvbVByb3BlcnRpZXModHhIYXNoQnVmLCB0eE91dE51bSwgc2NyaXB0LCBuU2VxdWVuY2UpKVxuICAgICAgdGhpcy51VHhPdXRNYXAuYWRkKHR4SGFzaEJ1ZiwgdHhPdXROdW0sIHR4T3V0KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXkgXCJmcm9tXCIgYSBwdWJLZXlIYXNoIG91dHB1dCAtIGluIG90aGVyIHdvcmRzLCBhZGQgYW4gaW5wdXQgdG8gdGhlXG4gICAgICogdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgaW5wdXRGcm9tUHViS2V5SGFzaCAodHhIYXNoQnVmLCB0eE91dE51bSwgdHhPdXQsIHB1YktleSwgblNlcXVlbmNlKSB7XG4gICAgICBpZiAoIShCdWZmZXIuaXNCdWZmZXIodHhIYXNoQnVmKSkgfHwgISh0eXBlb2YgdHhPdXROdW0gPT09ICdudW1iZXInKSB8fCAhKHR4T3V0IGluc3RhbmNlb2YgVHhPdXQpIHx8ICEocHViS2V5IGluc3RhbmNlb2YgUHViS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb25lIG9mOiB0eEhhc2hCdWYsIHR4T3V0TnVtLCB0eE91dCwgcHViS2V5JylcbiAgICAgIH1cbiAgICAgIHRoaXMudHhJbnMucHVzaChuZXcgVHhJbigpLmZyb21PYmplY3Qoe25TZXF1ZW5jZX0pLmZyb21QdWJLZXlIYXNoVHhPdXQodHhIYXNoQnVmLCB0eE91dE51bSwgdHhPdXQsIHB1YktleSkpXG4gICAgICB0aGlzLnVUeE91dE1hcC5hZGQodHhIYXNoQnVmLCB0eE91dE51bSwgdHhPdXQpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBheSBcImZyb21cIiBhIHNjcmlwdEhhc2ggKHAyc2gpIG91dHB1dCAtIGluIG90aGVyIHdvcmRzLCBhZGQgYW4gaW5wdXQgdG9cbiAgICAgKiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgaW5wdXRGcm9tU2NyaXB0SGFzaE11bHRpU2lnICh0eEhhc2hCdWYsIHR4T3V0TnVtLCB0eE91dCwgcmVkZWVtU2NyaXB0LCBuU2VxdWVuY2UpIHtcbiAgICAgIGlmICghKEJ1ZmZlci5pc0J1ZmZlcih0eEhhc2hCdWYpKSB8fCAhKHR5cGVvZiB0eE91dE51bSA9PT0gJ251bWJlcicpIHx8ICEodHhPdXQgaW5zdGFuY2VvZiBUeE91dCkgfHwgIShyZWRlZW1TY3JpcHQgaW5zdGFuY2VvZiBTY3JpcHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvbmUgb2Y6IHR4SGFzaEJ1ZiwgdHhPdXROdW0sIHR4T3V0LCByZWRlZW1TY3JpcHQnKVxuICAgICAgfVxuICAgICAgdGhpcy50eElucy5wdXNoKG5ldyBUeEluKCkuZnJvbU9iamVjdCh7blNlcXVlbmNlfSkuZnJvbVNjcmlwdEhhc2hNdWx0aVNpZ1R4T3V0KHR4SGFzaEJ1ZiwgdHhPdXROdW0sIHR4T3V0LCByZWRlZW1TY3JpcHQpKVxuICAgICAgdGhpcy51VHhPdXRNYXAuYWRkKHR4SGFzaEJ1ZiwgdHhPdXROdW0sIHR4T3V0KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhZGRyZXNzIHRvIHNlbmQgZnVuZHMgdG8sIGFsb25nIHdpdGggdGhlIGFtb3VudC4gVGhlIGFtb3VudCBzaG91bGQgYmVcbiAgICAgKiBkZW5vbWluYXRlZCBpbiBzYXRvc2hpcywgbm90IGJpdGNvaW5zLlxuICAgICAqL1xuICAgIG91dHB1dFRvQWRkcmVzcyAodmFsdWVCbiwgYWRkcikge1xuICAgICAgaWYgKCEoYWRkciBpbnN0YW5jZW9mIEFkZHJlc3MpIHx8ICEodmFsdWVCbiBpbnN0YW5jZW9mIEJuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZHIgbXVzdCBiZSBhbiBBZGRyZXNzLCBhbmQgdmFsdWVCbiBtdXN0IGJlIGEgQm4nKVxuICAgICAgfVxuICAgICAgbGV0IHNjcmlwdFxuICAgICAgaWYgKGFkZHIudHlwZSgpID09PSAnc2NyaXB0SGFzaCcpIHtcbiAgICAgICAgc2NyaXB0ID0gbmV3IFNjcmlwdCgpLmZyb21TY3JpcHRIYXNoKGFkZHIuaGFzaEJ1ZilcbiAgICAgIH0gZWxzZSBpZiAoYWRkci50eXBlKCkgPT09ICdwdWJLZXlIYXNoJykge1xuICAgICAgICBzY3JpcHQgPSBuZXcgU2NyaXB0KCkuZnJvbVB1YktleUhhc2goYWRkci5oYXNoQnVmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFkZHJlc3MgdHlwZScpXG4gICAgICB9XG4gICAgICB0aGlzLm91dHB1dFRvU2NyaXB0KHZhbHVlQm4sIHNjcmlwdClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzY3JpcHQgdG8gc2VuZCBmdW5kcyB0bywgYWxvbmcgd2l0aCB0aGUgYW1vdW50LiBUaGUgYW1vdW50IHNob3VsZCBiZVxuICAgICAqIGRlbm9taW5hdGVkIGluIHNhdG9zaGlzLCBub3QgYml0Y29pbnMuXG4gICAgICovXG4gICAgb3V0cHV0VG9TY3JpcHQgKHZhbHVlQm4sIHNjcmlwdCkge1xuICAgICAgaWYgKCEoc2NyaXB0IGluc3RhbmNlb2YgU2NyaXB0KSB8fCAhKHZhbHVlQm4gaW5zdGFuY2VvZiBCbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY3JpcHQgbXVzdCBiZSBhIFNjcmlwdCwgYW5kIHZhbHVlQm4gbXVzdCBiZSBhIEJuJylcbiAgICAgIH1cbiAgICAgIGxldCB0eE91dCA9IFR4T3V0LmZyb21Qcm9wZXJ0aWVzKHZhbHVlQm4sIHNjcmlwdClcbiAgICAgIHRoaXMudHhPdXRzLnB1c2godHhPdXQpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGJ1aWxkT3V0cHV0cyAoKSB7XG4gICAgICBsZXQgb3V0YW1vdW50ID0gbmV3IEJuKDApXG4gICAgICB0aGlzLnR4T3V0cy5mb3JFYWNoKCh0eE91dCkgPT4ge1xuICAgICAgICBvdXRhbW91bnQgPSBvdXRhbW91bnQuYWRkKHR4T3V0LnZhbHVlQm4pXG4gICAgICAgIHRoaXMudHguYWRkVHhPdXQodHhPdXQpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIG91dGFtb3VudFxuICAgIH1cblxuICAgIGJ1aWxkSW5wdXRzIChvdXRhbW91bnQsIGV4dHJhSW5wdXRzTnVtID0gMCkge1xuICAgICAgbGV0IGluYW1vdW50ID0gbmV3IEJuKDApXG4gICAgICBmb3IgKGxldCB0eEluIG9mIHRoaXMudHhJbnMpIHtcbiAgICAgICAgbGV0IHR4T3V0ID0gdGhpcy51VHhPdXRNYXAuZ2V0KHR4SW4udHhIYXNoQnVmLCB0eEluLnR4T3V0TnVtKVxuICAgICAgICBpbmFtb3VudCA9IGluYW1vdW50LmFkZCh0eE91dC52YWx1ZUJuKVxuICAgICAgICB0aGlzLnR4LmFkZFR4SW4odHhJbilcbiAgICAgICAgaWYgKGluYW1vdW50LmdlcShvdXRhbW91bnQpKSB7XG4gICAgICAgICAgaWYgKGV4dHJhSW5wdXRzTnVtIDw9IDApIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGV4dHJhSW5wdXRzTnVtLS1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluYW1vdW50Lmx0KG91dGFtb3VudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgZW5vdWdoIGZ1bmRzIGZvciBvdXRwdXQnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGluYW1vdW50XG4gICAgfVxuXG4gICAgLy8gRm9yIG5vdyB0aGlzIG1ldGhvZCBvbmx5IHN1cHBvcnRzIHB1YktleUhhc2ggaW5wdXRzLiBJdCBhc3N1bWVzIHdlIGhhdmVcbiAgICAvLyBub3QgeWV0IGFkZGVkIHNpZ25hdHVyZXMgdG8gb3VyIGlucHV0cy5cbiAgICAvLyBUT0RPOiBTdXBwb3J0IGl0IHdoZW4gdGhlIHNpZ25hdHVyZXMgYXJlIGFscmVhZHkgb24gdGhlIGlucHV0cy5cbiAgICAvLyBUT0RPOiBTdXBwb3J0IHAyc2ggaW5wdXRzLlxuICAgIGVzdGltYXRlU2l6ZSAoKSB7XG4gICAgICAvLyBsYXJnZXN0IHBvc3NpYmxlIHNpZyBzaXplXG4gICAgICBsZXQgc2lnc2l6ZSA9IDEgKyAxICsgMSArIDEgKyAzMiArIDEgKyAxICsgMzIgKyAxXG4gICAgICBsZXQgc2l6ZSA9IHRoaXMudHgudG9CdWZmZXIoKS5sZW5ndGhcbiAgICAgIHNpemUgPSBzaXplICsgc2lnc2l6ZSAqIHRoaXMudHgudHhJbnMubGVuZ3RoXG4gICAgICBzaXplID0gc2l6ZSArIDEgLy8gYXNzdW1lIHR4SW5zVmkgaW5jcmVhc2VzIGJ5IDEgYnl0ZVxuICAgICAgcmV0dXJuIHNpemVcbiAgICB9XG5cbiAgICBlc3RpbWF0ZUZlZSAoKSB7XG4gICAgICAvLyBUT0RPOiBTdXBwb3J0IGNhbGN1bGF0aW5nIGZlZXMgZnJvbSBwMnNoIG11bHRpc2lnLlxuICAgICAgbGV0IGZlZSA9IE1hdGguY2VpbCh0aGlzLmVzdGltYXRlU2l6ZSgpIC8gMTAwMCkgKiB0aGlzLmZlZVBlcktiTnVtXG4gICAgICByZXR1cm4gbmV3IEJuKGZlZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIHRyYW5zYWN0aW9uIGFuZCBhZGRzIHRoZSBhcHByb3ByaWF0ZSBmZWUgYnkgc3VidHJhY3RpbmcgZnJvbVxuICAgICAqIHRoZSBjaGFuZ2Ugb3V0cHV0LiBOb3RlIHRoYXQgYnkgZGVmYXVsdCB0aGUgVHhCdWlsZGVyIHdpbGwgdXNlIGFzIG1hbnlcbiAgICAgKiBpbnB1dHMgYXMgbmVjZXNzYXJ5IHRvIHBheSB0aGUgb3V0cHV0IGFtb3VudHMgYW5kIHRoZSByZXF1aXJlZCBmZWUuIFRoZVxuICAgICAqIFR4QnVpbGRlciB3aWxsIG5vdCBuZWNlc3NhcmlseSB1cyBhbGwgdGhlIGlucHV0cy4gVG8gZm9yY2UgdGhlIFR4QnVpbGRlclxuICAgICAqIHRvIHVzZSBhbGwgdGhlIGlucHV0cyAoc3VjaCBhcyBpZiB5b3Ugd2lzaCB0byBzcGVuZCB0aGUgZW50aXJlIGJhbGFuY2VcbiAgICAgKiBvZiBhIHdhbGxldCksIHNldCB0aGUgYXJndW1lbnQgdXNlQWxsSW5wdXRzID0gdHJ1ZS5cbiAgICAgKi9cbiAgICBidWlsZCAodXNlQWxsSW5wdXRzID0gZmFsc2UpIHtcbiAgICAgIGxldCBjaGFuZ2VBbW91bnQsIHNob3VsZGZlZWJuXG4gICAgICBmb3IgKGxldCBleHRyYUlucHV0c051bSA9IHVzZUFsbElucHV0cyA/IHRoaXMudHhJbnMubGVuZ3RoIC0gMSA6IDA7IGV4dHJhSW5wdXRzTnVtIDwgdGhpcy50eElucy5sZW5ndGg7IGV4dHJhSW5wdXRzTnVtKyspIHtcbiAgICAgICAgdGhpcy50eCA9IG5ldyBUeCgpXG4gICAgICAgIGxldCBvdXRhbW91bnQgPSB0aGlzLmJ1aWxkT3V0cHV0cygpXG4gICAgICAgIGxldCBjaGFuZ2VTY3JpcHQgPSB0aGlzLmNoYW5nZVNjcmlwdFxuICAgICAgICBsZXQgY2hhbmdlVHhPdXQgPSBUeE91dC5mcm9tUHJvcGVydGllcyhuZXcgQm4oMCksIGNoYW5nZVNjcmlwdClcbiAgICAgICAgdGhpcy50eC5hZGRUeE91dChjaGFuZ2VUeE91dClcblxuICAgICAgICBsZXQgaW5hbW91bnQgPSB0aGlzLmJ1aWxkSW5wdXRzKG91dGFtb3VudCwgZXh0cmFJbnB1dHNOdW0pXG5cbiAgICAgICAgLy8gVE9ETzogV2hhdCBpZiBjaGFuZ2UgYW1vdW50IGlzIGxlc3MgdGhhbiBkdXN0P1xuICAgICAgICAvLyBTZXQgY2hhbmdlIGFtb3VudCBmcm9tIGluYW1vdW50IC0gb3V0YW1vdW50XG4gICAgICAgIGNoYW5nZUFtb3VudCA9IGluYW1vdW50LnN1YihvdXRhbW91bnQpXG4gICAgICAgIHRoaXMudHgudHhPdXRzW3RoaXMudHgudHhPdXRzLmxlbmd0aCAtIDFdLnZhbHVlQm4gPSBjaGFuZ2VBbW91bnRcblxuICAgICAgICBzaG91bGRmZWVibiA9IHRoaXMuZXN0aW1hdGVGZWUoKVxuICAgICAgICBpZiAoY2hhbmdlQW1vdW50LmdlcShzaG91bGRmZWVibikgJiYgY2hhbmdlQW1vdW50LnN1YihzaG91bGRmZWVibikuZ3QoQ29uc3RhbnRzLmR1c3ROdW0pKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZUFtb3VudC5nZXEoc2hvdWxkZmVlYm4pKSB7XG4gICAgICAgIC8vIFN1YnRyYWN0IGZlZSBmcm9tIGNoYW5nZVxuICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIGNoYW5nZSBpcyBsZXNzIHRoYW4gZHVzdD8gV2hhdCBpZiBjaGFuZ2UgaXMgMD9cbiAgICAgICAgY2hhbmdlQW1vdW50ID0gY2hhbmdlQW1vdW50LnN1YihzaG91bGRmZWVibilcbiAgICAgICAgdGhpcy50eC50eE91dHNbdGhpcy50eC50eE91dHMubGVuZ3RoIC0gMV0udmFsdWVCbiA9IGNoYW5nZUFtb3VudFxuXG4gICAgICAgIGlmIChjaGFuZ2VBbW91bnQubHQoQ29uc3RhbnRzLmR1c3ROdW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gY3JlYXRlIGNoYW5nZSBhbW91bnQgZ3JlYXRlciB0aGFuIGR1c3QnKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50eC5uTG9ja1RpbWUgPSB0aGlzLm5Mb2NrVGltZVxuICAgICAgICB0aGlzLnR4LnZlcnNpb25CeXRlc051bSA9IHRoaXMudmVyc2lvbkJ5dGVzTnVtXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBnYXRoZXIgZW5vdWdoIGlucHV0cyBmb3Igb3V0cHV0cyBhbmQgZmVlJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbGwgc2lnbmF0dXJlcyBhcmUgcHJlc2VudCBpbiBhIHAyc2ggbXVsdGlzaWcgaW5wdXQgc2NyaXB0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhbGxTaWdzUHJlc2VudCAobSwgc2NyaXB0KSB7XG4gICAgICAvLyBUaGUgZmlyc3QgZWxlbWVudCBpcyBhIEZhbW91cyBNdWx0aVNpZyBCdWcgT1BfMCwgYW5kIGxhc3QgZWxlbWVudCBpcyB0aGVcbiAgICAgIC8vIHJlZGVlbVNjcmlwdC4gVGhlIHJlc3QgYXJlIHNpZ25hdHVyZXMuXG4gICAgICBsZXQgcHJlc2VudCA9IDBcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2NyaXB0LmNodW5rcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHNjcmlwdC5jaHVua3NbaV0uYnVmKSB7XG4gICAgICAgICAgcHJlc2VudCsrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVzZW50ID09PSBtXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGJsYW5rIHNpZ25hdHVyZXMgaW4gYSBwMnNoIG11bHRpc2lnIGlucHV0IHNjcmlwdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVtb3ZlQmxhbmtTaWdzIChzY3JpcHQpIHtcbiAgICAgIC8vIFRoZSBmaXJzdCBlbGVtZW50IGlzIGEgRmFtb3VzIE11bHRpU2lnIEJ1ZyBPUF8wLCBhbmQgbGFzdCBlbGVtZW50IGlzIHRoZVxuICAgICAgLy8gcmVkZWVtU2NyaXB0LiBUaGUgcmVzdCBhcmUgc2lnbmF0dXJlcy5cbiAgICAgIHNjcmlwdCA9IG5ldyBTY3JpcHQoc2NyaXB0LmNodW5rcy5zbGljZSgpKSAvLyBjb3B5IHRoZSBzY3JpcHRcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2NyaXB0LmNodW5rcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKCFzY3JpcHQuY2h1bmtzW2ldLmJ1Zikge1xuICAgICAgICAgIHNjcmlwdC5jaHVua3Muc3BsaWNlKGksIDEpIC8vIHJlbW92ZSBpdGggZWxlbWVudFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NyaXB0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIHNpZ25hdHVyZSBmb3IgYSB0cmFuc2FjdGlvbiwgZmlsbCBpdCBpbiB0aGUgYXBwcm9wcmlhdGUgcGxhY2VcbiAgICAgKiBmb3IgYW4gaW5wdXQgdGhhdCBzcGVuZHMgYSBwdWJLZXlIYXNoIG91dHB1dC5cbiAgICAgKi9cbiAgICBmaWxsUHViS2V5SGFzaFNpZyAoaSwga2V5UGFpciwgc2lnKSB7XG4gICAgICBsZXQgdHhJbiA9IHRoaXMudHgudHhJbnNbaV1cbiAgICAgIHR4SW4uc2NyaXB0LmNodW5rc1swXSA9IG5ldyBTY3JpcHQoKS53cml0ZUJ1ZmZlcihzaWcudG9UeEZvcm1hdCgpKS5jaHVua3NbMF1cbiAgICAgIHR4SW4uc2NyaXB0VmkgPSBWYXJJbnQuZnJvbU51bWJlcih0eEluLnNjcmlwdC50b0J1ZmZlcigpLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZmlsbFNjcmlwdEhhc2hNdWx0aVNpZ1NpZyAoaSwga2V5UGFpciwgc2lnLCByZWRlZW1TY3JpcHQpIHtcbiAgICAgIGxldCB0eEluID0gdGhpcy50eC50eEluc1tpXVxuICAgICAgbGV0IHNjcmlwdCA9IHR4SW4uc2NyaXB0XG5cbiAgICAgIC8vIHRocmVlIG5vcm1hbCBvcENvZGVzLCBhbmQgdGhlIHJlc3QgYXJlIHB1YktleXNcbiAgICAgIGxldCBwdWJLZXljaHVua3MgPSByZWRlZW1TY3JpcHQuY2h1bmtzLnNsaWNlKDEsIHJlZGVlbVNjcmlwdC5jaHVua3MubGVuZ3RoIC0gMilcblxuICAgICAgbGV0IHB1YktleWJ1ZnMgPSBwdWJLZXljaHVua3MubWFwKChjaHVuaykgPT4gY2h1bmsuYnVmKVxuICAgICAgbGV0IHB1YktleWJ1ZiA9IGtleVBhaXIucHViS2V5LnRvQnVmZmVyKClcblxuICAgICAgLy8gZmluZCB3aGljaCBwdWJLZXkgaW4gdGhlIHJlZGVlbVNjcmlwdCBpcyB0aGUgb25lIHdlIGFyZSB0cnlpbmcgdG8gc2lnblxuICAgICAgbGV0IHRoaXNQdWJLZXlJbmRleFxuICAgICAgZm9yICh0aGlzUHViS2V5SW5kZXggPSAwOyB0aGlzUHViS2V5SW5kZXggPCBwdWJLZXlidWZzLmxlbmd0aDsgdGhpc1B1YktleUluZGV4KyspIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5jb21wYXJlKHB1YktleWJ1ZiwgcHViS2V5YnVmc1t0aGlzUHViS2V5SW5kZXhdKSA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNQdWJLZXlJbmRleCA+PSBwdWJLZXlidWZzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzaWduOyBwdWJLZXkgbm90IGZvdW5kIGluIGlucHV0ICcgKyBpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNjcmlwdC5jaHVua3NbdGhpc1B1YktleUluZGV4ICsgMV0gPSBuZXcgU2NyaXB0KCkud3JpdGVCdWZmZXIoc2lnLnRvVHhGb3JtYXQoKSkuY2h1bmtzWzBdXG4gICAgICBsZXQgbSA9IHJlZGVlbVNjcmlwdC5jaHVua3NbMF0ub3BDb2RlTnVtIC0gMHg1MFxuICAgICAgaWYgKFR4QnVpbGRlci5hbGxTaWdzUHJlc2VudChtLCBzY3JpcHQpKSB7XG4gICAgICAgIHR4SW4uc2NyaXB0ID0gVHhCdWlsZGVyLnJlbW92ZUJsYW5rU2lncyhzY3JpcHQpXG4gICAgICB9XG4gICAgICB0eEluLnNjcmlwdFZpID0gVmFySW50LmZyb21OdW1iZXIodHhJbi5zY3JpcHQudG9CdWZmZXIoKS5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpZ24gYW4gaW5wdXQsIGJ1dCBkbyBub3QgZmlsbCB0aGUgc2lnbmF0dXJlIGludG8gdGhlIHRyYW5zYWN0aW9uLiBSZXR1cm5cbiAgICAgKiB0aGUgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogRm9yIGEgbm9ybWFsIHRyYW5zYWN0aW9uLCBzdWJTY3JpcHQgaXMgdXN1YWxseSB0aGUgc2NyaXB0UHViS2V5LiBGb3IgYVxuICAgICAqIHAyc2ggdHJhbnNhY3Rpb24sIHN1YlNjcmlwdCBpcyB1c3VhbGx5IHRoZSByZWRlZW1TY3JpcHQuIElmIHlvdSdyZSBub3RcbiAgICAgKiBub3JtYWwgYmVjYXVzZSB5b3UncmUgdXNpbmcgT1BfQ09ERVNFUEFSQVRPUnMsIHlvdSBrbm93IHdoYXQgdG8gZG8uXG4gICAgICovXG4gICAgZ2V0U2lnIChrZXlQYWlyLCBuSGFzaFR5cGUsIG5Jbiwgc3ViU2NyaXB0KSB7XG4gICAgICBuSGFzaFR5cGUgPSBuSGFzaFR5cGUgPT09IHVuZGVmaW5lZCA/IFNpZy5TSUdIQVNIX0FMTCA6IG5IYXNoVHlwZVxuICAgICAgcmV0dXJuIHRoaXMudHguc2lnbihrZXlQYWlyLCBuSGFzaFR5cGUsIG5Jbiwgc3ViU2NyaXB0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHNpZ24gYW4gaW5wdXQgaW4gYSB3b3JrZXIsIGJ1dCBkbyBub3QgZmlsbCB0aGUgc2lnbmF0dXJlXG4gICAgICogaW50byB0aGUgdHJhbnNhY3Rpb24uIFJldHVybiB0aGUgc2lnbmF0dXJlLlxuICAgICAqL1xuICAgIGFzeW5jR2V0U2lnIChrZXlQYWlyLCBuSGFzaFR5cGUsIG5Jbiwgc3ViU2NyaXB0KSB7XG4gICAgICBuSGFzaFR5cGUgPSBuSGFzaFR5cGUgPT09IHVuZGVmaW5lZCA/IFNpZy5TSUdIQVNIX0FMTCA6IG5IYXNoVHlwZVxuICAgICAgcmV0dXJuIHRoaXMudHguYXN5bmNTaWduKGtleVBhaXIsIG5IYXNoVHlwZSwgbkluLCBzdWJTY3JpcHQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2lnbiBpdGggaW5wdXQgd2l0aCBrZXlQYWlyIGFuZCBpbnNlcnQgdGhlIHNpZ25hdHVyZSBpbnRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBvbmx5IHdvcmtzIGZvciBzb21lIHN0YW5kYXJkIHRyYW5zYWN0aW9uIHR5cGVzLiBGb3JcbiAgICAgKiBub24tc3RhbmRhcmQgdHJhbnNhY3Rpb24gdHlwZXMsIHVzZSBnZXRTaWcuXG4gICAgICovXG4gICAgc2lnbiAoaSwga2V5UGFpciwgdHhPdXQpIHtcbiAgICAgIGxldCB0eEluID0gdGhpcy50eC50eEluc1tpXVxuICAgICAgbGV0IHNjcmlwdCA9IHR4SW4uc2NyaXB0XG4gICAgICBpZiAoc2NyaXB0LmlzUHViS2V5SGFzaEluKCkpIHtcbiAgICAgICAgbGV0IHR4SGFzaEJ1ZiA9IHR4SW4udHhIYXNoQnVmXG4gICAgICAgIGxldCB0eE91dE51bSA9IHR4SW4udHhPdXROdW1cbiAgICAgICAgaWYgKCF0eE91dCkge1xuICAgICAgICAgIHR4T3V0ID0gdGhpcy51VHhPdXRNYXAuZ2V0KHR4SGFzaEJ1ZiwgdHhPdXROdW0pXG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dFNjcmlwdCA9IHR4T3V0LnNjcmlwdFxuICAgICAgICBsZXQgc3ViU2NyaXB0ID0gb3V0U2NyaXB0IC8vIHRydWUgZm9yIHN0YW5kYXJkIHNjcmlwdCB0eXBlc1xuICAgICAgICBsZXQgc2lnID0gdGhpcy5nZXRTaWcoa2V5UGFpciwgU2lnLlNJR0hBU0hfQUxMLCBpLCBzdWJTY3JpcHQpXG4gICAgICAgIHRoaXMuZmlsbFB1YktleUhhc2hTaWcoaSwga2V5UGFpciwgc2lnLCBzdWJTY3JpcHQpXG4gICAgICB9IGVsc2UgaWYgKHNjcmlwdC5pc1NjcmlwdEhhc2hJbigpKSB7XG4gICAgICAgIGxldCByZWRlZW1TY3JpcHQgPSBuZXcgU2NyaXB0KCkuZnJvbUJ1ZmZlcihzY3JpcHQuY2h1bmtzW3NjcmlwdC5jaHVua3MubGVuZ3RoIC0gMV0uYnVmKVxuICAgICAgICBsZXQgc3ViU2NyaXB0ID0gcmVkZWVtU2NyaXB0XG4gICAgICAgIGlmICghcmVkZWVtU2NyaXB0LmlzTXVsdGlTaWdPdXQoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNpZ24gbm9uLW11bHRpc2lnIHNjcmlwdEhhc2ggc2NyaXB0IHR5cGUgZm9yIGlucHV0ICcgKyBpKVxuICAgICAgICB9XG4gICAgICAgIGxldCBzaWcgPSB0aGlzLnR4LnNpZ24oa2V5UGFpciwgU2lnLlNJR0hBU0hfQUxMLCBpLCBzdWJTY3JpcHQpXG4gICAgICAgIHRoaXMuZmlsbFNjcmlwdEhhc2hNdWx0aVNpZ1NpZyhpLCBrZXlQYWlyLCBzaWcsIHJlZGVlbVNjcmlwdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNpZ24gdW5rbm93biBzY3JpcHQgdHlwZSBmb3IgaW5wdXQgJyArIGkpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHNpZ24gaXRoIGlucHV0IHdpdGgga2V5UGFpciBpbiBhIHdvcmtlciBhbmQgaW5zZXJ0IHRoZVxuICAgICAqIHNpZ25hdHVyZSBpbnRvIHRoZSB0cmFuc2FjdGlvbi4gIFRoaXMgbWV0aG9kIG9ubHkgd29ya3MgZm9yIHNvbWUgc3RhbmRhcmRcbiAgICAgKiB0cmFuc2FjdGlvbiB0eXBlcy4gRm9yIG5vbi1zdGFuZGFyZCB0cmFuc2FjdGlvbiB0eXBlcywgdXNlIGFzeW5jR2V0U2lnLlxuICAgICAqL1xuICAgIGFzeW5jU2lnbiAoaSwga2V5UGFpciwgdHhPdXQpIHtcbiAgICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgbGV0IHR4SW4gPSB0aGlzLnR4LnR4SW5zW2ldXG4gICAgICAgIGxldCBzY3JpcHQgPSB0eEluLnNjcmlwdFxuICAgICAgICBpZiAoc2NyaXB0LmlzUHViS2V5SGFzaEluKCkpIHtcbiAgICAgICAgICBsZXQgdHhIYXNoQnVmID0gdHhJbi50eEhhc2hCdWZcbiAgICAgICAgICBsZXQgdHhPdXROdW0gPSB0eEluLnR4T3V0TnVtXG4gICAgICAgICAgaWYgKCF0eE91dCkge1xuICAgICAgICAgICAgdHhPdXQgPSB0aGlzLnVUeE91dE1hcC5nZXQodHhIYXNoQnVmLCB0eE91dE51bSlcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG91dFNjcmlwdCA9IHR4T3V0LnNjcmlwdFxuICAgICAgICAgIGxldCBzdWJTY3JpcHQgPSBvdXRTY3JpcHQgLy8gdHJ1ZSBmb3Igc3RhbmRhcmQgc2NyaXB0IHR5cGVzXG4gICAgICAgICAgbGV0IHNpZyA9IHlpZWxkIHRoaXMuYXN5bmNHZXRTaWcoa2V5UGFpciwgU2lnLlNJR0hBU0hfQUxMLCBpLCBzdWJTY3JpcHQpXG4gICAgICAgICAgdGhpcy5maWxsUHViS2V5SGFzaFNpZyhpLCBrZXlQYWlyLCBzaWcsIHN1YlNjcmlwdClcbiAgICAgICAgfSBlbHNlIGlmIChzY3JpcHQuaXNTY3JpcHRIYXNoSW4oKSkge1xuICAgICAgICAgIGxldCByZWRlZW1TY3JpcHQgPSBuZXcgU2NyaXB0KCkuZnJvbUJ1ZmZlcihzY3JpcHQuY2h1bmtzW3NjcmlwdC5jaHVua3MubGVuZ3RoIC0gMV0uYnVmKVxuICAgICAgICAgIGxldCBzdWJTY3JpcHQgPSByZWRlZW1TY3JpcHRcbiAgICAgICAgICBpZiAoIXJlZGVlbVNjcmlwdC5pc011bHRpU2lnT3V0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNpZ24gbm9uLW11bHRpc2lnIHNjcmlwdEhhc2ggc2NyaXB0IHR5cGUgZm9yIGlucHV0ICcgKyBpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc2lnID0geWllbGQgdGhpcy50eC5hc3luY1NpZ24oa2V5UGFpciwgU2lnLlNJR0hBU0hfQUxMLCBpLCBzdWJTY3JpcHQpXG4gICAgICAgICAgdGhpcy5maWxsU2NyaXB0SGFzaE11bHRpU2lnU2lnKGksIGtleVBhaXIsIHNpZywgcmVkZWVtU2NyaXB0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNpZ24gdW5rbm93biBzY3JpcHQgdHlwZSBmb3IgaW5wdXQgJyArIGkpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFR4QnVpbGRlclxufVxuXG5pbmplY3QgPSByZXF1aXJlKCdpbmplY3RlcicpKGluamVjdCwgZGVwZW5kZW5jaWVzKVxubGV0IFR4QnVpbGRlciA9IGluamVjdCgpXG5tb2R1bGUuZXhwb3J0cyA9IFR4QnVpbGRlclxuIiwiLypcbiAqIFRyYW5zYWN0aW9uIElucHV0XG4gKiA9PT09PT09PT09PT09PT09PVxuICpcbiAqIEFuIGlucHV0IHRvIGEgdHJhbnNhY3Rpb24uIFRoZSB3YXkgeW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIHRoaXMgaXMgdGhyb3VnaFxuICogdGhlIGNvbnZlbmllbnQgbWV0aG9kIG9mIG5ldyBUeEluKHR4SGFzaEJ1ZiwgdHhPdXROdW0sIHNjcmlwdCwgblNlcXVlbmNlKSAoaS5lLiwgeW91XG4gKiBjYW4gbGVhdmUgb3V0IHRoZSBzY3JpcHRWaSwgd2hpY2ggaXMgY29tcHV0ZWQgYXV0b21hdGljYWxseSBpZiB5b3UgbGVhdmUgaXRcbiAqIG91dC4pXG4gKi9cbid1c2Ugc3RyaWN0J1xubGV0IGRlcGVuZGVuY2llcyA9IHtcbiAgQnc6IHJlcXVpcmUoJy4vYncnKSxcbiAgVmFySW50OiByZXF1aXJlKCcuL3Zhci1pbnQnKSxcbiAgT3BDb2RlOiByZXF1aXJlKCcuL29wLWNvZGUnKSxcbiAgU2NyaXB0OiByZXF1aXJlKCcuL3NjcmlwdCcpLFxuICBTdHJ1Y3Q6IHJlcXVpcmUoJy4vc3RydWN0Jylcbn1cblxubGV0IGluamVjdCA9IGZ1bmN0aW9uIChkZXBzKSB7XG4gIGxldCBCdyA9IGRlcHMuQndcbiAgbGV0IFZhckludCA9IGRlcHMuVmFySW50XG4gIGxldCBPcENvZGUgPSBkZXBzLk9wQ29kZVxuICBsZXQgU2NyaXB0ID0gZGVwcy5TY3JpcHRcbiAgbGV0IFN0cnVjdCA9IGRlcHMuU3RydWN0XG5cbiAgY2xhc3MgVHhJbiBleHRlbmRzIFN0cnVjdCB7XG4gICAgY29uc3RydWN0b3IgKHR4SGFzaEJ1ZiwgdHhPdXROdW0sIHNjcmlwdFZpLCBzY3JpcHQsIG5TZXF1ZW5jZSA9IDB4ZmZmZmZmZmYpIHtcbiAgICAgIHN1cGVyKHt0eEhhc2hCdWYsIHR4T3V0TnVtLCBzY3JpcHRWaSwgc2NyaXB0LCBuU2VxdWVuY2V9KVxuICAgIH1cblxuICAgIHNldFNjcmlwdCAoc2NyaXB0KSB7XG4gICAgICB0aGlzLnNjcmlwdFZpID0gVmFySW50LmZyb21OdW1iZXIoc2NyaXB0LnRvQnVmZmVyKCkubGVuZ3RoKVxuICAgICAgdGhpcy5zY3JpcHQgPSBzY3JpcHRcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZnJvbVByb3BlcnRpZXMgKHR4SGFzaEJ1ZiwgdHhPdXROdW0sIHNjcmlwdCwgblNlcXVlbmNlKSB7XG4gICAgICB0aGlzLmZyb21PYmplY3Qoe3R4SGFzaEJ1ZiwgdHhPdXROdW0sIG5TZXF1ZW5jZX0pXG4gICAgICB0aGlzLnNldFNjcmlwdChzY3JpcHQpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tUHJvcGVydGllcyAodHhIYXNoQnVmLCB0eE91dE51bSwgc2NyaXB0LCBuU2VxdWVuY2UpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmZyb21Qcm9wZXJ0aWVzKHR4SGFzaEJ1ZiwgdHhPdXROdW0sIHNjcmlwdCwgblNlcXVlbmNlKVxuICAgIH1cblxuICAgIGZyb21KU09OIChqc29uKSB7XG4gICAgICB0aGlzLmZyb21PYmplY3Qoe1xuICAgICAgICB0eEhhc2hCdWY6IG5ldyBCdWZmZXIoanNvbi50eEhhc2hCdWYsICdoZXgnKSxcbiAgICAgICAgdHhPdXROdW06IGpzb24udHhPdXROdW0sXG4gICAgICAgIHNjcmlwdFZpOiBWYXJJbnQuZnJvbUpTT04oanNvbi5zY3JpcHRWaSksXG4gICAgICAgIHNjcmlwdDogU2NyaXB0LmZyb21KU09OKGpzb24uc2NyaXB0KSxcbiAgICAgICAgblNlcXVlbmNlOiBqc29uLm5TZXF1ZW5jZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdG9KU09OICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGFzaEJ1ZjogdGhpcy50eEhhc2hCdWYudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICB0eE91dE51bTogdGhpcy50eE91dE51bSxcbiAgICAgICAgc2NyaXB0Vmk6IHRoaXMuc2NyaXB0VmkudG9KU09OKCksXG4gICAgICAgIHNjcmlwdDogdGhpcy5zY3JpcHQudG9KU09OKCksXG4gICAgICAgIG5TZXF1ZW5jZTogdGhpcy5uU2VxdWVuY2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmcm9tQnIgKGJyKSB7XG4gICAgICB0aGlzLnR4SGFzaEJ1ZiA9IGJyLnJlYWQoMzIpXG4gICAgICB0aGlzLnR4T3V0TnVtID0gYnIucmVhZFVJbnQzMkxFKClcbiAgICAgIHRoaXMuc2NyaXB0VmkgPSBWYXJJbnQuZnJvbUJ1ZmZlcihici5yZWFkVmFySW50QnVmKCkpXG4gICAgICB0aGlzLnNjcmlwdCA9IFNjcmlwdC5mcm9tQnVmZmVyKGJyLnJlYWQodGhpcy5zY3JpcHRWaS50b051bWJlcigpKSlcbiAgICAgIHRoaXMublNlcXVlbmNlID0gYnIucmVhZFVJbnQzMkxFKClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdG9CdyAoYncpIHtcbiAgICAgIGlmICghYncpIHtcbiAgICAgICAgYncgPSBuZXcgQncoKVxuICAgICAgfVxuICAgICAgYncud3JpdGUodGhpcy50eEhhc2hCdWYpXG4gICAgICBidy53cml0ZVVJbnQzMkxFKHRoaXMudHhPdXROdW0pXG4gICAgICBidy53cml0ZSh0aGlzLnNjcmlwdFZpLmJ1ZilcbiAgICAgIGJ3LndyaXRlKHRoaXMuc2NyaXB0LnRvQnVmZmVyKCkpXG4gICAgICBidy53cml0ZVVJbnQzMkxFKHRoaXMublNlcXVlbmNlKVxuICAgICAgcmV0dXJuIGJ3XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdHhJbiB3aXRoIGJsYW5rIHNpZ25hdHVyZXMgZnJvbSBhIHR4T3V0IGFuZCBpdHNcbiAgICAgKiB0eEhhc2hCdWYrdHhPdXROdW0uIEEgXCJibGFua1wiIHNpZ25hdHVyZSBpcyBqdXN0IGFuIE9QXzAuXG4gICAgICovXG4gICAgZnJvbVB1YktleUhhc2hUeE91dCAodHhIYXNoQnVmLCB0eE91dE51bSwgdHhPdXQsIHB1YktleSkge1xuICAgICAgbGV0IHNjcmlwdCA9IG5ldyBTY3JpcHQoKVxuICAgICAgaWYgKHR4T3V0LnNjcmlwdC5pc1B1YktleUhhc2hPdXQoKSkge1xuICAgICAgICBzY3JpcHQud3JpdGVPcENvZGUoT3BDb2RlLk9QXzApIC8vIGJsYW5rIHNpZ25hdHVyZVxuICAgICAgICBzY3JpcHQud3JpdGVCdWZmZXIocHViS2V5LnRvQnVmZmVyKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4T3V0IG11c3QgYmUgb2YgdHlwZSBwdWJLZXlIYXNoJylcbiAgICAgIH1cbiAgICAgIHRoaXMudHhIYXNoQnVmID0gdHhIYXNoQnVmXG4gICAgICB0aGlzLnR4T3V0TnVtID0gdHhPdXROdW1cbiAgICAgIHRoaXMuc2V0U2NyaXB0KHNjcmlwdClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdHhJbiB3aXRoIGJsYW5rIHNpZ25hdHVyZXMgZnJvbSBhIHR4T3V0IGFuZCBpdHNcbiAgICAgKiB0eEhhc2hCdWYrdHhPdXROdW0uIEEgXCJibGFua1wiIHNpZ25hdHVyZSBpcyBqdXN0IGFuIE9QXzAuXG4gICAgICpcbiAgICAgKiBUT0RPOiBBbHNvIHN1cHBvcnQgb3RoZXIgdHlwZXMgb2YgcDJzaCBvdXRwdXRzIG90aGVyIHRoYW4gbXVsdGlzaWcuXG4gICAgICovXG4gICAgZnJvbVNjcmlwdEhhc2hNdWx0aVNpZ1R4T3V0ICh0eEhhc2hCdWYsIHR4T3V0TnVtLCB0eE91dCwgcmVkZWVtU2NyaXB0KSB7XG4gICAgICBsZXQgc2NyaXB0ID0gbmV3IFNjcmlwdCgpXG4gICAgICBpZiAoIXR4T3V0LnNjcmlwdC5pc1NjcmlwdEhhc2hPdXQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R4T3V0IG11c3QgYmUgb2YgdHlwZSBzY3JpcHRIYXNoJylcbiAgICAgIH1cbiAgICAgIGlmICghcmVkZWVtU2NyaXB0LmlzTXVsdGlTaWdPdXQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlZGVlbVNjcmlwdCBtdXN0IGJlIG11bHRpc2lnJylcbiAgICAgIH1cbiAgICAgIHNjcmlwdC53cml0ZU9wQ29kZShPcENvZGUuT1BfMCkgLy8gZXh0cmEgT1BfMDsgZmFtb3VzIG11bHRpc2lnIGJ1ZyBpbiBiaXRjb2luIHBvcHMgb25lIHRvbyBtYW55IGl0ZW1zIGZyb20gdGhlIHN0YWNrXG4gICAgICBsZXQgbnVtcHViS2V5cyA9IHJlZGVlbVNjcmlwdC5jaHVua3MubGVuZ3RoIC0gMyAvLyAzIG5vcm1hbCBvcENvZGVzLCB0aGUgcmVzdCBwdWJLZXlzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bXB1YktleXM7IGkrKykge1xuICAgICAgICBzY3JpcHQud3JpdGVPcENvZGUoT3BDb2RlLk9QXzApIC8vIG9uZSBibGFuayBwZXIgcHViS2V5IChub3QgcGVyIHNpZylcbiAgICAgIH1cbiAgICAgIHNjcmlwdC53cml0ZUJ1ZmZlcihyZWRlZW1TY3JpcHQudG9CdWZmZXIoKSlcbiAgICAgIHRoaXMuZnJvbVByb3BlcnRpZXModHhIYXNoQnVmLCB0eE91dE51bSwgc2NyaXB0KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbVNjcmlwdEhhc2hNdWx0aVNpZ1R4T3V0ICh0eEhhc2hCdWYsIHR4T3V0TnVtLCB0eE91dCwgcmVkZWVtU2NyaXB0KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tU2NyaXB0SGFzaE11bHRpU2lnVHhPdXQodHhIYXNoQnVmLCB0eE91dE51bSwgdHhPdXQsIHJlZGVlbVNjcmlwdClcbiAgICB9XG5cbiAgICBoYXNOdWxsSW5wdXQgKCkge1xuICAgICAgbGV0IGhleCA9IHRoaXMudHhIYXNoQnVmLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgaWYgKGhleCA9PT0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnICYmIHRoaXMudHhPdXROdW0gPT09IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWxhZ291cyB0byBiaXRjb2luZCdzIFNldE51bGwgaW4gQ091dFBvaW50XG4gICAgICovXG4gICAgc2V0TnVsbElucHV0ICgpIHtcbiAgICAgIHRoaXMudHhIYXNoQnVmID0gbmV3IEJ1ZmZlcigzMilcbiAgICAgIHRoaXMudHhIYXNoQnVmLmZpbGwoMClcbiAgICAgIHRoaXMudHhPdXROdW0gPSAweGZmZmZmZmZmIC8vIC0xIGNhc3QgdG8gdW5zaWduZWQgaW50XG4gICAgfVxuICB9XG5cbiAgLyogSW50ZXJwcmV0IHNlcXVlbmNlIG51bWJlcnMgYXMgcmVsYXRpdmUgbG9jay10aW1lIGNvbnN0cmFpbnRzLiAqL1xuICBUeEluLkxPQ0tUSU1FX1ZFUklGWV9TRVFVRU5DRSA9ICgxIDw8IDApXG5cbiAgLyogU2V0dGluZyBuU2VxdWVuY2UgdG8gdGhpcyB2YWx1ZSBmb3IgZXZlcnkgaW5wdXQgaW4gYSB0cmFuc2FjdGlvbiBkaXNhYmxlc1xuICAgKiBuTG9ja1RpbWUuICovXG4gIFR4SW4uU0VRVUVOQ0VfRklOQUwgPSAweGZmZmZmZmZmXG5cbiAgLyogQmVsb3cgZmxhZ3MgYXBwbHkgaW4gdGhlIGNvbnRleHQgb2YgQmlwIDY4Ki9cbiAgLyogSWYgdGhpcyBmbGFnIHNldCwgdHhJbi5uU2VxdWVuY2UgaXMgTk9UIGludGVycHJldGVkIGFzIGEgcmVsYXRpdmUgbG9jay10aW1lLlxuICAgKiAqL1xuICBUeEluLlNFUVVFTkNFX0xPQ0tUSU1FX0RJU0FCTEVfRkxBRyA9ICgxIDw8IDMxKVxuXG4gIC8qIElmIHR4SW4ublNlcXVlbmNlIGVuY29kZXMgYSByZWxhdGl2ZSBsb2NrLXRpbWUgYW5kIHRoaXMgZmxhZyBpcyBzZXQsIHRoZVxuICAgKiByZWxhdGl2ZSBsb2NrLXRpbWUgaGFzIHVuaXRzIG9mIDUxMiBzZWNvbmRzLCBvdGhlcndpc2UgaXQgc3BlY2lmaWVzIGJsb2Nrc1xuICAgKiB3aXRoIGEgZ3JhbnVsYXJpdHkgb2YgMS4gKi9cbiAgVHhJbi5TRVFVRU5DRV9MT0NLVElNRV9UWVBFX0ZMQUcgPSAoMSA8PCAyMilcblxuICAvKiBJZiB0eEluLm5TZXF1ZW5jZSBlbmNvZGVzIGEgcmVsYXRpdmUgbG9jay10aW1lLCB0aGlzIG1hc2sgaXMgYXBwbGllZCB0b1xuICAgKiBleHRyYWN0IHRoYXQgbG9jay10aW1lIGZyb20gdGhlIHNlcXVlbmNlIGZpZWxkLiAqL1xuICBUeEluLlNFUVVFTkNFX0xPQ0tUSU1FX01BU0sgPSAweDAwMDBmZmZmXG5cbiAgLyogSW4gb3JkZXIgdG8gdXNlIHRoZSBzYW1lIG51bWJlciBvZiBiaXRzIHRvIGVuY29kZSByb3VnaGx5IHRoZSBzYW1lXG4gICAqIHdhbGwtY2xvY2sgZHVyYXRpb24sIGFuZCBiZWNhdXNlIGJsb2NrcyBhcmUgbmF0dXJhbGx5IGxpbWl0ZWQgdG8gb2NjdXJcbiAgICogZXZlcnkgNjAwcyBvbiBhdmVyYWdlLCB0aGUgbWluaW11bSBncmFudWxhcml0eSBmb3IgdGltZS1iYXNlZCByZWxhdGl2ZVxuICAgKiBsb2NrLXRpbWUgaXMgZml4ZWQgYXQgNTEyIHNlY29uZHMuICBDb252ZXJ0aW5nIGZyb20gQ1R4SW46Om5TZXF1ZW5jZSB0b1xuICAgKiBzZWNvbmRzIGlzIHBlcmZvcm1lZCBieSBtdWx0aXBseWluZyBieSA1MTIgPSAyXjksIG9yIGVxdWl2YWxlbnRseVxuICAgKiBzaGlmdGluZyB1cCBieSA5IGJpdHMuICovXG4gIFR4SW4uU0VRVUVOQ0VfTE9DS1RJTUVfR1JBTlVMQVJJVFkgPSA5XG5cbiAgcmV0dXJuIFR4SW5cbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBUeEluID0gaW5qZWN0KClcbm1vZHVsZS5leHBvcnRzID0gVHhJblxuIiwiLyoqXG4gKiBUcmFuc2FjdGlvbiBPdXRwdXQgTWFwXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQSBtYXAgZnJvbSBhIHRyYW5zYWN0aW9uIGhhc2ggYW5kIG91dHB1dCBudW1iZXIgdG8gdGhhdCBwYXJ0aWN1bGFyIG91dHB1dC5cbiAqIE5vdGUgdGhhdCB0aGUgbWFwIGlzIGZyb20gdGhlIHRyYW5zYWN0aW9uICpoYXNoKiwgd2hpY2ggaXMgdGhlIHZhbHVlIHRoYXRcbiAqIG9jY3VycyBpbiB0aGUgYmxvY2tjaGFpbiwgbm90IHRoZSBpZCwgd2hpY2ggaXMgdGhlIHJldmVyc2Ugb2YgdGhlIGhhc2guXG4gKi9cbid1c2Ugc3RyaWN0J1xubGV0IGRlcGVuZGVuY2llcyA9IHtcbiAgU3RydWN0OiByZXF1aXJlKCcuL3N0cnVjdCcpLFxuICBUeE91dDogcmVxdWlyZSgnLi90eC1vdXQnKVxufVxuXG5sZXQgaW5qZWN0ID0gZnVuY3Rpb24gKGRlcHMpIHtcbiAgbGV0IFN0cnVjdCA9IGRlcHMuU3RydWN0XG4gIGxldCBUeE91dCA9IGRlcHMuVHhPdXRcblxuICBjbGFzcyBUeE91dE1hcCBleHRlbmRzIFN0cnVjdCB7XG4gICAgY29uc3RydWN0b3IgKG1hcCA9IG5ldyBNYXAoKSkge1xuICAgICAgc3VwZXIoe21hcH0pXG4gICAgfVxuXG4gICAgdG9KU09OICgpIHtcbiAgICAgIGxldCBqc29uID0ge31cbiAgICAgIHRoaXMubWFwLmZvckVhY2goKHR4T3V0LCBsYWJlbCkgPT4ge1xuICAgICAgICBqc29uW2xhYmVsXSA9IHR4T3V0LnRvSGV4KClcbiAgICAgIH0pXG4gICAgICByZXR1cm4ganNvblxuICAgIH1cblxuICAgIGZyb21KU09OIChqc29uKSB7XG4gICAgICBPYmplY3Qua2V5cyhqc29uKS5mb3JFYWNoKChsYWJlbCkgPT4ge1xuICAgICAgICB0aGlzLm1hcC5zZXQobGFiZWwsIFR4T3V0LmZyb21IZXgoanNvbltsYWJlbF0pKVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgYWRkICh0eEhhc2hCdWYsIHR4T3V0TnVtLCB0eE91dCkge1xuICAgICAgbGV0IGxhYmVsID0gdHhIYXNoQnVmLnRvU3RyaW5nKCdoZXgnKSArICc6JyArIHR4T3V0TnVtXG4gICAgICB0aGlzLm1hcC5zZXQobGFiZWwsIHR4T3V0KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXQgKHR4SGFzaEJ1ZiwgdHhPdXROdW0pIHtcbiAgICAgIGxldCBsYWJlbCA9IHR4SGFzaEJ1Zi50b1N0cmluZygnaGV4JykgKyAnOicgKyB0eE91dE51bVxuICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChsYWJlbClcbiAgICB9XG5cbiAgICBhZGRUeCAodHgpIHtcbiAgICAgIGxldCB0eGhhc2hoZXggPSB0eC5oYXNoKCkudG9TdHJpbmcoJ2hleCcpXG4gICAgICB0eC50eE91dHMuZm9yRWFjaCgodHhPdXQsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCBsYWJlbCA9IHR4aGFzaGhleCArICc6JyArIGluZGV4XG4gICAgICAgIHRoaXMubWFwLnNldChsYWJlbCwgdHhPdXQpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVHhPdXRNYXBcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBUeE91dE1hcCA9IGluamVjdCgpXG5tb2R1bGUuZXhwb3J0cyA9IFR4T3V0TWFwXG4iLCIvKipcbiAqIFRyYW5zYWN0aW9uIE91dHB1dFxuICogPT09PT09PT09PT09PT09PT09XG4gKlxuICogQW4gb3V0cHV0IHRvIGEgdHJhbnNhY3Rpb24uIFRoZSB3YXkgeW91IG5vcm1hbGx5IHdhbnQgdG8gbWFrZSBvbmUgaXMgd2l0aFxuICogbmV3IFR4T3V0KHZhbHVlQm4sIHNjcmlwdCkgKGkuZS4sIGp1c3QgYXMgd2l0aCBUeEluLCB5b3UgY2FuIGxlYXZlIG91dCB0aGVcbiAqIHNjcmlwdFZpLCBzaW5jZSBpdCBjYW4gYmUgY29tcHV0ZWQgYXV0b21hdGljYWxseS5cbiovXG4ndXNlIHN0cmljdCdcbmxldCBkZXBlbmRlbmNpZXMgPSB7XG4gIEJuOiByZXF1aXJlKCcuL2JuJyksXG4gIEJ3OiByZXF1aXJlKCcuL2J3JyksXG4gIFNjcmlwdDogcmVxdWlyZSgnLi9zY3JpcHQnKSxcbiAgU3RydWN0OiByZXF1aXJlKCcuL3N0cnVjdCcpLFxuICBWYXJJbnQ6IHJlcXVpcmUoJy4vdmFyLWludCcpXG59XG5cbmxldCBpbmplY3QgPSBmdW5jdGlvbiAoZGVwcykge1xuICBsZXQgQm4gPSBkZXBzLkJuXG4gIGxldCBCdyA9IGRlcHMuQndcbiAgbGV0IFNjcmlwdCA9IGRlcHMuU2NyaXB0XG4gIGxldCBTdHJ1Y3QgPSBkZXBzLlN0cnVjdFxuICBsZXQgVmFySW50ID0gZGVwcy5WYXJJbnRcblxuICBjbGFzcyBUeE91dCBleHRlbmRzIFN0cnVjdCB7XG4gICAgY29uc3RydWN0b3IgKHZhbHVlQm4sIHNjcmlwdFZpLCBzY3JpcHQpIHtcbiAgICAgIHN1cGVyKHt2YWx1ZUJuLCBzY3JpcHRWaSwgc2NyaXB0fSlcbiAgICB9XG5cbiAgICBzZXRTY3JpcHQgKHNjcmlwdCkge1xuICAgICAgdGhpcy5zY3JpcHRWaSA9IFZhckludC5mcm9tTnVtYmVyKHNjcmlwdC50b0J1ZmZlcigpLmxlbmd0aClcbiAgICAgIHRoaXMuc2NyaXB0ID0gc2NyaXB0XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGZyb21Qcm9wZXJ0aWVzICh2YWx1ZUJuLCBzY3JpcHQpIHtcbiAgICAgIHRoaXMuZnJvbU9iamVjdCh7dmFsdWVCbn0pXG4gICAgICB0aGlzLnNldFNjcmlwdChzY3JpcHQpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tUHJvcGVydGllcyAodmFsdWVCbiwgc2NyaXB0KSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tUHJvcGVydGllcyh2YWx1ZUJuLCBzY3JpcHQpXG4gICAgfVxuXG4gICAgZnJvbUpTT04gKGpzb24pIHtcbiAgICAgIHRoaXMuZnJvbU9iamVjdCh7XG4gICAgICAgIHZhbHVlQm46IG5ldyBCbigpLmZyb21KU09OKGpzb24udmFsdWVCbiksXG4gICAgICAgIHNjcmlwdFZpOiBuZXcgVmFySW50KCkuZnJvbUpTT04oanNvbi5zY3JpcHRWaSksXG4gICAgICAgIHNjcmlwdDogbmV3IFNjcmlwdCgpLmZyb21KU09OKGpzb24uc2NyaXB0KVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdG9KU09OICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlQm46IHRoaXMudmFsdWVCbi50b0pTT04oKSxcbiAgICAgICAgc2NyaXB0Vmk6IHRoaXMuc2NyaXB0VmkudG9KU09OKCksXG4gICAgICAgIHNjcmlwdDogdGhpcy5zY3JpcHQudG9KU09OKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmcm9tQnIgKGJyKSB7XG4gICAgICB0aGlzLnZhbHVlQm4gPSBici5yZWFkVUludDY0TEVCbigpXG4gICAgICB0aGlzLnNjcmlwdFZpID0gVmFySW50LmZyb21OdW1iZXIoYnIucmVhZFZhckludE51bSgpKVxuICAgICAgdGhpcy5zY3JpcHQgPSBuZXcgU2NyaXB0KCkuZnJvbUJ1ZmZlcihici5yZWFkKHRoaXMuc2NyaXB0VmkudG9OdW1iZXIoKSkpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRvQncgKGJ3KSB7XG4gICAgICBpZiAoIWJ3KSB7XG4gICAgICAgIGJ3ID0gbmV3IEJ3KClcbiAgICAgIH1cbiAgICAgIGJ3LndyaXRlVUludDY0TEVCbih0aGlzLnZhbHVlQm4pXG4gICAgICBidy53cml0ZSh0aGlzLnNjcmlwdFZpLmJ1ZilcbiAgICAgIGJ3LndyaXRlKHRoaXMuc2NyaXB0LnRvQnVmZmVyKCkpXG4gICAgICByZXR1cm4gYndcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVHhPdXRcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBUeE91dCA9IGluamVjdCgpXG5tb2R1bGUuZXhwb3J0cyA9IFR4T3V0XG4iLCIvKipcbiAqIFRyYW5zYWN0aW9uXG4gKiA9PT09PT09PT09PVxuICpcbiAqIEEgYml0Y29pbiB0cmFuc2FjdGlvbi5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5sZXQgZGVwZW5kZW5jaWVzID0ge1xuICBCbjogcmVxdWlyZSgnLi9ibicpLFxuICBCcjogcmVxdWlyZSgnLi9icicpLFxuICBCdzogcmVxdWlyZSgnLi9idycpLFxuICBFY2RzYTogcmVxdWlyZSgnLi9lY2RzYScpLFxuICBIYXNoOiByZXF1aXJlKCcuL2hhc2gnKSxcbiAgU2NyaXB0OiByZXF1aXJlKCcuL3NjcmlwdCcpLFxuICBTaWc6IHJlcXVpcmUoJy4vc2lnJyksXG4gIFN0cnVjdDogcmVxdWlyZSgnLi9zdHJ1Y3QnKSxcbiAgVHhJbjogcmVxdWlyZSgnLi90eC1pbicpLFxuICBUeE91dDogcmVxdWlyZSgnLi90eC1vdXQnKSxcbiAgVmFySW50OiByZXF1aXJlKCcuL3Zhci1pbnQnKSxcbiAgV29ya2VyczogcmVxdWlyZSgnLi93b3JrZXJzJyksXG4gIGFzaW5rOiByZXF1aXJlKCdhc2luaycpXG59XG5cbmxldCBpbmplY3QgPSBmdW5jdGlvbiAoZGVwcykge1xuICBsZXQgQm4gPSBkZXBzLkJuXG4gIGxldCBCciA9IGRlcHMuQnJcbiAgbGV0IEJ3ID0gZGVwcy5Cd1xuICBsZXQgRWNkc2EgPSBkZXBzLkVjZHNhXG4gIGxldCBIYXNoID0gZGVwcy5IYXNoXG4gIGxldCBTY3JpcHQgPSBkZXBzLlNjcmlwdFxuICBsZXQgU2lnID0gZGVwcy5TaWdcbiAgbGV0IFN0cnVjdCA9IGRlcHMuU3RydWN0XG4gIGxldCBUeEluID0gZGVwcy5UeEluXG4gIGxldCBUeE91dCA9IGRlcHMuVHhPdXRcbiAgbGV0IFZhckludCA9IGRlcHMuVmFySW50XG4gIGxldCBXb3JrZXJzID0gZGVwcy5Xb3JrZXJzXG4gIGxldCBhc2luayA9IGRlcHMuYXNpbmtcblxuICBjbGFzcyBUeCBleHRlbmRzIFN0cnVjdCB7XG4gICAgY29uc3RydWN0b3IgKHZlcnNpb25CeXRlc051bSA9IDEsIHR4SW5zVmkgPSBWYXJJbnQuZnJvbU51bWJlcigwKSwgdHhJbnMgPSBbXSwgdHhPdXRzVmkgPSBWYXJJbnQuZnJvbU51bWJlcigwKSwgdHhPdXRzID0gW10sIG5Mb2NrVGltZSA9IDApIHtcbiAgICAgIHN1cGVyKHt2ZXJzaW9uQnl0ZXNOdW0sIHR4SW5zVmksIHR4SW5zLCB0eE91dHNWaSwgdHhPdXRzLCBuTG9ja1RpbWV9KVxuICAgIH1cblxuICAgIGZyb21KU09OIChqc29uKSB7XG4gICAgICBsZXQgdHhJbnMgPSBbXVxuICAgICAganNvbi50eElucy5mb3JFYWNoKGZ1bmN0aW9uICh0eEluKSB7XG4gICAgICAgIHR4SW5zLnB1c2gobmV3IFR4SW4oKS5mcm9tSlNPTih0eEluKSlcbiAgICAgIH0pXG4gICAgICBsZXQgdHhPdXRzID0gW11cbiAgICAgIGpzb24udHhPdXRzLmZvckVhY2goZnVuY3Rpb24gKHR4T3V0KSB7XG4gICAgICAgIHR4T3V0cy5wdXNoKG5ldyBUeE91dCgpLmZyb21KU09OKHR4T3V0KSlcbiAgICAgIH0pXG4gICAgICB0aGlzLmZyb21PYmplY3Qoe1xuICAgICAgICB2ZXJzaW9uQnl0ZXNOdW06IGpzb24udmVyc2lvbkJ5dGVzTnVtLFxuICAgICAgICB0eEluc1ZpOiBuZXcgVmFySW50KCkuZnJvbUpTT04oanNvbi50eEluc1ZpKSxcbiAgICAgICAgdHhJbnM6IHR4SW5zLFxuICAgICAgICB0eE91dHNWaTogbmV3IFZhckludCgpLmZyb21KU09OKGpzb24udHhPdXRzVmkpLFxuICAgICAgICB0eE91dHM6IHR4T3V0cyxcbiAgICAgICAgbkxvY2tUaW1lOiBqc29uLm5Mb2NrVGltZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdG9KU09OICgpIHtcbiAgICAgIGxldCB0eElucyA9IFtdXG4gICAgICB0aGlzLnR4SW5zLmZvckVhY2goZnVuY3Rpb24gKHR4SW4pIHtcbiAgICAgICAgdHhJbnMucHVzaCh0eEluLnRvSlNPTigpKVxuICAgICAgfSlcbiAgICAgIGxldCB0eE91dHMgPSBbXVxuICAgICAgdGhpcy50eE91dHMuZm9yRWFjaChmdW5jdGlvbiAodHhPdXQpIHtcbiAgICAgICAgdHhPdXRzLnB1c2godHhPdXQudG9KU09OKCkpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbkJ5dGVzTnVtOiB0aGlzLnZlcnNpb25CeXRlc051bSxcbiAgICAgICAgdHhJbnNWaTogdGhpcy50eEluc1ZpLnRvSlNPTigpLFxuICAgICAgICB0eEluczogdHhJbnMsXG4gICAgICAgIHR4T3V0c1ZpOiB0aGlzLnR4T3V0c1ZpLnRvSlNPTigpLFxuICAgICAgICB0eE91dHM6IHR4T3V0cyxcbiAgICAgICAgbkxvY2tUaW1lOiB0aGlzLm5Mb2NrVGltZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZyb21CciAoYnIpIHtcbiAgICAgIHRoaXMudmVyc2lvbkJ5dGVzTnVtID0gYnIucmVhZFVJbnQzMkxFKClcbiAgICAgIHRoaXMudHhJbnNWaSA9IG5ldyBWYXJJbnQoYnIucmVhZFZhckludEJ1ZigpKVxuICAgICAgbGV0IHR4SW5zTnVtID0gdGhpcy50eEluc1ZpLnRvTnVtYmVyKClcbiAgICAgIHRoaXMudHhJbnMgPSBbXVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eEluc051bTsgaSsrKSB7XG4gICAgICAgIHRoaXMudHhJbnMucHVzaChuZXcgVHhJbigpLmZyb21CcihicikpXG4gICAgICB9XG4gICAgICB0aGlzLnR4T3V0c1ZpID0gbmV3IFZhckludChici5yZWFkVmFySW50QnVmKCkpXG4gICAgICBsZXQgdHhPdXRzTnVtID0gdGhpcy50eE91dHNWaS50b051bWJlcigpXG4gICAgICB0aGlzLnR4T3V0cyA9IFtdXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4T3V0c051bTsgaSsrKSB7XG4gICAgICAgIHRoaXMudHhPdXRzLnB1c2gobmV3IFR4T3V0KCkuZnJvbUJyKGJyKSlcbiAgICAgIH1cbiAgICAgIHRoaXMubkxvY2tUaW1lID0gYnIucmVhZFVJbnQzMkxFKClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdG9CdyAoYncpIHtcbiAgICAgIGlmICghYncpIHtcbiAgICAgICAgYncgPSBuZXcgQncoKVxuICAgICAgfVxuICAgICAgYncud3JpdGVVSW50MzJMRSh0aGlzLnZlcnNpb25CeXRlc051bSlcbiAgICAgIGJ3LndyaXRlKHRoaXMudHhJbnNWaS5idWYpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHhJbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy50eEluc1tpXS50b0J3KGJ3KVxuICAgICAgfVxuICAgICAgYncud3JpdGUodGhpcy50eE91dHNWaS5idWYpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHhPdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudHhPdXRzW2ldLnRvQncoYncpXG4gICAgICB9XG4gICAgICBidy53cml0ZVVJbnQzMkxFKHRoaXMubkxvY2tUaW1lKVxuICAgICAgcmV0dXJuIGJ3XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIGEgbm9ybWFsIHRyYW5zYWN0aW9uLCBzdWJTY3JpcHQgaXMgdXN1YWxseSB0aGUgc2NyaXB0UHViS2V5LiBGb3IgYVxuICAgICAqIHAyc2ggdHJhbnNhY3Rpb24sIHN1YlNjcmlwdCBpcyB1c3VhbGx5IHRoZSByZWRlZW1TY3JpcHQuIElmIHlvdSdyZSBub3RcbiAgICAgKiBub3JtYWwgYmVjYXVzZSB5b3UncmUgdXNpbmcgT1BfQ09ERVNFUEFSQVRPUnMsIHlvdSBrbm93IHdoYXQgdG8gZG8uXG4gICAgICovXG4gICAgc2lnaGFzaCAobkhhc2hUeXBlLCBuSW4sIHN1YlNjcmlwdCkge1xuICAgICAgbGV0IHR4Y29weSA9IHRoaXMuY2xvbmVCeUJ1ZmZlcigpXG5cbiAgICAgIHN1YlNjcmlwdCA9IG5ldyBTY3JpcHQoKS5mcm9tQnVmZmVyKHN1YlNjcmlwdC50b0J1ZmZlcigpKVxuICAgICAgc3ViU2NyaXB0LnJlbW92ZUNvZGVzZXBhcmF0b3JzKClcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eGNvcHkudHhJbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHhjb3B5LnR4SW5zW2ldID0gVHhJbi5mcm9tQnVmZmVyKHR4Y29weS50eEluc1tpXS50b0J1ZmZlcigpKS5zZXRTY3JpcHQobmV3IFNjcmlwdCgpKVxuICAgICAgfVxuXG4gICAgICB0eGNvcHkudHhJbnNbbkluXSA9IFR4SW4uZnJvbUJ1ZmZlcih0eGNvcHkudHhJbnNbbkluXS50b0J1ZmZlcigpKS5zZXRTY3JpcHQoc3ViU2NyaXB0KVxuXG4gICAgICBpZiAoKG5IYXNoVHlwZSAmIDMxKSA9PT0gU2lnLlNJR0hBU0hfTk9ORSkge1xuICAgICAgICB0eGNvcHkudHhPdXRzLmxlbmd0aCA9IDBcbiAgICAgICAgdHhjb3B5LnR4T3V0c1ZpID0gVmFySW50LmZyb21OdW1iZXIoMClcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4Y29weS50eElucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpICE9PSBuSW4pIHtcbiAgICAgICAgICAgIHR4Y29weS50eEluc1tpXS5uU2VxdWVuY2UgPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChuSGFzaFR5cGUgJiAzMSkgPT09IFNpZy5TSUdIQVNIX1NJTkdMRSkge1xuICAgICAgICAvLyBUaGUgU0lHSEFTSF9TSU5HTEUgYnVnLlxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9MjYwNTk1LjBcbiAgICAgICAgaWYgKG5JbiA+IHR4Y29weS50eE91dHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKCcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgJ2hleCcpXG4gICAgICAgIH1cblxuICAgICAgICB0eGNvcHkudHhPdXRzLmxlbmd0aCA9IG5JbiArIDFcbiAgICAgICAgdHhjb3B5LnR4T3V0c1ZpID0gVmFySW50LmZyb21OdW1iZXIobkluICsgMSlcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4Y29weS50eE91dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSA8IG5Jbikge1xuICAgICAgICAgICAgdHhjb3B5LnR4T3V0c1tpXSA9IFR4T3V0LmZyb21Qcm9wZXJ0aWVzKG5ldyBCbigpLmZyb21CdWZmZXIobmV3IEJ1ZmZlcignZmZmZmZmZmZmZmZmZmZmZicsICdoZXgnKSksIG5ldyBTY3JpcHQoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4Y29weS50eElucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpICE9PSBuSW4pIHtcbiAgICAgICAgICAgIHR4Y29weS50eEluc1tpXS5uU2VxdWVuY2UgPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBlbHNlLCBTSUdIQVNIX0FMTFxuXG4gICAgICBpZiAobkhhc2hUeXBlICYgU2lnLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSB7XG4gICAgICAgIHR4Y29weS50eEluc1swXSA9IHR4Y29weS50eEluc1tuSW5dXG4gICAgICAgIHR4Y29weS50eElucy5sZW5ndGggPSAxXG4gICAgICAgIHR4Y29weS50eEluc1ZpID0gVmFySW50LmZyb21OdW1iZXIoMSlcbiAgICAgIH1cblxuICAgICAgbGV0IGJ1ZiA9IG5ldyBCdygpLndyaXRlKHR4Y29weS50b0J1ZmZlcigpKS53cml0ZUludDMyTEUobkhhc2hUeXBlKS50b0J1ZmZlcigpXG4gICAgICByZXR1cm4gbmV3IEJyKEhhc2guc2hhMjU2U2hhMjU2KGJ1ZikpLnJlYWRSZXZlcnNlKClcbiAgICB9XG5cbiAgICBhc3luY1NpZ2hhc2ggKG5IYXNoVHlwZSwgbkluLCBzdWJTY3JpcHQpIHtcbiAgICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgbGV0IHdvcmtlcnNSZXN1bHQgPSB5aWVsZCBXb3JrZXJzLmFzeW5jT2JqZWN0TWV0aG9kKHRoaXMsICdzaWdoYXNoJywgW25IYXNoVHlwZSwgbkluLCBzdWJTY3JpcHRdKVxuICAgICAgICByZXR1cm4gd29ya2Vyc1Jlc3VsdC5yZXNidWZcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgc2lnbmF0dXJlIGJ1dCBkb2VzIG5vdCB1cGRhdGUgYW55IGlucHV0c1xuICAgIHNpZ24gKGtleVBhaXIsIG5IYXNoVHlwZSwgbkluLCBzdWJTY3JpcHQpIHtcbiAgICAgIGxldCBoYXNoQnVmID0gdGhpcy5zaWdoYXNoKG5IYXNoVHlwZSwgbkluLCBzdWJTY3JpcHQpXG4gICAgICBsZXQgc2lnID0gRWNkc2Euc2lnbihoYXNoQnVmLCBrZXlQYWlyLCAnbGl0dGxlJykuZnJvbU9iamVjdCh7bkhhc2hUeXBlOiBuSGFzaFR5cGV9KVxuICAgICAgcmV0dXJuIHNpZ1xuICAgIH1cblxuICAgIGFzeW5jU2lnbiAoa2V5UGFpciwgbkhhc2hUeXBlLCBuSW4sIHN1YlNjcmlwdCkge1xuICAgICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNPYmplY3RNZXRob2QodGhpcywgJ3NpZ24nLCBba2V5UGFpciwgbkhhc2hUeXBlLCBuSW4sIHN1YlNjcmlwdF0pXG4gICAgICAgIHJldHVybiBuZXcgU2lnKCkuZnJvbUZhc3RCdWZmZXIod29ya2Vyc1Jlc3VsdC5yZXNidWYpXG4gICAgICB9LCB0aGlzKVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBzaWduYXR1cmUgYXMgaW5wdXQgYW5kIGRvZXMgbm90IHBhcnNlIGFueSBpbnB1dHNcbiAgICB2ZXJpZnkgKHNpZywgcHViS2V5LCBuSW4sIHN1YlNjcmlwdCkge1xuICAgICAgbGV0IGhhc2hCdWYgPSB0aGlzLnNpZ2hhc2goc2lnLm5IYXNoVHlwZSwgbkluLCBzdWJTY3JpcHQpXG4gICAgICByZXR1cm4gRWNkc2EudmVyaWZ5KGhhc2hCdWYsIHNpZywgcHViS2V5LCAnbGl0dGxlJylcbiAgICB9XG5cbiAgICBhc3luY1ZlcmlmeSAoc2lnLCBwdWJLZXksIG5Jbiwgc3ViU2NyaXB0KSB7XG4gICAgICByZXR1cm4gYXNpbmsoZnVuY3Rpb24gKiAoKSB7XG4gICAgICAgIGxldCB3b3JrZXJzUmVzdWx0ID0geWllbGQgV29ya2Vycy5hc3luY09iamVjdE1ldGhvZCh0aGlzLCAndmVyaWZ5JywgW3NpZywgcHViS2V5LCBuSW4sIHN1YlNjcmlwdF0pXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHdvcmtlcnNSZXN1bHQucmVzYnVmLnRvU3RyaW5nKCkpXG4gICAgICB9LCB0aGlzKVxuICAgIH1cblxuICAgIGhhc2ggKCkge1xuICAgICAgcmV0dXJuIEhhc2guc2hhMjU2U2hhMjU2KHRoaXMudG9CdWZmZXIoKSlcbiAgICB9XG5cbiAgICBhc3luY0hhc2ggKCkge1xuICAgICAgcmV0dXJuIGFzaW5rKGZ1bmN0aW9uICogKCkge1xuICAgICAgICBsZXQgd29ya2Vyc1Jlc3VsdCA9IHlpZWxkIFdvcmtlcnMuYXN5bmNPYmplY3RNZXRob2QodGhpcywgJ2hhc2gnLCBbXSlcbiAgICAgICAgcmV0dXJuIHdvcmtlcnNSZXN1bHQucmVzYnVmXG4gICAgICB9LCB0aGlzKVxuICAgIH1cblxuICAgIGlkICgpIHtcbiAgICAgIHJldHVybiBuZXcgQnIodGhpcy5oYXNoKCkpLnJlYWRSZXZlcnNlKClcbiAgICB9XG5cbiAgICBhc3luY0lkICgpIHtcbiAgICAgIHJldHVybiBhc2luayhmdW5jdGlvbiAqICgpIHtcbiAgICAgICAgbGV0IHdvcmtlcnNSZXN1bHQgPSB5aWVsZCBXb3JrZXJzLmFzeW5jT2JqZWN0TWV0aG9kKHRoaXMsICdpZCcsIFtdKVxuICAgICAgICByZXR1cm4gd29ya2Vyc1Jlc3VsdC5yZXNidWZcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuXG4gICAgYWRkVHhJbiAodHhIYXNoQnVmLCB0eE91dE51bSwgc2NyaXB0LCBuU2VxdWVuY2UpIHtcbiAgICAgIGxldCB0eEluXG4gICAgICBpZiAodHhIYXNoQnVmIGluc3RhbmNlb2YgVHhJbikge1xuICAgICAgICB0eEluID0gdHhIYXNoQnVmXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eEluID0gbmV3IFR4SW4oKS5mcm9tT2JqZWN0KHt0eEhhc2hCdWYsIHR4T3V0TnVtLCBuU2VxdWVuY2V9KS5zZXRTY3JpcHQoc2NyaXB0KVxuICAgICAgfVxuICAgICAgdGhpcy50eElucy5wdXNoKHR4SW4pXG4gICAgICB0aGlzLnR4SW5zVmkgPSBWYXJJbnQuZnJvbU51bWJlcih0aGlzLnR4SW5zVmkudG9OdW1iZXIoKSArIDEpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGFkZFR4T3V0ICh2YWx1ZUJuLCBzY3JpcHQpIHtcbiAgICAgIGxldCB0eE91dFxuICAgICAgaWYgKHZhbHVlQm4gaW5zdGFuY2VvZiBUeE91dCkge1xuICAgICAgICB0eE91dCA9IHZhbHVlQm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR4T3V0ID0gbmV3IFR4T3V0KCkuZnJvbU9iamVjdCh7dmFsdWVCbn0pLnNldFNjcmlwdChzY3JpcHQpXG4gICAgICB9XG4gICAgICB0aGlzLnR4T3V0cy5wdXNoKHR4T3V0KVxuICAgICAgdGhpcy50eE91dHNWaSA9IFZhckludC5mcm9tTnVtYmVyKHRoaXMudHhPdXRzVmkudG9OdW1iZXIoKSArIDEpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWxhZ291cyB0byBiaXRjb2luZCdzIElzQ29pbkJhc2UgZnVuY3Rpb24gaW4gdHJhbnNhY3Rpb24uaFxuICAgICAqL1xuICAgIGlzQ29pbmJhc2UgKCkge1xuICAgICAgcmV0dXJuICh0aGlzLnR4SW5zLmxlbmd0aCA9PT0gMSAmJiB0aGlzLnR4SW5zWzBdLmhhc051bGxJbnB1dCgpKVxuICAgIH1cbiAgfVxuXG4gIFR4Lk1BWF9NT05FWSA9IDIxMDAwMDAwICogMWU4XG5cbiAgcmV0dXJuIFR4XG59XG5cbmluamVjdCA9IHJlcXVpcmUoJ2luamVjdGVyJykoaW5qZWN0LCBkZXBlbmRlbmNpZXMpXG5sZXQgVHggPSBpbmplY3QoKVxubW9kdWxlLmV4cG9ydHMgPSBUeFxuIiwiLyoqXG4gKiBWYXJJbnQgKGEuay5hLiBDb21wYWN0IFNpemUpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQSB2YXJJbnQgaXMgYSB2YXJpYmxlIHNpemVkIGludGVnZXIsIGFuZCBpdCBpcyBhIGZvcm1hdCB0aGF0IGlzIHVuaXF1ZSB0b1xuICogYml0Y29pbiwgYW5kIHVzZWQgdGhyb3VnaG91dCBiaXRjb2luIHRvIHJlcHJlc2VudCB0aGUgbGVuZ3RoIG9mIGJpbmFyeSBkYXRhXG4gKiBpbiBhIGNvbXBhY3QgZm9ybWF0IHRoYXQgY2FuIHRha2UgdXAgYXMgbGl0dGxlIGFzIDEgYnl0ZSBvciBhcyBtdWNoIGFzIDlcbiAqIGJ5dGVzLlxuICovXG4ndXNlIHN0cmljdCdcbmxldCBkZXBlbmRlbmNpZXMgPSB7XG4gIEJyOiByZXF1aXJlKCcuL2JyJyksXG4gIEJ3OiByZXF1aXJlKCcuL2J3JyksXG4gIFN0cnVjdDogcmVxdWlyZSgnLi9zdHJ1Y3QnKVxufVxuXG5sZXQgaW5qZWN0ID0gZnVuY3Rpb24gKGRlcHMpIHtcbiAgbGV0IEJyID0gZGVwcy5CclxuICBsZXQgQncgPSBkZXBzLkJ3XG4gIGxldCBTdHJ1Y3QgPSBkZXBzLlN0cnVjdFxuXG4gIGNsYXNzIFZhckludCBleHRlbmRzIFN0cnVjdCB7XG4gICAgY29uc3RydWN0b3IgKGJ1Zikge1xuICAgICAgc3VwZXIoe2J1Zn0pXG4gICAgfVxuXG4gICAgZnJvbUpTT04gKGpzb24pIHtcbiAgICAgIHRoaXMuZnJvbU9iamVjdCh7XG4gICAgICAgIGJ1ZjogbmV3IEJ1ZmZlcihqc29uLCAnaGV4JylcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRvSlNPTiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5idWYudG9TdHJpbmcoJ2hleCcpXG4gICAgfVxuXG4gICAgZnJvbUJ1ZmZlciAoYnVmKSB7XG4gICAgICB0aGlzLmJ1ZiA9IGJ1ZlxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBmcm9tQnIgKGJyKSB7XG4gICAgICB0aGlzLmJ1ZiA9IGJyLnJlYWRWYXJJbnRCdWYoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBmcm9tQm4gKGJuKSB7XG4gICAgICB0aGlzLmJ1ZiA9IG5ldyBCdygpLndyaXRlVmFySW50Qm4oYm4pLnRvQnVmZmVyKClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21CbiAoYm4pIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmZyb21CbihibilcbiAgICB9XG5cbiAgICBmcm9tTnVtYmVyIChudW0pIHtcbiAgICAgIHRoaXMuYnVmID0gbmV3IEJ3KCkud3JpdGVWYXJJbnROdW0obnVtKS50b0J1ZmZlcigpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tTnVtYmVyIChudW0pIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmZyb21OdW1iZXIobnVtKVxuICAgIH1cblxuICAgIHRvQnVmZmVyICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1ZlxuICAgIH1cblxuICAgIHRvQm4gKCkge1xuICAgICAgcmV0dXJuIG5ldyBCcih0aGlzLmJ1ZikucmVhZFZhckludEJuKClcbiAgICB9XG5cbiAgICB0b051bWJlciAoKSB7XG4gICAgICByZXR1cm4gbmV3IEJyKHRoaXMuYnVmKS5yZWFkVmFySW50TnVtKClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVmFySW50XG59XG5cbmluamVjdCA9IHJlcXVpcmUoJ2luamVjdGVyJykoaW5qZWN0LCBkZXBlbmRlbmNpZXMpXG5sZXQgVmFySW50ID0gaW5qZWN0KClcbm1vZHVsZS5leHBvcnRzID0gVmFySW50XG4iLCIvKipcbiAqIFdvcmtlcnNDbWRcbiAqID09PT09PT09PT1cbiAqXG4gKiBBIGNvbW1hbmQgc2VudCB0byBhIHdvcmtlci4gVGhlIGlkZWEgaXMgdGhhdCB5b3Ugc2VuZCB0aGUgd29ya2VyIGEgb2JqZWN0LFxuICogYW5kIGEgbWV0aG9kIHRvIHBlcmZvcm0gb24gdGhhdCBvYmplY3QsIGFuZCB0aGUgYXJndW1lbnRzIHRvIHRoYXQgbWV0aG9kLFxuICogYWxsIGNvbnRhaW5lZCBpbnNpZGUgYSBXb3JrZXJzQ21kIG9iamVjdC4gVGhlIHdvcmtlciB3aWxsIHNlbmQgYmFjayBhXG4gKiByZXN1bHQsIHdoaWNoIGlzIGEgV29ya2Vyc1Jlc3VsdCBvYmplY3QuXG4gKi9cbid1c2Ugc3RyaWN0J1xubGV0IGRlcGVuZGVuY2llcyA9IHtcbiAgQnc6IHJlcXVpcmUoJy4vYncnKSxcbiAgU3RydWN0OiByZXF1aXJlKCcuL3N0cnVjdCcpXG59XG5cbmxldCBpbmplY3QgPSBmdW5jdGlvbiAoZGVwcykge1xuICBsZXQgQncgPSBkZXBzLkJ3XG4gIGxldCBTdHJ1Y3QgPSBkZXBzLlN0cnVjdFxuXG4gIGNsYXNzIFdvcmtlcnNDbWQgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAgIGNvbnN0cnVjdG9yIChvYmpidWYsIGNsYXNzbmFtZSwgbWV0aG9kbmFtZSwgYXJncywgaWQpIHtcbiAgICAgIHN1cGVyKHtvYmpidWYsIGNsYXNzbmFtZSwgbWV0aG9kbmFtZSwgYXJncywgaWR9KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdG8gYSB3b3JrZXJzIGNvbW1hbmQgY2FuIGJlIG5vcm1hbCBqYXZhc2NyaXB0IG9iamVjdHMsXG4gICAgICogYnVmZmVycywgb3IgWW91cnMgQml0Y29pbiBvYmplY3RzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcmdzVG9CdyAoYncsIGFyZ3MpIHtcbiAgICAgIGJ3LndyaXRlVmFySW50TnVtKGFyZ3MubGVuZ3RoKVxuICAgICAgZm9yIChsZXQgaW5kZXggaW4gYXJncykge1xuICAgICAgICBsZXQgYXJnID0gYXJnc1tpbmRleF1cbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhcmcpKSB7XG4gICAgICAgICAgLy8gYXJndW1lbnQgaXMgQnVmZmVyXG4gICAgICAgICAgYncud3JpdGVVSW50OCgwKSAvLyBoZWFkZXIgYnl0ZVxuICAgICAgICAgIGJ3LndyaXRlVmFySW50TnVtKGFyZy5sZW5ndGgpXG4gICAgICAgICAgYncud3JpdGUoYXJnKVxuICAgICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIFN0cnVjdCkge1xuICAgICAgICAgIC8vIGFyZ3VtZW50IGlzIFlvdXJzIEJpdGNvaW4gb2JqZWN0XG4gICAgICAgICAgYncud3JpdGVVSW50OCgxKSAvLyBoZWFkZXIgYnl0ZVxuICAgICAgICAgIGxldCBjbGFzc25hbWUgPSBhcmcuY29uc3RydWN0b3IubmFtZVxuICAgICAgICAgIGJ3LndyaXRlVmFySW50TnVtKGNsYXNzbmFtZS5sZW5ndGgpXG4gICAgICAgICAgYncud3JpdGUobmV3IEJ1ZmZlcihjbGFzc25hbWUpKVxuICAgICAgICAgIGxldCBidWYgPSBhcmcudG9GYXN0QnVmZmVyKClcbiAgICAgICAgICBidy53cml0ZVZhckludE51bShidWYubGVuZ3RoKVxuICAgICAgICAgIGJ3LndyaXRlKGJ1ZilcbiAgICAgICAgfSBlbHNlIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJ3LndyaXRlVUludDgoMikgLy8gaGVhZGVyIGJ5dGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhc3N1bWUgYmFzaWMgamF2YXNjcmlwdCB0eXBlXG4gICAgICAgICAgYncud3JpdGVVSW50OCgzKSAvLyBoZWFkZXIgYnl0ZVxuICAgICAgICAgIGxldCBidWYgPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KGFyZykpXG4gICAgICAgICAgYncud3JpdGVWYXJJbnROdW0oYnVmLmxlbmd0aClcbiAgICAgICAgICBidy53cml0ZShidWYpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBid1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBhcmd1bWVudHMgdG8gYSB3b3JrZXJzIGNvbW1hbmQgY2FuIGJlIG5vcm1hbCBqYXZhc2NyaXB0IG9iamVjdHMsXG4gICAgICogYnVmZmVycywgb3IgWW91cnMgQml0Y29pbiBvYmplY3RzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcmdzRnJvbUJyIChiciwgY2xhc3Nlcykge1xuICAgICAgbGV0IGFyZ3NsZW4gPSBici5yZWFkVmFySW50TnVtKClcbiAgICAgIGxldCBhcmdzID0gW11cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnc2xlbjsgaSsrKSB7XG4gICAgICAgIGxldCBoZWFkZXIgPSBici5yZWFkVUludDgoKVxuICAgICAgICBpZiAoaGVhZGVyID09PSAwKSB7XG4gICAgICAgICAgLy8gYXJndW1lbnQgaXMgQnVmZmVyXG4gICAgICAgICAgbGV0IGxlbiA9IGJyLnJlYWRWYXJJbnROdW0oKVxuICAgICAgICAgIGxldCBidWYgPSBici5yZWFkKGxlbilcbiAgICAgICAgICBhcmdzLnB1c2goYnVmKVxuICAgICAgICB9IGVsc2UgaWYgKGhlYWRlciA9PT0gMSkge1xuICAgICAgICAgIC8vIGFyZ3VtZW50IGlzIFlvdXJzIEJpdGNvaW4gb2JqZWN0XG4gICAgICAgICAgbGV0IGNsYXNzTmFtZUxFbiA9IGJyLnJlYWRWYXJJbnROdW0oKVxuICAgICAgICAgIGxldCBjbGFzc25hbWUgPSBici5yZWFkKGNsYXNzTmFtZUxFbikudG9TdHJpbmcoKVxuICAgICAgICAgIGxldCBidWZsZW4gPSBici5yZWFkVmFySW50TnVtKClcbiAgICAgICAgICBsZXQgYnVmID0gYnIucmVhZChidWZsZW4pXG4gICAgICAgICAgbGV0IG9iaiA9IG5ldyBjbGFzc2VzW2NsYXNzbmFtZV0oKS5mcm9tRmFzdEJ1ZmZlcihidWYpXG4gICAgICAgICAgYXJncy5wdXNoKG9iailcbiAgICAgICAgfSBlbHNlIGlmIChoZWFkZXIgPT09IDIpIHtcbiAgICAgICAgICBhcmdzLnB1c2godW5kZWZpbmVkKVxuICAgICAgICB9IGVsc2UgaWYgKGhlYWRlciA9PT0gMykge1xuICAgICAgICAgIC8vIGFyZ3VtZW50IGlzIGJhc2ljIGphdmFzY3JpcHQgdHlwZVxuICAgICAgICAgIGxldCBsZW4gPSBici5yZWFkVmFySW50TnVtKClcbiAgICAgICAgICBsZXQgYnVmID0gYnIucmVhZChsZW4pXG4gICAgICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UoYnVmLnRvU3RyaW5nKCkpXG4gICAgICAgICAgYXJncy5wdXNoKG9iailcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGVhZGVyIGJ5dGUgZm9yIGFyZ3VtZW50JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFyZ3NcbiAgICB9XG5cbiAgICB0b0J3IChidykge1xuICAgICAgaWYgKCFidykge1xuICAgICAgICBidyA9IG5ldyBCdygpXG4gICAgICB9XG4gICAgICBsZXQgY2xhc3NOYW1lQnVmID0gbmV3IEJ1ZmZlcih0aGlzLmNsYXNzbmFtZSlcbiAgICAgIGJ3LndyaXRlVUludDgoTnVtYmVyKHRoaXMuaXNvYmopKVxuICAgICAgYncud3JpdGVWYXJJbnROdW0oY2xhc3NOYW1lQnVmLmxlbmd0aClcbiAgICAgIGJ3LndyaXRlKGNsYXNzTmFtZUJ1ZilcbiAgICAgIGxldCBtZXRob2ROYW1lQnVmID0gbmV3IEJ1ZmZlcih0aGlzLm1ldGhvZG5hbWUpXG4gICAgICBidy53cml0ZVZhckludE51bShtZXRob2ROYW1lQnVmLmxlbmd0aClcbiAgICAgIGJ3LndyaXRlKG1ldGhvZE5hbWVCdWYpXG4gICAgICBidy53cml0ZVZhckludE51bSh0aGlzLm9iamJ1Zi5sZW5ndGgpXG4gICAgICBidy53cml0ZSh0aGlzLm9iamJ1ZilcbiAgICAgIFdvcmtlcnNDbWQuYXJnc1RvQncoYncsIHRoaXMuYXJncylcbiAgICAgIGJ3LndyaXRlVmFySW50TnVtKHRoaXMuaWQpXG4gICAgICByZXR1cm4gYndcbiAgICB9XG5cbiAgICBmcm9tQnIgKGJyLCBjbGFzc2VzKSB7XG4gICAgICB0aGlzLmlzb2JqID0gQm9vbGVhbihici5yZWFkVUludDgoKSlcbiAgICAgIGxldCBjbGFzc05hbWVMRW4gPSBici5yZWFkVmFySW50TnVtKClcbiAgICAgIHRoaXMuY2xhc3NuYW1lID0gYnIucmVhZChjbGFzc05hbWVMRW4pLnRvU3RyaW5nKClcbiAgICAgIGxldCBtZXRob2ROYW1lTEVuID0gYnIucmVhZFZhckludE51bSgpXG4gICAgICB0aGlzLm1ldGhvZG5hbWUgPSBici5yZWFkKG1ldGhvZE5hbWVMRW4pLnRvU3RyaW5nKClcbiAgICAgIGxldCBvYmpidWZsZW4gPSBici5yZWFkVmFySW50TnVtKClcbiAgICAgIHRoaXMub2JqYnVmID0gYnIucmVhZChvYmpidWZsZW4pXG4gICAgICB0aGlzLmFyZ3MgPSBXb3JrZXJzQ21kLmFyZ3NGcm9tQnIoYnIsIGNsYXNzZXMpXG4gICAgICB0aGlzLmlkID0gYnIucmVhZFZhckludE51bSgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGZyb21PYmplY3RNZXRob2QgKG9iaiwgbWV0aG9kbmFtZSwgYXJncywgaWQpIHtcbiAgICAgIHRoaXMuaXNvYmogPSB0cnVlXG4gICAgICB0aGlzLm9iamJ1ZiA9IG9iai50b0Zhc3RCdWZmZXIoKVxuICAgICAgdGhpcy5jbGFzc25hbWUgPSBvYmouY29uc3RydWN0b3IubmFtZVxuICAgICAgdGhpcy5tZXRob2RuYW1lID0gbWV0aG9kbmFtZVxuICAgICAgdGhpcy5hcmdzID0gYXJnc1xuICAgICAgdGhpcy5pZCA9IGlkXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tT2JqZWN0TWV0aG9kIChvYmosIG1ldGhvZG5hbWUsIGFyZ3MsIGlkKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tT2JqZWN0TWV0aG9kKG9iaiwgbWV0aG9kbmFtZSwgYXJncywgaWQpXG4gICAgfVxuXG4gICAgZnJvbUNsYXNzTWV0aG9kIChjbGFzc25hbWUsIG1ldGhvZG5hbWUsIGFyZ3MsIGlkKSB7XG4gICAgICB0aGlzLmlzb2JqID0gZmFsc2VcbiAgICAgIHRoaXMub2JqYnVmID0gbmV3IEJ1ZmZlcigwKVxuICAgICAgdGhpcy5jbGFzc25hbWUgPSBjbGFzc25hbWVcbiAgICAgIHRoaXMubWV0aG9kbmFtZSA9IG1ldGhvZG5hbWVcbiAgICAgIHRoaXMuYXJncyA9IGFyZ3NcbiAgICAgIHRoaXMuaWQgPSBpZFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUNsYXNzTWV0aG9kIChjbGFzc25hbWUsIG1ldGhvZG5hbWUsIGFyZ3MsIGlkKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKS5mcm9tQ2xhc3NNZXRob2QoY2xhc3NuYW1lLCBtZXRob2RuYW1lLCBhcmdzLCBpZClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gV29ya2Vyc0NtZFxufVxuXG5pbmplY3QgPSByZXF1aXJlKCdpbmplY3RlcicpKGluamVjdCwgZGVwZW5kZW5jaWVzKVxubGV0IFdvcmtlcnNDbWQgPSBpbmplY3QoKVxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZXJzQ21kXG4iLCIvKipcbiAqIFdvcmtlcnNSZXN1bHRcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBBIHJlc3BvbnNlIHNlbnQgYmFjayBmcm9tIGEgd29ya2VyIHRvIHRoZSBtYWluIHRocmVhZC4gQ29udGFpbnMgdGhlIFwicmVzdWx0XCJcbiAqIG9mIHRoZSBjb21wdXRhdGlvbiBpbiB0aGUgZm9ybSBvZiBhIGJ1ZmZlciwgcmVzYnVmLiBJZiB0aGUgYWN0dWFsIHJlc3VsdCBpc1xuICogYW4gb2JqZWN0IHdpdGggYSAudG9GYXN0QnVmZmVyIG1ldGhvZCwgdGhlIG9iamVjdCBpcyBjb252ZXJ0ZWQgdG8gYSBidWZmZXJcbiAqIHVzaW5nIHRoYXQgbWV0aG9kLiBPdGhlcndpc2UgaXQgaXMgSlNPTiBzZXJpYWxpemVkIGludG8gYSBidWZmZXIuIFRoZSByZXN1bHRcbiAqIGNhbiBhbHNvIGJlIGFuIGVycm9yLCBpbiB3aGljaCBjYXNlIHRoZSBpc0Vycm9yIGZsYWcgaXMgc2V0LlxuICovXG4ndXNlIHN0cmljdCdcbmxldCBkZXBlbmRlbmNpZXMgPSB7XG4gIEJ3OiByZXF1aXJlKCcuL2J3JyksXG4gIFN0cnVjdDogcmVxdWlyZSgnLi9zdHJ1Y3QnKVxufVxuXG5sZXQgaW5qZWN0ID0gZnVuY3Rpb24gKGRlcHMpIHtcbiAgbGV0IEJ3ID0gZGVwcy5Cd1xuICBsZXQgU3RydWN0ID0gZGVwcy5TdHJ1Y3RcblxuICBjbGFzcyBXb3JrZXJzUmVzdWx0IGV4dGVuZHMgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3RvciAocmVzYnVmLCBpc0Vycm9yLCBpZCkge1xuICAgICAgc3VwZXIoe3Jlc2J1ZiwgaXNFcnJvciwgaWR9KVxuICAgIH1cblxuICAgIGZyb21SZXN1bHQgKHJlc3VsdCwgaWQpIHtcbiAgICAgIGlmIChyZXN1bHQudG9GYXN0QnVmZmVyKSB7XG4gICAgICAgIHRoaXMucmVzYnVmID0gcmVzdWx0LnRvRmFzdEJ1ZmZlcigpXG4gICAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihyZXN1bHQpKSB7XG4gICAgICAgIHRoaXMucmVzYnVmID0gcmVzdWx0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc2J1ZiA9IG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSlcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNFcnJvciA9IGZhbHNlXG4gICAgICB0aGlzLmlkID0gaWRcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21SZXN1bHQgKHJlc3VsdCwgaWQpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpLmZyb21SZXN1bHQocmVzdWx0LCBpZClcbiAgICB9XG5cbiAgICBmcm9tRXJyb3IgKGVycm9yLCBpZCkge1xuICAgICAgdGhpcy5yZXNidWYgPSBuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KGVycm9yLm1lc3NhZ2UpKVxuICAgICAgdGhpcy5pc0Vycm9yID0gdHJ1ZVxuICAgICAgdGhpcy5pZCA9IGlkXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRvQncgKGJ3KSB7XG4gICAgICBpZiAoIWJ3KSB7XG4gICAgICAgIGJ3ID0gbmV3IEJ3KClcbiAgICAgIH1cbiAgICAgIGJ3LndyaXRlVmFySW50TnVtKHRoaXMucmVzYnVmLmxlbmd0aClcbiAgICAgIGJ3LndyaXRlKHRoaXMucmVzYnVmKVxuICAgICAgYncud3JpdGVVSW50OChOdW1iZXIodGhpcy5pc0Vycm9yKSlcbiAgICAgIGJ3LndyaXRlVmFySW50TnVtKHRoaXMuaWQpXG4gICAgICByZXR1cm4gYndcbiAgICB9XG5cbiAgICBmcm9tQnIgKGJyKSB7XG4gICAgICBsZXQgcmVzYnVmbGVuID0gYnIucmVhZFZhckludE51bSgpXG4gICAgICB0aGlzLnJlc2J1ZiA9IGJyLnJlYWQocmVzYnVmbGVuKVxuICAgICAgdGhpcy5pc0Vycm9yID0gQm9vbGVhbihici5yZWFkVUludDgoKSlcbiAgICAgIHRoaXMuaWQgPSBici5yZWFkVmFySW50TnVtKClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFdvcmtlcnNSZXN1bHRcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBXb3JrZXJzUmVzdWx0ID0gaW5qZWN0KClcbm1vZHVsZS5leHBvcnRzID0gV29ya2Vyc1Jlc3VsdFxuIiwiLyogZ2xvYmFsIHNlbGYgKi9cbi8qKlxuICogV29ya2Vyc1xuICogPT09PT09PVxuICpcbiAqIFdvcmtlcnMgbWFuYWdlcyBlaXRoZXIgcHJvY2Vzc2VzIChpbiBub2RlKSBvciB0aHJlYWRzIChpbiBhIGJyb3dzZXIpLiBUaGVcbiAqIHdvcmtlcnMgYXJlIGludGVuZGVkIHRvIGhhbmRsZSBDUFUtaGVhdnkgdGFza3MgdGhhdCBibG9jayBJTy4gVGhpcyBjbGFzcyBpc1xuICogYSBsaXR0bGUgdW51c3VhbCBpbiB0aGF0IGl0IG11c3QgdXNlIGRpZmZlcmVudCBpbnRlcmZhY2VzIHdoZXRoZXIgaW4gbm9kZSBvclxuICogaW4gdGhlIGJyb3dzZXIuIEluIG5vZGUsIHdlIHVzZSBub2RlJ3MgYnVpbGQtaW4gY2hpbGRfcHJvY2VzcyBmb3JrIHRvIGNyZWF0ZVxuICogbmV3IHdvcmtlcnMgd2UgY2FuIGNvbW11bmljYXRlIHdpdGguIEluIHRoZSBicm93c2VyLCB3ZSB1c2Ugd2ViIHdvcmtlcnMuXG4gKiBVbmZvcnR1bmF0ZWx5LCBub2RlIGFuZCB3ZWIgYnJvd3NlcnMgZG8gbm90IGhhdmUgYSBjb21tb24gaW50ZXJmYWNlIGZvclxuICogd29ya2Vycy4gVGhlcmUgaXMgYSBub2RlIG1vZHVsZSBjYWxsZWQgd2Vid29ya2VyLXRocmVhZHMgZm9yIG5vZGUgdGhhdFxuICogbWltaWNzIHRoZSBicm93c2VyJ3Mgd2ViIHdvcmtlcnMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHJlcXVpcmUoKSwgYW5kIHRodXMgaXNuJ3QgdmVyeSB1c2VmdWwgaW4gb3VyIGNhc2UuIFRoZXJlZm9yZSB3ZSBmYWxsIGJhY2sgdG9cbiAqIHByb2Nlc3MgZm9ya3MuXG4gKlxuICogWW91IHByb2JhYmx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMgY2xhc3MgZGlyZWN0bHkuIFVzZSBXb3JrLCB3aGljaCB3aWxsXG4gKiBhdXRvbWF0aWNhbGx5IHNwYXduIG5ldyB3b3JrZXJzIGlmIG5lZWRlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5sZXQgZGVwZW5kZW5jaWVzID0ge1xuICBXb3JrZXI6ICFwcm9jZXNzLmJyb3dzZXIgPyByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd24gOiBzZWxmLldvcmtlcixcbiAgV29ya2Vyc0NtZDogcmVxdWlyZSgnLi93b3JrZXJzLWNtZCcpLFxuICBXb3JrZXJzUmVzdWx0OiByZXF1aXJlKCcuL3dvcmtlcnMtcmVzdWx0JyksXG4gIHBhdGg6ICFwcm9jZXNzLmJyb3dzZXIgPyByZXF1aXJlKCdwYXRoJykgOiB1bmRlZmluZWRcbn1cblxubGV0IGluamVjdCA9IGZ1bmN0aW9uIChkZXBzKSB7XG4gIGxldCBXb3JrZXIgPSBkZXBzLldvcmtlclxuICBsZXQgV29ya2Vyc0NtZCA9IGRlcHMuV29ya2Vyc0NtZFxuICBsZXQgV29ya2Vyc1Jlc3VsdCA9IGRlcHMuV29ya2Vyc1Jlc3VsdFxuICBsZXQgcGF0aCA9IGRlcHMucGF0aFxuXG4gIGxldCBnbG9iYWxXb3JrZXJzXG5cbiAgY2xhc3MgV29ya2VycyB7XG4gICAgY29uc3RydWN0b3IgKG5hdGl2ZVdvcmtlcnMgPSBbXSwgbGFzdGlkID0gMCwgcHJvbWlzZW1hcCA9IG5ldyBNYXAoKSkge1xuICAgICAgdGhpcy5uYXRpdmVXb3JrZXJzID0gbmF0aXZlV29ya2Vyc1xuICAgICAgdGhpcy5sYXN0aWQgPSBsYXN0aWRcbiAgICAgIHRoaXMucHJvbWlzZW1hcCA9IHByb21pc2VtYXBcbiAgICB9XG5cbiAgICBzcGF3bkJyb3dzZXIgKCkge1xuICAgICAgLy8gVE9ETzogU3VwcG9ydCBtb3JlIHRoYW4gb25lIHdvcmtlclxuICAgICAgdGhpcy5uYXRpdmVXb3JrZXJzWzBdID0gbmV3IFdvcmtlcihwcm9jZXNzLmVudi5ZT1VSU19CSVRDT0lOX0pTX0JBU0VfVVJMICsgcHJvY2Vzcy5lbnYuWU9VUlNfQklUQ09JTl9KU19XT1JLRVJfRklMRSlcbiAgICAgIHRoaXMuaGFuZGxlQnJvd3NlcigpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGhhbmRsZUJyb3dzZXIgKCkge1xuICAgICAgdGhpcy5uYXRpdmVXb3JrZXJzWzBdLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGV2ZW50Lm1lc3NhZ2UgKyAnOiAnICsgZXZlbnQuZmlsZW5hbWUgKyAnOicgKyBldmVudC5saW5lbm8pXG4gICAgICB9LmJpbmQodGhpcylcbiAgICAgIHRoaXMubmF0aXZlV29ya2Vyc1swXS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vblN0ZG91dERhdGEobmV3IEJ1ZmZlcihldmVudC5kYXRhKSlcbiAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzcGF3bk5vZGUgKCkge1xuICAgICAgLy8gVE9ETzogU3VwcG9ydCBtb3JlIHRoYW4gb25lIHdvcmtlclxuICAgICAgLy8gVE9ETzoge21heEJ1ZmZlcjogMTAwMCoxMDI0fVxuICAgICAgdGhpcy5uYXRpdmVXb3JrZXJzWzBdID0gV29ya2VyKCdub2RlJywgW3BhdGguam9pbihfX2Rpcm5hbWUsICd3b3JrZXItbm9kZS5qcycpXSlcbiAgICAgIHRoaXMuaGFuZGxlTm9kZSgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGhhbmRsZU5vZGUgKCkge1xuICAgICAgdGhpcy5uYXRpdmVXb3JrZXJzWzBdLm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpXG4gICAgICB9KVxuICAgICAgdGhpcy5uYXRpdmVXb3JrZXJzWzBdLm9uKCdleGl0JywgKCkgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoJ3VuZXhwZWN0ZWQgZXhpdCcpXG4gICAgICB9KVxuICAgICAgdGhpcy5uYXRpdmVXb3JrZXJzWzBdLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKCd1bmV4cGVjdGVkIGNsb3NlJylcbiAgICAgIH0pXG4gICAgICB0aGlzLm5hdGl2ZVdvcmtlcnNbMF0ub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMub25FcnJvcigndW5leHBlY3RlZCBkaXNjb25uZWN0JylcbiAgICAgIH0pXG4gICAgICB0aGlzLm5hdGl2ZVdvcmtlcnNbMF0uc3Rkb3V0Lm9uKCdkYXRhJywgKGJ1ZikgPT4ge1xuICAgICAgICB0aGlzLm9uU3Rkb3V0RGF0YShidWYpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBvblN0ZG91dERhdGEgKGJ1Zikge1xuICAgICAgbGV0IHdvcmtlcnNSZXN1bHQgPSBuZXcgV29ya2Vyc1Jlc3VsdCgpLmZyb21GYXN0QnVmZmVyKGJ1ZilcbiAgICAgIHJldHVybiB0aGlzLm9uUmVzdWx0KHdvcmtlcnNSZXN1bHQpXG4gICAgfVxuXG4gICAgb25SZXN1bHQgKHdvcmtlcnNSZXN1bHQpIHtcbiAgICAgIGlmICghd29ya2Vyc1Jlc3VsdC5pc0Vycm9yKSB7XG4gICAgICAgIGxldCByZXNvbHZlID0gdGhpcy5wcm9taXNlbWFwLmdldCh3b3JrZXJzUmVzdWx0LmlkKS5yZXNvbHZlXG4gICAgICAgIHJlc29sdmUod29ya2Vyc1Jlc3VsdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHdvcmtlcnNSZXN1bHQucmVzYnVmLnRvU3RyaW5nKCkpIC8vIHRocm93IGFuIGVycm9yIGluIHdvcmtlciB0byBzZWUgb3V0cHV0IGhlcmVcbiAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKEpTT04ucGFyc2Uod29ya2Vyc1Jlc3VsdC5yZXNidWYudG9TdHJpbmcoKSkpXG4gICAgICAgIGxldCByZWplY3QgPSB0aGlzLnByb21pc2VtYXAuZ2V0KHdvcmtlcnNSZXN1bHQuaWQpLnJlamVjdFxuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9XG4gICAgICB0aGlzLnByb21pc2VtYXAuZGVsZXRlKHdvcmtlcnNSZXN1bHQuaWQpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIG9uRXJyb3IgKGVycm9yKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc3Bhd24gKCkge1xuICAgICAgaWYgKGdsb2JhbFdvcmtlcnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1dhcm5pbmc6IFNwb29saW5nIHVwIG5vbi1nbG9iYWwgd29ya2Vycy4nKVxuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGF3bkJyb3dzZXIoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Bhd25Ob2RlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZW5kQnVmZmVyIChidWYpIHtcbiAgICAgIGxldCBidWZsZW4gPSBuZXcgQnVmZmVyKDQpXG4gICAgICBidWZsZW4ud3JpdGVVSW50MzJCRShidWYubGVuZ3RoKVxuICAgICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmbGVuLCBidWZdKVxuICAgICAgaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICAgICAgICB0aGlzLm5hdGl2ZVdvcmtlcnNbMF0ucG9zdE1lc3NhZ2UoYnVmKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5uYXRpdmVXb3JrZXJzWzBdLnN0ZGluLndyaXRlKGJ1ZilcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgYXN5bmNPYmplY3RNZXRob2QgKG9iaiwgbWV0aG9kbmFtZSwgYXJncywgaWQpIHtcbiAgICAgIGlmICghYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmeSBhcmdzJylcbiAgICAgIH1cbiAgICAgIGlkID0gaWQgIT09IHVuZGVmaW5lZCA/IGlkIDogKyt0aGlzLmxhc3RpZFxuICAgICAgbGV0IHdvcmtlcnNDbWQgPSBuZXcgV29ya2Vyc0NtZCgpLmZyb21PYmplY3RNZXRob2Qob2JqLCBtZXRob2RuYW1lLCBhcmdzLCBpZClcbiAgICAgIGxldCBidWYgPSB3b3JrZXJzQ21kLnRvRmFzdEJ1ZmZlcigpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIoYnVmKVxuICAgICAgICB0aGlzLnByb21pc2VtYXAuc2V0KGlkLCB7XG4gICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3Q6IHJlamVjdFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmNPYmplY3RNZXRob2QgKG9iaiwgbWV0aG9kbmFtZSwgYXJncywgaWQpIHtcbiAgICAgIGlmICghZ2xvYmFsV29ya2Vycykge1xuICAgICAgICBnbG9iYWxXb3JrZXJzID0gbmV3IFdvcmtlcnMoKS5zcGF3bigpXG4gICAgICB9XG4gICAgICByZXR1cm4gZ2xvYmFsV29ya2Vycy5hc3luY09iamVjdE1ldGhvZChvYmosIG1ldGhvZG5hbWUsIGFyZ3MsIGlkKVxuICAgIH1cblxuICAgIGFzeW5jQ2xhc3NNZXRob2QgKGNsYXNzbmFtZSwgbWV0aG9kbmFtZSwgYXJncywgaWQpIHtcbiAgICAgIGlmICghYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmeSBhcmdzJylcbiAgICAgIH1cbiAgICAgIGlkID0gaWQgIT09IHVuZGVmaW5lZCA/IGlkIDogKyt0aGlzLmxhc3RpZFxuICAgICAgbGV0IHdvcmtlcnNDbWQgPSBuZXcgV29ya2Vyc0NtZCgpLmZyb21DbGFzc01ldGhvZChjbGFzc25hbWUsIG1ldGhvZG5hbWUsIGFyZ3MsIGlkKVxuICAgICAgbGV0IGJ1ZiA9IHdvcmtlcnNDbWQudG9GYXN0QnVmZmVyKClcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlcihidWYpXG4gICAgICAgIHRoaXMucHJvbWlzZW1hcC5zZXQoaWQsIHtcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogcmVqZWN0XG4gICAgICAgIH0pXG4gICAgICB9LmJpbmQodGhpcykpXG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jQ2xhc3NNZXRob2QgKG9iaiwgbWV0aG9kbmFtZSwgYXJncywgaWQpIHtcbiAgICAgIGlmICghZ2xvYmFsV29ya2Vycykge1xuICAgICAgICBnbG9iYWxXb3JrZXJzID0gbmV3IFdvcmtlcnMoKS5zcGF3bigpXG4gICAgICB9XG4gICAgICByZXR1cm4gZ2xvYmFsV29ya2Vycy5hc3luY0NsYXNzTWV0aG9kKG9iaiwgbWV0aG9kbmFtZSwgYXJncywgaWQpXG4gICAgfVxuXG4gICAgc3RhdGljIGVuZEdsb2JhbFdvcmtlcnMgKCkge1xuICAgICAgaWYgKGdsb2JhbFdvcmtlcnMgJiYgIXByb2Nlc3MuYnJvd3Nlcikge1xuICAgICAgICAvLyBUT0RPOiBTdXBwb3J0IG11bHRpcGxlIHdvcmtlcnMuXG4gICAgICAgIGdsb2JhbFdvcmtlcnMubmF0aXZlV29ya2Vyc1swXS5raWxsKCdTSUdJTlQnKVxuICAgICAgICBnbG9iYWxXb3JrZXJzID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFdvcmtlcnNcbn1cblxuaW5qZWN0ID0gcmVxdWlyZSgnaW5qZWN0ZXInKShpbmplY3QsIGRlcGVuZGVuY2llcylcbmxldCBXb3JrZXJzID0gaW5qZWN0KClcbm1vZHVsZS5leHBvcnRzID0gV29ya2Vyc1xuIiwiLyoqXG4gKiBhc2lua1xuICogPT09PT1cbiAqXG4gKiBhc2luayBpcyB0aGUgc2FtZSB0aGluZyBhcywgb3IgYSByZW5hbWUgb2YsIHNwYXduLiBzcGF3biBpbiB0dXJuIGlzIGEgdG9vbFxuICogZm9yIHJlcGVhdGVkbHkgY2FsbGluZyB0aGUgLnRoZW5zIG9mIHByb21pc2VzIHlpZWxkZWQgYnkgYSBnZW5lcmF0b3IuXG4gKiBCYXNpY2FsbHksIHRoaXMgbWFrZXMgaXQgcG9zc2libGUgdG8gd3JpdGUgYXN5bmNocm9ub3VzLCBwcm9taXNpZmllZCBjb2RlXG4gKiB3aXRoIG5vcm1hbCB0cnkvY2F0Y2hlcyB0aGF0IGxvb2sganVzdCBsaWtlIHN5bmNocm9ub3VzIGNvZGUuIEl0IGNyZWF0ZXNcbiAqIHNob3J0ZXIgYW5kIGVhc2llciB0byB1bmRlcnN0YW5kIGNvZGUuIEh5cG90aGV0aWNhbGx5LCB0aGVyZSB3aWxsIGJlIGFcbiAqIGZlYXR1cmUgaW4gdGhlIG5leHQgdmVyc2lvbiBvZiBqYXZhc2NyaXB0LCBFUzcsIGNhbGxlZCBcImFzeW5jIGZ1bmN0aW9uc1wiLFxuICogd2hpY2ggZG8gZXhhY3RseSB3aGF0IGFzaW5rIGRvZXMuIFdoZW4vaWYgdGhhdCBoYXBwZW5zIGFuZCB3ZSBjYW4gYWNjZXNzIGl0XG4gKiBpbiBub2RlLCB3ZSBjYW4gc2ltcGx5IHJlbW92ZSBhbGwgY2FsbHMgdG8gYXNpbmsgYW5kIG91ciBjb2RlIHNob3VsZCBiZWhhdmVcbiAqIGluIHRoZSBzYW1lIHdheS5cbiAqXG4gKiBTZWU6XG4gKiBodHRwOi8vdGMzOS5naXRodWIuaW8vZWNtYXNjcmlwdC1hc3luY2F3YWl0L1xuICogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYXNjcmlwdC1hc3luY2F3YWl0XG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qYWtlYXJjaGliYWxkLzMxYjg5Y2JhNjI3OTI0OTcyYWQ2XG4gKiBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9lczYvcHJvbWlzZXMvXG4gKiBodHRwczovL2Jsb2dzLndpbmRvd3MuY29tL21zZWRnZWRldi8yMDE1LzA5LzMwL2FzeW5jaHJvbm91cy1jb2RlLWdldHMtZWFzaWVyLXdpdGgtZXMyMDE2LWFzeW5jLWZ1bmN0aW9uLXN1cHBvcnQtaW4tY2hha3JhLWFuZC1taWNyb3NvZnQtZWRnZS9cbiAqL1xuJ3VzZSBzdHJpY3QnXG5mdW5jdGlvbiBzcGF3biAoZ2VuRiwgc2VsZikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBnZW4gPSBnZW5GLmNhbGwoc2VsZilcbiAgICBmdW5jdGlvbiBzdGVwIChuZXh0Rikge1xuICAgICAgdmFyIG5leHRcbiAgICAgIHRyeSB7XG4gICAgICAgIG5leHQgPSBuZXh0RigpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGZpbmlzaGVkIHdpdGggZmFpbHVyZSwgcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICAgIHJlamVjdChlKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgICAgLy8gZmluaXNoZWQgd2l0aCBzdWNjZXNzLCByZXNvbHZlIHRoZSBwcm9taXNlXG4gICAgICAgIHJlc29sdmUobmV4dC52YWx1ZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBub3QgZmluaXNoZWQsIGNoYWluIG9mZiB0aGUgeWllbGRlZCBwcm9taXNlIGFuZCBgc3RlcGAgYWdhaW5cbiAgICAgIFByb21pc2UucmVzb2x2ZShuZXh0LnZhbHVlKS50aGVuKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHN0ZXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuLm5leHQodikgfSlcbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHN0ZXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuLnRocm93KGUpIH0pXG4gICAgICB9KVxuICAgIH1cbiAgICBzdGVwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbi5uZXh0KHVuZGVmaW5lZCkgfSlcbiAgfSlcbn1cbm1vZHVsZS5leHBvcnRzID0gc3Bhd25cbiIsIi8vIGJhc2UteCBlbmNvZGluZ1xuLy8gRm9ya2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iczU4XG4vLyBPcmlnaW5hbGx5IHdyaXR0ZW4gYnkgTWlrZSBIZWFybiBmb3IgQml0Y29pbkpcbi8vIENvcHlyaWdodCAoYykgMjAxMSBHb29nbGUgSW5jXG4vLyBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBTdGVmYW4gVGhvbWFzXG4vLyBNZXJnZWQgQnVmZmVyIHJlZmFjdG9yaW5ncyBmcm9tIGJhc2U1OC1uYXRpdmUgYnkgU3RlcGhlbiBQYWlyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQml0UGF5IEluY1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIHZhciBBTFBIQUJFVF9NQVAgPSB7fVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG5cbiAgLy8gcHJlLWNvbXB1dGUgbG9va3VwIHRhYmxlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICBBTFBIQUJFVF9NQVBbQUxQSEFCRVQuY2hhckF0KGkpXSA9IGlcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVybiAnJ1xuXG4gICAgdmFyIGRpZ2l0cyA9IFswXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSBzb3VyY2VbaV07IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDhcbiAgICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSBCQVNFXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgfCAwXG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBCQVNFKVxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpIHwgMFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgZm9yICh2YXIgayA9IDA7IHNvdXJjZVtrXSA9PT0gMCAmJiBrIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraykge1xuICAgICAgZGlnaXRzLnB1c2goMClcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICAgIGZvciAodmFyIGlpID0gMCwgamogPSBkaWdpdHMubGVuZ3RoIC0gMTsgaWkgPD0gamo7ICsraWksIC0tamopIHtcbiAgICAgIHZhciB0bXAgPSBBTFBIQUJFVFtkaWdpdHNbaWldXVxuICAgICAgZGlnaXRzW2lpXSA9IEFMUEhBQkVUW2RpZ2l0c1tqal1dXG4gICAgICBkaWdpdHNbampdID0gdG1wXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpZ2l0cy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdXG5cbiAgICB2YXIgYnl0ZXMgPSBbMF1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gQUxQSEFCRVRfTUFQW3N0cmluZ1tpXV1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBjYXJyeSA9IHZhbHVlOyBqIDwgYnl0ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiBCQVNFXG4gICAgICAgIGJ5dGVzW2pdID0gY2FycnkgJiAweGZmXG4gICAgICAgIGNhcnJ5ID4+PSA4XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpXG4gICAgICAgIGNhcnJ5ID4+PSA4XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IgKHZhciBrID0gMDsgc3RyaW5nW2tdID09PSBMRUFERVIgJiYgayA8IHN0cmluZy5sZW5ndGggLSAxOyArK2spIHtcbiAgICAgIGJ5dGVzLnB1c2goMClcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXMucmV2ZXJzZSgpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH1cbn1cbiIsIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmJyArICdmZXInKS5CdWZmZXI7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3IubmFtZSA9PT0gJ0JOJyAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gMTYpIHtcbiAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgbnVtYmVyICYgMHgzZmZmZmZmIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleCAoc3RyLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgPDw9IDQ7XG5cbiAgICAgIC8vICdhJyAtICdmJ1xuICAgICAgaWYgKGMgPj0gNDkgJiYgYyA8PSA1NCkge1xuICAgICAgICByIHw9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnIC0gJ0YnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcgJiYgYyA8PSAyMikge1xuICAgICAgICByIHw9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByIHw9IGMgJiAweGY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCkge1xuICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxuICAgIHZhciBvZmYgPSAwO1xuICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSA2LCBqID0gMDsgaSA+PSBzdGFydDsgaSAtPSA2KSB7XG4gICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBpLCBpICsgNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAvLyBOT1RFOiBgMHgzZmZmZmZgIGlzIGludGVudGlvbmFsIGhlcmUsIDI2Yml0cyBtYXggc2hpZnQgKyAyNGJpdCBoZXggbGltYlxuICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuICAgICAgb2ZmICs9IDI0O1xuICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgKyA2ICE9PSBzdGFydCkge1xuICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgc3RhcnQsIGkgKyA2KTtcbiAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmFzZSAoc3RyLCBzdGFydCwgZW5kLCBtdWwpIHtcbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciAqPSBtdWw7XG5cbiAgICAgIC8vICdhJ1xuICAgICAgaWYgKGMgPj0gNDkpIHtcbiAgICAgICAgciArPSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG4gICAgICAgIHIgKz0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgKz0gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgdGhpcy5sZW5ndGggPSAxO1xuXG4gICAgLy8gRmluZCBsZW5ndGggb2YgbGltYiBpbiBiYXNlXG4gICAgZm9yICh2YXIgbGltYkxlbiA9IDAsIGxpbWJQb3cgPSAxOyBsaW1iUG93IDw9IDB4M2ZmZmZmZjsgbGltYlBvdyAqPSBiYXNlKSB7XG4gICAgICBsaW1iTGVuKys7XG4gICAgfVxuICAgIGxpbWJMZW4tLTtcbiAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cbiAgICB2YXIgdG90YWwgPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIG1vZCA9IHRvdGFsICUgbGltYkxlbjtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG4gICAgdmFyIHdvcmQgPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBsaW1iTGVuKSB7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG4gICAgICB0aGlzLmltdWxuKGxpbWJQb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2QgIT09IDApIHtcbiAgICAgIHZhciBwb3cgPSAxO1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIG51bWJlci5sZW5ndGgsIGJhc2UpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kOyBpKyspIHtcbiAgICAgICAgcG93ICo9IGJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW11bG4ocG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG4gICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB9XG4gICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgICB0aGlzLmNvcHkocik7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuICAgIC8vIC0wID0gMFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+JztcbiAgfTtcblxuICAvKlxuXG4gIHZhciB6ZXJvcyA9IFtdO1xuICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG4gIHZhciBzID0gJyc7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICAgIHplcm9zW2ldID0gcztcbiAgICBzICs9ICcwJztcbiAgfVxuICBncm91cFNpemVzWzBdID0gMDtcbiAgZ3JvdXBTaXplc1sxXSA9IDA7XG4gIGdyb3VwQmFzZXNbMF0gPSAwO1xuICBncm91cEJhc2VzWzFdID0gMDtcbiAgdmFyIGJhc2UgPSAyIC0gMTtcbiAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICAgIHZhciBncm91cFNpemUgPSAwO1xuICAgIHZhciBncm91cEJhc2UgPSAxO1xuICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICAgIGdyb3VwU2l6ZSArPSAxO1xuICAgIH1cbiAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG4gIH1cblxuICAqL1xuXG4gIHZhciB6ZXJvcyA9IFtcbiAgICAnJyxcbiAgICAnMCcsXG4gICAgJzAwJyxcbiAgICAnMDAwJyxcbiAgICAnMDAwMCcsXG4gICAgJzAwMDAwJyxcbiAgICAnMDAwMDAwJyxcbiAgICAnMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgXTtcblxuICB2YXIgZ3JvdXBTaXplcyA9IFtcbiAgICAwLCAwLFxuICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG4gIF07XG5cbiAgdmFyIGdyb3VwQmFzZXMgPSBbXG4gICAgMCwgMCxcbiAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuICBdO1xuXG4gIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cbiAgICB2YXIgb3V0O1xuICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgb2ZmID0gMDtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1s2IC0gd29yZC5sZW5ndGhdICsgd29yZCArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuICAgICAgICB9XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG4gICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwO1xuICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgIHZhciByID0gYy5tb2RuKGdyb3VwQmFzZSkudG9TdHJpbmcoYmFzZSk7XG4gICAgICAgIGMgPSBjLmlkaXZuKGdyb3VwQmFzZSk7XG5cbiAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbZ3JvdXBTaXplIC0gci5sZW5ndGhdICsgciArIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgPSByICsgb3V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdCYXNlIHNob3VsZCBiZSBiZXR3ZWVuIDIgYW5kIDM2Jyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIgKCkge1xuICAgIHZhciByZXQgPSB0aGlzLndvcmRzWzBdO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0ICs9IHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA9PT0gMyAmJiB0aGlzLndvcmRzWzJdID09PSAweDAxKSB7XG4gICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG4gICAgICByZXQgKz0gMHgxMDAwMDAwMDAwMDAwMCArICh0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gMikge1xuICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgPyAtcmV0IDogcmV0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKDE2KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uIHRvQXJyYXlMaWtlIChBcnJheVR5cGUsIGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcbiAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuICAgIHZhciBsaXR0bGVFbmRpYW4gPSBlbmRpYW4gPT09ICdsZSc7XG4gICAgdmFyIHJlcyA9IG5ldyBBcnJheVR5cGUocmVxTGVuZ3RoKTtcblxuICAgIHZhciBiLCBpO1xuICAgIHZhciBxID0gdGhpcy5jbG9uZSgpO1xuICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG4gICAgICAvLyBBc3N1bWUgYmlnLWVuZGlhblxuICAgICAgZm9yIChpID0gMDsgaSA8IHJlcUxlbmd0aCAtIGJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbcmVxTGVuZ3RoIC0gaSAtIDFdID0gYjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW2ldID0gYjtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGkgPCByZXFMZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgaWYgKE1hdGguY2x6MzIpIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcbiAgICAgIHZhciB0ID0gdztcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuICAgICAgICByICs9IDEzO1xuICAgICAgICB0ID4+Pj0gMTM7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDQwKSB7XG4gICAgICAgIHIgKz0gNztcbiAgICAgICAgdCA+Pj49IDc7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDgpIHtcbiAgICAgICAgciArPSA0O1xuICAgICAgICB0ID4+Pj0gNDtcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4MDIpIHtcbiAgICAgICAgciArPSAyO1xuICAgICAgICB0ID4+Pj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByICsgdDtcbiAgICB9O1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl96ZXJvQml0cyA9IGZ1bmN0aW9uIF96ZXJvQml0cyAodykge1xuICAgIC8vIFNob3J0LWN1dFxuICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cbiAgICB2YXIgdCA9IHc7XG4gICAgdmFyIHIgPSAwO1xuICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcbiAgICAgIHIgKz0gMTM7XG4gICAgICB0ID4+Pj0gMTM7XG4gICAgfVxuICAgIGlmICgodCAmIDB4N2YpID09PSAwKSB7XG4gICAgICByICs9IDc7XG4gICAgICB0ID4+Pj0gNztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHhmKSA9PT0gMCkge1xuICAgICAgciArPSA0O1xuICAgICAgdCA+Pj49IDQ7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcbiAgICAgIHIgKz0gMjtcbiAgICAgIHQgPj4+PSAyO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDEpID09PSAwKSB7XG4gICAgICByKys7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cbiAgQk4ucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uIGJpdExlbmd0aCAoKSB7XG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuICAgIHJldHVybiAodGhpcy5sZW5ndGggLSAxKSAqIDI2ICsgaGk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG4gICAgdmFyIHcgPSBuZXcgQXJyYXkobnVtLmJpdExlbmd0aCgpKTtcblxuICAgIGZvciAodmFyIGJpdCA9IDA7IGJpdCA8IHcubGVuZ3RoOyBiaXQrKykge1xuICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgICAgd1tiaXRdID0gKG51bS53b3Jkc1tvZmZdICYgKDEgPDwgd2JpdCkpID4+PiB3Yml0O1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgIHIgKz0gYjtcbiAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlvciA9IGZ1bmN0aW9uIGlvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pb3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVvciA9IGZ1bmN0aW9uIHVvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcbiAgICAvLyBiID0gbWluLWxlbmd0aChudW0sIHRoaXMpXG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGIubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcyAhPT0gYSkge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgYnl0ZXNOZWVkZWQtLTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG4gICAgfVxuXG4gICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5vdG4od2lkdGgpO1xuICB9O1xuXG4gIC8vIFNldCBgYml0YCBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNldG4gPSBmdW5jdGlvbiBzZXRuIChiaXQsIHZhbCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG5cbiAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgdmFyIHdiaXQgPSBiaXQgJSAyNjtcblxuICAgIHRoaXMuX2V4cGFuZChvZmYgKyAxKTtcblxuICAgIGlmICh2YWwpIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSB8ICgxIDw8IHdiaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG4gICAgdmFyIHI7XG5cbiAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhLCBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG4gICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGQobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGEgPiBiXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cbiAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuICAvLyB0byB3b3JrIHdpdGggMjU2LWJpdCBudW1iZXJzLCBvdGhlcndpc2UgaXQgZ2l2ZXMgMjAlIGltcHJvdmVtZW50IGZvciAyNTYtYml0XG4gIC8vIG11bHRpcGxpY2F0aW9uIChsaWtlIGVsbGlwdGljIHNlY3AyNTZrMSkuXG4gIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBhID0gc2VsZi53b3JkcztcbiAgICB2YXIgYiA9IG51bS53b3JkcztcbiAgICB2YXIgbyA9IG91dC53b3JkcztcbiAgICB2YXIgYyA9IDA7XG4gICAgdmFyIGxvO1xuICAgIHZhciBtaWQ7XG4gICAgdmFyIGhpO1xuICAgIHZhciBhMCA9IGFbMF0gfCAwO1xuICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcbiAgICB2YXIgYWgwID0gYTAgPj4+IDEzO1xuICAgIHZhciBhMSA9IGFbMV0gfCAwO1xuICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcbiAgICB2YXIgYWgxID0gYTEgPj4+IDEzO1xuICAgIHZhciBhMiA9IGFbMl0gfCAwO1xuICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcbiAgICB2YXIgYWgyID0gYTIgPj4+IDEzO1xuICAgIHZhciBhMyA9IGFbM10gfCAwO1xuICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcbiAgICB2YXIgYWgzID0gYTMgPj4+IDEzO1xuICAgIHZhciBhNCA9IGFbNF0gfCAwO1xuICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcbiAgICB2YXIgYWg0ID0gYTQgPj4+IDEzO1xuICAgIHZhciBhNSA9IGFbNV0gfCAwO1xuICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcbiAgICB2YXIgYWg1ID0gYTUgPj4+IDEzO1xuICAgIHZhciBhNiA9IGFbNl0gfCAwO1xuICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcbiAgICB2YXIgYWg2ID0gYTYgPj4+IDEzO1xuICAgIHZhciBhNyA9IGFbN10gfCAwO1xuICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcbiAgICB2YXIgYWg3ID0gYTcgPj4+IDEzO1xuICAgIHZhciBhOCA9IGFbOF0gfCAwO1xuICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcbiAgICB2YXIgYWg4ID0gYTggPj4+IDEzO1xuICAgIHZhciBhOSA9IGFbOV0gfCAwO1xuICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcbiAgICB2YXIgYWg5ID0gYTkgPj4+IDEzO1xuICAgIHZhciBiMCA9IGJbMF0gfCAwO1xuICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcbiAgICB2YXIgYmgwID0gYjAgPj4+IDEzO1xuICAgIHZhciBiMSA9IGJbMV0gfCAwO1xuICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcbiAgICB2YXIgYmgxID0gYjEgPj4+IDEzO1xuICAgIHZhciBiMiA9IGJbMl0gfCAwO1xuICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcbiAgICB2YXIgYmgyID0gYjIgPj4+IDEzO1xuICAgIHZhciBiMyA9IGJbM10gfCAwO1xuICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcbiAgICB2YXIgYmgzID0gYjMgPj4+IDEzO1xuICAgIHZhciBiNCA9IGJbNF0gfCAwO1xuICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcbiAgICB2YXIgYmg0ID0gYjQgPj4+IDEzO1xuICAgIHZhciBiNSA9IGJbNV0gfCAwO1xuICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcbiAgICB2YXIgYmg1ID0gYjUgPj4+IDEzO1xuICAgIHZhciBiNiA9IGJbNl0gfCAwO1xuICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcbiAgICB2YXIgYmg2ID0gYjYgPj4+IDEzO1xuICAgIHZhciBiNyA9IGJbN10gfCAwO1xuICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcbiAgICB2YXIgYmg3ID0gYjcgPj4+IDEzO1xuICAgIHZhciBiOCA9IGJbOF0gfCAwO1xuICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcbiAgICB2YXIgYmg4ID0gYjggPj4+IDEzO1xuICAgIHZhciBiOSA9IGJbOV0gfCAwO1xuICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcbiAgICB2YXIgYmg5ID0gYjkgPj4+IDEzO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0gc2VsZi5uZWdhdGl2ZSBeIG51bS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gMTk7XG4gICAgLyogayA9IDAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDAsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMCwgYmgwKTtcbiAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcwID4+PiAyNikpIHwgMDtcbiAgICB3MCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDEsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDEpKSB8IDA7XG4gICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MSA+Pj4gMjYpKSB8IDA7XG4gICAgdzEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwyLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDIsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDIsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcbiAgICB2YXIgdzIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcyID4+PiAyNikpIHwgMDtcbiAgICB3MiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDMsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMykpIHwgMDtcbiAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHczID4+PiAyNikpIHwgMDtcbiAgICB3MyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDQsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDQpKSB8IDA7XG4gICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NCA+Pj4gMjYpKSB8IDA7XG4gICAgdzQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw1LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDUsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDUsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcbiAgICB2YXIgdzUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc1ID4+PiAyNikpIHwgMDtcbiAgICB3NSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDYsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNikpIHwgMDtcbiAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc2ID4+PiAyNikpIHwgMDtcbiAgICB3NiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDcsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNywgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNywgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDcpKSB8IDA7XG4gICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NyA+Pj4gMjYpKSB8IDA7XG4gICAgdzcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw4LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDgsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDgsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcbiAgICB2YXIgdzggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc4ID4+PiAyNikpIHwgMDtcbiAgICB3OCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDkgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc5ID4+PiAyNikpIHwgMDtcbiAgICB3OSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDEpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTAgPj4+IDI2KSkgfCAwO1xuICAgIHcxMCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDExICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDIpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMSA+Pj4gMjYpKSB8IDA7XG4gICAgdzExICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwzKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgzKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTIgPj4+IDI2KSkgfCAwO1xuICAgIHcxMiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDQpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzEzID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTMgPj4+IDI2KSkgfCAwO1xuICAgIHcxMyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDUpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNSk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw2KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg2KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTUgPj4+IDI2KSkgfCAwO1xuICAgIHcxNSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDcpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTYgPj4+IDI2KSkgfCAwO1xuICAgIHcxNiAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDgpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNyA+Pj4gMjYpKSB8IDA7XG4gICAgdzE3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw5KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg5KTtcbiAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTggPj4+IDI2KSkgfCAwO1xuICAgIHcxOCAmPSAweDNmZmZmZmY7XG4gICAgb1swXSA9IHcwO1xuICAgIG9bMV0gPSB3MTtcbiAgICBvWzJdID0gdzI7XG4gICAgb1szXSA9IHczO1xuICAgIG9bNF0gPSB3NDtcbiAgICBvWzVdID0gdzU7XG4gICAgb1s2XSA9IHc2O1xuICAgIG9bN10gPSB3NztcbiAgICBvWzhdID0gdzg7XG4gICAgb1s5XSA9IHc5O1xuICAgIG9bMTBdID0gdzEwO1xuICAgIG9bMTFdID0gdzExO1xuICAgIG9bMTJdID0gdzEyO1xuICAgIG9bMTNdID0gdzEzO1xuICAgIG9bMTRdID0gdzE0O1xuICAgIG9bMTVdID0gdzE1O1xuICAgIG9bMTZdID0gdzE2O1xuICAgIG9bMTddID0gdzE3O1xuICAgIG9bMThdID0gdzE4O1xuICAgIGlmIChjICE9PSAwKSB7XG4gICAgICBvWzE5XSA9IGM7XG4gICAgICBvdXQubGVuZ3RoKys7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG5cbiAgLy8gUG9seWZpbGwgY29tYlxuICBpZiAoIU1hdGguaW11bCkge1xuICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpZ011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aDtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgdmFyIGhuY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0Lmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBobmNhcnJ5O1xuICAgICAgaG5jYXJyeSA9IDA7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IGsgLSBqO1xuICAgICAgICB2YXIgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICB2YXIgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHZhciByID0gYSAqIGI7XG5cbiAgICAgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArICgociAvIDB4NDAwMDAwMCkgfCAwKSkgfCAwO1xuICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAobG8gPj4+IDI2KSkgfCAwO1xuXG4gICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcbiAgICAgICAgbmNhcnJ5ICY9IDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuICAgICAgY2FycnkgPSBuY2Fycnk7XG4gICAgICBuY2FycnkgPSBobmNhcnJ5O1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gICAgcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG4gIH1cblxuICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCArIG51bS5sZW5ndGg7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuICAgICAgcmVzID0gY29tYjEwTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgNjMpIHtcbiAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAyNCkge1xuICAgICAgcmVzID0gYmlnTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvb2xleS1UdWtleSBhbGdvcml0aG0gZm9yIEZGVFxuICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cbiAgZnVuY3Rpb24gRkZUTSAoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIEZGVE0ucHJvdG90eXBlLm1ha2VSQlQgPSBmdW5jdGlvbiBtYWtlUkJUIChOKSB7XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGwgPSBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyhOKSAtIDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGJpbmFyeS1yZXZlcnNlZCByZXByZXNlbnRhdGlvbiBvZiBgeGBcbiAgRkZUTS5wcm90b3R5cGUucmV2QmluID0gZnVuY3Rpb24gcmV2QmluICh4LCBsLCBOKSB7XG4gICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG4gICAgdmFyIHJiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcbiAgICAgIHggPj49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJiO1xuICB9O1xuXG4gIC8vIFBlcmZvcm1zIFwidHdlZWRsaW5nXCIgcGhhc2UsIHRoZXJlZm9yZSAnZW11bGF0aW5nJ1xuICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cbiAgRkZUTS5wcm90b3R5cGUucGVybXV0ZSA9IGZ1bmN0aW9uIHBlcm11dGUgKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuICAgICAgaXR3c1tpXSA9IGl3c1tyYnRbaV1dO1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOLCByYnQpIHtcbiAgICB0aGlzLnBlcm11dGUocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTik7XG5cbiAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcbiAgICAgIHZhciBsID0gcyA8PCAxO1xuXG4gICAgICB2YXIgcnR3ZGYgPSBNYXRoLmNvcygyICogTWF0aC5QSSAvIGwpO1xuICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBOOyBwICs9IGwpIHtcbiAgICAgICAgdmFyIHJ0d2RmXyA9IHJ0d2RmO1xuICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmUgPSBydHdzW3AgKyBqXTtcbiAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuICAgICAgICAgIHZhciBybyA9IHJ0d3NbcCArIGogKyBzXTtcbiAgICAgICAgICB2YXIgaW8gPSBpdHdzW3AgKyBqICsgc107XG5cbiAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG4gICAgICAgICAgaW8gPSBydHdkZl8gKiBpbyArIGl0d2RmXyAqIHJvO1xuICAgICAgICAgIHJvID0gcng7XG5cbiAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG4gICAgICAgICAgaXR3c1twICsgal0gPSBpZSArIGlvO1xuXG4gICAgICAgICAgcnR3c1twICsgaiArIHNdID0gcmUgLSBybztcbiAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG4gICAgICAgICAgLyoganNoaW50IG1heGRlcHRoIDogZmFsc2UgKi9cbiAgICAgICAgICBpZiAoaiAhPT0gbCkge1xuICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG4gICAgICAgICAgICBpdHdkZl8gPSBydHdkZiAqIGl0d2RmXyArIGl0d2RmICogcnR3ZGZfO1xuICAgICAgICAgICAgcnR3ZGZfID0gcng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmd1ZXNzTGVuMTNiID0gZnVuY3Rpb24gZ3Vlc3NMZW4xM2IgKG4sIG0pIHtcbiAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcbiAgICB2YXIgb2RkID0gTiAmIDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiBjb25qdWdhdGUgKHJ3cywgaXdzLCBOKSB7XG4gICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJ3c1tpXTtcblxuICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG4gICAgICByd3NbTiAtIGkgLSAxXSA9IHQ7XG5cbiAgICAgIHQgPSBpd3NbaV07XG5cbiAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcbiAgICAgIGl3c1tOIC0gaSAtIDFdID0gLXQ7XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm5vcm1hbGl6ZTEzYiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZTEzYiAod3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHcgPSBNYXRoLnJvdW5kKHdzWzIgKiBpICsgMV0gLyBOKSAqIDB4MjAwMCArXG4gICAgICAgIE1hdGgucm91bmQod3NbMiAqIGldIC8gTikgK1xuICAgICAgICBjYXJyeTtcblxuICAgICAgd3NbaV0gPSB3ICYgMHgzZmZmZmZmO1xuXG4gICAgICBpZiAodyA8IDB4NDAwMDAwMCkge1xuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHcgLyAweDQwMDAwMDAgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cztcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5jb252ZXJ0MTNiID0gZnVuY3Rpb24gY29udmVydDEzYiAod3MsIGxlbiwgcndzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYXJyeSA9IGNhcnJ5ICsgKHdzW2ldIHwgMCk7XG5cbiAgICAgIHJ3c1syICogaV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICB9XG5cbiAgICAvLyBQYWQgd2l0aCB6ZXJvZXNcbiAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG4gICAgICByd3NbaV0gPSAwO1xuICAgIH1cblxuICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG4gICAgYXNzZXJ0KChjYXJyeSAmIH4weDFmZmYpID09PSAwKTtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuICAgIHZhciBwaCA9IG5ldyBBcnJheShOKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgcGhbaV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwaDtcbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5tdWxwID0gZnVuY3Rpb24gbXVscCAoeCwgeSwgb3V0KSB7XG4gICAgdmFyIE4gPSAyICogdGhpcy5ndWVzc0xlbjEzYih4Lmxlbmd0aCwgeS5sZW5ndGgpO1xuXG4gICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuICAgIHZhciBfID0gdGhpcy5zdHViKE4pO1xuXG4gICAgdmFyIHJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBucndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbml3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgcm13cyA9IG91dC53b3JkcztcbiAgICBybXdzLmxlbmd0aCA9IE47XG5cbiAgICB0aGlzLmNvbnZlcnQxM2IoeC53b3JkcywgeC5sZW5ndGgsIHJ3cywgTik7XG4gICAgdGhpcy5jb252ZXJ0MTNiKHkud29yZHMsIHkubGVuZ3RoLCBucndzLCBOKTtcblxuICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShucndzLCBfLCBucndzdCwgbml3c3QsIE4sIHJidCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuICAgICAgaXdzdFtpXSA9IHJ3c3RbaV0gKiBuaXdzdFtpXSArIGl3c3RbaV0gKiBucndzdFtpXTtcbiAgICAgIHJ3c3RbaV0gPSByeDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZShyd3N0LCBpd3N0LCBOKTtcbiAgICB0aGlzLnRyYW5zZm9ybShyd3N0LCBpd3N0LCBybXdzLCBfLCBOLCByYnQpO1xuICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuICAgIHRoaXMubm9ybWFsaXplMTNiKHJtd3MsIE4pO1xuXG4gICAgb3V0Lm5lZ2F0aXZlID0geC5uZWdhdGl2ZSBeIHkubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG4gIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbiAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cbiAgICAvLyBDYXJyeVxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKiBudW07XG4gICAgICB2YXIgbG8gPSAodyAmIDB4M2ZmZmZmZikgKyAoY2FycnkgJiAweDNmZmZmZmYpO1xuICAgICAgY2FycnkgPj49IDI2O1xuICAgICAgY2FycnkgKz0gKHcgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgIC8vIE5PVEU6IGxvIGlzIDI3Yml0IG1heGltdW1cbiAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gIH07XG5cbiAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcbiAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG4gICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICAgIHZhciByZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbiAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgaDtcbiAgICBpZiAoaGludCkge1xuICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgICBoIC09IHM7XG4gICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG4gICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcbiAgICB9XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgIH1cblxuICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uIGlzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNocm4oYml0cywgaGludCwgZXh0ZW5kZWQpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnRcbiAgQk4ucHJvdG90eXBlLnNobG4gPSBmdW5jdGlvbiBzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNobG4gPSBmdW5jdGlvbiB1c2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0XG4gIEJOLnByb3RvdHlwZS5zaHJuID0gZnVuY3Rpb24gc2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaHJuID0gZnVuY3Rpb24gdXNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcbiAgfTtcblxuICAvLyBUZXN0IGlmIG4gYml0IGlzIHNldFxuICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBiaXQgYW5kIHJldHVyblxuICAgIHZhciB3ID0gdGhpcy53b3Jkc1tzXTtcblxuICAgIHJldHVybiAhISh3ICYgcSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyIChpbi1wbGFjZSlcbiAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAnaW1hc2tuIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZSBudW1iZXJzJyk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLnN0cmlwKCk7XG4gICAgfVxuICAgIGEuc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IHIyID09PSAxICYmIGNtcCA9PT0gMCkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICByLnN0cmlwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiIsInZhciByO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJhbmQobGVuKSB7XG4gIGlmICghcilcbiAgICByID0gbmV3IFJhbmQobnVsbCk7XG5cbiAgcmV0dXJuIHIuZ2VuZXJhdGUobGVuKTtcbn07XG5cbmZ1bmN0aW9uIFJhbmQocmFuZCkge1xuICB0aGlzLnJhbmQgPSByYW5kO1xufVxubW9kdWxlLmV4cG9ydHMuUmFuZCA9IFJhbmQ7XG5cblJhbmQucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuKSB7XG4gIHJldHVybiB0aGlzLl9yYW5kKGxlbik7XG59O1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgaWYgKHdpbmRvdy5jcnlwdG8gJiYgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlcnNcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93Lm1zQ3J5cHRvICYmIHdpbmRvdy5tc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBJRVxuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIE9sZCBqdW5rXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH07XG4gIH1cbn0gZWxzZSB7XG4gIC8vIE5vZGUuanMgb3IgV2ViIHdvcmtlclxuICB0cnkge1xuICAgIHZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnknICsgJ3B0bycpO1xuXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKG4pO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBFbXVsYXRlIGNyeXB0byBBUEkgdXNpbmcgcmFuZHlcbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHZhciByZXMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXNbaV0gPSB0aGlzLnJhbmQuZ2V0Qnl0ZSgpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICB9XG59XG4iLCJ2YXIgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG52YXIgYmFzZTU4ID0gYmFzZXgoQUxQSEFCRVQpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGU6IGJhc2U1OC5lbmNvZGUsXG4gIGRlY29kZTogYmFzZTU4LmRlY29kZVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5lbGxpcHRpYy52ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmVsbGlwdGljLnV0aWxzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy91dGlscycpO1xuZWxsaXB0aWMucmFuZCA9IHJlcXVpcmUoJ2Jyb3JhbmQnKTtcbmVsbGlwdGljLmhtYWNEUkJHID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9obWFjLWRyYmcnKTtcbmVsbGlwdGljLmN1cnZlID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZScpO1xuZWxsaXB0aWMuY3VydmVzID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9jdXJ2ZXMnKTtcblxuLy8gUHJvdG9jb2xzXG5lbGxpcHRpYy5lYyA9IHJlcXVpcmUoJy4vZWxsaXB0aWMvZWMnKTtcbmVsbGlwdGljLmVkZHNhID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9lZGRzYScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGdldE5BRiA9IHV0aWxzLmdldE5BRjtcbnZhciBnZXRKU0YgPSB1dGlscy5nZXRKU0Y7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnAgPSBuZXcgQk4oY29uZi5wLCAxNik7XG5cbiAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuICB0aGlzLnJlZCA9IGNvbmYucHJpbWUgPyBCTi5yZWQoY29uZi5wcmltZSkgOiBCTi5tb250KHRoaXMucCk7XG5cbiAgLy8gVXNlZnVsIGZvciBtYW55IGN1cnZlc1xuICB0aGlzLnplcm8gPSBuZXcgQk4oMCkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLm9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuICB0aGlzLm4gPSBjb25mLm4gJiYgbmV3IEJOKGNvbmYubiwgMTYpO1xuICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcblxuICAvLyBUZW1wb3JhcnkgYXJyYXlzXG4gIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KTtcblxuICAvLyBHZW5lcmFsaXplZCBHcmVnIE1heHdlbGwncyB0cmlja1xuICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcbiAgICB0aGlzLnJlZE4gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG4gICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBCYXNlQ3VydmU7XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcbiAgYXNzZXJ0KHAucHJlY29tcHV0ZWQpO1xuICB2YXIgZG91YmxlcyA9IHAuX2dldERvdWJsZXMoKTtcblxuICB2YXIgbmFmID0gZ2V0TkFGKGssIDEpO1xuICB2YXIgSSA9ICgxIDw8IChkb3VibGVzLnN0ZXAgKyAxKSkgLSAoZG91Ymxlcy5zdGVwICUgMiA9PT0gMCA/IDIgOiAxKTtcbiAgSSAvPSAzO1xuXG4gIC8vIFRyYW5zbGF0ZSBpbnRvIG1vcmUgd2luZG93ZWQgZm9ybVxuICB2YXIgcmVwciA9IFtdO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IG5hZi5sZW5ndGg7IGogKz0gZG91Ymxlcy5zdGVwKSB7XG4gICAgdmFyIG5hZlcgPSAwO1xuICAgIGZvciAodmFyIGsgPSBqICsgZG91Ymxlcy5zdGVwIC0gMTsgayA+PSBqOyBrLS0pXG4gICAgICBuYWZXID0gKG5hZlcgPDwgMSkgKyBuYWZba107XG4gICAgcmVwci5wdXNoKG5hZlcpO1xuICB9XG5cbiAgdmFyIGEgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIGIgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IEk7IGkgPiAwOyBpLS0pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuYWZXID0gcmVwcltqXTtcbiAgICAgIGlmIChuYWZXID09PSBpKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXSk7XG4gICAgICBlbHNlIGlmIChuYWZXID09PSAtaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0ubmVnKCkpO1xuICAgIH1cbiAgICBhID0gYS5hZGQoYik7XG4gIH1cbiAgcmV0dXJuIGEudG9QKCk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsID0gZnVuY3Rpb24gX3duYWZNdWwocCwgaykge1xuICB2YXIgdyA9IDQ7XG5cbiAgLy8gUHJlY29tcHV0ZSB3aW5kb3dcbiAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyh3KTtcbiAgdyA9IG5hZlBvaW50cy53bmQ7XG4gIHZhciB3bmQgPSBuYWZQb2ludHMucG9pbnRzO1xuXG4gIC8vIEdldCBOQUYgZm9ybVxuICB2YXIgbmFmID0gZ2V0TkFGKGssIHcpO1xuXG4gIC8vIEFkZCBgdGhpc2AqKE4rMSkgZm9yIGV2ZXJ5IHctTkFGIGluZGV4XG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IG5hZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIC8vIENvdW50IHplcm9lc1xuICAgIGZvciAodmFyIGsgPSAwOyBpID49IDAgJiYgbmFmW2ldID09PSAwOyBpLS0pXG4gICAgICBrKys7XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcblxuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuICAgIHZhciB6ID0gbmFmW2ldO1xuICAgIGFzc2VydCh6ICE9PSAwKTtcbiAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJykge1xuICAgICAgLy8gSiArLSBQXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKICstIEpcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHAudHlwZSA9PT0gJ2FmZmluZScgPyBhY2MudG9QKCkgOiBhY2M7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkID0gZnVuY3Rpb24gX3duYWZNdWxBZGQoZGVmVyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYWNvYmlhblJlc3VsdCkge1xuICB2YXIgd25kV2lkdGggPSB0aGlzLl93bmFmVDE7XG4gIHZhciB3bmQgPSB0aGlzLl93bmFmVDI7XG4gIHZhciBuYWYgPSB0aGlzLl93bmFmVDM7XG5cbiAgLy8gRmlsbCBhbGwgYXJyYXlzXG4gIHZhciBtYXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyhkZWZXKTtcbiAgICB3bmRXaWR0aFtpXSA9IG5hZlBvaW50cy53bmQ7XG4gICAgd25kW2ldID0gbmFmUG9pbnRzLnBvaW50cztcbiAgfVxuXG4gIC8vIENvbWIgc21hbGwgd2luZG93IE5BRnNcbiAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMTsgaSAtPSAyKSB7XG4gICAgdmFyIGEgPSBpIC0gMTtcbiAgICB2YXIgYiA9IGk7XG4gICAgaWYgKHduZFdpZHRoW2FdICE9PSAxIHx8IHduZFdpZHRoW2JdICE9PSAxKSB7XG4gICAgICBuYWZbYV0gPSBnZXROQUYoY29lZmZzW2FdLCB3bmRXaWR0aFthXSk7XG4gICAgICBuYWZbYl0gPSBnZXROQUYoY29lZmZzW2JdLCB3bmRXaWR0aFtiXSk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYV0ubGVuZ3RoLCBtYXgpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2JdLmxlbmd0aCwgbWF4KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjb21iID0gW1xuICAgICAgcG9pbnRzW2FdLCAvKiAxICovXG4gICAgICBudWxsLCAvKiAzICovXG4gICAgICBudWxsLCAvKiA1ICovXG4gICAgICBwb2ludHNbYl0gLyogNyAqL1xuICAgIF07XG5cbiAgICAvLyBUcnkgdG8gYXZvaWQgUHJvamVjdGl2ZSBwb2ludHMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkucmVkTmVnKCkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gW1xuICAgICAgLTMsIC8qIC0xIC0xICovXG4gICAgICAtMSwgLyogLTEgMCAqL1xuICAgICAgLTUsIC8qIC0xIDEgKi9cbiAgICAgIC03LCAvKiAwIC0xICovXG4gICAgICAwLCAvKiAwIDAgKi9cbiAgICAgIDcsIC8qIDAgMSAqL1xuICAgICAgNSwgLyogMSAtMSAqL1xuICAgICAgMSwgLyogMSAwICovXG4gICAgICAzICAvKiAxIDEgKi9cbiAgICBdO1xuXG4gICAgdmFyIGpzZiA9IGdldEpTRihjb2VmZnNbYV0sIGNvZWZmc1tiXSk7XG4gICAgbWF4ID0gTWF0aC5tYXgoanNmWzBdLmxlbmd0aCwgbWF4KTtcbiAgICBuYWZbYV0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBuYWZbYl0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1heDsgaisrKSB7XG4gICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuICAgICAgdmFyIGpiID0ganNmWzFdW2pdIHwgMDtcblxuICAgICAgbmFmW2FdW2pdID0gaW5kZXhbKGphICsgMSkgKiAzICsgKGpiICsgMSldO1xuICAgICAgbmFmW2JdW2pdID0gMDtcbiAgICAgIHduZFthXSA9IGNvbWI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgdG1wID0gdGhpcy5fd25hZlQ0O1xuICBmb3IgKHZhciBpID0gbWF4OyBpID49IDA7IGktLSkge1xuICAgIHZhciBrID0gMDtcblxuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIHZhciB6ZXJvID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgdG1wW2pdID0gbmFmW2pdW2ldIHwgMDtcbiAgICAgICAgaWYgKHRtcFtqXSAhPT0gMClcbiAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXplcm8pXG4gICAgICAgIGJyZWFrO1xuICAgICAgaysrO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoaSA+PSAwKVxuICAgICAgaysrO1xuICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHogPSB0bXBbal07XG4gICAgICB2YXIgcDtcbiAgICAgIGlmICh6ID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGVsc2UgaWYgKHogPiAwKVxuICAgICAgICBwID0gd25kW2pdWyh6IC0gMSkgPj4gMV07XG4gICAgICBlbHNlIGlmICh6IDwgMClcbiAgICAgICAgcCA9IHduZFtqXVsoLXogLSAxKSA+PiAxXS5uZWcoKTtcblxuICAgICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZChwKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICB9XG4gIH1cbiAgLy8gWmVyb2lmeSByZWZlcmVuY2VzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgd25kW2ldID0gbnVsbDtcblxuICBpZiAoamFjb2JpYW5SZXN1bHQpXG4gICAgcmV0dXJuIGFjYztcbiAgZWxzZVxuICAgIHJldHVybiBhY2MudG9QKCk7XG59O1xuXG5mdW5jdGlvbiBCYXNlUG9pbnQoY3VydmUsIHR5cGUpIHtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZWNvbXB1dGVkID0gbnVsbDtcbn1cbkJhc2VDdXJ2ZS5CYXNlUG9pbnQgPSBCYXNlUG9pbnQ7XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSgvKm90aGVyKi8pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICBieXRlcyA9IHV0aWxzLnRvQXJyYXkoYnl0ZXMsIGVuYyk7XG5cbiAgdmFyIGxlbiA9IHRoaXMucC5ieXRlTGVuZ3RoKCk7XG5cbiAgLy8gdW5jb21wcmVzc2VkLCBoeWJyaWQtb2RkLCBoeWJyaWQtZXZlblxuICBpZiAoKGJ5dGVzWzBdID09PSAweDA0IHx8IGJ5dGVzWzBdID09PSAweDA2IHx8IGJ5dGVzWzBdID09PSAweDA3KSAmJlxuICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gMiAqIGxlbikge1xuICAgIGlmIChieXRlc1swXSA9PT0gMHgwNilcbiAgICAgIGFzc2VydChieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDApO1xuICAgIGVsc2UgaWYgKGJ5dGVzWzBdID09PSAweDA3KVxuICAgICAgYXNzZXJ0KGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG5cbiAgICB2YXIgcmVzID0gIHRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLnNsaWNlKDEgKyBsZW4sIDEgKyAyICogbGVuKSk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKChieXRlc1swXSA9PT0gMHgwMiB8fCBieXRlc1swXSA9PT0gMHgwMykgJiZcbiAgICAgICAgICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRGcm9tWChieXRlcy5zbGljZSgxLCAxICsgbGVuKSwgYnl0ZXNbMF0gPT09IDB4MDMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwb2ludCBmb3JtYXQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIGVuY29kZUNvbXByZXNzZWQoZW5jKSB7XG4gIHJldHVybiB0aGlzLmVuY29kZShlbmMsIHRydWUpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZShjb21wYWN0KSB7XG4gIHZhciBsZW4gPSB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO1xuICB2YXIgeCA9IHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgbGVuKTtcblxuICBpZiAoY29tcGFjdClcbiAgICByZXR1cm4gWyB0aGlzLmdldFkoKS5pc0V2ZW4oKSA/IDB4MDIgOiAweDAzIF0uY29uY2F0KHgpO1xuXG4gIHJldHVybiBbIDB4MDQgXS5jb25jYXQoeCwgdGhpcy5nZXRZKCkudG9BcnJheSgnYmUnLCBsZW4pKSA7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShlbmMsIGNvbXBhY3QpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLl9lbmNvZGUoY29tcGFjdCksIGVuYyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciBwcmVjb21wdXRlZCA9IHtcbiAgICBkb3VibGVzOiBudWxsLFxuICAgIG5hZjogbnVsbCxcbiAgICBiZXRhOiBudWxsXG4gIH07XG4gIHByZWNvbXB1dGVkLm5hZiA9IHRoaXMuX2dldE5BRlBvaW50cyg4KTtcbiAgcHJlY29tcHV0ZWQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgcG93ZXIpO1xuICBwcmVjb21wdXRlZC5iZXRhID0gdGhpcy5fZ2V0QmV0YSgpO1xuICB0aGlzLnByZWNvbXB1dGVkID0gcHJlY29tcHV0ZWQ7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9oYXNEb3VibGVzID0gZnVuY3Rpb24gX2hhc0RvdWJsZXMoaykge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkb3VibGVzID0gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuICBpZiAoIWRvdWJsZXMpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBkb3VibGVzLnBvaW50cy5sZW5ndGggPj0gTWF0aC5jZWlsKChrLmJpdExlbmd0aCgpICsgMSkgLyBkb3VibGVzLnN0ZXApO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0RG91YmxlcyA9IGZ1bmN0aW9uIF9nZXREb3VibGVzKHN0ZXAsIHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcylcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuXG4gIHZhciBkb3VibGVzID0gWyB0aGlzIF07XG4gIHZhciBhY2MgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvd2VyOyBpICs9IHN0ZXApIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXA7IGorKylcbiAgICAgIGFjYyA9IGFjYy5kYmwoKTtcbiAgICBkb3VibGVzLnB1c2goYWNjKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0ZXA6IHN0ZXAsXG4gICAgcG9pbnRzOiBkb3VibGVzXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG5cbiAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuICB2YXIgbWF4ID0gKDEgPDwgd25kKSAtIDE7XG4gIHZhciBkYmwgPSBtYXggPT09IDEgPyBudWxsIDogdGhpcy5kYmwoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcbiAgICByZXNbaV0gPSByZXNbaSAtIDFdLmFkZChkYmwpO1xuICByZXR1cm4ge1xuICAgIHduZDogd25kLFxuICAgIHBvaW50czogcmVzXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChrKSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspXG4gICAgciA9IHIuZGJsKCk7XG4gIHJldHVybiByO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY3VydmUnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gY3VydmUuYmFzZTtcblxudmFyIGFzc2VydCA9IGVsbGlwdGljLnV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gRWR3YXJkc0N1cnZlKGNvbmYpIHtcbiAgLy8gTk9URTogSW1wb3J0YW50IGFzIHdlIGFyZSBjcmVhdGluZyBwb2ludCBpbiBCYXNlLmNhbGwoKVxuICB0aGlzLnR3aXN0ZWQgPSAoY29uZi5hIHwgMCkgIT09IDE7XG4gIHRoaXMubU9uZUEgPSB0aGlzLnR3aXN0ZWQgJiYgKGNvbmYuYSB8IDApID09PSAtMTtcbiAgdGhpcy5leHRlbmRlZCA9IHRoaXMubU9uZUE7XG5cbiAgQmFzZS5jYWxsKHRoaXMsICdlZHdhcmRzJywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnVtb2QodGhpcy5yZWQubSk7XG4gIHRoaXMuYSA9IHRoaXMuYS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYyA9IG5ldyBCTihjb25mLmMsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYzIgPSB0aGlzLmMucmVkU3FyKCk7XG4gIHRoaXMuZCA9IG5ldyBCTihjb25mLmQsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuZGQgPSB0aGlzLmQucmVkQWRkKHRoaXMuZCk7XG5cbiAgYXNzZXJ0KCF0aGlzLnR3aXN0ZWQgfHwgdGhpcy5jLmZyb21SZWQoKS5jbXBuKDEpID09PSAwKTtcbiAgdGhpcy5vbmVDID0gKGNvbmYuYyB8IDApID09PSAxO1xufVxuaW5oZXJpdHMoRWR3YXJkc0N1cnZlLCBCYXNlKTtcbm1vZHVsZS5leHBvcnRzID0gRWR3YXJkc0N1cnZlO1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLl9tdWxBID0gZnVuY3Rpb24gX211bEEobnVtKSB7XG4gIGlmICh0aGlzLm1PbmVBKVxuICAgIHJldHVybiBudW0ucmVkTmVnKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5hLnJlZE11bChudW0pO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5fbXVsQyA9IGZ1bmN0aW9uIF9tdWxDKG51bSkge1xuICBpZiAodGhpcy5vbmVDKVxuICAgIHJldHVybiBudW07XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jLnJlZE11bChudW0pO1xufTtcblxuLy8gSnVzdCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIFNob3J0IGN1cnZlXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6LCB0KSB7XG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHksIHosIHQpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgeCA9IG5ldyBCTih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZFN1Yih0aGlzLmEucmVkTXVsKHgyKSk7XG4gIHZhciBsaHMgPSB0aGlzLm9uZS5yZWRTdWIodGhpcy5jMi5yZWRNdWwodGhpcy5kKS5yZWRNdWwoeDIpKTtcblxuICB2YXIgeTIgPSByaHMucmVkTXVsKGxocy5yZWRJbnZtKCkpO1xuICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcbiAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21ZID0gZnVuY3Rpb24gcG9pbnRGcm9tWSh5LCBvZGQpIHtcbiAgeSA9IG5ldyBCTih5LCAxNik7XG4gIGlmICgheS5yZWQpXG4gICAgeSA9IHkudG9SZWQodGhpcy5yZWQpO1xuXG4gIC8vIHheMiA9ICh5XjIgLSAxKSAvIChkIHleMiArIDEpXG4gIHZhciB5MiA9IHkucmVkU3FyKCk7XG4gIHZhciBsaHMgPSB5Mi5yZWRTdWIodGhpcy5vbmUpO1xuICB2YXIgcmhzID0geTIucmVkTXVsKHRoaXMuZCkucmVkQWRkKHRoaXMub25lKTtcbiAgdmFyIHgyID0gbGhzLnJlZE11bChyaHMucmVkSW52bSgpKTtcblxuICBpZiAoeDIuY21wKHRoaXMuemVybykgPT09IDApIHtcbiAgICBpZiAob2RkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMucG9pbnQodGhpcy56ZXJvLCB5KTtcbiAgfVxuXG4gIHZhciB4ID0geDIucmVkU3FydCgpO1xuICBpZiAoeC5yZWRTcXIoKS5yZWRTdWIoeDIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIGlmICh4LmlzT2RkKCkgIT09IG9kZClcbiAgICB4ID0geC5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIEN1cnZlOiBBICogWF4yICsgWV4yID0gQ14yICogKDEgKyBEICogWF4yICogWV4yKVxuICBwb2ludC5ub3JtYWxpemUoKTtcblxuICB2YXIgeDIgPSBwb2ludC54LnJlZFNxcigpO1xuICB2YXIgeTIgPSBwb2ludC55LnJlZFNxcigpO1xuICB2YXIgbGhzID0geDIucmVkTXVsKHRoaXMuYSkucmVkQWRkKHkyKTtcbiAgdmFyIHJocyA9IHRoaXMuYzIucmVkTXVsKHRoaXMub25lLnJlZEFkZCh0aGlzLmQucmVkTXVsKHgyKS5yZWRNdWwoeTIpKSk7XG5cbiAgcmV0dXJuIGxocy5jbXAocmhzKSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCB6LCB0KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUuemVybztcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnQgPSB0aGlzLmN1cnZlLnplcm87XG4gICAgdGhpcy56T25lID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgdGhpcy56ID0geiA/IG5ldyBCTih6LCAxNikgOiB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnQgPSB0ICYmIG5ldyBCTih0LCAxNik7XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMueS5yZWQpXG4gICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy56LnJlZClcbiAgICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKHRoaXMudCAmJiAhdGhpcy50LnJlZClcbiAgICAgIHRoaXMudCA9IHRoaXMudC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcblxuICAgIC8vIFVzZSBleHRlbmRlZCBjb29yZGluYXRlc1xuICAgIGlmICh0aGlzLmN1cnZlLmV4dGVuZGVkICYmICF0aGlzLnQpIHtcbiAgICAgIHRoaXMudCA9IHRoaXMueC5yZWRNdWwodGhpcy55KTtcbiAgICAgIGlmICghdGhpcy56T25lKVxuICAgICAgICB0aGlzLnQgPSB0aGlzLnQucmVkTXVsKHRoaXMuei5yZWRJbnZtKCkpO1xuICAgIH1cbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmopIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaik7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgeiwgdCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIHosIHQpO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdLCBvYmpbMl0pO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy54LmNtcG4oMCkgPT09IDAgJiZcbiAgICAgICAgIHRoaXMueS5jbXAodGhpcy56KSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZXh0RGJsID0gZnVuY3Rpb24gX2V4dERibCgpIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDgtaHdjZFxuICAvLyA0TSArIDRTXG5cbiAgLy8gQSA9IFgxXjJcbiAgdmFyIGEgPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIEIgPSBZMV4yXG4gIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAvLyBDID0gMiAqIFoxXjJcbiAgdmFyIGMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIGMgPSBjLnJlZElBZGQoYyk7XG4gIC8vIEQgPSBhICogQVxuICB2YXIgZCA9IHRoaXMuY3VydmUuX211bEEoYSk7XG4gIC8vIEUgPSAoWDEgKyBZMSleMiAtIEEgLSBCXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihiKTtcbiAgLy8gRyA9IEQgKyBCXG4gIHZhciBnID0gZC5yZWRBZGQoYik7XG4gIC8vIEYgPSBHIC0gQ1xuICB2YXIgZiA9IGcucmVkU3ViKGMpO1xuICAvLyBIID0gRCAtIEJcbiAgdmFyIGggPSBkLnJlZFN1YihiKTtcbiAgLy8gWDMgPSBFICogRlxuICB2YXIgbnggPSBlLnJlZE11bChmKTtcbiAgLy8gWTMgPSBHICogSFxuICB2YXIgbnkgPSBnLnJlZE11bChoKTtcbiAgLy8gVDMgPSBFICogSFxuICB2YXIgbnQgPSBlLnJlZE11bChoKTtcbiAgLy8gWjMgPSBGICogR1xuICB2YXIgbnogPSBmLnJlZE11bChnKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueiwgbnQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9wcm9qRGJsID0gZnVuY3Rpb24gX3Byb2pEYmwoKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLXByb2plY3RpdmUuaHRtbFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA4LWJiamxwXG4gIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDctYmxcbiAgLy8gYW5kIG90aGVyc1xuICAvLyBHZW5lcmFsbHkgM00gKyA0UyBvciAyTSArIDRTXG5cbiAgLy8gQiA9IChYMSArIFkxKV4yXG4gIHZhciBiID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZFNxcigpO1xuICAvLyBDID0gWDFeMlxuICB2YXIgYyA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gRCA9IFkxXjJcbiAgdmFyIGQgPSB0aGlzLnkucmVkU3FyKCk7XG5cbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIC8vIEUgPSBhICogQ1xuICAgIHZhciBlID0gdGhpcy5jdXJ2ZS5fbXVsQShjKTtcbiAgICAvLyBGID0gRSArIERcbiAgICB2YXIgZiA9IGUucmVkQWRkKGQpO1xuICAgIGlmICh0aGlzLnpPbmUpIHtcbiAgICAgIC8vIFgzID0gKEIgLSBDIC0gRCkgKiAoRiAtIDIpXG4gICAgICBueCA9IGIucmVkU3ViKGMpLnJlZFN1YihkKS5yZWRNdWwoZi5yZWRTdWIodGhpcy5jdXJ2ZS50d28pKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGXjIgLSAyICogRlxuICAgICAgbnogPSBmLnJlZFNxcigpLnJlZFN1YihmKS5yZWRTdWIoZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEggPSBaMV4yXG4gICAgICB2YXIgaCA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICAgIC8vIEogPSBGIC0gMiAqIEhcbiAgICAgIHZhciBqID0gZi5yZWRTdWIoaCkucmVkSVN1YihoKTtcbiAgICAgIC8vIFgzID0gKEItQy1EKSpKXG4gICAgICBueCA9IGIucmVkU3ViKGMpLnJlZElTdWIoZCkucmVkTXVsKGopO1xuICAgICAgLy8gWTMgPSBGICogKEUgLSBEKVxuICAgICAgbnkgPSBmLnJlZE11bChlLnJlZFN1YihkKSk7XG4gICAgICAvLyBaMyA9IEYgKiBKXG4gICAgICBueiA9IGYucmVkTXVsKGopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBFID0gQyArIERcbiAgICB2YXIgZSA9IGMucmVkQWRkKGQpO1xuICAgIC8vIEggPSAoYyAqIFoxKV4yXG4gICAgdmFyIGggPSB0aGlzLmN1cnZlLl9tdWxDKHRoaXMuYy5yZWRNdWwodGhpcy56KSkucmVkU3FyKCk7XG4gICAgLy8gSiA9IEUgLSAyICogSFxuICAgIHZhciBqID0gZS5yZWRTdWIoaCkucmVkU3ViKGgpO1xuICAgIC8vIFgzID0gYyAqIChCIC0gRSkgKiBKXG4gICAgbnggPSB0aGlzLmN1cnZlLl9tdWxDKGIucmVkSVN1YihlKSkucmVkTXVsKGopO1xuICAgIC8vIFkzID0gYyAqIEUgKiAoQyAtIEQpXG4gICAgbnkgPSB0aGlzLmN1cnZlLl9tdWxDKGUpLnJlZE11bChjLnJlZElTdWIoZCkpO1xuICAgIC8vIFozID0gRSAqIEpcbiAgICBueiA9IGUucmVkTXVsKGopO1xuICB9XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnopO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIERvdWJsZSBpbiBleHRlbmRlZCBjb29yZGluYXRlc1xuICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZClcbiAgICByZXR1cm4gdGhpcy5fZXh0RGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fcHJvakRibCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9leHRBZGQgPSBmdW5jdGlvbiBfZXh0QWRkKHApIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDgtaHdjZC0zXG4gIC8vIDhNXG5cbiAgLy8gQSA9IChZMSAtIFgxKSAqIChZMiAtIFgyKVxuICB2YXIgYSA9IHRoaXMueS5yZWRTdWIodGhpcy54KS5yZWRNdWwocC55LnJlZFN1YihwLngpKTtcbiAgLy8gQiA9IChZMSArIFgxKSAqIChZMiArIFgyKVxuICB2YXIgYiA9IHRoaXMueS5yZWRBZGQodGhpcy54KS5yZWRNdWwocC55LnJlZEFkZChwLngpKTtcbiAgLy8gQyA9IFQxICogayAqIFQyXG4gIHZhciBjID0gdGhpcy50LnJlZE11bCh0aGlzLmN1cnZlLmRkKS5yZWRNdWwocC50KTtcbiAgLy8gRCA9IFoxICogMiAqIFoyXG4gIHZhciBkID0gdGhpcy56LnJlZE11bChwLnoucmVkQWRkKHAueikpO1xuICAvLyBFID0gQiAtIEFcbiAgdmFyIGUgPSBiLnJlZFN1YihhKTtcbiAgLy8gRiA9IEQgLSBDXG4gIHZhciBmID0gZC5yZWRTdWIoYyk7XG4gIC8vIEcgPSBEICsgQ1xuICB2YXIgZyA9IGQucmVkQWRkKGMpO1xuICAvLyBIID0gQiArIEFcbiAgdmFyIGggPSBiLnJlZEFkZChhKTtcbiAgLy8gWDMgPSBFICogRlxuICB2YXIgbnggPSBlLnJlZE11bChmKTtcbiAgLy8gWTMgPSBHICogSFxuICB2YXIgbnkgPSBnLnJlZE11bChoKTtcbiAgLy8gVDMgPSBFICogSFxuICB2YXIgbnQgPSBlLnJlZE11bChoKTtcbiAgLy8gWjMgPSBGICogR1xuICB2YXIgbnogPSBmLnJlZE11bChnKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueiwgbnQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9wcm9qQWRkID0gZnVuY3Rpb24gX3Byb2pBZGQocCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1wcm9qZWN0aXZlLmh0bWxcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwOC1iYmpscFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA3LWJsXG4gIC8vIDEwTSArIDFTXG5cbiAgLy8gQSA9IFoxICogWjJcbiAgdmFyIGEgPSB0aGlzLnoucmVkTXVsKHAueik7XG4gIC8vIEIgPSBBXjJcbiAgdmFyIGIgPSBhLnJlZFNxcigpO1xuICAvLyBDID0gWDEgKiBYMlxuICB2YXIgYyA9IHRoaXMueC5yZWRNdWwocC54KTtcbiAgLy8gRCA9IFkxICogWTJcbiAgdmFyIGQgPSB0aGlzLnkucmVkTXVsKHAueSk7XG4gIC8vIEUgPSBkICogQyAqIERcbiAgdmFyIGUgPSB0aGlzLmN1cnZlLmQucmVkTXVsKGMpLnJlZE11bChkKTtcbiAgLy8gRiA9IEIgLSBFXG4gIHZhciBmID0gYi5yZWRTdWIoZSk7XG4gIC8vIEcgPSBCICsgRVxuICB2YXIgZyA9IGIucmVkQWRkKGUpO1xuICAvLyBYMyA9IEEgKiBGICogKChYMSArIFkxKSAqIChYMiArIFkyKSAtIEMgLSBEKVxuICB2YXIgdG1wID0gdGhpcy54LnJlZEFkZCh0aGlzLnkpLnJlZE11bChwLngucmVkQWRkKHAueSkpLnJlZElTdWIoYykucmVkSVN1YihkKTtcbiAgdmFyIG54ID0gYS5yZWRNdWwoZikucmVkTXVsKHRtcCk7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICBpZiAodGhpcy5jdXJ2ZS50d2lzdGVkKSB7XG4gICAgLy8gWTMgPSBBICogRyAqIChEIC0gYSAqIEMpXG4gICAgbnkgPSBhLnJlZE11bChnKS5yZWRNdWwoZC5yZWRTdWIodGhpcy5jdXJ2ZS5fbXVsQShjKSkpO1xuICAgIC8vIFozID0gRiAqIEdcbiAgICBueiA9IGYucmVkTXVsKGcpO1xuICB9IGVsc2Uge1xuICAgIC8vIFkzID0gQSAqIEcgKiAoRCAtIEMpXG4gICAgbnkgPSBhLnJlZE11bChnKS5yZWRNdWwoZC5yZWRTdWIoYykpO1xuICAgIC8vIFozID0gYyAqIEYgKiBHXG4gICAgbnogPSB0aGlzLmN1cnZlLl9tdWxDKGYpLnJlZE11bChnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZClcbiAgICByZXR1cm4gdGhpcy5fZXh0QWRkKHApO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2pBZGQocCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwLCBrMikge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBbIHRoaXMsIHAgXSwgWyBrMSwgazIgXSwgMiwgZmFsc2UpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwLCBrMikge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBbIHRoaXMsIHAgXSwgWyBrMSwgazIgXSwgMiwgdHJ1ZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICBpZiAodGhpcy56T25lKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlc1xuICB2YXIgemkgPSB0aGlzLnoucmVkSW52bSgpO1xuICB0aGlzLnggPSB0aGlzLngucmVkTXVsKHppKTtcbiAgdGhpcy55ID0gdGhpcy55LnJlZE11bCh6aSk7XG4gIGlmICh0aGlzLnQpXG4gICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh6aSk7XG4gIHRoaXMueiA9IHRoaXMuY3VydmUub25lO1xuICB0aGlzLnpPbmUgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWROZWcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnosXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudCAmJiB0aGlzLnQucmVkTmVnKCkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICB0aGlzLm5vcm1hbGl6ZSgpO1xuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgdGhpcy5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIHRoaXMueS5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHxcbiAgICAgICAgIHRoaXMuZ2V0WCgpLmNtcChvdGhlci5nZXRYKCkpID09PSAwICYmXG4gICAgICAgICB0aGlzLmdldFkoKS5jbXAob3RoZXIuZ2V0WSgpKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwodGhpcy56KTtcbiAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4YyA9IHguY2xvbmUoKTtcbiAgdmFyIHQgPSB0aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHRoaXMueik7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIENvbXBhdGliaWxpdHkgd2l0aCBCYXNlQ3VydmVcblBvaW50LnByb3RvdHlwZS50b1AgPSBQb2ludC5wcm90b3R5cGUubm9ybWFsaXplO1xuUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gUG9pbnQucHJvdG90eXBlLmFkZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gZXhwb3J0cztcblxuY3VydmUuYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuY3VydmUuc2hvcnQgPSByZXF1aXJlKCcuL3Nob3J0Jyk7XG5jdXJ2ZS5tb250ID0gcmVxdWlyZSgnLi9tb250Jyk7XG5jdXJ2ZS5lZHdhcmRzID0gcmVxdWlyZSgnLi9lZHdhcmRzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2N1cnZlJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gY3VydmUuYmFzZTtcblxudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xuXG5mdW5jdGlvbiBNb250Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ21vbnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmk0ID0gbmV3IEJOKDQpLnRvUmVkKHRoaXMucmVkKS5yZWRJbnZtKCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5hMjQgPSB0aGlzLmk0LnJlZE11bCh0aGlzLmEucmVkQWRkKHRoaXMudHdvKSk7XG59XG5pbmhlcml0cyhNb250Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBNb250Q3VydmU7XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICB2YXIgeCA9IHBvaW50Lm5vcm1hbGl6ZSgpLng7XG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB4Mi5yZWRNdWwoeCkucmVkQWRkKHgyLnJlZE11bCh0aGlzLmEpKS5yZWRBZGQoeCk7XG4gIHZhciB5ID0gcmhzLnJlZFNxcnQoKTtcblxuICByZXR1cm4geS5yZWRTcXIoKS5jbXAocmhzKSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSB0aGlzLmN1cnZlLnplcm87XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnoucmVkKVxuICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgcmV0dXJuIHRoaXMucG9pbnQodXRpbHMudG9BcnJheShieXRlcywgZW5jKSwgMSk7XG59O1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeikge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHopO1xufTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmopIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG4gIC8vIE5vLW9wXG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCkpO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdIHx8IGN1cnZlLm9uZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tbW9udGdvbS14ei5odG1sI2RvdWJsaW5nLWRibC0xOTg3LW0tM1xuICAvLyAyTSArIDJTICsgNEFcblxuICAvLyBBID0gWDEgKyBaMVxuICB2YXIgYSA9IHRoaXMueC5yZWRBZGQodGhpcy56KTtcbiAgLy8gQUEgPSBBXjJcbiAgdmFyIGFhID0gYS5yZWRTcXIoKTtcbiAgLy8gQiA9IFgxIC0gWjFcbiAgdmFyIGIgPSB0aGlzLngucmVkU3ViKHRoaXMueik7XG4gIC8vIEJCID0gQl4yXG4gIHZhciBiYiA9IGIucmVkU3FyKCk7XG4gIC8vIEMgPSBBQSAtIEJCXG4gIHZhciBjID0gYWEucmVkU3ViKGJiKTtcbiAgLy8gWDMgPSBBQSAqIEJCXG4gIHZhciBueCA9IGFhLnJlZE11bChiYik7XG4gIC8vIFozID0gQyAqIChCQiArIEEyNCAqIEMpXG4gIHZhciBueiA9IGMucmVkTXVsKGJiLnJlZEFkZCh0aGlzLmN1cnZlLmEyNC5yZWRNdWwoYykpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGlmZkFkZCA9IGZ1bmN0aW9uIGRpZmZBZGQocCwgZGlmZikge1xuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLW1vbnRnb20teHouaHRtbCNkaWZmYWRkLWRhZGQtMTk4Ny1tLTNcbiAgLy8gNE0gKyAyUyArIDZBXG5cbiAgLy8gQSA9IFgyICsgWjJcbiAgdmFyIGEgPSB0aGlzLngucmVkQWRkKHRoaXMueik7XG4gIC8vIEIgPSBYMiAtIFoyXG4gIHZhciBiID0gdGhpcy54LnJlZFN1Yih0aGlzLnopO1xuICAvLyBDID0gWDMgKyBaM1xuICB2YXIgYyA9IHAueC5yZWRBZGQocC56KTtcbiAgLy8gRCA9IFgzIC0gWjNcbiAgdmFyIGQgPSBwLngucmVkU3ViKHAueik7XG4gIC8vIERBID0gRCAqIEFcbiAgdmFyIGRhID0gZC5yZWRNdWwoYSk7XG4gIC8vIENCID0gQyAqIEJcbiAgdmFyIGNiID0gYy5yZWRNdWwoYik7XG4gIC8vIFg1ID0gWjEgKiAoREEgKyBDQileMlxuICB2YXIgbnggPSBkaWZmLnoucmVkTXVsKGRhLnJlZEFkZChjYikucmVkU3FyKCkpO1xuICAvLyBaNSA9IFgxICogKERBIC0gQ0IpXjJcbiAgdmFyIG56ID0gZGlmZi54LnJlZE11bChkYS5yZWRJU3ViKGNiKS5yZWRTcXIoKSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgdmFyIHQgPSBrLmNsb25lKCk7XG4gIHZhciBhID0gdGhpczsgLy8gKE4gLyAyKSAqIFEgKyBRXG4gIHZhciBiID0gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTsgLy8gKE4gLyAyKSAqIFFcbiAgdmFyIGMgPSB0aGlzOyAvLyBRXG5cbiAgZm9yICh2YXIgYml0cyA9IFtdOyB0LmNtcG4oMCkgIT09IDA7IHQuaXVzaHJuKDEpKVxuICAgIGJpdHMucHVzaCh0LmFuZGxuKDEpKTtcblxuICBmb3IgKHZhciBpID0gYml0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChiaXRzW2ldID09PSAwKSB7XG4gICAgICAvLyBOICogUSArIFEgPSAoKE4gLyAyKSAqIFEgKyBRKSkgKyAoTiAvIDIpICogUVxuICAgICAgYSA9IGEuZGlmZkFkZChiLCBjKTtcbiAgICAgIC8vIE4gKiBRID0gMiAqICgoTiAvIDIpICogUSArIFEpKVxuICAgICAgYiA9IGIuZGJsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE4gKiBRID0gKChOIC8gMikgKiBRICsgUSkgKyAoKE4gLyAyKSAqIFEpXG4gICAgICBiID0gYS5kaWZmQWRkKGIsIGMpO1xuICAgICAgLy8gTiAqIFEgKyBRID0gMiAqICgoTiAvIDIpICogUSArIFEpXG4gICAgICBhID0gYS5kYmwoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGI7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmp1bWxBZGQgPSBmdW5jdGlvbiBqdW1sQWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpLmNtcChvdGhlci5nZXRYKCkpID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdGhpcy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4uL2N1cnZlJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi8uLi9lbGxpcHRpYycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IGN1cnZlLmJhc2U7XG5cbnZhciBhc3NlcnQgPSBlbGxpcHRpYy51dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNob3J0Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ3Nob3J0JywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5iID0gbmV3IEJOKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy50aW52ID0gdGhpcy50d28ucmVkSW52bSgpO1xuXG4gIHRoaXMuemVyb0EgPSB0aGlzLmEuZnJvbVJlZCgpLmNtcG4oMCkgPT09IDA7XG4gIHRoaXMudGhyZWVBID0gdGhpcy5hLmZyb21SZWQoKS5zdWIodGhpcy5wKS5jbXBuKC0zKSA9PT0gMDtcblxuICAvLyBJZiB0aGUgY3VydmUgaXMgZW5kb21vcnBoaWMsIHByZWNhbGN1bGF0ZSBiZXRhIGFuZCBsYW1iZGFcbiAgdGhpcy5lbmRvID0gdGhpcy5fZ2V0RW5kb21vcnBoaXNtKGNvbmYpO1xuICB0aGlzLl9lbmRvV25hZlQxID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl9lbmRvV25hZlQyID0gbmV3IEFycmF5KDQpO1xufVxuaW5oZXJpdHMoU2hvcnRDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNob3J0Q3VydmU7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpIHtcbiAgLy8gTm8gZWZmaWNpZW50IGVuZG9tb3JwaGlzbVxuICBpZiAoIXRoaXMuemVyb0EgfHwgIXRoaXMuZyB8fCAhdGhpcy5uIHx8IHRoaXMucC5tb2RuKDMpICE9PSAxKVxuICAgIHJldHVybjtcblxuICAvLyBDb21wdXRlIGJldGEgYW5kIGxhbWJkYSwgdGhhdCBsYW1iZGEgKiBQID0gKGJldGEgKiBQeDsgUHkpXG4gIHZhciBiZXRhO1xuICB2YXIgbGFtYmRhO1xuICBpZiAoY29uZi5iZXRhKSB7XG4gICAgYmV0YSA9IG5ldyBCTihjb25mLmJldGEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJldGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCk7XG4gICAgLy8gQ2hvb3NlIHRoZSBzbWFsbGVzdCBiZXRhXG4gICAgYmV0YSA9IGJldGFzWzBdLmNtcChiZXRhc1sxXSkgPCAwID8gYmV0YXNbMF0gOiBiZXRhc1sxXTtcbiAgICBiZXRhID0gYmV0YS50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbiAgaWYgKGNvbmYubGFtYmRhKSB7XG4gICAgbGFtYmRhID0gbmV3IEJOKGNvbmYubGFtYmRhLCAxNik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hvb3NlIHRoZSBsYW1iZGEgdGhhdCBpcyBtYXRjaGluZyBzZWxlY3RlZCBiZXRhXG4gICAgdmFyIGxhbWJkYXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtcbiAgICBpZiAodGhpcy5nLm11bChsYW1iZGFzWzBdKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzFdO1xuICAgICAgYXNzZXJ0KHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuICB2YXIgYmFzaXM7XG4gIGlmIChjb25mLmJhc2lzKSB7XG4gICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IG5ldyBCTih2ZWMuYSwgMTYpLFxuICAgICAgICBiOiBuZXcgQk4odmVjLmIsIDE2KVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBiYXNpcyA9IHRoaXMuX2dldEVuZG9CYXNpcyhsYW1iZGEpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZXRhOiBiZXRhLFxuICAgIGxhbWJkYTogbGFtYmRhLFxuICAgIGJhc2lzOiBiYXNpc1xuICB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9Sb290cyA9IGZ1bmN0aW9uIF9nZXRFbmRvUm9vdHMobnVtKSB7XG4gIC8vIEZpbmQgcm9vdHMgb2YgZm9yIHheMiArIHggKyAxIGluIEZcbiAgLy8gUm9vdCA9ICgtMSArLSBTcXJ0KC0zKSkgLyAyXG4gIC8vXG4gIHZhciByZWQgPSBudW0gPT09IHRoaXMucCA/IHRoaXMucmVkIDogQk4ubW9udChudW0pO1xuICB2YXIgdGludiA9IG5ldyBCTigyKS50b1JlZChyZWQpLnJlZEludm0oKTtcbiAgdmFyIG50aW52ID0gdGludi5yZWROZWcoKTtcblxuICB2YXIgcyA9IG5ldyBCTigzKS50b1JlZChyZWQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwodGludik7XG5cbiAgdmFyIGwxID0gbnRpbnYucmVkQWRkKHMpLmZyb21SZWQoKTtcbiAgdmFyIGwyID0gbnRpbnYucmVkU3ViKHMpLmZyb21SZWQoKTtcbiAgcmV0dXJuIFsgbDEsIGwyIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb0Jhc2lzID0gZnVuY3Rpb24gX2dldEVuZG9CYXNpcyhsYW1iZGEpIHtcbiAgLy8gYXByeFNxcnQgPj0gc3FydCh0aGlzLm4pXG4gIHZhciBhcHJ4U3FydCA9IHRoaXMubi51c2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKSAvIDIpKTtcblxuICAvLyAzLjc0XG4gIC8vIFJ1biBFR0NELCB1bnRpbCByKEwgKyAxKSA8IGFwcnhTcXJ0XG4gIHZhciB1ID0gbGFtYmRhO1xuICB2YXIgdiA9IHRoaXMubi5jbG9uZSgpO1xuICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gIHZhciB5MSA9IG5ldyBCTigwKTtcbiAgdmFyIHgyID0gbmV3IEJOKDApO1xuICB2YXIgeTIgPSBuZXcgQk4oMSk7XG5cbiAgLy8gTk9URTogYWxsIHZlY3RvcnMgYXJlIHJvb3RzIG9mOiBhICsgYiAqIGxhbWJkYSA9IDAgKG1vZCBuKVxuICB2YXIgYTA7XG4gIHZhciBiMDtcbiAgLy8gRmlyc3QgdmVjdG9yXG4gIHZhciBhMTtcbiAgdmFyIGIxO1xuICAvLyBTZWNvbmQgdmVjdG9yXG4gIHZhciBhMjtcbiAgdmFyIGIyO1xuXG4gIHZhciBwcmV2UjtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcjtcbiAgdmFyIHg7XG4gIHdoaWxlICh1LmNtcG4oMCkgIT09IDApIHtcbiAgICB2YXIgcSA9IHYuZGl2KHUpO1xuICAgIHIgPSB2LnN1YihxLm11bCh1KSk7XG4gICAgeCA9IHgyLnN1YihxLm11bCh4MSkpO1xuICAgIHZhciB5ID0geTIuc3ViKHEubXVsKHkxKSk7XG5cbiAgICBpZiAoIWExICYmIHIuY21wKGFwcnhTcXJ0KSA8IDApIHtcbiAgICAgIGEwID0gcHJldlIubmVnKCk7XG4gICAgICBiMCA9IHgxO1xuICAgICAgYTEgPSByLm5lZygpO1xuICAgICAgYjEgPSB4O1xuICAgIH0gZWxzZSBpZiAoYTEgJiYgKytpID09PSAyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldlIgPSByO1xuXG4gICAgdiA9IHU7XG4gICAgdSA9IHI7XG4gICAgeDIgPSB4MTtcbiAgICB4MSA9IHg7XG4gICAgeTIgPSB5MTtcbiAgICB5MSA9IHk7XG4gIH1cbiAgYTIgPSByLm5lZygpO1xuICBiMiA9IHg7XG5cbiAgdmFyIGxlbjEgPSBhMS5zcXIoKS5hZGQoYjEuc3FyKCkpO1xuICB2YXIgbGVuMiA9IGEyLnNxcigpLmFkZChiMi5zcXIoKSk7XG4gIGlmIChsZW4yLmNtcChsZW4xKSA+PSAwKSB7XG4gICAgYTIgPSBhMDtcbiAgICBiMiA9IGIwO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIHNpZ25zXG4gIGlmIChhMS5uZWdhdGl2ZSkge1xuICAgIGExID0gYTEubmVnKCk7XG4gICAgYjEgPSBiMS5uZWcoKTtcbiAgfVxuICBpZiAoYTIubmVnYXRpdmUpIHtcbiAgICBhMiA9IGEyLm5lZygpO1xuICAgIGIyID0gYjIubmVnKCk7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHsgYTogYTEsIGI6IGIxIH0sXG4gICAgeyBhOiBhMiwgYjogYjIgfVxuICBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuICB2YXIgYmFzaXMgPSB0aGlzLmVuZG8uYmFzaXM7XG4gIHZhciB2MSA9IGJhc2lzWzBdO1xuICB2YXIgdjIgPSBiYXNpc1sxXTtcblxuICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG4gIHZhciBwMSA9IGMxLm11bCh2MS5hKTtcbiAgdmFyIHAyID0gYzIubXVsKHYyLmEpO1xuICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG4gIHZhciBxMiA9IGMyLm11bCh2Mi5iKTtcblxuICAvLyBDYWxjdWxhdGUgYW5zd2VyXG4gIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuICB2YXIgazIgPSBxMS5hZGQocTIpLm5lZygpO1xuICByZXR1cm4geyBrMTogazEsIGsyOiBrMiB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcbiAgLy8gdG8gbm9uLXJlZCBmb3JtP1xuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaW5mKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4ID0gcG9pbnQueDtcbiAgdmFyIHkgPSBwb2ludC55O1xuXG4gIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG4gIHZhciByaHMgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKGF4KS5yZWRJQWRkKHRoaXMuYik7XG4gIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID1cbiAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG4gIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcbiAgdmFyIG5jb2VmZnMgPSB0aGlzLl9lbmRvV25hZlQyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG4gICAgICBzcGxpdC5rMS5pbmVnKCk7XG4gICAgICBwID0gcC5uZWcodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzcGxpdC5rMi5uZWdhdGl2ZSkge1xuICAgICAgc3BsaXQuazIuaW5lZygpO1xuICAgICAgYmV0YSA9IGJldGEubmVnKHRydWUpO1xuICAgIH1cblxuICAgIG5wb2ludHNbaSAqIDJdID0gcDtcbiAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuICAgIG5jb2VmZnNbaSAqIDJdID0gc3BsaXQuazE7XG4gICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG4gIH1cbiAgdmFyIHJlcyA9IHRoaXMuX3duYWZNdWxBZGQoMSwgbnBvaW50cywgbmNvZWZmcywgaSAqIDIsIGphY29iaWFuUmVzdWx0KTtcblxuICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuICAgIG5wb2ludHNbal0gPSBudWxsO1xuICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCBpc1JlZCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaiwgcmVkKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuO1xuXG4gIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICBpZiAocHJlICYmIHByZS5iZXRhKVxuICAgIHJldHVybiBwcmUuYmV0YTtcblxuICB2YXIgYmV0YSA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksIHRoaXMueSk7XG4gIGlmIChwcmUpIHtcbiAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuICAgIHZhciBlbmRvTXVsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcbiAgICB9O1xuICAgIHByZS5iZXRhID0gYmV0YTtcbiAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuICAgICAgYmV0YTogbnVsbCxcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKGVuZG9NdWwpXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBiZXRhO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XG5cbiAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMucHJlY29tcHV0ZWQgJiYge1xuICAgIGRvdWJsZXM6IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50cy5zbGljZSgxKVxuICAgIH0sXG4gICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG4gICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpXG4gICAgfVxuICB9IF07XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmosIHJlZCkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXG4gICAgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuICB2YXIgcmVzID0gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIGlmICghb2JqWzJdKVxuICAgIHJldHVybiByZXM7XG5cbiAgZnVuY3Rpb24gb2JqMnBvaW50KG9iaikge1xuICAgIHJldHVybiBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgfVxuXG4gIHZhciBwcmUgPSBvYmpbMl07XG4gIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICBiZXRhOiBudWxsLFxuICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9LFxuICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSlcbiAgICB9XG4gIH07XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIHJldHVybiB0aGlzLmluZjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gUCArIFAgPSAyUFxuICBpZiAodGhpcy5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICAvLyBQICsgKC1QKSA9IE9cbiAgaWYgKHRoaXMubmVnKCkuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgLy8gUCArIFEgPSBPXG4gIGlmICh0aGlzLnguY21wKHAueCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGMgPSB0aGlzLnkucmVkU3ViKHAueSk7XG4gIGlmIChjLmNtcG4oMCkgIT09IDApXG4gICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54KS5yZWRJU3ViKHAueCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMlAgPSBPXG4gIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIGlmICh5czEuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICB2YXIgeDIgPSB0aGlzLngucmVkU3FyKCk7XG4gIHZhciBkeWludiA9IHlzMS5yZWRJbnZtKCk7XG4gIHZhciBjID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7XG5cbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBrID0gbmV3IEJOKGssIDE2KTtcblxuICBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQoWyB0aGlzIF0sIFsgayBdKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuam11bEFkZCA9IGZ1bmN0aW9uIGptdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIHRydWUpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIsIHRydWUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICByZXR1cm4gdGhpcyA9PT0gcCB8fFxuICAgICAgICAgdGhpcy5pbmYgPT09IHAuaW5mICYmXG4gICAgICAgICAgICAgKHRoaXMuaW5mIHx8IHRoaXMueC5jbXAocC54KSA9PT0gMCAmJiB0aGlzLnkuY21wKHAueSkgPT09IDApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhfcHJlY29tcHV0ZSkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCkpO1xuICBpZiAoX3ByZWNvbXB1dGUgJiYgdGhpcy5wcmVjb21wdXRlZCkge1xuICAgIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICAgIHZhciBuZWdhdGUgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcC5uZWcoKTtcbiAgICB9O1xuICAgIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKG5lZ2F0ZSlcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChuZWdhdGUpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSiA9IGZ1bmN0aW9uIHRvSigpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnksIHRoaXMuY3VydmUub25lKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIEpQb2ludChjdXJ2ZSwgeCwgeSwgeikge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnamFjb2JpYW4nKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gbmV3IEJOKDApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICB9XG4gIGlmICghdGhpcy54LnJlZClcbiAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMueS5yZWQpXG4gICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnoucmVkKVxuICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cbiAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcbn1cbmluaGVyaXRzKEpQb2ludCwgQmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeikge1xuICByZXR1cm4gbmV3IEpQb2ludCh0aGlzLCB4LCB5LCB6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24gdG9QKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIHppbnYgPSB0aGlzLnoucmVkSW52bSgpO1xuICB2YXIgemludjIgPSB6aW52LnJlZFNxcigpO1xuICB2YXIgYXggPSB0aGlzLngucmVkTXVsKHppbnYyKTtcbiAgdmFyIGF5ID0gdGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LCBheSk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpLCB0aGlzLnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMTJNICsgNFMgKyA3QVxuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueC5yZWRNdWwocHoyKTtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6Mi5yZWRNdWwodGhpcy56KSk7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IGZ1bmN0aW9uIG1peGVkQWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcC50b0ooKTtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDhNICsgM1MgKyA3QVxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueDtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6MikucmVkTXVsKHRoaXMueik7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcbiAgaWYgKHBvdyA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoIXBvdylcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSB8fCB0aGlzLmN1cnZlLnRocmVlQSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKVxuICAgICAgciA9IHIuZGJsKCk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICAvLyAxTSArIDJTICsgMUEgKyBOICogKDRTICsgNU0gKyA4QSlcbiAgLy8gTiA9IDEgPT4gNk0gKyA2UyArIDlBXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuICB2YXIgdGludiA9IHRoaXMuY3VydmUudGludjtcblxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgLy8gUmV1c2UgcmVzdWx0c1xuICB2YXIganlkID0gankucmVkQWRkKGp5KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3c7IGkrKykge1xuICAgIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgICB2YXIganlkMiA9IGp5ZC5yZWRTcXIoKTtcbiAgICB2YXIganlkNCA9IGp5ZDIucmVkU3FyKCk7XG4gICAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cbiAgICB2YXIgdDEgPSBqeC5yZWRNdWwoanlkMik7XG4gICAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuICAgIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuICAgIHZhciBkbnkgPSBjLnJlZE11bCh0Mik7XG4gICAgZG55ID0gZG55LnJlZElBZGQoZG55KS5yZWRJU3ViKGp5ZDQpO1xuICAgIHZhciBueiA9IGp5ZC5yZWRNdWwoanopO1xuICAgIGlmIChpICsgMSA8IHBvdylcbiAgICAgIGp6NCA9IGp6NC5yZWRNdWwoanlkNCk7XG5cbiAgICBqeCA9IG54O1xuICAgIGp6ID0gbno7XG4gICAganlkID0gZG55O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGp4LCBqeWQucmVkTXVsKHRpbnYpLCBqeik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLl96ZXJvRGJsKCk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUudGhyZWVBKVxuICAgIHJldHVybiB0aGlzLl90aHJlZURibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX2RibCgpO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5femVyb0RibCA9IGZ1bmN0aW9uIF96ZXJvRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNEFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhOyBhID0gMFxuICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcbiAgICAvLyBUID0gTSBeIDIgLSAyKlNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuXG4gICAgLy8gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuXG4gICAgLy8gWDMgPSBUXG4gICAgbnggPSB0O1xuICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIqWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDktbFxuICAgIC8vIDJNICsgNVMgKyAxM0FcblxuICAgIC8vIEEgPSBYMV4yXG4gICAgdmFyIGEgPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gQiA9IFkxXjJcbiAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBDID0gQl4yXG4gICAgdmFyIGMgPSBiLnJlZFNxcigpO1xuICAgIC8vIEQgPSAyICogKChYMSArIEIpXjIgLSBBIC0gQylcbiAgICB2YXIgZCA9IHRoaXMueC5yZWRBZGQoYikucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGMpO1xuICAgIGQgPSBkLnJlZElBZGQoZCk7XG4gICAgLy8gRSA9IDMgKiBBXG4gICAgdmFyIGUgPSBhLnJlZEFkZChhKS5yZWRJQWRkKGEpO1xuICAgIC8vIEYgPSBFXjJcbiAgICB2YXIgZiA9IGUucmVkU3FyKCk7XG5cbiAgICAvLyA4ICogQ1xuICAgIHZhciBjOCA9IGMucmVkSUFkZChjKTtcbiAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG5cbiAgICAvLyBYMyA9IEYgLSAyICogRFxuICAgIG54ID0gZi5yZWRJU3ViKGQpLnJlZElTdWIoZCk7XG4gICAgLy8gWTMgPSBFICogKEQgLSBYMykgLSA4ICogQ1xuICAgIG55ID0gZS5yZWRNdWwoZC5yZWRJU3ViKG54KSkucmVkSVN1YihjOCk7XG4gICAgLy8gWjMgPSAyICogWTEgKiBaMVxuICAgIG56ID0gdGhpcy55LnJlZE11bCh0aGlzLnopO1xuICAgIG56ID0gbnoucmVkSUFkZChueik7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl90aHJlZURibCA9IGZ1bmN0aW9uIF90aHJlZURibCgpIHtcbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgMTVBXG5cbiAgICAvLyBYWCA9IFgxXjJcbiAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gWVkgPSBZMV4yXG4gICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcbiAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAvLyBNID0gMyAqIFhYICsgYVxuICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KS5yZWRJQWRkKHRoaXMuY3VydmUuYSk7XG4gICAgLy8gVCA9IE1eMiAtIDIgKiBTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG4gICAgLy8gWjMgPSAyICogWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbCNkb3VibGluZy1kYmwtMjAwMS1iXG4gICAgLy8gM00gKyA1U1xuXG4gICAgLy8gZGVsdGEgPSBaMV4yXG4gICAgdmFyIGRlbHRhID0gdGhpcy56LnJlZFNxcigpO1xuICAgIC8vIGdhbW1hID0gWTFeMlxuICAgIHZhciBnYW1tYSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBiZXRhID0gWDEgKiBnYW1tYVxuICAgIHZhciBiZXRhID0gdGhpcy54LnJlZE11bChnYW1tYSk7XG4gICAgLy8gYWxwaGEgPSAzICogKFgxIC0gZGVsdGEpICogKFgxICsgZGVsdGEpXG4gICAgdmFyIGFscGhhID0gdGhpcy54LnJlZFN1YihkZWx0YSkucmVkTXVsKHRoaXMueC5yZWRBZGQoZGVsdGEpKTtcbiAgICBhbHBoYSA9IGFscGhhLnJlZEFkZChhbHBoYSkucmVkSUFkZChhbHBoYSk7XG4gICAgLy8gWDMgPSBhbHBoYV4yIC0gOCAqIGJldGFcbiAgICB2YXIgYmV0YTQgPSBiZXRhLnJlZElBZGQoYmV0YSk7XG4gICAgYmV0YTQgPSBiZXRhNC5yZWRJQWRkKGJldGE0KTtcbiAgICB2YXIgYmV0YTggPSBiZXRhNC5yZWRBZGQoYmV0YTQpO1xuICAgIG54ID0gYWxwaGEucmVkU3FyKCkucmVkSVN1YihiZXRhOCk7XG4gICAgLy8gWjMgPSAoWTEgKyBaMSleMiAtIGdhbW1hIC0gZGVsdGFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy56KS5yZWRTcXIoKS5yZWRJU3ViKGdhbW1hKS5yZWRJU3ViKGRlbHRhKTtcbiAgICAvLyBZMyA9IGFscGhhICogKDQgKiBiZXRhIC0gWDMpIC0gOCAqIGdhbW1hXjJcbiAgICB2YXIgZ2dhbW1hOCA9IGdhbW1hLnJlZFNxcigpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIG55ID0gYWxwaGEucmVkTXVsKGJldGE0LnJlZElTdWIobngpKS5yZWRJU3ViKGdnYW1tYTgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5fZGJsID0gZnVuY3Rpb24gX2RibCgpIHtcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cbiAgLy8gNE0gKyA2UyArIDEwQVxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICB2YXIgankyID0gankucmVkU3FyKCk7XG5cbiAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cbiAgdmFyIGp4ZDQgPSBqeC5yZWRBZGQoangpO1xuICBqeGQ0ID0ganhkNC5yZWRJQWRkKGp4ZDQpO1xuICB2YXIgdDEgPSBqeGQ0LnJlZE11bChqeTIpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuXG4gIHZhciBqeWQ4ID0gankyLnJlZFNxcigpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0MikucmVkSVN1YihqeWQ4KTtcbiAgdmFyIG56ID0gankucmVkQWRkKGp5KS5yZWRNdWwoanopO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudHJwbCA9IGZ1bmN0aW9uIHRycGwoKSB7XG4gIGlmICghdGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKS5hZGQodGhpcyk7XG5cbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWwjdHJpcGxpbmctdHBsLTIwMDctYmxcbiAgLy8gNU0gKyAxMFMgKyAuLi5cblxuICAvLyBYWCA9IFgxXjJcbiAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBZWSA9IFkxXjJcbiAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAvLyBaWiA9IFoxXjJcbiAgdmFyIHp6ID0gdGhpcy56LnJlZFNxcigpO1xuICAvLyBZWVlZID0gWVleMlxuICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAvLyBNID0gMyAqIFhYICsgYSAqIFpaMjsgYSA9IDBcbiAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAvLyBNTSA9IE1eMlxuICB2YXIgbW0gPSBtLnJlZFNxcigpO1xuICAvLyBFID0gNiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSkgLSBNTVxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gIGUgPSBlLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZEFkZChlKS5yZWRJQWRkKGUpO1xuICBlID0gZS5yZWRJU3ViKG1tKTtcbiAgLy8gRUUgPSBFXjJcbiAgdmFyIGVlID0gZS5yZWRTcXIoKTtcbiAgLy8gVCA9IDE2KllZWVlcbiAgdmFyIHQgPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIC8vIFUgPSAoTSArIEUpXjIgLSBNTSAtIEVFIC0gVFxuICB2YXIgdSA9IG0ucmVkSUFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKG1tKS5yZWRJU3ViKGVlKS5yZWRJU3ViKHQpO1xuICAvLyBYMyA9IDQgKiAoWDEgKiBFRSAtIDQgKiBZWSAqIFUpXG4gIHZhciB5eXU0ID0geXkucmVkTXVsKHUpO1xuICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuICB2YXIgbnggPSB0aGlzLngucmVkTXVsKGVlKS5yZWRJU3ViKHl5dTQpO1xuICBueCA9IG54LnJlZElBZGQobngpO1xuICBueCA9IG54LnJlZElBZGQobngpO1xuICAvLyBZMyA9IDggKiBZMSAqIChVICogKFQgLSBVKSAtIEUgKiBFRSlcbiAgdmFyIG55ID0gdGhpcy55LnJlZE11bCh1LnJlZE11bCh0LnJlZElTdWIodSkpLnJlZElTdWIoZS5yZWRNdWwoZWUpKSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIC8vIFozID0gKFoxICsgRSleMiAtIFpaIC0gRUVcbiAgdmFyIG56ID0gdGhpcy56LnJlZEFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKHp6KS5yZWRJU3ViKGVlKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrLCBrYmFzZSkge1xuICBrID0gbmV3IEJOKGssIGtiYXNlKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgIHJldHVybiB0aGlzLmVxKHAudG9KKCkpO1xuXG4gIGlmICh0aGlzID09PSBwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIHgxICogejJeMiA9PSB4MiAqIHoxXjJcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICBpZiAodGhpcy54LnJlZE11bChwejIpLnJlZElTdWIocC54LnJlZE11bCh6MikpLmNtcG4oMCkgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIHkxICogejJeMyA9PSB5MiAqIHoxXjNcbiAgdmFyIHozID0gejIucmVkTXVsKHRoaXMueik7XG4gIHZhciBwejMgPSBwejIucmVkTXVsKHAueik7XG4gIHJldHVybiB0aGlzLnkucmVkTXVsKHB6MykucmVkSVN1YihwLnkucmVkTXVsKHozKSkuY21wbigwKSA9PT0gMDtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24gZXFYVG9QKHgpIHtcbiAgdmFyIHpzID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwoenMpO1xuICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHhjID0geC5jbG9uZSgpO1xuICB2YXIgdCA9IHRoaXMuY3VydmUucmVkTi5yZWRNdWwoenMpO1xuICBmb3IgKDs7KSB7XG4gICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcngucmVkSUFkZCh0KTtcbiAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmVzID0gZXhwb3J0cztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgZWxsaXB0aWMgPSByZXF1aXJlKCcuLi9lbGxpcHRpYycpO1xuXG52YXIgYXNzZXJ0ID0gZWxsaXB0aWMudXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaG9ydCcpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5zaG9ydChvcHRpb25zKTtcbiAgZWxzZSBpZiAob3B0aW9ucy50eXBlID09PSAnZWR3YXJkcycpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5lZHdhcmRzKG9wdGlvbnMpO1xuICBlbHNlXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBlbGxpcHRpYy5jdXJ2ZS5tb250KG9wdGlvbnMpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG4gIGFzc2VydCh0aGlzLmcudmFsaWRhdGUoKSwgJ0ludmFsaWQgY3VydmUnKTtcbiAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xufVxuY3VydmVzLlByZXNldEN1cnZlID0gUHJlc2V0Q3VydmU7XG5cbmZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUHJlc2V0Q3VydmUob3B0aW9ucyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGN1cnZlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5kZWZpbmVDdXJ2ZSgncDE5MicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMTkyJyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzY0MjEwNTE5IGU1OWM4MGU3IDBmYTdlOWFiIDcyMjQzMDQ5IGZlYjhkZWVjIGMxNDZiOWIxJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzE4OGRhODBlIGIwMzA5MGY2IDdjYmYyMGViIDQzYTE4ODAwIGY0ZmYwYWZkIDgyZmYxMDEyJyxcbiAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDIyNCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMjI0JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlJyxcbiAgYjogJ2I0MDUwYTg1IDBjMDRiM2FiIGY1NDEzMjU2IDUwNDRiMGI3IGQ3YmZkOGJhIDI3MGIzOTQzIDIzNTVmZmI0JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmYxNmEyIGUwYjhmMDNlIDEzZGQyOTQ1IDVjNWMyYTNkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2I3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxJyxcbiAgICAnYmQzNzYzODggYjVmNzIzZmIgNGMyMmRmZTYgY2Q0Mzc1YTAgNWEwNzQ3NjQgNDRkNTgxOTkgODUwMDdlMzQnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDI1NicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc1YWM2MzVkOCBhYTNhOTNlNyBiM2ViYmQ1NSA3Njk4ODZiYyA2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicsXG4gIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc2YjE3ZDFmMiBlMTJjNDI0NyBmOGJjZTZlNSA2M2E0NDBmMiA3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicsXG4gICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AzODQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcbiAgYjogJ2IzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmICcgK1xuICAgICAnNTAxMzg3NWEgYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWYnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgJyArXG4gICAgICdmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3MycsXG4gIGhhc2g6IGhhc2guc2hhMzg0LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCAnICtcbiAgICAnNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjcnLFxuICAgICczNjE3ZGU0YSA5NjI2MmM2ZiA1ZDllOThiZiA5MjkyZGMyOSBmOGY0MWRiZCAyODlhMTQ3YyBlOWRhMzExMyBiNWYwYjhjMCAnICtcbiAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDUyMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViICcgK1xuICAgICAnOTliMzE1ZjMgYjhiNDg5OTEgOGVmMTA5ZTEgNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgJyArXG4gICAgICczYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMCcsXG4gIG46ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhIDUxODY4NzgzIGJmMmY5NjZiIDdmY2MwMTQ4ICcgK1xuICAgICAnZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDknLFxuICBoYXNoOiBoYXNoLnNoYTUxMixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMDAwMDAwYzYgODU4ZTA2YjcgMDQwNGU5Y2QgOWUzZWNiNjYgMjM5NWI0NDIgOWM2NDgxMzkgJyArXG4gICAgJzA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3ICcgK1xuICAgICdhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicsXG4gICAgJzAwMDAwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5IDk4ZjU0NDQ5ICcgK1xuICAgICc1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAnICtcbiAgICAnM2ZhZDA3NjEgMzUzYzcwODYgYTI3MmMyNDAgODhiZTk0NzYgOWZkMTY2NTAnXG4gIF1cbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcbiAgdHlwZTogJ21vbnQnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJzc2ZDA2JyxcbiAgYjogJzAnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc5J1xuICBdXG59KTtcblxuZGVmaW5lQ3VydmUoJ2VkMjU1MTknLCB7XG4gIHR5cGU6ICdlZHdhcmRzJyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICctMScsXG4gIGM6ICcxJyxcbiAgLy8gLTEyMTY2NSAqICgxMjE2NjZeKC0xKSkgKG1vZCBQKVxuICBkOiAnNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhMycsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnLFxuXG4gICAgLy8gNC81XG4gICAgJzY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnXG4gIF1cbn0pO1xuXG52YXIgcHJlO1xudHJ5IHtcbiAgcHJlID0gcmVxdWlyZSgnLi9wcmVjb21wdXRlZC9zZWNwMjU2azEnKTtcbn0gY2F0Y2ggKGUpIHtcbiAgcHJlID0gdW5kZWZpbmVkO1xufVxuXG5kZWZpbmVDdXJ2ZSgnc2VjcDI1NmsxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ2syNTYnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnLFxuICBhOiAnMCcsXG4gIGI6ICc3JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxJyxcbiAgaDogJzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcblxuICAvLyBQcmVjb21wdXRlZCBlbmRvbW9ycGhpc21cbiAgYmV0YTogJzdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnLFxuICBsYW1iZGE6ICc1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyJyxcbiAgYmFzaXM6IFtcbiAgICB7XG4gICAgICBhOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgICAgYjogJy1lNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMydcbiAgICB9LFxuICAgIHtcbiAgICAgIGE6ICcxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnLFxuICAgICAgYjogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1J1xuICAgIH1cbiAgXSxcblxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyxcbiAgICAnNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOCcsXG4gICAgcHJlXG4gIF1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxudmFyIEtleVBhaXIgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIEVDKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVDKSlcbiAgICByZXR1cm4gbmV3IEVDKG9wdGlvbnMpO1xuXG4gIC8vIFNob3J0Y3V0IGBlbGxpcHRpYy5lYyhjdXJ2ZS1uYW1lKWBcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIGFzc2VydChlbGxpcHRpYy5jdXJ2ZXMuaGFzT3duUHJvcGVydHkob3B0aW9ucyksICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSBlbGxpcHRpYy5jdXJ2ZXNbb3B0aW9uc107XG4gIH1cblxuICAvLyBTaG9ydGN1dCBmb3IgYGVsbGlwdGljLmVjKGVsbGlwdGljLmN1cnZlcy5jdXJ2ZU5hbWUpYFxuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIGVsbGlwdGljLmN1cnZlcy5QcmVzZXRDdXJ2ZSlcbiAgICBvcHRpb25zID0geyBjdXJ2ZTogb3B0aW9ucyB9O1xuXG4gIHRoaXMuY3VydmUgPSBvcHRpb25zLmN1cnZlLmN1cnZlO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMubmggPSB0aGlzLm4udXNocm4oMSk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblxuICAvLyBQb2ludCBvbiBjdXJ2ZVxuICB0aGlzLmcgPSBvcHRpb25zLmN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKG9wdGlvbnMuY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG4gIC8vIEhhc2ggZm9yIGZ1bmN0aW9uIGZvciBEUkJHXG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaCB8fCBvcHRpb25zLmN1cnZlLmhhc2g7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEVDO1xuXG5FQy5wcm90b3R5cGUua2V5UGFpciA9IGZ1bmN0aW9uIGtleVBhaXIob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEtleVBhaXIodGhpcywgb3B0aW9ucyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVByaXZhdGUgPSBmdW5jdGlvbiBrZXlGcm9tUHJpdmF0ZShwcml2LCBlbmMpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHVibGljKHRoaXMsIHB1YiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZW5LZXlQYWlyID0gZnVuY3Rpb24gZ2VuS2V5UGFpcihvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IGVsbGlwdGljLmhtYWNEUkJHKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCBlbGxpcHRpYy5yYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpXG4gIH0pO1xuXG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBuczIgPSB0aGlzLm4uc3ViKG5ldyBCTigyKSk7XG4gIGRvIHtcbiAgICB2YXIgcHJpdiA9IG5ldyBCTihkcmJnLmdlbmVyYXRlKGJ5dGVzKSk7XG4gICAgaWYgKHByaXYuY21wKG5zMikgPiAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBwcml2LmlhZGRuKDEpO1xuICAgIHJldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpO1xuICB9IHdoaWxlICh0cnVlKTtcbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiB0cnVuY2F0ZVRvTihtc2csIHRydW5jT25seSkge1xuICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcbiAgaWYgKGRlbHRhID4gMClcbiAgICBtc2cgPSBtc2cudXNocm4oZGVsdGEpO1xuICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gbXNnLnN1Yih0aGlzLm4pO1xuICBlbHNlXG4gICAgcmV0dXJuIG1zZztcbn07XG5cbkVDLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGtleSwgZW5jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZW5jID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIGtleSA9IHRoaXMua2V5RnJvbVByaXZhdGUoa2V5LCBlbmMpO1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIGtleSB0byBwcm92aWRlIGVub3VnaCBlbnRyb3B5XG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBia2V5ID0ga2V5LmdldFByaXZhdGUoKS50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBaZXJvLWV4dGVuZCBub25jZSB0byBoYXZlIHRoZSBzYW1lIGJ5dGUgc2l6ZSBhcyBOXG4gIHZhciBub25jZSA9IG1zZy50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgZWxsaXB0aWMuaG1hY0RSQkcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBlbnRyb3B5OiBia2V5LFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jXG4gIH0pO1xuXG4gIC8vIE51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZVxuICB2YXIgbnMxID0gdGhpcy5uLnN1YihuZXcgQk4oMSkpO1xuXG4gIGZvciAodmFyIGl0ZXIgPSAwOyB0cnVlOyBpdGVyKyspIHtcbiAgICB2YXIgayA9IG9wdGlvbnMuayA/XG4gICAgICAgIG9wdGlvbnMuayhpdGVyKSA6XG4gICAgICAgIG5ldyBCTihkcmJnLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtcbiAgICBrID0gdGhpcy5fdHJ1bmNhdGVUb04oaywgdHJ1ZSk7XG4gICAgaWYgKGsuY21wbigxKSA8PSAwIHx8IGsuY21wKG5zMSkgPj0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwID0gdGhpcy5nLm11bChrKTtcbiAgICBpZiAoa3AuaXNJbmZpbml0eSgpKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3BYID0ga3AuZ2V0WCgpO1xuICAgIHZhciByID0ga3BYLnVtb2QodGhpcy5uKTtcbiAgICBpZiAoci5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcyA9IGsuaW52bSh0aGlzLm4pLm11bChyLm11bChrZXkuZ2V0UHJpdmF0ZSgpKS5pYWRkKG1zZykpO1xuICAgIHMgPSBzLnVtb2QodGhpcy5uKTtcbiAgICBpZiAocy5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9IChrcC5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoa3BYLmNtcChyKSAhPT0gMCA/IDIgOiAwKTtcblxuICAgIC8vIFVzZSBjb21wbGVtZW50IG9mIGBzYCwgaWYgaXQgaXMgPiBgbiAvIDJgXG4gICAgaWYgKG9wdGlvbnMuY2Fub25pY2FsICYmIHMuY21wKHRoaXMubmgpID4gMCkge1xuICAgICAgcyA9IHRoaXMubi5zdWIocyk7XG4gICAgICByZWNvdmVyeVBhcmFtIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoeyByOiByLCBzOiBzLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuICB9XG59O1xuXG5FQy5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlLCBrZXksIGVuYykge1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuICBrZXkgPSB0aGlzLmtleUZyb21QdWJsaWMoa2V5LCBlbmMpO1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgJ2hleCcpO1xuXG4gIC8vIFBlcmZvcm0gcHJpbWl0aXZlIHZhbHVlcyB2YWxpZGF0aW9uXG4gIHZhciByID0gc2lnbmF0dXJlLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlLnM7XG4gIGlmIChyLmNtcG4oMSkgPCAwIHx8IHIuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChzLmNtcG4oMSkgPCAwIHx8IHMuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVmFsaWRhdGUgc2lnbmF0dXJlXG4gIHZhciBzaW52ID0gcy5pbnZtKHRoaXMubik7XG4gIHZhciB1MSA9IHNpbnYubXVsKG1zZykudW1vZCh0aGlzLm4pO1xuICB2YXIgdTIgPSBzaW52Lm11bChyKS51bW9kKHRoaXMubik7XG5cbiAgaWYgKCF0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2spIHtcbiAgICB2YXIgcCA9IHRoaXMuZy5tdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuICAgIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBwLmdldFgoKS51bW9kKHRoaXMubikuY21wKHIpID09PSAwO1xuICB9XG5cbiAgLy8gTk9URTogR3JlZyBNYXh3ZWxsJ3MgdHJpY2ssIGluc3BpcmVkIGJ5OlxuICAvLyBodHRwczovL2dpdC5pby92YWQzS1xuXG4gIHZhciBwID0gdGhpcy5nLmptdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIENvbXBhcmUgYHAueGAgb2YgSmFjb2JpYW4gcG9pbnQgd2l0aCBgcmAsXG4gIC8vIHRoaXMgd2lsbCBkbyBgcC54ID09IHIgKiBwLnpeMmAgaW5zdGVhZCBvZiBtdWx0aXBseWluZyBgcC54YCBieSB0aGVcbiAgLy8gaW52ZXJzZSBvZiBgcC56XjJgXG4gIHJldHVybiBwLmVxWFRvUChyKTtcbn07XG5cbkVDLnByb3RvdHlwZS5yZWNvdmVyUHViS2V5ID0gZnVuY3Rpb24obXNnLCBzaWduYXR1cmUsIGosIGVuYykge1xuICBhc3NlcnQoKDMgJiBqKSA9PT0gaiwgJ1RoZSByZWNvdmVyeSBwYXJhbSBpcyBtb3JlIHRoYW4gdHdvIGJpdHMnKTtcbiAgc2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZShzaWduYXR1cmUsIGVuYyk7XG5cbiAgdmFyIG4gPSB0aGlzLm47XG4gIHZhciBlID0gbmV3IEJOKG1zZyk7XG4gIHZhciByID0gc2lnbmF0dXJlLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlLnM7XG5cbiAgLy8gQSBzZXQgTFNCIHNpZ25pZmllcyB0aGF0IHRoZSB5LWNvb3JkaW5hdGUgaXMgb2RkXG4gIHZhciBpc1lPZGQgPSBqICYgMTtcbiAgdmFyIGlzU2Vjb25kS2V5ID0gaiA+PiAxO1xuICBpZiAoci5jbXAodGhpcy5jdXJ2ZS5wLnVtb2QodGhpcy5jdXJ2ZS5uKSkgPj0gMCAmJiBpc1NlY29uZEtleSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZScpO1xuXG4gIC8vIDEuMS4gTGV0IHggPSByICsgam4uXG4gIGlmIChpc1NlY29uZEtleSlcbiAgICByID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKHIuYWRkKHRoaXMuY3VydmUubiksIGlzWU9kZCk7XG4gIGVsc2VcbiAgICByID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKHIsIGlzWU9kZCk7XG5cbiAgdmFyIGVOZWcgPSBuLnN1YihlKTtcblxuICAvLyAxLjYuMSBDb21wdXRlIFEgPSByXi0xIChzUiAtICBlRylcbiAgLy8gICAgICAgICAgICAgICBRID0gcl4tMSAoc1IgKyAtZUcpXG4gIHZhciBySW52ID0gc2lnbmF0dXJlLnIuaW52bShuKTtcbiAgcmV0dXJuIHRoaXMuZy5tdWxBZGQoZU5lZywgciwgcykubXVsKHJJbnYpO1xufTtcblxuRUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbihlLCBzaWduYXR1cmUsIFEsIGVuYykge1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcbiAgaWYgKHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtICE9PSBudWxsKVxuICAgIHJldHVybiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUsIGkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChRcHJpbWUuZXEoUSkpXG4gICAgICByZXR1cm4gaTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcblxuZnVuY3Rpb24gS2V5UGFpcihlYywgb3B0aW9ucykge1xuICB0aGlzLmVjID0gZWM7XG4gIHRoaXMucHJpdiA9IG51bGw7XG4gIHRoaXMucHViID0gbnVsbDtcblxuICAvLyBLZXlQYWlyKGVjLCB7IHByaXY6IC4uLiwgcHViOiAuLi4gfSlcbiAgaWYgKG9wdGlvbnMucHJpdilcbiAgICB0aGlzLl9pbXBvcnRQcml2YXRlKG9wdGlvbnMucHJpdiwgb3B0aW9ucy5wcml2RW5jKTtcbiAgaWYgKG9wdGlvbnMucHViKVxuICAgIHRoaXMuX2ltcG9ydFB1YmxpYyhvcHRpb25zLnB1Yiwgb3B0aW9ucy5wdWJFbmMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyO1xuXG5LZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVjLCBwdWIsIGVuYykge1xuICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHViO1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHB1YjogcHViLFxuICAgIHB1YkVuYzogZW5jXG4gIH0pO1xufTtcblxuS2V5UGFpci5mcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGZyb21Qcml2YXRlKGVjLCBwcml2LCBlbmMpIHtcbiAgaWYgKHByaXYgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwcml2O1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHByaXY6IHByaXYsXG4gICAgcHJpdkVuYzogZW5jXG4gIH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cbiAgaWYgKHB1Yi5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgaXMgbm90IGEgcG9pbnQnIH07XG4gIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG4gIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgcmVhc29uOiBudWxsIH07XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG4gIC8vIGNvbXBhY3QgaXMgb3B0aW9uYWwgYXJndW1lbnRcbiAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgY29tcGFjdCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXRoaXMucHViKVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO1xuXG4gIGlmICghZW5jKVxuICAgIHJldHVybiB0aGlzLnB1YjtcblxuICByZXR1cm4gdGhpcy5wdWIuZW5jb2RlKGVuYywgY29tcGFjdCk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuICB0aGlzLnByaXYgPSBuZXcgQk4oa2V5LCBlbmMgfHwgMTYpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2RcbiAgdGhpcy5wcml2ID0gdGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSwgZW5jKSB7XG4gIGlmIChrZXkueCB8fCBrZXkueSkge1xuICAgIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChrZXkueCwga2V5LnkpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUuZGVjb2RlUG9pbnQoa2V5LCBlbmMpO1xufTtcblxuLy8gRUNESFxuS2V5UGFpci5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gZGVyaXZlKHB1Yikge1xuICByZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKTtcbn07XG5cbi8vIEVDRFNBXG5LZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5lYy5zaWduKG1zZywgdGhpcywgZW5jLCBvcHRpb25zKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSkge1xuICByZXR1cm4gdGhpcy5lYy52ZXJpZnkobXNnLCBzaWduYXR1cmUsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAnPEtleSBwcml2OiAnICsgKHRoaXMucHJpdiAmJiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpKSArXG4gICAgICAgICAnIHB1YjogJyArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgJyA+Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZShvcHRpb25zLCBlbmMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIG9wdGlvbnM7XG5cbiAgaWYgKHRoaXMuX2ltcG9ydERFUihvcHRpb25zLCBlbmMpKVxuICAgIHJldHVybjtcblxuICBhc3NlcnQob3B0aW9ucy5yICYmIG9wdGlvbnMucywgJ1NpZ25hdHVyZSB3aXRob3V0IHIgb3IgcycpO1xuICB0aGlzLnIgPSBuZXcgQk4ob3B0aW9ucy5yLCAxNik7XG4gIHRoaXMucyA9IG5ldyBCTihvcHRpb25zLnMsIDE2KTtcbiAgaWYgKG9wdGlvbnMucmVjb3ZlcnlQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG4gIGVsc2VcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBvcHRpb25zLnJlY292ZXJ5UGFyYW07XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hdHVyZTtcblxuZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gIHRoaXMucGxhY2UgPSAwO1xufVxuXG5mdW5jdGlvbiBnZXRMZW5ndGgoYnVmLCBwKSB7XG4gIHZhciBpbml0aWFsID0gYnVmW3AucGxhY2UrK107XG4gIGlmICghKGluaXRpYWwgJiAweDgwKSkge1xuICAgIHJldHVybiBpbml0aWFsO1xuICB9XG4gIHZhciBvY3RldExlbiA9IGluaXRpYWwgJiAweGY7XG4gIHZhciB2YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgb2ZmID0gcC5wbGFjZTsgaSA8IG9jdGV0TGVuOyBpKyssIG9mZisrKSB7XG4gICAgdmFsIDw8PSA4O1xuICAgIHZhbCB8PSBidWZbb2ZmXTtcbiAgfVxuICBwLnBsYWNlID0gb2ZmO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBybVBhZGRpbmcoYnVmKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLSAxO1xuICB3aGlsZSAoIWJ1ZltpXSAmJiAhKGJ1ZltpICsgMV0gJiAweDgwKSAmJiBpIDwgbGVuKSB7XG4gICAgaSsrO1xuICB9XG4gIGlmIChpID09PSAwKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gYnVmLnNsaWNlKGkpO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsIGVuYykge1xuICBkYXRhID0gdXRpbHMudG9BcnJheShkYXRhLCBlbmMpO1xuICB2YXIgcCA9IG5ldyBQb3NpdGlvbigpO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDMwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmICgobGVuICsgcC5wbGFjZSkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHJsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIHZhciByID0gZGF0YS5zbGljZShwLnBsYWNlLCBybGVuICsgcC5wbGFjZSk7XG4gIHAucGxhY2UgKz0gcmxlbjtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2xlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBzbGVuICsgcC5wbGFjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcyA9IGRhdGEuc2xpY2UocC5wbGFjZSwgc2xlbiArIHAucGxhY2UpO1xuICBpZiAoclswXSA9PT0gMCAmJiAoclsxXSAmIDB4ODApKSB7XG4gICAgciA9IHIuc2xpY2UoMSk7XG4gIH1cbiAgaWYgKHNbMF0gPT09IDAgJiYgKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG5cbiAgdGhpcy5yID0gbmV3IEJOKHIpO1xuICB0aGlzLnMgPSBuZXcgQk4ocyk7XG4gIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA8IDB4ODApIHtcbiAgICBhcnIucHVzaChsZW4pO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2N0ZXRzID0gMSArIChNYXRoLmxvZyhsZW4pIC8gTWF0aC5MTjIgPj4+IDMpO1xuICBhcnIucHVzaChvY3RldHMgfCAweDgwKTtcbiAgd2hpbGUgKC0tb2N0ZXRzKSB7XG4gICAgYXJyLnB1c2goKGxlbiA+Pj4gKG9jdGV0cyA8PCAzKSkgJiAweGZmKTtcbiAgfVxuICBhcnIucHVzaChsZW4pO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24gdG9ERVIoZW5jKSB7XG4gIHZhciByID0gdGhpcy5yLnRvQXJyYXkoKTtcbiAgdmFyIHMgPSB0aGlzLnMudG9BcnJheSgpO1xuXG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHJbMF0gJiAweDgwKVxuICAgIHIgPSBbIDAgXS5jb25jYXQocik7XG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHNbMF0gJiAweDgwKVxuICAgIHMgPSBbIDAgXS5jb25jYXQocyk7XG5cbiAgciA9IHJtUGFkZGluZyhyKTtcbiAgcyA9IHJtUGFkZGluZyhzKTtcblxuICB3aGlsZSAoIXNbMF0gJiYgIShzWzFdICYgMHg4MCkpIHtcbiAgICBzID0gcy5zbGljZSgxKTtcbiAgfVxuICB2YXIgYXJyID0gWyAweDAyIF07XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHIubGVuZ3RoKTtcbiAgYXJyID0gYXJyLmNvbmNhdChyKTtcbiAgYXJyLnB1c2goMHgwMik7XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHMubGVuZ3RoKTtcbiAgdmFyIGJhY2tIYWxmID0gYXJyLmNvbmNhdChzKTtcbiAgdmFyIHJlcyA9IFsgMHgzMCBdO1xuICBjb25zdHJ1Y3RMZW5ndGgocmVzLCBiYWNrSGFsZi5sZW5ndGgpO1xuICByZXMgPSByZXMuY29uY2F0KGJhY2tIYWxmKTtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgcGFyc2VCeXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXM7XG52YXIgS2V5UGFpciA9IHJlcXVpcmUoJy4va2V5Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcblxuZnVuY3Rpb24gRUREU0EoY3VydmUpIHtcbiAgYXNzZXJ0KGN1cnZlID09PSAnZWQyNTUxOScsICdvbmx5IHRlc3RlZCB3aXRoIGVkMjU1MTkgc28gZmFyJyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVERFNBKSlcbiAgICByZXR1cm4gbmV3IEVERFNBKGN1cnZlKTtcblxuICB2YXIgY3VydmUgPSBlbGxpcHRpYy5jdXJ2ZXNbY3VydmVdLmN1cnZlO1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMuZyA9IGN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKGN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICB0aGlzLnBvaW50Q2xhc3MgPSBjdXJ2ZS5wb2ludCgpLmNvbnN0cnVjdG9yO1xuICB0aGlzLmVuY29kaW5nTGVuZ3RoID0gTWF0aC5jZWlsKGN1cnZlLm4uYml0TGVuZ3RoKCkgLyA4KTtcbiAgdGhpcy5oYXNoID0gaGFzaC5zaGE1MTI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRUREU0E7XG5cbi8qKlxuKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gbWVzc2FnZSAtIG1lc3NhZ2UgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8S2V5UGFpcn0gc2VjcmV0IC0gc2VjcmV0IGJ5dGVzIG9yIGEga2V5cGFpclxuKiBAcmV0dXJucyB7U2lnbmF0dXJlfSAtIHNpZ25hdHVyZVxuKi9cbkVERFNBLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBzZWNyZXQpIHtcbiAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gIHZhciBrZXkgPSB0aGlzLmtleUZyb21TZWNyZXQoc2VjcmV0KTtcbiAgdmFyIHIgPSB0aGlzLmhhc2hJbnQoa2V5Lm1lc3NhZ2VQcmVmaXgoKSwgbWVzc2FnZSk7XG4gIHZhciBSID0gdGhpcy5nLm11bChyKTtcbiAgdmFyIFJlbmNvZGVkID0gdGhpcy5lbmNvZGVQb2ludChSKTtcbiAgdmFyIHNfID0gdGhpcy5oYXNoSW50KFJlbmNvZGVkLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSlcbiAgICAgICAgICAgICAgIC5tdWwoa2V5LnByaXYoKSk7XG4gIHZhciBTID0gci5hZGQoc18pLnVtb2QodGhpcy5jdXJ2ZS5uKTtcbiAgcmV0dXJuIHRoaXMubWFrZVNpZ25hdHVyZSh7IFI6IFIsIFM6IFMsIFJlbmNvZGVkOiBSZW5jb2RlZCB9KTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge0FycmF5fSBtZXNzYWdlIC0gbWVzc2FnZSBieXRlc1xuKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xTaWduYXR1cmV9IHNpZyAtIHNpZyBieXRlc1xuKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xQb2ludHxLZXlQYWlyfSBwdWIgLSBwdWJsaWMga2V5XG4qIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgcHVibGljIGtleSBtYXRjaGVzIHNpZyBvZiBtZXNzYWdlXG4qL1xuRUREU0EucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWcsIHB1Yikge1xuICBtZXNzYWdlID0gcGFyc2VCeXRlcyhtZXNzYWdlKTtcbiAgc2lnID0gdGhpcy5tYWtlU2lnbmF0dXJlKHNpZyk7XG4gIHZhciBrZXkgPSB0aGlzLmtleUZyb21QdWJsaWMocHViKTtcbiAgdmFyIGggPSB0aGlzLmhhc2hJbnQoc2lnLlJlbmNvZGVkKCksIGtleS5wdWJCeXRlcygpLCBtZXNzYWdlKTtcbiAgdmFyIFNHID0gdGhpcy5nLm11bChzaWcuUygpKTtcbiAgdmFyIFJwbHVzQWggPSBzaWcuUigpLmFkZChrZXkucHViKCkubXVsKGgpKTtcbiAgcmV0dXJuIFJwbHVzQWguZXEoU0cpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmhhc2hJbnQgPSBmdW5jdGlvbiBoYXNoSW50KCkge1xuICB2YXIgaGFzaCA9IHRoaXMuaGFzaCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICBoYXNoLnVwZGF0ZShhcmd1bWVudHNbaV0pO1xuICByZXR1cm4gdXRpbHMuaW50RnJvbUxFKGhhc2guZGlnZXN0KCkpLnVtb2QodGhpcy5jdXJ2ZS5uKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVB1YmxpYyh0aGlzLCBwdWIpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmtleUZyb21TZWNyZXQgPSBmdW5jdGlvbiBrZXlGcm9tU2VjcmV0KHNlY3JldCkge1xuICByZXR1cm4gS2V5UGFpci5mcm9tU2VjcmV0KHRoaXMsIHNlY3JldCk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUubWFrZVNpZ25hdHVyZSA9IGZ1bmN0aW9uIG1ha2VTaWduYXR1cmUoc2lnKSB7XG4gIGlmIChzaWcgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIHNpZztcbiAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcywgc2lnKTtcbn07XG5cbi8qKlxuKiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1qb3NlZnNzb24tZWRkc2EtZWQyNTUxOS0wMyNzZWN0aW9uLTUuMlxuKlxuKiBFRERTQSBkZWZpbmVzIG1ldGhvZHMgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBwb2ludHMgYW5kIGludGVnZXJzLiBUaGVzZSBhcmVcbiogaGVscGVyIGNvbnZlbmllbmNlIG1ldGhvZHMsIHRoYXQgcGFzcyBhbG9uZyB0byB1dGlsaXR5IGZ1bmN0aW9ucyBpbXBsaWVkXG4qIHBhcmFtZXRlcnMuXG4qXG4qL1xuRUREU0EucHJvdG90eXBlLmVuY29kZVBvaW50ID0gZnVuY3Rpb24gZW5jb2RlUG9pbnQocG9pbnQpIHtcbiAgdmFyIGVuYyA9IHBvaW50LmdldFkoKS50b0FycmF5KCdsZScsIHRoaXMuZW5jb2RpbmdMZW5ndGgpO1xuICBlbmNbdGhpcy5lbmNvZGluZ0xlbmd0aCAtIDFdIHw9IHBvaW50LmdldFgoKS5pc09kZCgpID8gMHg4MCA6IDA7XG4gIHJldHVybiBlbmM7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcykge1xuICBieXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXMoYnl0ZXMpO1xuXG4gIHZhciBsYXN0SXggPSBieXRlcy5sZW5ndGggLSAxO1xuICB2YXIgbm9ybWVkID0gYnl0ZXMuc2xpY2UoMCwgbGFzdEl4KS5jb25jYXQoYnl0ZXNbbGFzdEl4XSAmIH4weDgwKTtcbiAgdmFyIHhJc09kZCA9IChieXRlc1tsYXN0SXhdICYgMHg4MCkgIT09IDA7XG5cbiAgdmFyIHkgPSB1dGlscy5pbnRGcm9tTEUobm9ybWVkKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnRGcm9tWSh5LCB4SXNPZGQpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmVuY29kZUludCA9IGZ1bmN0aW9uIGVuY29kZUludChudW0pIHtcbiAgcmV0dXJuIG51bS50b0FycmF5KCdsZScsIHRoaXMuZW5jb2RpbmdMZW5ndGgpO1xufTtcblxuRUREU0EucHJvdG90eXBlLmRlY29kZUludCA9IGZ1bmN0aW9uIGRlY29kZUludChieXRlcykge1xuICByZXR1cm4gdXRpbHMuaW50RnJvbUxFKGJ5dGVzKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5pc1BvaW50ID0gZnVuY3Rpb24gaXNQb2ludCh2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIHRoaXMucG9pbnRDbGFzcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGxpcHRpYyA9IHJlcXVpcmUoJy4uLy4uL2VsbGlwdGljJyk7XG52YXIgdXRpbHMgPSBlbGxpcHRpYy51dGlscztcbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG52YXIgcGFyc2VCeXRlcyA9IHV0aWxzLnBhcnNlQnl0ZXM7XG52YXIgY2FjaGVkUHJvcGVydHkgPSB1dGlscy5jYWNoZWRQcm9wZXJ0eTtcblxuLyoqXG4qIEBwYXJhbSB7RUREU0F9IGVkZHNhIC0gaW5zdGFuY2VcbiogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHB1YmxpYy9wcml2YXRlIGtleSBwYXJhbWV0ZXJzXG4qXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZT59IFtwYXJhbXMuc2VjcmV0XSAtIHNlY3JldCBzZWVkIGJ5dGVzXG4qIEBwYXJhbSB7UG9pbnR9IFtwYXJhbXMucHViXSAtIHB1YmxpYyBrZXkgcG9pbnQgKGFrYSBgQWAgaW4gZWRkc2EgdGVybXMpXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZT59IFtwYXJhbXMucHViXSAtIHB1YmxpYyBrZXkgcG9pbnQgZW5jb2RlZCBhcyBieXRlc1xuKlxuKi9cbmZ1bmN0aW9uIEtleVBhaXIoZWRkc2EsIHBhcmFtcykge1xuICB0aGlzLmVkZHNhID0gZWRkc2E7XG4gIHRoaXMuX3NlY3JldCA9IHBhcnNlQnl0ZXMocGFyYW1zLnNlY3JldCk7XG4gIGlmIChlZGRzYS5pc1BvaW50KHBhcmFtcy5wdWIpKVxuICAgIHRoaXMuX3B1YiA9IHBhcmFtcy5wdWI7XG4gIGVsc2VcbiAgICB0aGlzLl9wdWJCeXRlcyA9IHBhcnNlQnl0ZXMocGFyYW1zLnB1Yik7XG59XG5cbktleVBhaXIuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMoZWRkc2EsIHB1Yikge1xuICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHViO1xuICByZXR1cm4gbmV3IEtleVBhaXIoZWRkc2EsIHsgcHViOiBwdWIgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21TZWNyZXQgPSBmdW5jdGlvbiBmcm9tU2VjcmV0KGVkZHNhLCBzZWNyZXQpIHtcbiAgaWYgKHNlY3JldCBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHNlY3JldDtcbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVkZHNhLCB7IHNlY3JldDogc2VjcmV0IH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuc2VjcmV0ID0gZnVuY3Rpb24gc2VjcmV0KCkge1xuICByZXR1cm4gdGhpcy5fc2VjcmV0O1xufTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3B1YkJ5dGVzJywgZnVuY3Rpb24gcHViQnl0ZXMoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZVBvaW50KHRoaXMucHViKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwdWInLCBmdW5jdGlvbiBwdWIoKSB7XG4gIGlmICh0aGlzLl9wdWJCeXRlcylcbiAgICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLl9wdWJCeXRlcyk7XG4gIHJldHVybiB0aGlzLmVkZHNhLmcubXVsKHRoaXMucHJpdigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHJpdkJ5dGVzJywgZnVuY3Rpb24gcHJpdkJ5dGVzKCkge1xuICB2YXIgZWRkc2EgPSB0aGlzLmVkZHNhO1xuICB2YXIgaGFzaCA9IHRoaXMuaGFzaCgpO1xuICB2YXIgbGFzdEl4ID0gZWRkc2EuZW5jb2RpbmdMZW5ndGggLSAxO1xuXG4gIHZhciBhID0gaGFzaC5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG4gIGFbMF0gJj0gMjQ4O1xuICBhW2xhc3RJeF0gJj0gMTI3O1xuICBhW2xhc3RJeF0gfD0gNjQ7XG5cbiAgcmV0dXJuIGE7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3ByaXYnLCBmdW5jdGlvbiBwcml2KCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVJbnQodGhpcy5wcml2Qnl0ZXMoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ2hhc2gnLCBmdW5jdGlvbiBoYXNoKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5oYXNoKCkudXBkYXRlKHRoaXMuc2VjcmV0KCkpLmRpZ2VzdCgpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdtZXNzYWdlUHJlZml4JywgZnVuY3Rpb24gbWVzc2FnZVByZWZpeCgpIHtcbiAgcmV0dXJuIHRoaXMuaGFzaCgpLnNsaWNlKHRoaXMuZWRkc2EuZW5jb2RpbmdMZW5ndGgpO1xufSk7XG5cbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UpIHtcbiAgYXNzZXJ0KHRoaXMuX3NlY3JldCwgJ0tleVBhaXIgY2FuIG9ubHkgdmVyaWZ5Jyk7XG4gIHJldHVybiB0aGlzLmVkZHNhLnNpZ24obWVzc2FnZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLnZlcmlmeShtZXNzYWdlLCBzaWcsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0U2VjcmV0ID0gZnVuY3Rpb24gZ2V0U2VjcmV0KGVuYykge1xuICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBpcyBwdWJsaWMgb25seScpO1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMuc2VjcmV0KCksIGVuYyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoZW5jKSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5wdWJCeXRlcygpLCBlbmMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWlyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBlZGRzYSBpbnN0YW5jZVxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxPYmplY3R9IHNpZyAtXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fFBvaW50fSBbc2lnLlJdIC0gUiBwb2ludCBhcyBQb2ludCBvciBieXRlc1xuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxibn0gW3NpZy5TXSAtIFMgc2NhbGFyIGFzIGJuIG9yIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fSBbc2lnLlJlbmNvZGVkXSAtIFIgcG9pbnQgZW5jb2RlZFxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPn0gW3NpZy5TZW5jb2RlZF0gLSBTIHNjYWxhciBlbmNvZGVkXG4qL1xuZnVuY3Rpb24gU2lnbmF0dXJlKGVkZHNhLCBzaWcpIHtcbiAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuXG4gIGlmICh0eXBlb2Ygc2lnICE9PSAnb2JqZWN0JylcbiAgICBzaWcgPSBwYXJzZUJ5dGVzKHNpZyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHNpZyA9IHtcbiAgICAgIFI6IHNpZy5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCksXG4gICAgICBTOiBzaWcuc2xpY2UoZWRkc2EuZW5jb2RpbmdMZW5ndGgpXG4gICAgfTtcbiAgfVxuXG4gIGFzc2VydChzaWcuUiAmJiBzaWcuUywgJ1NpZ25hdHVyZSB3aXRob3V0IFIgb3IgUycpO1xuXG4gIGlmIChlZGRzYS5pc1BvaW50KHNpZy5SKSlcbiAgICB0aGlzLl9SID0gc2lnLlI7XG4gIGlmIChzaWcuUyBpbnN0YW5jZW9mIEJOKVxuICAgIHRoaXMuX1MgPSBzaWcuUztcblxuICB0aGlzLl9SZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoc2lnLlIpID8gc2lnLlIgOiBzaWcuUmVuY29kZWQ7XG4gIHRoaXMuX1NlbmNvZGVkID0gQXJyYXkuaXNBcnJheShzaWcuUykgPyBzaWcuUyA6IHNpZy5TZW5jb2RlZDtcbn1cblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnUycsIGZ1bmN0aW9uIFMoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLlNlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1InLCBmdW5jdGlvbiBSKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVQb2ludCh0aGlzLlJlbmNvZGVkKCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1JlbmNvZGVkJywgZnVuY3Rpb24gUmVuY29kZWQoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmVuY29kZVBvaW50KHRoaXMuUigpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdTZW5jb2RlZCcsIGZ1bmN0aW9uIFNlbmNvZGVkKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVJbnQodGhpcy5TKCkpO1xufSk7XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMoKSB7XG4gIHJldHVybiB0aGlzLlJlbmNvZGVkKCkuY29uY2F0KHRoaXMuU2VuY29kZWQoKSk7XG59O1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24gdG9IZXgoKSB7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy50b0J5dGVzKCksICdoZXgnKS50b1VwcGVyQ2FzZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnaGFzaC5qcycpO1xudmFyIGVsbGlwdGljID0gcmVxdWlyZSgnLi4vZWxsaXB0aWMnKTtcbnZhciB1dGlscyA9IGVsbGlwdGljLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gSG1hY0RSQkcob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hY0RSQkcpKVxuICAgIHJldHVybiBuZXcgSG1hY0RSQkcob3B0aW9ucyk7XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcbiAgdGhpcy5wcmVkUmVzaXN0ID0gISFvcHRpb25zLnByZWRSZXNpc3Q7XG5cbiAgdGhpcy5vdXRMZW4gPSB0aGlzLmhhc2gub3V0U2l6ZTtcbiAgdGhpcy5taW5FbnRyb3B5ID0gb3B0aW9ucy5taW5FbnRyb3B5IHx8IHRoaXMuaGFzaC5obWFjU3RyZW5ndGg7XG5cbiAgdGhpcy5yZXNlZWQgPSBudWxsO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gbnVsbDtcbiAgdGhpcy5LID0gbnVsbDtcbiAgdGhpcy5WID0gbnVsbDtcblxuICB2YXIgZW50cm9weSA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5lbnRyb3B5LCBvcHRpb25zLmVudHJvcHlFbmMpO1xuICB2YXIgbm9uY2UgPSB1dGlscy50b0FycmF5KG9wdGlvbnMubm9uY2UsIG9wdGlvbnMubm9uY2VFbmMpO1xuICB2YXIgcGVycyA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5wZXJzLCBvcHRpb25zLnBlcnNFbmMpO1xuICBhc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hY0RSQkc7XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpIHtcbiAgdmFyIHNlZWQgPSBlbnRyb3B5LmNvbmNhdChub25jZSkuY29uY2F0KHBlcnMpO1xuXG4gIHRoaXMuSyA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICB0aGlzLlYgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLlYubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLktbaV0gPSAweDAwO1xuICAgIHRoaXMuVltpXSA9IDB4MDE7XG4gIH1cblxuICB0aGlzLl91cGRhdGUoc2VlZCk7XG4gIHRoaXMucmVzZWVkID0gMTtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IDB4MTAwMDAwMDAwMDAwMDsgIC8vIDJeNDhcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faG1hYyA9IGZ1bmN0aW9uIGhtYWMoKSB7XG4gIHJldHVybiBuZXcgaGFzaC5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWQpIHtcbiAgdmFyIGttYWMgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAwIF0pO1xuICBpZiAoc2VlZClcbiAgICBrbWFjID0ga21hYy51cGRhdGUoc2VlZCk7XG4gIHRoaXMuSyA9IGttYWMuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgaWYgKCFzZWVkKVxuICAgIHJldHVybjtcblxuICB0aGlzLksgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDEgXSlcbiAgICAgICAgICAgICAgIC51cGRhdGUoc2VlZClcbiAgICAgICAgICAgICAgIC5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLnJlc2VlZCA9IGZ1bmN0aW9uIHJlc2VlZChlbnRyb3B5LCBlbnRyb3B5RW5jLCBhZGQsIGFkZEVuYykge1xuICAvLyBPcHRpb25hbCBlbnRyb3B5IGVuY1xuICBpZiAodHlwZW9mIGVudHJvcHlFbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVudHJvcHlFbmM7XG4gICAgZW50cm9weUVuYyA9IG51bGw7XG4gIH1cblxuICBlbnRyb3B5ID0gdXRpbHMudG9CdWZmZXIoZW50cm9weSwgZW50cm9weUVuYyk7XG4gIGFkZCA9IHV0aWxzLnRvQnVmZmVyKGFkZCwgYWRkRW5jKTtcblxuICBhc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuXG4gIHRoaXMuX3VwZGF0ZShlbnRyb3B5LmNvbmNhdChhZGQgfHwgW10pKTtcbiAgdGhpcy5yZXNlZWQgPSAxO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuLCBlbmMsIGFkZCwgYWRkRW5jKSB7XG4gIGlmICh0aGlzLnJlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cblxuICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcbiAgaWYgKGFkZCkge1xuICAgIGFkZCA9IHV0aWxzLnRvQXJyYXkoYWRkLCBhZGRFbmMpO1xuICAgIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB9XG5cbiAgdmFyIHRlbXAgPSBbXTtcbiAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbGVuKSB7XG4gICAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICAgIHRlbXAgPSB0ZW1wLmNvbmNhdCh0aGlzLlYpO1xuICB9XG5cbiAgdmFyIHJlcyA9IHRlbXAuc2xpY2UoMCwgbGVuKTtcbiAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIHRoaXMucmVzZWVkKys7XG4gIHJldHVybiB1dGlscy5lbmNvZGUocmVzLCBlbmMpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBkb3VibGVzOiB7XG4gICAgc3RlcDogNCxcbiAgICBwb2ludHM6IFtcbiAgICAgIFtcbiAgICAgICAgJ2U2MGZjZTkzYjU5ZTllYzUzMDExYWFiYzIxYzIzZTk3YjJhMzEzNjliODdhNWFlOWM0NGVlODllMmE2ZGVjMGEnLFxuICAgICAgICAnZjdlMzUwNzM5OWU1OTU5MjlkYjk5ZjM0ZjU3OTM3MTAxMjk2ODkxZTQ0ZDIzZjBiZTFmMzJjY2U2OTYxNjgyMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MjgyMjYzMjEyYzYwOWQ5ZWEyYTZlM2UxNzJkZTIzOGQ4YzM5Y2FiZDVhYzFjYTEwNjQ2ZTIzZmQ1ZjUxNTA4JyxcbiAgICAgICAgJzExZjhhODA5ODU1N2RmZTQ1ZTgyNTZlODMwYjYwYWNlNjJkNjEzYWMyZjdiMTdiZWQzMWI2ZWFmZjZlMjZjYWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTc1ZTE1OWY3MjhiODY1YTcyZjk5Y2M2YzZmYzg0NmRlMGI5MzgzM2ZkMjIyMmVkNzNmY2U1YjU1MWU1YjczOScsXG4gICAgICAgICdkMzUwNmUwZDllM2M3OWViYTRlZjk3YTUxZmY3MWY1ZWFjYjU5NTVhZGQyNDM0NWM2ZWZhNmZmZWU5ZmVkNjk1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM2M2Q5MGQ0NDdiMDBjOWM5OWNlYWMwNWI2MjYyZWUwNTM0NDFjN2U1NTU1MmZmZTUyNmJhZDhmODNmZjQ2NDAnLFxuICAgICAgICAnNGUyNzNhZGZjNzMyMjIxOTUzYjQ0NTM5N2YzMzYzMTQ1YjlhODkwMDgxOTllY2I2MjAwM2M3ZjNiZWU5ZGU5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhiNGI1ZjE2NWRmM2MyYmU4YzYyNDRiNWI3NDU2Mzg4NDNlNGE3ODFhMTViY2QxYjY5Zjc5YTU1ZGZmZGY4MGMnLFxuICAgICAgICAnNGFhZDBhNmY2OGQzMDhiNGIzZmJkNzgxM2FiMGRhMDRmOWUzMzY1NDYxNjJlZTU2YjNlZmYwYzY1ZmQ0ZmQzNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3MjNjYmFhNmU1ZGI5OTZkNmJmNzcxYzAwYmQ1NDhjN2I3MDBkYmZmYTZjMGU3N2JjYjYxMTU5MjUyMzJmY2RhJyxcbiAgICAgICAgJzk2ZTg2N2I1NTk1Y2M0OThhOTIxMTM3NDg4ODI0ZDZlMjY2MGEwNjUzNzc5NDk0ODAxZGMwNjlkOWViMzlmNWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWViZmE0ZDQ5M2JlYmY5OGJhNWZlZWM4MTJjMmQzYjUwOTQ3OTYxMjM3YTkxOTgzOWE1MzNlY2EwZTdkZDdmYScsXG4gICAgICAgICc1ZDlhOGNhMzk3MGVmMGYyNjllZTdlZGFmMTc4MDg5ZDlhZTRjZGMzYTcxMWY3MTJkZGZkNGZkYWUxZGU4OTk5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEwMGY0NGRhNjk2ZTcxNjcyNzkxZDBhMDliN2JkZTQ1OWYxMjE1YTI5YjNjMDNiZmVmZDc4MzViMzlhNDhkYjAnLFxuICAgICAgICAnY2RkOWUxMzE5MmEwMGI3NzJlYzhmMzMwMGMwOTA2NjZiN2ZmNGExOGZmNTE5NWFjMGZiZDVjZDYyYmM2NWEwOSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMTAzMWJlMjYyYzdlZDFiMWRjOTIyN2E0YTA0YzAxN2E3N2Y4ZDQ0NjRmM2IzODUyYzhhY2RlNmU1MzRmZDJkJyxcbiAgICAgICAgJzlkNzA2MTkyODk0MDQwNWU2YmI2YTQxNzY1OTc1MzVhZjI5MmRkNDE5ZTFjZWQ3OWE0NGYxOGYyOTQ1NmEwMGQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmVlYTZjYWU0NmQ1NWI1MzBhYzI4MzlmMTQzYmQ3ZWM1Y2Y4YjI2NmE0MWQ2YWY1MmQ1ZTY4OGQ5MDk0Njk2ZCcsXG4gICAgICAgICdlNTdjNmI2Yzk3ZGNlMWJhYjA2ZTRlMTJiZjNlY2Q1Yzk4MWM4OTU3Y2M0MTQ0MmQzMTU1ZGViZjE4MDkwMDg4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhNjdhOTFkOTEwNDljZGNiMzY3YmU0YmU2ZmZjYTNjZmVlZDY1N2Q4MDg1ODNkZTMzZmE5NzhiYzFlYzZjYjEnLFxuICAgICAgICAnOWJhY2FhMzU0ODE2NDJiYzQxZjQ2M2Y3ZWM5NzgwZTVkZWM3YWRjNTA4Zjc0MGExN2U5ZWE4ZTI3YTY4YmUxZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MzkwNGZhYTBiMzM0Y2RkYTZlMDAwOTM1ZWYyMjE1MWVjMDhkMGY3YmIxMTA2OWY1NzU0NWNjYzFhMzdiN2MwJyxcbiAgICAgICAgJzViYzA4N2QwYmM4MDEwNmQ4OGM5ZWNjYWMyMGQzYzFjMTM5OTk5ODFlMTQ0MzQ2OTlkY2IwOTZiMDIyNzcxYzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGU3YmNkMGJkMzU5ODNhNzcxOWNjYTc3NjRjYTkwNjc3OWI1M2EwNDNhOWI4YmNhZWZmOTU5ZjQzYWQ4NjA0NycsXG4gICAgICAgICcxMGI3NzcwYjJhM2RhNGIzOTQwMzEwNDIwY2E5NTE0NTc5ZTg4ZTJlNDdmZDY4YjNlYTEwMDQ3ZTg0NjAzNzJhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM4NWVlZDM0YzFjZGZmMjFlNmQwODE4Njg5YjgxYmRlNzFhN2Y0ZjE4Mzk3ZTY2OTBhODQxZTE1OTljNDM4NjInLFxuICAgICAgICAnMjgzYmViYzNlOGVhMjNmNTY3MDFkZTE5ZTllYmY0NTc2YjMwNGVlYzIwODZkYzhjYzA0NThmZTU1NDJlNTQ1MydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2ZjlkOWI4MDNlY2YxOTE2MzdjNzNhNDQxM2RmYTE4MGZkZGY4NGE1OTQ3ZmJjOWM2MDZlZDg2YzNmYWMzYTcnLFxuICAgICAgICAnN2M4MGM2OGU2MDMwNTliYTY5YjhlMmEzMGU0NWM0ZDQ3ZWE0ZGQyZjVjMjgxMDAyZDg2ODkwNjAzYTg0MjE2MCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMzIyZDQwMTI0M2M0ZTI1ODJhMjE0N2MxMDRkNmVjYmY3NzRkMTYzZGIwZjVlNTMxM2I3ZTBlNzQyZDBlNmJkJyxcbiAgICAgICAgJzU2ZTcwNzk3ZTk2NjRlZjViZmIwMTliYzRkZGFmOWI3MjgwNWY2M2VhMjg3M2FmNjI0ZjNhMmU5NmMyOGIyYTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODU2NzJjN2QyZGUwYjdkYTJiZDE3NzBkODk2NjU4Njg3NDFiM2Y5YWY3NjQzMzk3NzIxZDc0ZDI4MTM0YWI4MycsXG4gICAgICAgICc3YzQ4MWI5YjViNDNiMmViNjM3NDA0OWJmYTYyYzJlNWU3N2YxN2ZjYzUyOThmNDRjOGUzMDk0Zjc5MDMxM2E2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk0OGJmODA5YjE5ODhhNDZiMDZjOWYxOTE5NDEzYjEwZjkyMjZjNjBmNjY4ODMyZmZkOTU5YWY2MGM4MmEwYScsXG4gICAgICAgICc1M2E1NjI4NTZkY2I2NjQ2ZGM2Yjc0YzVkMWMzNDE4YzZkNGRmZjA4Yzk3Y2QyYmVkNGNiN2Y4OGQ4YzhlNTg5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYyNjBjZTdmNDYxODAxYzM0ZjA2N2NlMGYwMjg3M2E4ZjFiMGU0NGRmYzY5NzUyYWNjZWNkODE5ZjM4ZmQ4ZTgnLFxuICAgICAgICAnYmMyZGE4MmI2ZmE1YjU3MWE3ZjA5MDQ5Nzc2YTFlZjdlY2QyOTIyMzgwNTFjMTk4YzFhODRlOTViMmI0YWUxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNTAzN2RlMGFmYzFkOGQ0M2Q4MzQ4NDE0YmJmNDEwMzA0M2VjOGY1NzViZmRjNDMyOTUzY2M4ZDIwMzdmYTJkJyxcbiAgICAgICAgJzQ1NzE1MzRiYWE5NGQzYjVmOWY5OGQwOWZiOTkwYmRkYmQ1ZjViMDNlYzQ4MWYxMGUwZTVkYzg0MWQ3NTViZGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTA2MzcyYjBmNGEyMDdhZGY1ZWE5MDVlOGYxNzcxYjRlN2U4ZGJkMWM2YTZjNWI3MjU4NjZhMGFlNGZjZTcyNScsXG4gICAgICAgICc3YTkwODk3NGJjZTE4Y2ZlMTJhMjdiYjJhZDVhNDg4Y2Q3NDg0YTc3ODcxMDQ4NzBiMjcwMzRmOTRlZWUzMWRkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzIxM2M3YTcxNWNkNWQ0NTM1OGQwYmJmOWRjMGNlMDIyMDRiMTBiZGRlMmEzZjU4NTQwYWQ2OTA4ZDA1NTk3NTQnLFxuICAgICAgICAnNGI2ZGFkMGI1YWU0NjI1MDcwMTNhZDA2MjQ1YmExOTBiYjQ4NTBmNWYzNmE3ZWVkZGZmMmMyNzUzNGI0NThmMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZTdjMjcyYTdhZjRiMzRlOGRiYjkzNTJhNTQxOWE4N2UyODM4YzcwYWRjNjJjZGRmMGNjM2EzYjA4ZmJkNTNjJyxcbiAgICAgICAgJzE3NzQ5Yzc2NmM5ZDBiMThlMTZmZDA5ZjZkZWY2ODFiNTMwYjk2MTRiZmY3ZGQzM2UwYjM5NDE4MTdkY2FhZTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZmVhNzRlM2RiZTc3OGIxYjEwZjIzOGFkNjE2ODZhYTVjNzZlM2RiMmJlNDMwNTc2MzI0MjdlMjg0MGZiMjdiNicsXG4gICAgICAgICc2ZTA1NjhkYjliMGIxMzI5N2NmNjc0ZGVjY2I2YWY5MzEyNmI1OTZiOTczZjdiNzc3MDFkM2RiN2YyM2NiOTZmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2ZTY0MTEzZjY3N2NmMGUxMGEyNTcwZDU5OTk2OGQzMTU0NGUxNzliNzYwNDMyOTUyYzAyYTQ0MTdiZGRlMzknLFxuICAgICAgICAnYzkwZGRmOGRlZTRlOTVjZjU3NzA2NmQ3MDY4MWYwZDM1ZTJhMzNkMmI1NmQyMDMyYjRiMTc1MmQxOTAxYWMwMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNzM4YzU2YjAzYjJhYmUxZTgyODFiYWE3NDNmOGY5YThmN2NjNjQzZGYyNmNiZWUzYWIxNTAyNDJiY2JiODkxJyxcbiAgICAgICAgJzg5M2ZiNTc4OTUxYWQyNTM3ZjcxOGYyZWFjYmZiYmJiODIzMTRlZWY3ODgwY2ZlOTE3ZTczNWQ5Njk5YTg0YzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDg5NTYyNjU0OGI2NWI4MWUyNjRjNzYzN2M5NzI4NzdkMWQ3MmU1ZjNhOTI1MDE0MzcyZTlmNjU4OGY2YzE0YicsXG4gICAgICAgICdmZWJmYWEzOGYyYmM3ZWFlNzI4ZWM2MDgxOGMzNDBlYjAzNDI4ZDYzMmJiMDY3ZTE3OTM2M2VkNzVkN2Q5OTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I4ZGE5NDAzMmE5NTc1MThlYjBmNjQzMzU3MWU4NzYxY2VmZmM3MzY5M2U4NGVkZDQ5MTUwYTU2NGY2NzZlMDMnLFxuICAgICAgICAnMjgwNGRmYTQ0ODA1YTFlNGQ3Yzk5Y2M5NzYyODA4YjA5MmNjNTg0ZDk1ZmYzYjUxMTQ4OGU0ZTc0ZWZkZjZlNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlODBmZWExNDQ0MWZiMzNhN2Q4YWRhYjk0NzVkN2ZhYjIwMTllZmZiNTE1NmE3OTJmMWExMTc3OGUzYzBkZjVkJyxcbiAgICAgICAgJ2VlZDFkZTdmNjM4ZTAwNzcxZTg5NzY4Y2EzY2E5NDQ3MmQxNTVlODBhZjMyMmVhOWZjYjQyOTFiNmFjOWVjNzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTMwMTY5N2JkZmNkNzA0MzEzYmE0OGU1MWQ1Njc1NDNmMmExODIwMzFlZmQ2OTE1ZGRjMDdiYmNjNGUxNjA3MCcsXG4gICAgICAgICc3MzcwZjkxY2ZiNjdlNGY1MDgxODA5ZmEyNWQ0MGY5YjE3MzVkYmY3YzBhMTFhMTMwYzBkMWEwNDFlMTc3ZWExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkwYWQ4NWIzODlkNmI5MzY0NjNmOWQwNTEyNjc4ZGUyMDhjYzMzMGIxMTMwN2ZmZmFiN2FjNjNlM2ZiMDRlZDQnLFxuICAgICAgICAnZTUwN2EzNjIwYTM4MjYxYWZmZGNiZDk0MjcyMjJiODM5YWVmYWJlMTU4Mjg5NGQ5OTFkNGQ0OGNiNmVmMTUwJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhmNjhiOWQyZjYzYjVmMzM5MjM5YzFhZDk4MWYxNjJlZTg4YzU2Nzg3MjNlYTMzNTFiN2I0NDRjOWVjNGMwZGEnLFxuICAgICAgICAnNjYyYTlmMmRiYTA2Mzk4NmRlMWQ5MGMyYjZiZTIxNWRiYmVhMmNmZTk1NTEwYmZkZjIzY2JmNzk1MDFmZmY4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNGYzZmIwMTc2YWY4NWQ2NWZmOTlmZjkxOThjMzYwOTFmNDhlODY1MDM2ODFlM2U2Njg2ZmQ1MDUzMjMxZTExJyxcbiAgICAgICAgJzFlNjM2MzNhZDBlZjRmMWMxNjYxYTZkMGVhMDJiNzI4NmNjN2U3NGVjOTUxZDFjOTgyMmMzODU3NmZlYjczYmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGMwMGZhOWIxOGViZjMzMWViOTYxNTM3YTQ1YTQyNjZjNzAzNGYyZjBkNGUxZDA3MTZmYjZlYWUyMGVhZTI5ZScsXG4gICAgICAgICdlZmE0NzI2N2ZlYTUyMWExYTlkYzM0M2EzNzM2Yzk3NGMyZmFkYWZhODFlMzZjNTRlN2QyYTRjNjY3MDI0MTRiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3YTI2Y2U2OWRkNDgyOWYzZTEwY2VjMGE5ZTk4ZWQzMTQzZDA4NGYzMDhiOTJjMDk5N2ZkZGZjNjBjYjNlNDEnLFxuICAgICAgICAnMmE3NThlMzAwZmE3OTg0YjQ3MWIwMDZhMWFhZmJiMThkMGE2YjJjMDQyMGU4M2UyMGU4YTk0MjFjZjJjZmQ1MSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiNjQ1OWUwZWUzNjYyZWM4ZDIzNTQwYzIyM2JjYmRjNTcxY2JjYjk2N2Q3OTQyNGYzY2YyOWViM2RlNmI4MGVmJyxcbiAgICAgICAgJzY3Yzg3NmQwNmYzZTA2ZGUxZGFkZjE2ZTU2NjFkYjNjNGIzYWU2ZDQ4ZTM1YjJmZjMwYmYwYjYxYTcxYmE0NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNjhhODBjODI4MGJiODQwNzkzMjM0YWExMThmMDYyMzFkNmYxZmM2N2U3M2M1YTVkZWRhMGY1YjQ5Njk0M2U4JyxcbiAgICAgICAgJ2RiOGJhOWZmZjRiNTg2ZDAwYzRiMWY5MTc3YjBlMjhiNWIwZTdiOGY3ODQ1Mjk1YTI5NGM4NDI2NmIxMzMxMjAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzI0YWVkN2RmNjVjODA0MjUyZGMwMjcwOTA3YTMwYjA5NjEyYWViOTczNDQ5Y2VhNDA5NTk4MGZjMjhkM2Q1ZCcsXG4gICAgICAgICc2NDhhMzY1Nzc0YjYxZjJmZjEzMGMwYzM1YWVjMWY0ZjE5MjEzYjBjN2UzMzI4NDM5NjcyMjRhZjk2YWI3Yzg0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRkZjljMTQ5MTljZGU2MWY2ZDUxZGZkYmU1ZmVlNWRjZWVjNDE0M2JhOGQxY2E4ODhlOGJkMzczZmQwNTRjOTYnLFxuICAgICAgICAnMzVlYzUxMDkyZDg3MjgwNTA5NzRjMjNhMWQ4NWQ0YjVkNTA2Y2RjMjg4NDkwMTkyZWJhYzA2Y2FkMTBkNWQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOWMzOTE5YTg0YTQ3NDg3MGZhZWQ4YTljMWNjNjYwMjE1MjM0ODkwNTRkN2YwMzA4Y2JmYzk5YzhhYzFmOThjZCcsXG4gICAgICAgICdkZGI4NGYwZjRhNGRkZDU3NTg0ZjA0NGJmMjYwZTY0MTkwNTMyNmY3NmM2NGM4ZTZiZTdlNWUwM2Q0ZmM1OTlkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNTcxNzBiMWRkMTJmZGY4ZGUwNWYyODFkOGUwNmJiOTFlMTQ5M2E4YjkxZDRjYzVhMjEzODIxMjBhOTU5ZTUnLFxuICAgICAgICAnOWExYWYwYjI2YTZhNDgwN2FkZDlhMmRhZjcxZGYyNjI0NjUxNTJiYzNlZTI0YzY1ZTg5OWJlOTMyMzg1YTJhOCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNTc2ZGY4ZTIzYTA4NDExNDIxNDM5YTQ1MThkYTMxODgwY2VmMGZiYTdkNGRmMTJiMWE2OTczZWVjYjk0MjY2JyxcbiAgICAgICAgJzQwYTZiZjIwZTc2NjQwYjJjOTJiOTdhZmU1OGNkODJjNDMyZTEwYTdmNTE0ZDlmM2VlOGJlMTFhZTFiMjhlYzgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc3OGE3OGMyOGRlYzNlMzBhMDVmZTk2MjlkZThjMzhiYjMwZDFmNWNmOWEzYTIwOGY3NjM4ODliZTU4YWQ3MScsXG4gICAgICAgICczNDYyNmQ5YWI1YTViMjJmZjcwOThlMTJmMmZmNTgwMDg3YjM4NDExZmYyNGFjNTYzYjUxM2ZjMWZkOWY0M2FjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkyODk1NWVlNjM3YTg0NDYzNzI5ZmQzMGU3YWZkMmVkNWY5NjI3NGU1YWQ3ZTVjYjA5ZWRhOWMwNmQ5MDNhYycsXG4gICAgICAgICdjMjU2MjEwMDNkM2Y0MmE4MjdiNzhhMTMwOTNhOTVlZWFjM2QyNmVmYThhOGQ4M2ZjNTE4MGU5MzViY2QwOTFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1ZDBmZWYzZWM2ZGIxMDkzOTkwNjRmM2EwZTNiMjg1NTY0NWI0YTkwN2FkMzU0NTI3YWFlNzUxNjNkODI3NTEnLFxuICAgICAgICAnMWYwMzY0ODQxM2EzOGMwYmUyOWQ0OTZlNTgyY2Y1NjYzZTg3NTFlOTY4NzczMzE1ODJjMjM3YTI0ZWIxZjk2MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZjJiMGRjZTk3ZWVjZTk3YzFjOWI2MDQxNzk4Yjg1ZGZkZmI2ZDg4ODJkYTIwMzA4ZjU0MDQ4MjQ1MjYwODdlJyxcbiAgICAgICAgJzQ5M2QxM2ZlZjUyNGJhMTg4YWY0YzRkYzU0ZDA3OTM2YzdiN2VkNmZiOTBlMmNlYjJjOTUxZTAxZjBjMjk5MDcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODI3ZmJiZTRiMWU4ODBlYTllZDJiMmU2MzAxYjIxMmI1N2YxZWUxNDhjZDZkZDI4NzgwZTVlMmNmODU2ZTI0MScsXG4gICAgICAgICdjNjBmOWM5MjNjNzI3YjBiNzFiZWYyYzY3ZDFkMTI2ODdmZjdhNjMxODY5MDMxNjZkNjA1YjY4YmFlYzI5M2VjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhYTY0OWYyMWY1MWJkYmFlN2JlNGFlMzRjZTZlNTIxN2E1OGZkY2U3ZjQ3ZjlhYTdmM2I1OGZhMjEyMGUyYjMnLFxuICAgICAgICAnYmUzMjc5ZWQ1YmJiYjAzYWM2OWE4MGY4OTg3OWFhNWEwMWE2Yjk2NWYxM2Y3ZTU5ZDQ3YTUzMDViYTVhZDkzZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNGE0MmQ0M2M1Y2YxNjlkOTM5MWRmNmRlY2Y0MmVlNTQxYjZkOGYwYzlhMTM3NDAxZTIzNjMyZGRhMzRkMjRmJyxcbiAgICAgICAgJzRkOWY5MmU3MTZkMWM3MzUyNmZjOTljY2ZiOGFkMzRjZTg4NmVlZGZhOGQ4ZTRmMTNhN2Y3MTMxZGViYTk0MTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWVjODBmZWYzNjBjYmRkOTU0MTYwZmFkYWIzNTJiNmI5MmI1MzU3NmE4OGZlYTQ5NDcxNzNiOWQ0MzAwYmYxOScsXG4gICAgICAgICdhZWVmZTkzNzU2YjUzNDBkMmYzYTQ5NThhN2FiYmY1ZTAxNDZlNzdmNjI5NWEwN2I2NzFjZGMxY2MxMDdjZWZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE0NmE3NzhjMDQ2NzBjMmY5MWIwMGFmNDY4MGRmYThiY2UzNDkwNzE3ZDU4YmE4ODlkZGI1OTI4MzY2NjQyYmUnLFxuICAgICAgICAnYjMxOGUwZWMzMzU0MDI4YWRkNjY5ODI3ZjlkNGIyODcwYWFhOTcxZDJmN2U1ZWQxZDBiMjk3NDgzZDgzZWZkMCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmYTUwYzBmNjFkMjJlNWYwN2UzYWNlYmIxYWEwN2IxMjhkMDAxMjIwOWEyOGI5Nzc2ZDc2YTg3OTMxODBlZWY5JyxcbiAgICAgICAgJzZiODRjNjkyMjM5N2ViYTliNzJjZDI4NzIyODFhNjhhNWU2ODMyOTNhNTdhMjEzYjM4Y2Q4ZDdkM2Y0ZjI4MTEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGExZDYxZDBjYTcyMWExMWIxYTViZjZiN2Q4OGU4NDIxYTI4OGFiNWQ1YmJhNTIyMGU1M2QzMmI1ZjA2N2VjMicsXG4gICAgICAgICc4MTU3ZjU1YTdjOTkzMDZjNzljMDc2NjE2MWM5MWUyOTY2YTczODk5ZDI3OWI0OGE2NTVmYmEwZjFhZDgzNmYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E4ZTI4MmZmMGM5NzA2OTA3MjE1ZmY5OGU4ZmQ0MTY2MTUzMTFkZTA0NDZmMWUwNjJhNzNiMDYxMGQwNjRlMTMnLFxuICAgICAgICAnN2Y5NzM1NWI4ZGI4MWMwOWFiZmI3ZjNjNWIyNTE1ODg4YjY3OWEzZTUwZGQ2YmQ2Y2VmN2M3MzExMWY0Y2MwYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNzRhNTNiOWM5YTI4NTg3MmQzOWU1NmU2OTEzY2FiMTVkNTliMWZhNTEyNTA4YzAyMmYzODJkZTgzMTk0OTdjJyxcbiAgICAgICAgJ2NjYzlkYzM3YWJmYzljMTY1N2I0MTU1ZjJjNDdmOWU2NjQ2YjNhMWQ4Y2I5ODU0MzgzZGExM2FjMDc5YWZhNzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTU5Mzk2OTgxOTQzNzg1YzNkM2U1N2VkZjUwMThjZGJlMDM5ZTczMGU0OTE4YjNkODg0ZmRmZjA5NDc1YjdiYScsXG4gICAgICAgICcyZTdlNTUyODg4YzMzMWRkOGJhMDM4NmE0YjljZDY4NDljNjUzZjY0Yzg3MDkzODVlOWI4YWJmODc1MjRmMmZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QyYTYzYTUwYWU0MDFlNTZkNjQ1YTExNTNiMTA5YThmY2NhMGE0M2Q1NjFmYmEyZGJiNTEzNDBjOWQ4MmIxNTEnLFxuICAgICAgICAnZTgyZDg2ZmI2NDQzZmNiNzU2NWFlZTU4YjI5NDgyMjBhNzBmNzUwYWY0ODRjYTUyZDQxNDIxNzRkY2Y4OTQwNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2NDU4N2UyMzM1NDcxZWI4OTBlZTc4OTZkN2NmZGM4NjZiYWNiZGJkMzgzOTMxN2IzNDM2ZjliNDU2MTdlMDczJyxcbiAgICAgICAgJ2Q5OWZjZGQ1YmY2OTAyZTJhZTk2ZGQ2NDQ3YzI5OWExODViOTBhMzkxMzNhZWFiMzU4Mjk5ZTVlOWZhZjY1ODknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQ4MWJkZTBlNGU0ZDg4NWIzYTU0NmQzZTU0OWRlMDQyZjBhYTZjZWEyNTBlN2ZkMzU4ZDZjODZkZDQ1ZTQ1OCcsXG4gICAgICAgICczOGVlN2I4Y2JhNTQwNGRkODRhMjViZjM5Y2VjYjJjYTkwMGE3OWM0MmIyNjJlNTU2ZDY0YjFiNTk3NzkwNTdlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEzNDY0YTU3YTc4MTAyYWE2MmI2OTc5YWU4MTdmNDYzN2ZmY2ZlZDNjNGIxY2UzMGJjZDYzMDNmNmNhZjY2NmInLFxuICAgICAgICAnNjliZTE1OTAwNDYxNDU4MGVmN2U0MzM0NTNjY2IwY2E0OGYzMDBhODFkMDk0MmUxM2Y0OTVhOTA3ZjZlY2MyNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdiYzRhOWRmNWI3MTNmZTJlOWFlZjQzMGJjYzFkYzk3YTBjZDljY2VkZTJmMjg1ODhjYWRhM2EwZDJkODNmMzY2JyxcbiAgICAgICAgJ2QzYTgxY2E2ZTc4NWMwNjM4MzkzN2FkZjRiNzk4Y2FhNmU4YTlmYmZhNTQ3YjE2ZDc1OGQ2NjY1ODFmMzNjMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YzI4YTk3YmY4Mjk4YmMwZDIzZDhjNzQ5NDUyYTMyZTY5NGI2NWUzMGE5NDcyYTM5NTRhYjMwZmU1MzI0Y2FhJyxcbiAgICAgICAgJzQwYTMwNDYzYTMzMDUxOTMzNzhmZWRmMzFmN2NjMGViN2FlNzg0ZjA0NTFjYjk0NTllNzFkYzczY2JlZjk0ODInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGVhOTY2NjEzOTUyN2E4YzFkZDk0Y2U0ZjA3MWZkMjNjOGIzNTBjNWE0YmIzMzc0OGM0YmExMTFmYWNjYWUwJyxcbiAgICAgICAgJzYyMGVmYWJiYzhlZTI3ODJlMjRlN2MwY2ZiOTVjNWQ3MzViNzgzYmU5Y2YwZjhlOTU1YWYzNGEzMGU2MmI5NDUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGQzNjI1ZmFlZjViYTA2MDc0NjY5NzE2YmJkMzc4OGQ4OWJkZGU4MTU5NTk5NjgwOTJmNzZjYzRlYjlhOTc4NycsXG4gICAgICAgICc3YTE4OGZhMzUyMGUzMGQ0NjFkYTI1MDEwNDU3MzFjYTk0MTQ2MTk4Mjg4MzM5NTkzN2Y2OGQwMGM2NDRhNTczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Y3MTBkNzlkOWViOTYyMjk3ZTRmNjIzMmI0MGU4ZjdmZWIyYmM2MzgxNDYxNGQ2OTJjMTJkZTc1MjQwODIyMWUnLFxuICAgICAgICAnZWE5OGU2NzIzMmQzYjMyOTVkM2I1MzU1MzIxMTVjY2FjODYxMmM3MjE4NTE2MTc1MjZhZTQ3YTljNzdiZmM4MidcbiAgICAgIF1cbiAgICBdXG4gIH0sXG4gIG5hZjoge1xuICAgIHduZDogNyxcbiAgICBwb2ludHM6IFtcbiAgICAgIFtcbiAgICAgICAgJ2Y5MzA4YTAxOTI1OGMzMTA0OTM0NGY4NWY4OWQ1MjI5YjUzMWM4NDU4MzZmOTliMDg2MDFmMTEzYmNlMDM2ZjknLFxuICAgICAgICAnMzg4ZjdiMGY2MzJkZTgxNDBmZTMzN2U2MmEzN2YzNTY2NTAwYTk5OTM0YzIyMzFiNmNiOWZkNzU4NGI4ZTY3MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyZjhiZGU0ZDFhMDcyMDkzNTViNGE3MjUwYTVjNTEyOGU4OGI4NGJkZGM2MTlhYjdjYmE4ZDU2OWIyNDBlZmU0JyxcbiAgICAgICAgJ2Q4YWMyMjI2MzZlNWUzZDZkNGRiYTlkZGE2YzljNDI2Zjc4ODI3MWJhYjBkNjg0MGRjYTg3ZDNhYTZhYzYyZDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWNiZGYwNjQ2ZTVkYjRlYWEzOThmMzY1ZjJlYTdhMGUzZDQxOWI3ZTAzMzBlMzljZTkyYmRkZWRjYWM0ZjliYycsXG4gICAgICAgICc2YWViY2E0MGJhMjU1OTYwYTMxNzhkNmQ4NjFhNTRkYmE4MTNkMGI4MTNmZGU3YjVhNTA4MjYyODA4NzI2NGRhJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FjZDQ4NGUyZjBjN2Y2NTMwOWFkMTc4YTlmNTU5YWJkZTA5Nzk2OTc0YzU3ZTcxNGMzNWYxMTBkZmMyN2NjYmUnLFxuICAgICAgICAnY2MzMzg5MjFiMGE3ZDlmZDY0MzgwOTcxNzYzYjYxZTlhZGQ4ODhhNDM3NWY4ZTBmMDVjYzI2MmFjNjRmOWMzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NzRhZTdmODU4YTk0MTFlNWVmNDI0NmI3MGM2NWFhYzU2NDk5ODBiZTVjMTc4OTFiYmVjMTc4OTVkYTAwOGNiJyxcbiAgICAgICAgJ2Q5ODRhMDMyZWI2YjVlMTkwMjQzZGQ1NmQ3YjdiMzY1MzcyZGIxZTJkZmY5ZDZhODMwMWQ3NGM5Yzk1M2M2MWInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjI4NzczYzJkOTc1Mjg4YmM3ZDFkMjA1YzM3NDg2NTFiMDc1ZmJjNjYxMGU1OGNkZGVlZGRmOGYxOTQwNWFhOCcsXG4gICAgICAgICdhYjA5MDJlOGQ4ODBhODk3NTgyMTJlYjY1Y2RhZjQ3M2ExYTA2ZGE1MjFmYTkxZjI5YjVjYjUyZGIwM2VkODEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDc5MjRkNGY3ZDQzZWE5NjVhNDY1YWUzMDk1ZmY0MTEzMWU1OTQ2ZjNjODVmNzllNDRhZGJjZjhlMjdlMDgwZScsXG4gICAgICAgICc1ODFlMjg3MmE4NmM3MmE2ODM4NDJlYzIyOGNjNmRlZmVhNDBhZjJiZDg5NmQzYTVjNTA0ZGM5ZmY2YTI2YjU4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RlZmRlYTRjZGI2Nzc3NTBhNDIwZmVlODA3ZWFjZjIxZWI5ODk4YWU3OWI5NzY4NzY2ZTRmYWEwNGEyZDRhMzQnLFxuICAgICAgICAnNDIxMWFiMDY5NDYzNTE2OGU5OTdiMGVhZDJhOTNkYWVjZWQxZjRhMDRhOTVjMGY2Y2ZiMTk5ZjY5ZTU2ZWI3NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyYjRlYTBhNzk3YTQ0M2QyOTNlZjVjZmY0NDRmNDk3OWYwNmFjZmViZDdlODZkMjc3NDc1NjU2MTM4Mzg1YjZjJyxcbiAgICAgICAgJzg1ZTg5YmMwMzc5NDVkOTNiMzQzMDgzYjVhMWM4NjEzMWEwMWY2MGM1MDI2OTc2M2I1NzBjODU0ZTVjMDliN2EnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzUyYmJmNGE0Y2RkMTI1NjRmOTNmYTMzMmNlMzMzMzAxZDlhZDQwMjcxZjgxMDcxODEzNDBhZWYyNWJlNTlkNScsXG4gICAgICAgICczMjFlYjQwNzUzNDhmNTM0ZDU5YzE4MjU5ZGRhM2UxZjRhMWIzYjJlNzFiMTAzOWM2N2JkM2Q4YmNmODE5OThjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJmYTIxMDRkNmIzOGQxMWIwMjMwMDEwNTU5ODc5MTI0ZTQyYWI4ZGZlZmY1ZmYyOWRjOWNkYWRkNGVjYWNjM2YnLFxuICAgICAgICAnMmRlMTA2ODI5NWRkODY1YjY0NTY5MzM1YmQ1ZGQ4MDE4MWQ3MGVjZmM4ODI2NDg0MjNiYTc2YjUzMmI3ZDY3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkyNDgyNzliMDliNGQ2OGRhYjIxYTliMDY2ZWRkYTgzMjYzYzNkODRlMDk1NzJlMjY5Y2EwY2Q3ZjU0NTM3MTQnLFxuICAgICAgICAnNzMwMTZmN2JmMjM0YWFkZTVkMWFhNzFiZGVhMmIxZmYzZmMwZGUyYTg4NzkxMmZmZTU0YTMyY2U5N2NiMzQwMidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYWVkNGYyYmUzYThiZjI3OGU3MDEzMmZiMGJlYjc1MjJmNTcwZTE0NGJmNjE1YzA3ZTk5NmQ0NDNkZWU4NzI5JyxcbiAgICAgICAgJ2E2OWRjZTRhN2Q2Yzk4ZThkNGExYWNhODdlZjhkNzAwM2Y4M2MyMzBmM2FmYTcyNmFiNDBlNTIyOTBiZTFjNTUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQ0ZDEyYzcwNjVkODEyZThhY2YyOGQ3Y2JiMTlmOTAxMWVjZDllOWZkZjI4MWIwZTZhM2I1ZTg3ZDIyZTdkYicsXG4gICAgICAgICcyMTE5YTQ2MGNlMzI2Y2RjNzZjNDU5MjZjOTgyZmRhYzBlMTA2ZTg2MWVkZjYxYzVhMDM5MDYzZjBlMGU2NDgyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzZhMjQ1YmY2ZGM2OTg1MDRjODlhMjBjZmRlZDYwODUzMTUyYjY5NTMzNmMyODA2M2I2MWM2NWNiZDI2OWU2YjQnLFxuICAgICAgICAnZTAyMmNmNDJjMmJkNGE3MDhiM2Y1MTI2ZjE2YTI0YWQ4YjMzYmE0OGQwNDIzYjZlZmQ1ZTYzNDgxMDBkOGE4MidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNjk3ZmZhNmZkOWRlNjI3YzA3N2UzZDJmZTU0MTA4NGNlMTMzMDBiMGJlYzExNDZmOTVhZTU3ZjBkMGJkNmE1JyxcbiAgICAgICAgJ2I5YzM5OGYxODY4MDZmNWQyNzU2MTUwNmU0NTU3NDMzYTJjZjE1MDA5ZTQ5OGFlN2FkZWU5ZDYzZDAxYjIzOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjA1YmRiMDE5OTgxNzE4Yjk4NmQwZjA3ZTgzNGNiMGQ5ZGViODM2MGZmYjdmNjFkZjk4MjM0NWVmMjdhNzQ3OScsXG4gICAgICAgICcyOTcyZDJkZTRmOGQyMDY4MWE3OGQ5M2VjOTZmZTIzYzI2YmZhZTg0ZmIxNGRiNDNiMDFlMWU5MDU2YjhjNDknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjJkMTRkYWI0MTUwYmY0OTc0MDJmZGM0NWEyMTVlMTBkY2IwMWMzNTQ5NTliMTBjZmUzMWM3ZTlkODdmZjMzZCcsXG4gICAgICAgICc4MGZjMDZiZDhjYzViMDEwOTgwODhhMTk1MGVlZDBkYjAxYWExMzI5NjdhYjQ3MjIzNWY1NjQyNDgzYjI1ZWFmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgwYzYwYWQwMDQwZjI3ZGFkZTViNGIwNmM0MDhlNTZiMmM1MGU5ZjU2YjliOGI0MjVlNTU1YzJmODYzMDhiNmYnLFxuICAgICAgICAnMWMzODMwM2YxY2M1YzMwZjI2ZTY2YmFkN2ZlNzJmNzBhNjVlZWQ0Y2JlNzAyNGViMWFhMDFmNTY0MzBiZDU3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3YTkzNzVhZDYxNjdhZDU0YWE3NGM2MzQ4Y2M1NGQzNDRjYzVkYzk0ODdkODQ3MDQ5ZDVlYWJiMGZhMDNjOGZiJyxcbiAgICAgICAgJ2QwZTNmYTllY2E4NzI2OTA5NTU5ZTBkNzkyNjkwNDZiZGM1OWVhMTBjNzBjZTJiMDJkNDk5ZWMyMjRkYzdmNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNTI4ZWNkOWI2OTZiNTRjOTA3YTllZDA0NTQ0N2E3OWJiNDA4ZWMzOWI2OGRmNTA0YmI1MWY0NTliYzNmZmM5JyxcbiAgICAgICAgJ2VlY2Y0MTI1MzEzNmU1Zjk5OTY2ZjIxODgxZmQ2NTZlYmM0MzQ1NDA1YzUyMGRiYzA2MzQ2NWI1MjE0MDk5MzMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDkzNzBhNGI1ZjQzNDEyZWEyNWY1MTRlOGVjZGFkMDUyNjYxMTVlNGE3ZWNiMTM4NzIzMTgwOGY4YjQ1OTYzJyxcbiAgICAgICAgJzc1OGYzZjQxYWZkNmVkNDI4YjMwODFiMDUxMmZkNjJhNTRjM2YzYWZiYjViNjc2NGI2NTMwNTJhMTI5NDljOWEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzdmMjMwOTM2ZWU4OGNiYmQ3M2RmOTMwZDY0NzAyZWY4ODFkODExZTBlMTQ5OGUyZjFjMTNlYjFmYzM0NWQ3NCcsXG4gICAgICAgICc5NThlZjQyYTc4ODZiNjQwMGEwODI2NmU5YmExYjM3ODk2Yzk1MzMwZDk3MDc3Y2JiZThlYjNjNzY3MWM2MGQ2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyZGFjOTkxY2M0Y2U0YjllYTQ0ODg3ZTVjN2MwYmNlNThjODAwNzRhYjlkNGRiYWViMjg1MzFiNzczOWY1MzAnLFxuICAgICAgICAnZTBkZWRjOWIzYjJmOGRhZDRkYTFmMzJkZWMyNTMxZGY5ZWI1ZmJlYjA1OThlNGZkMWExMTdkYmE3MDNhM2MzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0NjNiM2Q5ZjY2MjYyMWZiMWI0YmU4ZmJiZTI1MjAxMjVhMjE2Y2RmYzlkYWUzZGViY2JhNDg1MGM2OTBkNDViJyxcbiAgICAgICAgJzVlZDQzMGQ3OGMyOTZjMzU0MzExNDMwNmRkODYyMmQ3YzYyMmUyN2M5NzBhMWRlMzFjYjM3N2IwMWFmNzMwN2UnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjE2ZjgwNDI0NGU0NmUyYTA5MjMyZDRhZmYzYjU5OTc2Yjk4ZmFjMTQzMjhhMmQxYTMyNDk2YjQ5OTk4ZjI0NycsXG4gICAgICAgICdjZWRhYmQ5YjgyMjAzZjdlMTNkMjA2ZmNkZjRlMzNkOTJhNmM1M2MyNmU1Y2NlMjZkNjU3OTk2MmM0ZTMxZGY2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NhZjc1NDI3MmRjODQ1NjNiMDM1MmI3YTE0MzExYWY1NWQyNDUzMTVhY2UyN2M2NTM2OWUxNWY3MTUxZDQxZDEnLFxuICAgICAgICAnY2I0NzQ2NjBlZjM1ZjVmMmE0MWI2NDNmYTVlNDYwNTc1ZjRmYTliNzk2MjIzMmE1YzMyZjkwODMxOGEwNDQ3NidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyNjAwY2E0YjI4MmNiOTg2Zjg1ZDBmMTcwOTk3OWQ4YjQ0YTA5YzA3Y2I4NmQ3YzEyNDQ5N2JjODZmMDgyMTIwJyxcbiAgICAgICAgJzQxMTliODg3NTNjMTViZDZhNjkzYjAzZmNkZGJiNDVkNWFjNmJlNzRhYjVmMGVmNDRiMGJlOTQ3NWE3ZTRiNDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzYzNWNhNzJkN2U4NDMyYzMzOGVjNTNjZDEyMjIwYmMwMWM0ODY4NWUyNGY3ZGM4YzYwMmE3NzQ2OTk4ZTQzNScsXG4gICAgICAgICc5MWI2NDk2MDk0ODlkNjEzZDFkNWU1OTBmNzhlNmQ3NGVjZmMwNjFkNTcwNDhiYWQ5ZTc2ZjMwMmM1YjljNjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzU0ZTMyMzlmMzI1NTcwY2RiYmY0YTg3ZGVlZThhNjZiN2YyYjMzNDc5ZDQ2OGZiYzFhNTA3NDNiZjU2Y2MxOCcsXG4gICAgICAgICc2NzNmYjg2ZTViZGEzMGZiM2NkMGVkMzA0ZWE0OWEwMjNlZTMzZDAxOTdhNjk1ZDBjNWQ5ODA5M2M1MzY2ODMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTNlNmJkMTA3MWExZTk2YWZmNTc4NTljODJkNTcwZjAzMzA4MDA2NjFkMWM5NTJmOWZlMjY5NDY5MWQ5YjllOCcsXG4gICAgICAgICc1OWM5ZTBiYmEzOTRlNzZmNDBjMGFhNTgzNzlhM2NiNmE1YTIyODM5OTNlOTBjNDE2NzAwMmFmNDkyMGUzN2Y1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE4NmI0ODNkMDU2YTAzMzgyNmFlNzNkODhmNzMyOTg1YzRjY2IxZjMyYmEzNWY0YjRjYzQ3ZmRjZjA0YWE2ZWInLFxuICAgICAgICAnM2I5NTJkMzJjNjdjZjc3ZTJlMTc0NDZlMjA0MTgwYWIyMWZiODA5MDg5NTEzOGI0YTRhNzk3Zjg2ZTgwODg4YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZjlkNzBhNmI5ODc2Y2U1NDRjOTg1NjFmNGJlNGY3MjU0NDJlNmQyYjczN2Q5YzkxYTgzMjE3MjRjZTA5NjNmJyxcbiAgICAgICAgJzU1ZWIyZGFmZDg0ZDZjY2Q1Zjg2MmI3ODVkYzM5ZDRhYjE1NzIyMjcyMGVmOWRhMjE3YjhjNDVjZjJiYTI0MTcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWVkZDVjYzIzYzUxZTg3YTQ5N2NhODE1ZDVkY2UwZjhhYjUyNTU0Zjg0OWVkODk5NWRlNjRjNWYzNGNlNzE0MycsXG4gICAgICAgICdlZmFlOWM4ZGJjMTQxMzA2NjFlOGNlYzAzMGM4OWFkMGMxM2M2NmMwZDE3YTI5MDVjZGM3MDZhYjczOTlhODY4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzI5MDc5OGMyYjY0NzY4MzBkYTEyZmUwMjI4N2U5ZTc3N2FhM2ZiYTFjMzU1YjE3YTcyMmQzNjJmODQ2MTRmYmEnLFxuICAgICAgICAnZTM4ZGE3NmRjZDQ0MDYyMTk4OGQwMGJjZjc5YWYyNWQ1YjI5YzA5NGRiMmEyMzE0NmQwMDNhZmQ0MTk0M2U3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhZjNjNDIzYTk1ZDlmNWIzMDU0NzU0ZWZhMTUwYWMzOWNkMjk1NTJmZTM2MDI1NzM2MmRmZGVjZWY0MDUzYjQ1JyxcbiAgICAgICAgJ2Y5OGEzZmQ4MzFlYjJiNzQ5YTkzYjBlNmYzNWNmYjQwYzhjZDVhYTY2N2ExNTU4MWJjMmZlZGVkNDk4ZmQ5YzYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzY2ZGJiMjRkMTM0ZTc0NWNjY2FhMjhjOTliZjI3NDkwNmJiNjZiMjZkY2Y5OGRmOGQyZmVkNTBkODg0MjQ5YScsXG4gICAgICAgICc3NDRiMTE1MmVhY2JlNWUzOGRjYzg4Nzk4MGRhMzhiODk3NTg0YTY1ZmEwNmNlZGQyYzkyNGY5N2NiYWM1OTk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzU5ZGJmNDZmOGM5NDc1OWJhMjEyNzdjMzM3ODRmNDE2NDVmN2I0NGY2YzU5NmE1OGNlOTJlNjY2MTkxYWJlM2UnLFxuICAgICAgICAnYzUzNGFkNDQxNzVmYmMzMDBmNGVhNmNlNjQ4MzA5YTA0MmNlNzM5YTc5MTk3OThjZDg1ZTIxNmM0YTMwN2Y2ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMTNhZGE5NTEwM2M0NTM3MzA1ZTY5MWU3NGU5YTRhOGRkNjQ3ZTcxMWE5NWU3M2NiNjJkYzYwMThjZmQ4N2I4JyxcbiAgICAgICAgJ2UxMzgxN2I0NGVlMTRkZTY2M2JmNGJjODA4MzQxZjMyNjk0OWUyMWE2YTc1YzI1NzA3Nzg0MTliZGFmNTczM2QnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc1NGI0ZmEwZThhY2VkMDZkNDE2N2EyYzU5Y2NhNGNkYTE4NjljMDZlYmFkZmI2NDg4NTUwMDE1YTg4NTIyYycsXG4gICAgICAgICczMGU5M2U4NjRlNjY5ZDgyMjI0Yjk2N2MzMDIwYjhmYThkMWU0ZTM1MGI2Y2JjYzUzN2E0OGI1Nzg0MTE2M2EyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzk0OGRjYWRmNTk5MGUwNDhhYTM4NzRkNDZhYmVmOWQ3MDE4NThmOTVkZTgwNDFkMmE2ODI4Yzk5ZTIyNjI1MTknLFxuICAgICAgICAnZTQ5MWE0MjUzN2Y2ZTU5N2Q1ZDI4YTMyMjRiMWJjMjVkZjkxNTRlZmJkMmVmMWQyY2JiYTJjYWU1MzQ3ZDU3ZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OTYyNDE0NDUwYzc2YzE2ODljN2I0OGY4MjAyZWMzN2ZiMjI0Y2Y1YWMwYmZhMTU3MDMyOGE4YTNkN2M3N2FiJyxcbiAgICAgICAgJzEwMGI2MTBlYzRmZmI0NzYwZDVjMWZjMTMzZWY2ZjZiMTI1MDdhMDUxZjA0YWM1NzYwYWZhNWIyOWRiODM0MzcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzUxNDA4NzgzNDk2NGI1NGIxNWIxNjA2NDRkOTE1NDg1YTE2OTc3MjI1Yjg4NDdiYjBkZDA4NTEzN2VjNDdjYScsXG4gICAgICAgICdlZjBhZmJiMjA1NjIwNTQ0OGUxNjUyYzQ4ZTgxMjdmYzYwMzllNzdjMTVjMjM3OGI3ZTdkMTVhMGRlMjkzMzExJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2QzY2MzMGFkNmI0ODNlNGJjNzljZTJjOWRkOGJjNTQ5OTNlOTQ3ZWI4ZGY3ODdiNDQyOTQzZDNmN2I1MjdlYWYnLFxuICAgICAgICAnOGIzNzhhMjJkODI3Mjc4ZDg5YzVlOWJlOGY5NTA4YWUzYzJhZDQ2MjkwMzU4NjMwYWZiMzRkYjA0ZWVkZTBhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNjI0ZDg0NzgwNzMyODYwY2UxYzc4ZmNiZmVmZTA4YjJiMjk4MjNkYjkxM2Y2NDkzOTc1YmEwZmY0ODQ3NjEwJyxcbiAgICAgICAgJzY4NjUxY2Y5YjZkYTkwM2UwOTE0NDQ4YzZjZDlkNGNhODk2ODc4ZjUyODJiZTRjOGNjMDZlMmE0MDQwNzg1NzUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzMzY2U4MGRhOTU1YThhMjY5MDJjOTU2MzNlNjJhOTg1MTkyNDc0YjVhZjIwN2RhNmRmN2I0ZmQ1ZmM2MWNkNCcsXG4gICAgICAgICdmNTQzNWEyYmQyYmFkZjdkNDg1YTRkOGI4ZGI5ZmNjZTNlMWVmOGUwMjAxZTQ1NzhjNTQ2NzNiYzFkYzVlYTFkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE1ZDk0NDEyNTQ5NDUwNjRjZjFhMWMzM2JiZDNiNDlmODk2NmM1MDkyMTcxZTY5OWVmMjU4ZGZhYjgxYzA0NWMnLFxuICAgICAgICAnZDU2ZWIzMGI2OTQ2M2U3MjM0ZjUxMzdiNzNiODQxNzc0MzQ4MDBiYWNlYmZjNjg1ZmMzN2JiZTllZmU0MDcwZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMWQwZmNmMmVjOWRlNjc1YjYxMjEzNmU1Y2U3MGQyNzFjMjE0MTdjOWQyYjhhYWFhYzEzODU5OWQwNzE3OTQwJyxcbiAgICAgICAgJ2VkZDc3ZjUwYmNiNWEzY2FiMmU5MDczNzMwOTY2N2YyNjQxNDYyYTU0MDcwZjNkNTE5MjEyZDM5YzE5N2E2MjknXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTIyZmJlMTVjMGFmOGNjYzU3ODBjMDczNWY4NGRiZTlhNzkwYmFkZWU4MjQ1YzA2YzdjYTM3MzMxY2IzNjk4MCcsXG4gICAgICAgICdhODU1YmFiYWQ1Y2Q2MGM4OGI0MzBhNjlmNTNhMWE3YTM4Mjg5MTU0OTY0Nzk5YmU0M2QwNmQ3N2QzMWRhMDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzExMDkxZGQ5ODYwZThlMjBlZTEzNDczYzExNTVmNWY2OTYzNWUzOTQ3MDRlYWE3NDAwOTQ1MjI0NmNmYTliMycsXG4gICAgICAgICc2NmRiNjU2Zjg3ZDFmMDRmZmZkMWYwNDc4OGMwNjgzMDg3MWVjNWE2NGZlZWU2ODViZDgwZjBiMTI4NmQ4Mzc0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM0YzFmZDA0ZDMwMWJlODliMzFjMDQ0MmQzZTZhYzI0ODgzOTI4YjQ1YTkzNDA3ODE4NjdkNDIzMmVjMmRiZGYnLFxuICAgICAgICAnOTQxNDY4NWU5N2IxYjU5NTRiZDQ2ZjczMDE3NDEzNmQ1N2YxY2VlYjQ4NzQ0M2RjNTMyMTg1N2JhNzNhYmVlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyMTllYTVkNmI1NDcwMWMxYzE0ZGU1YjU1N2ViNDJhOGQxM2YzYWJiY2QwOGFmZmNjMmE1ZTZiMDQ5YjhkNjMnLFxuICAgICAgICAnNGNiOTU5NTdlODNkNDBiMGY3M2FmNDU0NGNjY2Y2YjFmNGIwOGQzYzA3YjI3ZmI4ZDhjMjk2MmE0MDA3NjZkMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkN2I4NzQwZjc0YThmYmFhYjFmNjgzZGI4ZjQ1ZGUyNjU0M2E1NDkwYmNhNjI3MDg3MjM2OTEyNDY5YTBiNDQ4JyxcbiAgICAgICAgJ2ZhNzc5NjgxMjhkOWM5MmVlMTAxMGYzMzdhZDQ3MTdlZmYxNWRiNWVkM2MwNDliMzQxMWUwMzE1ZWFhNDU5M2InXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzJkMzFjMjIyZjhmNmYwZWY4NmY3Yzk4ZDNhMzMzNWVhZDViY2QzMmFiZGQ5NDI4OWZlNGQzMDkxYWE4MjRiZicsXG4gICAgICAgICc1ZjMwMzJmNTg5MjE1NmUzOWNjZDNkNzkxNWI5ZTFkYTJlNmRhYzllNmYyNmU5NjExMThkMTRiODQ2MmUxNjYxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc0NjFmMzcxOTE0YWIzMjY3MTA0NWExNTVkOTgzMWVhODc5M2Q3N2NkNTk1OTJjNDM0MGY4NmNiYzE4MzQ3YjUnLFxuICAgICAgICAnOGVjMGJhMjM4Yjk2YmVjMGNiZGRkY2FlMGFhNDQyNTQyZWVlMWZmNTBjOTg2ZWE2YjM5ODQ3YjNjYzA5MmZmNidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZTA3OWFkYjFkZjE4NjAwNzQzNTZhMjVhYTM4MjA2YTZkNzE2YjJjM2U2NzQ1M2QyODc2OThiYWQ3YjJiMmQ2JyxcbiAgICAgICAgJzhkYzI0MTJhYWZlM2JlNWM0YzVmMzdlMGVjYzVmOWY2YTQ0Njk4OWFmMDRjNGUyNWViYWFjNDc5ZWMxYzhjMWUnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTZlYzkzZTQ0N2VjODNmMDQ2N2IxODMwMmVlNjIwZjdlNjVkZTMzMTg3NGM5ZGM3MmJmZDg2MTZiYTlkYTZiNScsXG4gICAgICAgICc1ZTQ2MzExNTBlNjJmYjQwZDBlOGMyYTdjYTU4MDRhMzlkNTgxODZhNTBlNDk3MTM5NjI2Nzc4ZTI1YjA2NzRkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhYTVmOTgwYzI0NWY2ZjAzODk3ODI5MGFmYTcwYjZiZDg4NTU4OTdmOThiNmFhNDg1Yjk2MDY1ZDUzN2JkOTknLFxuICAgICAgICAnZjY1ZjVkM2UyOTJjMmUwODE5YTUyODM5MWM5OTQ2MjRkNzg0ODY5ZDdlNmVhNjdmYjE4MDQxMDI0ZWRjMDdkYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3OGM5NDA3NTQ0YWMxMzI2OTJlZTE5MTBhMDI0Mzk5NThhZTA0ODc3MTUxMzQyZWE5NmM0YjZiMzVhNDlmNTEnLFxuICAgICAgICAnZjNlMDMxOTE2OWViOWI4NWQ1NDA0Nzk1NTM5YTVlNjhmYTFmYmQ1ODNjMDY0ZDI0NjJiNjc1ZjE5NGEzZGRiNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0OTRmNGJlMjE5YTFhNzcwMTZkY2Q4Mzg0MzFhZWEwMDAxY2RjOGFlN2E2ZmM2ODg3MjY1NzhkOTcwMjg1N2E1JyxcbiAgICAgICAgJzQyMjQyYTk2OTI4M2E1ZjMzOWJhN2YwNzVlMzZiYTJhZjkyNWNlMzBkNzY3ZWQ2ZTU1ZjRiMDMxODgwZDU2MmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU5OGE4MDMwZGE2ZDg2YzZiYzdmMmY1MTQ0ZWE1NDlkMjgyMTFlYTU4ZmFhNzBlYmY0YzFlNjY1YzFmZTliNScsXG4gICAgICAgICcyMDRiNWQ2Zjg0ODIyYzMwN2U0YjRhNzE0MDczN2FlYzIzZmM2M2I2NWIzNWY4NmExMDAyNmRiZDJkODY0ZTZiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0MTkxNjM2NWFiYjJiNWQwOTE5MmY1ZjJkYmVhZmVjMjA4ZjAyMGYxMjU3MGExODRkYmFkYzNlNTg1OTU5OTcnLFxuICAgICAgICAnNGYxNDM1MWQwMDg3ZWZhNDlkMjQ1YjMyODk4NDk4OWQ1Y2FmOTQ1MGYzNGJmYzBlZDE2ZTk2YjU4ZmE5OTEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0MWQ2MDYzYTU4NmZhNDc1YTcyNDYwNGRhMDNiYzViOTJhMmUwZDJlMGEzNmFjZmU0YzczYTU1MTQ3NDI4ODEnLFxuICAgICAgICAnNzM4NjdmNTljMDY1OWU4MTkwNGY5YTFjNzU0MzY5OGU2MjU2MmQ2NzQ0YzE2OWNlN2EzNmRlMDFhOGQ2MTU0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVlOTViYjM5OWE2OTcxZDM3NjAyNjk0N2Y4OWJkZTJmMjgyYjMzODEwOTI4YmU0ZGVkMTEyYWM0ZDcwZTIwZDUnLFxuICAgICAgICAnMzlmMjNmMzY2ODA5MDg1YmVlYmZjNzExODEzMTM3NzVhOTljOWFlZDdkOGJhMzhiMTYxMzg0Yzc0NjAxMjg2NSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNmU0NjQxYTUzOTQ4ZmQ0NzZjMzlmOGE5OWZkOTc0ZTVlYzA3NTY0YjUzMTVkOGJmOTk0NzFiY2EwZWYyZjY2JyxcbiAgICAgICAgJ2QyNDI0YjFiMWFiZTRlYjgxNjQyMjdiMDg1YzlhYTk0NTZlYTEzNDkzZmQ1NjNlMDZmZDUxY2Y1Njk0Yzc4ZmMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzM2NTgxZWE3YmZiYmIyOTBjMTkxYTJmNTA3YTQxY2Y1NjQzODQyMTcwZTkxNGZhZWFiMjdjMmM1NzlmNzI2JyxcbiAgICAgICAgJ2VhZDEyMTY4NTk1ZmUxYmU5OTI1MjEyOWI2ZTU2YjMzOTFmN2FiMTQxMGNkMWUwZWYzZGNkY2FiZDJmZGEyMjQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGFiODk4MTZkYWRmZDZiNmExZjI2MzRmY2YwMGVjODQwMzc4MTAyNWVkNjg5MGM0ODQ5NzQyNzA2YmQ0M2VkZScsXG4gICAgICAgICc2ZmRjZWYwOWYyZjZkMGEwNDRlNjU0YWVmNjI0MTM2ZjUwM2Q0NTljM2U4OTg0NTg1OGE0N2E5MTI5Y2RkMjRlJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFlMzNmMWE3NDZjOWM1Nzc4MTMzMzQ0ZDkyOTlmY2FhMjBiMDkzOGU4YWNmZjI1NDRiYjQwMjg0YjhjNWZiOTQnLFxuICAgICAgICAnNjA2NjAyNTdkZDExYjNhYTljOGVkNjE4ZDI0ZWRmZjIzMDZkMzIwZjFkMDMwMTBlMzNhN2QyMDU3ZjNiM2I2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg1YjdjMWRjYjNjZWMxYjdlZTdmMzBkZWQ3OWRkMjBhMGVkMWY0Y2MxOGNiY2ZjZmE0MTAzNjFmZDhmMDhmMzEnLFxuICAgICAgICAnM2Q5OGE5Y2RkMDI2ZGQ0M2YzOTA0OGYyNWE4ODQ3ZjRmY2FmYWQxODk1ZDdhNjMzYzZmZWQzYzM1ZTk5OTUxMSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOWRmOWZiZDhkOWU0NjUwOTI3NWY0YjEyNWQ2ZDQ1ZDdmYmU5YTNiODc4YTdhZjg3MmEyODAwNjYxYWM1ZjUxJyxcbiAgICAgICAgJ2I0YzRmZTk5Yzc3NWE2MDZlMmQ4ODYyMTc5MTM5ZmZkYTYxZGM4NjFjMDE5ZTU1Y2QyODc2ZWIyYTI3ZDg0YidcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhMGIxY2FlMDZiMGE4NDdhM2ZlYTZlNjcxYWFmOGFkZmRmZTU4Y2EyZjc2ODEwNWM4MDgyYjJlNDQ5ZmNlMjUyJyxcbiAgICAgICAgJ2FlNDM0MTAyZWRkZTA5NThlYzRiMTlkOTE3YTZhMjhlNmI3MmRhMTgzNGFmZjBlNjUwZjA0OTUwM2EyOTZjZjInXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU4Y2VhZmI5YjNlOWExMzZkYzdmZjY3ZTg0MDI5NWI0OTlkZmIzYjIxMzNlNGJhMTEzZjJlNGMwZTEyMWU1JyxcbiAgICAgICAgJ2NmMjE3NDExOGM4YjZkN2E0YjQ4ZjZkNTM0Y2U1Yzc5NDIyYzA4NmE2MzQ2MDUwMmI4MjdjZTYyYTMyNjY4M2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDI0YTQ0ZTA0N2UxOWI2ZjVhZmI4MWM3Y2EyZjY5MDgwYTUwNzY2ODlhMDEwOTE5ZjQyNzI1YzJiNzg5YTMzYicsXG4gICAgICAgICc2ZmI4ZDU1OTFiNDY2ZjhmYzYzZGI1MGYxYzBmMWM2OTAxM2Y5OTY4ODdiODI0NGQyY2RlYzQxN2FmZWE4ZmEzJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhMDE2MDZhN2E2YzljZGQyNDlmZGZjZmFjYjk5NTg0MDAxZWRkMjhhYmJhYjc3YjUxMDRlOThlOGUzYjM1ZDQnLFxuICAgICAgICAnMzIyYWY0OTA4YzczMTJiMGNmYmZlMzY5ZjdhN2IzY2RiN2Q0NDk0YmMyODIzNzAwY2ZkNjUyMTg4YTNlYTk4ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhZjhhZGRiZjJiNjYxYzhhNmM2MzI4NjU1ZWI5NjY1MTI1MjAwN2Q4YzVlYTMxYmU0YWQxOTZkZThjZTIxMzFmJyxcbiAgICAgICAgJzY3NDllNjdjMDI5Yjg1ZjUyYTAzNGVhZmQwOTY4MzZiMjUyMDgxODY4MGUyNmFjOGYzZGZiY2RiNzE3NDk3MDAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTNhZTE5NzQ1NjZjYTA2Y2M1MTZkNDdlMGZiMTY1YTY3NGEzZGFiY2ZjYTE1ZTcyMmYwZTM0NTBmNDU4ODknLFxuICAgICAgICAnMmFlYWJlN2U0NTMxNTEwMTE2MjE3ZjA3YmY0ZDA3MzAwZGU5N2U0ODc0ZjgxZjUzMzQyMGE3MmVlYjBiZDZhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1OTFlZTM1NTMxM2Q5OTcyMWNmNjk5M2ZmZWQxZTNlMzAxOTkzZmYzZWQyNTg4MDIwNzVlYThjZWQzOTdlMjQ2JyxcbiAgICAgICAgJ2IwZWE1NThhMTEzYzMwYmVhNjBmYzQ3NzU0NjBjNzkwMWZmMGIwNTNkMjVjYTJiZGVlZTk4ZjFhNGJlNWQxOTYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMTEzOTZkNTVmZGE1NGM0OWYxOWFhOTczMThkOGRhNjFmYTg1ODRlNDdiMDg0OTQ1MDc3Y2YwMzI1NWI1Mjk4NCcsXG4gICAgICAgICc5OThjNzRhOGNkNDVhYzAxMjg5ZDU4MzNhN2JlYjQ3NDRmZjUzNmIwMWIyNTdiZTRjNTc2N2JlYTkzZWE1N2E0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzNjNWQyYTFiYTM5YzVhMTc5MDAwMDczOGM5ZTBjNDBiOGRjZGZkNTQ2ODc1NGI2NDA1NTQwMTU3ZTAxN2FhN2EnLFxuICAgICAgICAnYjIyODQyNzk5OTVhMzRlMmY5ZDRkZTczOTZmYzE4YjgwZjliOGI5ZmRkMjcwZjY2NjFmNzljYTRjODFiZDI1NydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjYzg3MDRiOGE2MGEwZGVmYTNhOTlhNzI5OWYyZTljM2ZiYzM5NWFmYjA0YWMwNzg0MjVlZjhhMTc5M2NjMDMwJyxcbiAgICAgICAgJ2JkZDQ2MDM5ZmVlZDE3ODgxZDFlMDg2MmRiMzQ3ZjhjZjM5NWI3NGZjNGJjZGM0ZTk0MGI3NGUzYWMxZjFiMTMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzUzM2U0ZjdlYTg1NTVhYWNkOTc3N2FjNWNhZDI5Yjk3ZGQ0ZGVmY2NjNTNlZTdlYTIwNDExOWIyODg5YjE5NycsXG4gICAgICAgICc2ZjBhMjU2YmM1ZWZkZjQyOWEyZmI2MjQyZjFhNDNhMmQ5YjkyNWJiNGE0YjNhMjZiYjhlMGY0NWViNTk2MDk2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2MxNGY4ZjJjY2IyN2Q2ZjEwOWY2ZDA4ZDAzY2M5NmE2OWJhOGMzNGVlYzA3YmJjZjU2NmQ0OGUzM2RhNjU5MycsXG4gICAgICAgICdjMzU5ZDY5MjNiYjM5OGY3ZmQ0NDczZTE2ZmUxYzI4NDc1Yjc0MGRkMDk4MDc1ZTZjMGU4NjQ5MTEzZGMzYTM4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2E2Y2JjMzA0NmJjNmE0NTBiYWMyNDc4OWZhMTcxMTVhNGM5NzM5ZWQ3NWY4ZjIxY2U0NDFmNzJlMGI5MGU2ZWYnLFxuICAgICAgICAnMjFhZTdmNDY4MGU4ODliYjEzMDYxOWUyYzBmOTVhMzYwY2ViNTczYzcwNjAzMTM5ODYyYWZkNjE3ZmE5YjlmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM0N2Q2ZDlhMDJjNDg5MjdlYmZiODZjMTM1OWIxY2FmMTMwYTNjMDI2N2QxMWNlNjM0NGIzOWY5OWQ0M2NjMzgnLFxuICAgICAgICAnNjBlYTdmNjFhMzUzNTI0ZDFjOTg3ZjZlY2VjOTJmMDg2ZDU2NWFiNjg3ODcwY2IxMjY4OWZmMWUzMWM3NDQ0OCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTY1NDVkMjE4MWRiOGQ5ODNmN2RjYjM3NWVmNTg2NmQ0N2M2N2IxYmYzMWM4Y2Y4NTVlZjc0MzdiNzI2NTZhJyxcbiAgICAgICAgJzQ5Yjk2NzE1YWI2ODc4YTc5ZTc4ZjA3Y2U1NjgwYzVkNjY3MzA1MWI0OTM1YmQ4OTdmZWE4MjRiNzdkYzIwOGEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYzQwNzQ3Y2M5ZDAxMmNiMWExM2I4MTQ4MzA5YzZkZTdlYzI1ZDY5NDVkNjU3MTQ2YjlkNTk5NGI4ZmViMTExMScsXG4gICAgICAgICc1Y2E1NjA3NTNiZTJhMTJmYzZkZTZjYWYyY2I0ODk1NjVkYjkzNjE1NmI5NTE0ZTFiYjVlODMwMzdlMGZhMmQ0J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzRlNDJjOGVjODJjOTk3OThjY2YzYTYxMGJlODcwZTc4MzM4YzdmNzEzMzQ4YmQzNGM4MjAzZWY0MDM3ZjM1MDInLFxuICAgICAgICAnNzU3MWQ3NGVlNWUwZmI5MmE3YThiMzNhMDc3ODMzNDFhNTQ5MjE0NGNjNTRiY2M0MGE5NDQ3MzY5MzYwNjQzNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNzc1YWI3MDg5YmM2YWY4MjNhYmEyZTFhZjcwYjIzNmQyNTFjYWRiMGM4Njc0MzI4NzUyMmExYjNiMGRlZGVhJyxcbiAgICAgICAgJ2JlNTJkMTA3YmNmYTA5ZDhiY2I5NzM2YTgyOGNmYTdmYWM4ZGIxN2JmN2E3NmEyYzQyYWQ5NjE0MDkwMThjZjcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2VlMzFjYmY3ZTM0ZWMzNzlkOTRmYjgxNGQzZDc3NWFkOTU0NTk1ZDEzMTRiYTg4NDY5NTllM2U4MmY3NGUyNicsXG4gICAgICAgICc4ZmQ2NGExNGMwNmI1ODljMjZiOTQ3YWUyYmNmNmJmYTAxNDllZjBiZTE0ZWQ0ZDgwZjQ0OGEwMWM0M2IxYzZkJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2I0ZjllYWVhMDliNjkxNzYxOWY2ZWE2YTRlYjU0NjRlZmRkYjU4ZmQ0NWIxZWJlZmNkYzFhMDFkMDhiNDc5ODYnLFxuICAgICAgICAnMzllNWM5OTI1YjVhNTRiMDc0MzNhNGYxOGM2MTcyNmY4YmIxMzFjMDEyY2E1NDJlYjI0YThhYzA3MjAwNjgyYSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNDI2M2RmYzNkMmRmOTIzYTAxNzlhNDg5NjZkMzBjZTg0ZTI1MTVhZmMzZGNjYzFiNzc5MDc3OTJlYmNjNjBlJyxcbiAgICAgICAgJzYyZGZhZjA3YTBmNzhmZWIzMGUzMGQ2Mjk1ODUzY2UxODllMTI3NzYwYWQ2Y2Y3ZmFlMTY0ZTEyMmEyMDhkNTQnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDg0NTc1MjQ4MjBmYTY1YTRmOGQzNWViNjkzMDg1N2MwMDMyYWNjMGE0YTJkZTQyMjIzM2VlZGE4OTc2MTJjNCcsXG4gICAgICAgICcyNWE3NDhhYjM2Nzk3OWQ5ODczM2MzOGExZmExYzJlN2RjNmNjMDdkYjJkNjBhOWFlN2E3NmFhYTQ5YmQwZjc3J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RmZWVlZjE4ODExMDFmMmNiMTE2NDRmM2EyYWZkZmMyMDQ1ZTE5OTE5MTUyOTIzZjM2N2ExNzY3YzExY2NlZGEnLFxuICAgICAgICAnZWNmYjcwNTZjZjFkZTA0MmY5NDIwYmFiMzk2NzkzYzBjMzkwYmRlNzRiNGJiZGZmMTZhODNhZTA5YTlhNzUxNydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2ZDdlZjZiMTc1NDNmODM3M2M1NzNmNDRlMWYzODk4MzVkODliY2JjNjA2MmNlZDM2YzgyZGY4M2I4ZmFlODU5JyxcbiAgICAgICAgJ2NkNDUwZWMzMzU0Mzg5ODZkZmVmYTEwYzU3ZmVhOWJjYzUyMWEwOTU5YjJkODBiYmY3NGIxOTBkY2E3MTJkMTAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTc1NjA1ZDU5MTAyYTVhMjY4NDUwMGQzYjk5MWYyZTNmM2M4OGI5MzIyNTU0NzAzNWFmMjVhZjY2ZTA0NTQxZicsXG4gICAgICAgICdmNWM1NDc1NGE4ZjcxZWU1NDBiOWI0ODcyODQ3M2UzMTRmNzI5YWM1MzA4YjA2OTM4MzYwOTkwZTJiZmFkMTI1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ViOTg2NjBmNGM0ZGZhYTA2YTJiZTQ1M2Q1MDIwYmM5OWEwYzJlNjBhYmUzODg0NTdkZDQzZmVmYjFlZDYyMGMnLFxuICAgICAgICAnNmNiOWE4ODc2ZDljYjg1MjA2MDlhZjNhZGQyNmNkMjBhMGE3Y2Q4YTk0MTExMzFjZTg1ZjQ0MTAwMDk5MjIzZSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxM2U4N2IwMjdkODUxNGQzNTkzOWYyZTY4OTJiMTk5MjIxNTQ1OTY5NDE4ODgzMzZkYzM1NjNlM2I4ZGJhOTQyJyxcbiAgICAgICAgJ2ZlZjVhM2M2ODA1OWE2ZGVjNWQ2MjQxMTRiZjFlOTFhYWMyYjlkYTU2OGQ2YWJlYjI1NzBkNTU2NDZiOGFkZjEnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWUxNjMwMjZlOWZkNmZlMDE3YzM4ZjA2YTViZTZmYzEyNTQyNGIzNzFjZTI3MDhlN2JmNDQ5MTY5MWU1NzY0YScsXG4gICAgICAgICcxYWNiMjUwZjI1NWRkNjFjNDNkOTRjY2M2NzBkMGY1OGY0OWFlM2ZhMTViOTY2MjNlNTQzMGRhMGFkNmM2MmIyJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2IyNjhmNWVmOWFkNTFlNGQ3OGRlM2E3NTBjMmRjODliMWU2MjZkNDM1MDU4Njc5OTk5MzJlNWRiMzNhZjNkODAnLFxuICAgICAgICAnNWYzMTBkNGIzYzk5YjllYmIxOWY3N2Q0MWMxZGVlMDE4Y2YwZDM0ZmQ0MTkxNjE0MDAzZTk0NWExMjE2ZTQyMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZjA3ZjMxMThhOWRmMDM1ZTlmYWQ4NWViNmM3YmZlNDJiMDJmMDFjYTk5Y2VlYTNiZjdmZmRiYTkzYzQ3NTBkJyxcbiAgICAgICAgJzQzODEzNmQ2MDNlODU4YTNhNWM0NDBjMzhlY2NiYWRkYzFkMjk0MjExNGUyZWRkZDQ3NDBkMDk4Y2VkMWYwZDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGQ4Yjk4NTVjN2MwNTJhMzQxNDZmZDIwZmZiNjU4YmVhNGI5ZjY5ZTBkODI1ZWJlYzE2ZThjM2NlMmI1MjZhMScsXG4gICAgICAgICdjZGI1NTllZWRjMmQ3OWY5MjZiYWY0NGZiODRlYTRkNDRiY2Y1MGZlZTUxZDdjZWIzMGUyZTdmNDYzMDM2NzU4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzUyZGIwYjUzODRkZmJmMDViZmE5ZDQ3MmQ3YWUyNmRmZTRiODUxY2VjYTkxYjFlYmE1NDI2MzE4MGRhMzJiNjMnLFxuICAgICAgICAnYzNiOTk3ZDA1MGVlNWQ0MjNlYmFmNjZhNmRiOWY1N2IzMTgwYzkwMjg3NTY3OWRlOTI0YjY5ZDg0YTdiMzc1J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U2MmY5NDkwZDNkNTFkYTYzOTVlZmQyNGU4MDkxOWNjN2QwZjI5YzNmM2ZhNDhjNmZmZjU0M2JlY2JkNDMzNTInLFxuICAgICAgICAnNmQ4OWFkN2JhNDg3NmIwYjIyYzJjYTI4MGM2ODI4NjJmMzQyYzg1OTFmMWRhZjUxNzBlMDdiZmQ5Y2NhZmE3ZCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3ZjMwZWEyNDc2YjM5OWI0OTU3NTA5Yzg4Zjc3ZDAxOTFhZmEyZmY1Y2I3YjE0ZmQ2ZDhlN2Q2NWFhYWIxMTkzJyxcbiAgICAgICAgJ2NhNWVmN2Q0YjIzMWM5NGMzYjE1Mzg5YTVmNjMxMWU5ZGFmZjdiYjY3YjEwM2U5ODgwZWY0YmZmNjM3YWNhZWMnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTA5OGZmMWUxZDlmMTRmYjQ2YTIxMGZhZGE2YzkwM2ZlZjBmYjdiNGExZGQxZDlhYzYwYTAzNjE4MDBiN2EwMCcsXG4gICAgICAgICc5NzMxMTQxZDgxZmM4ZjgwODRkMzdjNmU3NTQyMDA2YjNlZTFiNDBkNjBkZmU1MzYyYTViMTMyZmQxN2RkYzAnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzJiNzhjN2RlOWVlNTEyYTcyODk1YmU2YjljYmVmYTZlMmYzYzRjY2NlNDQ1Yzk2YjlmMmM4MWUyNzc4YWQ1OCcsXG4gICAgICAgICdlZTE4NDlmNTEzZGY3MWUzMmVmYzM4OTZlZTI4MjYwYzczYmI4MDU0N2FlMjI3NWJhNDk3MjM3Nzk0Yzg3NTNjJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UyY2I3NGZkZGM4ZTlmYmNkMDc2ZWVmMmE3YzcyYjBjZTM3ZDUwZjA4MjY5ZGZjMDc0YjU4MTU1MDU0N2E0ZjcnLFxuICAgICAgICAnZDNhYTJlZDcxYzlkZDIyNDdhNjJkZjA2MjczNmViMGJhZGRlYTllMzYxMjJkMmJlODY0MWFiY2IwMDVjYzRhNCdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NDM4NDQ3NTY2ZDRkN2JlZGFkYzI5OTQ5NmFiMzU3NDI2MDA5YTM1ZjIzNWNiMTQxYmUwZDk5Y2QxMGFlM2E4JyxcbiAgICAgICAgJ2M0ZTEwMjA5MTY5ODBhNGRhNWQwMWFjNWU2YWQzMzA3MzRlZjBkNzkwNjYzMWM0ZjIzOTA0MjZiMmVkZDc5MWYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDE2MmQ0ODhiODk0MDIwMzliNTg0YzZmYzZjMzA4ODcwNTg3ZDljNDZmNjYwYjg3OGFiNjVjODJjNzExZDY3ZScsXG4gICAgICAgICc2NzE2M2U5MDMyMzYyODlmNzc2ZjIyYzI1ZmI4YTNhZmMxNzMyZjJiODRiNGU5NWRiZGE0N2FlNWEwODUyNjQ5J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzNmYWQzZmE4NGNhZjBmMzRmMGY4OWJmZDJkY2Y1NGZjMTc1ZDc2N2FlYzNlNTA2ODRmM2JhNGE0YmY1ZjY4M2QnLFxuICAgICAgICAnY2QxYmM3Y2I2Y2M0MDdiYjJmMGNhNjQ3YzcxOGE3MzBjZjcxODcyZTdkMGQyYTUzZmEyMGVmY2RmZTYxODI2J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzY3NGYyNjAwYTMwMDdhMDA1NjhjMWE3Y2UwNWQwODE2YzFmYjg0YmYxMzcwNzk4ZjFjNjk1MzJmYWViMWE4NmInLFxuICAgICAgICAnMjk5ZDIxZjk0MTNmMzNiM2VkZjQzYjI1NzAwNDU4MGI3MGRiNTdkYTBiMTgyMjU5ZTA5ZWVjYzY5ZTBkMzhhNSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMzJmNGRhNTRhZGU3NGFiYjgxYjgxNWFkMWZiM2IyNjNkODJkNmM2OTI3MTRiY2ZmODdkMjliZDVlZTlmMDhmJyxcbiAgICAgICAgJ2Y5NDI5ZTczOGI4ZTUzYjk2OGU5OTAxNmMwNTk3MDc3ODJlMTRmNDUzNTM1OWQ1ODJmYzQxNjkxMGIzZWVhODcnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzBlNGU2NzA0MzUzODU1NTZlNTkzNjU3MTM1ODQ1ZDM2ZmJiNjkzMWY3MmIwOGNiMWVkOTU0ZjFlM2NlM2ZmNicsXG4gICAgICAgICc0NjJmOWJjZTYxOTg5ODYzODQ5OTM1MDExM2JiYzliMTBhODc4ZDM1ZGE3MDc0MGRjNjk1YTU1OWViODhkYjdiJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2JlMjA2MjAwM2M1MWNjMzAwNDY4MjkwNDMzMGU0ZGVlN2YzZGNkMTBiMDFlNTgwYmYxOTcxYjA0ZDRjYWQyOTcnLFxuICAgICAgICAnNjIxODhiYzQ5ZDYxZTU0Mjg1NzNkNDhhNzRlMWM2NTViMWM2MTA5MDkwNTY4MmEwZDU1NThlZDcyZGNjYjliYydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MzE0NDQyM2FjZTM0NTFlZDI5ZTBmYjlhYzJhZjIxMWNiNmU4NGE2MDFkZjU5OTNjNDE5ODU5ZmZmNWRmMDRhJyxcbiAgICAgICAgJzdjMTBkZmIxNjRjMzQyNWY1YzcxYTNmOWQ3OTkyMDM4ZjEwNjUyMjRmNzJiYjlkMWQ5MDJhNmQxMzAzN2I0N2MnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjAxNWY4MDQ0ZjVmY2JkY2YyMWNhMjZkNmMzNGZiODE5NzgyOTIwNWM3YjdkMmE3Y2I2NjQxOGMxNTdiMTEyYycsXG4gICAgICAgICdhYjhjMWUwODZkMDRlODEzNzQ0YTY1NWIyZGY4ZDVmODNiM2NkYzZmYWEzMDg4YzFkM2FlYTE0NTRlM2ExZDVmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q1ZTllMWRhNjQ5ZDk3ZDg5ZTQ4NjgxMTdhNDY1YTNhNGY4YTE4ZGU1N2ExNDBkMzZiM2YyYWYzNDFhMjFiNTInLFxuICAgICAgICAnNGNiMDQ0MzdmMzkxZWQ3MzExMWExM2NjMWQ0ZGQwZGIxNjkzNDY1YzIyNDA0ODBkODk1NWU4NTkyZjI3NDQ3YSdcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2FlNDEwNDdkZDdjYTA2NWRiZjhlZDc3Yjk5MjQzOTk4MzAwNWNkNzJlMTZkNmY5OTZhNTMxNmQzNjk2NmJiJyxcbiAgICAgICAgJ2JkMWFlYjIxYWQyMmViYjIyYTEwZjAzMDM0MTdjNmQ5NjRmOGNkZDdkZjBhY2E2MTRiMTBkYzE0ZDEyNWFjNDYnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDYzZTI3NjNkODg1Zjk1OGZjNjZjZGQyMjgwMGYwYTQ4NzE5N2QwYTgyZTM3N2I0OWY4MGFmODdjODk3YjA2NScsXG4gICAgICAgICdiZmVmYWNkYjBlNWQwZmQ3ZGYzYTMxMWE5NGRlMDYyYjI2YjgwYzYxZmJjOTc1MDhiNzk5OTI2NzFlZjdjYTdmJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc5ODVmZGZkMTI3YzA1NjdjNmY1M2VjMWJiNjNlYzMxNThlNTk3YzQwYmZlNzQ3YzgzY2RkZmM5MTA2NDE5MTcnLFxuICAgICAgICAnNjAzYzEyZGFmM2Q5ODYyZWYyYjI1ZmUxZGUyODlhZWQyNGVkMjkxZTBlYzY3MDg3MDNhNWJkNTY3ZjMyZWQwMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NGExYWQ2YjVmNzZlMzlkYjJkZDI0OTQxMGVhYzdmOTllNzRjNTljYjgzZDJkMGVkNWZmMTU0M2RhNzcwM2U5JyxcbiAgICAgICAgJ2NjNjE1N2VmMThjOWM2M2NkNjE5M2Q4MzYzMWJiZWEwMDkzZTA5Njg5NDJlOGMzM2Q1NzM3ZmQ3OTBlMGRiMDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzA2ODJhNTA3MDMzNzVmNjAyZDQxNjY2NGJhMTliN2ZjOWJhYjQyYzcyNzQ3NDYzYTcxZDA4OTZiMjJmNmRhMycsXG4gICAgICAgICc1NTNlMDRmNmIwMThiNGZhNmM4ZjM5ZTdmMzExZDMxNzYyOTBkMGUwZjE5Y2E3M2YxNzcxNGQ5OTc3YTIyZmY4J1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzllMjE1OGYwZDdjMGQ1ZjI2YzM3OTFlZmVmYTc5NTk3NjU0ZTdhMmIyNDY0ZjUyYjFlZTZjMTM0Nzc2OWVmNTcnLFxuICAgICAgICAnNzEyZmNkZDFiOTA1M2YwOTAwM2EzNDgxZmE3NzYyZTlmZmQ3YzhlZjM1YTM4NTA5ZTJmYmYyNjI5MDA4MzczJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NmUyNjk4OWE0M2M5Y2ZlYmE0MDI5YzIwMjUzOGMyODE3MmU1NjZlM2M0ZmNlNzMyMjg1N2YzYmUzMjdkNjYnLFxuICAgICAgICAnZWQ4Y2M5ZDA0YjI5ZWI4NzdkMjcwYjQ4NzhkYzQzYzE5YWVmZDMxZjRlZWUwOWVlN2I0NzgzNGMxZmE0YjFjMydcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NWQ0NmVmZWEzNzcxZTZlNjhhYmI4OWExM2FkNzQ3ZWNmMTg5MjM5M2RmYzRmMWI3MDA0Nzg4YzUwMzc0ZGE4JyxcbiAgICAgICAgJzk4NTIzOTBhOTk1MDc2NzlmZDBiODZmZDJiMzlhODY4ZDdlZmMyMjE1MTM0NmUxYTNjYTQ3MjY1ODZhNmJlZDgnXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODA5YTIwYzY3ZDY0OTAwZmZiNjk4YzRjODI1ZjZkNWYyMzEwZmIwNDUxYzg2OTM0NWI3MzE5ZjY0NTYwNTcyMScsXG4gICAgICAgICc5ZTk5NDk4MGQ5OTE3ZTIyYjc2YjA2MTkyN2ZhMDQxNDNkMDk2Y2NjNTQ5NjNlNmE1ZWJmYTVmM2Y4ZTI4NmMxJ1xuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFiMzg5MDNhNDNmN2YxMTRlZDQ1MDBiNGVhYzcwODNmZGVmZWNlMWNmMjljNjM1MjhkNTYzNDQ2Zjk3MmMxODAnLFxuICAgICAgICAnNDAzNmVkYzkzMWE2MGFlODg5MzUzZjc3ZmQ1M2RlNGEyNzA4YjI2YjZmNWRhNzJhZDMzOTQxMTlkYWY0MDhmOSdcbiAgICAgIF1cbiAgICBdXG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xuXG51dGlscy5hc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufTtcblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnICE9PSAnc3RyaW5nJykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmICghZW5jKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaGkgPSBjID4+IDg7XG4gICAgICB2YXIgbG8gPSBjICYgMHhmZjtcbiAgICAgIGlmIChoaSlcbiAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzLnB1c2gobG8pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4ID0gdG9IZXg7XG5cbnV0aWxzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShhcnIsIGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdG9IZXgoYXJyKTtcbiAgZWxzZVxuICAgIHJldHVybiBhcnI7XG59O1xuXG4vLyBSZXByZXNlbnQgbnVtIGluIGEgdy1OQUYgZm9ybVxuZnVuY3Rpb24gZ2V0TkFGKG51bSwgdykge1xuICB2YXIgbmFmID0gW107XG4gIHZhciB3cyA9IDEgPDwgKHcgKyAxKTtcbiAgdmFyIGsgPSBudW0uY2xvbmUoKTtcbiAgd2hpbGUgKGsuY21wbigxKSA+PSAwKSB7XG4gICAgdmFyIHo7XG4gICAgaWYgKGsuaXNPZGQoKSkge1xuICAgICAgdmFyIG1vZCA9IGsuYW5kbG4od3MgLSAxKTtcbiAgICAgIGlmIChtb2QgPiAod3MgPj4gMSkgLSAxKVxuICAgICAgICB6ID0gKHdzID4+IDEpIC0gbW9kO1xuICAgICAgZWxzZVxuICAgICAgICB6ID0gbW9kO1xuICAgICAgay5pc3Vibih6KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IDA7XG4gICAgfVxuICAgIG5hZi5wdXNoKHopO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uLCBzaGlmdCBieSB3b3JkIGlmIHBvc3NpYmxlXG4gICAgdmFyIHNoaWZ0ID0gKGsuY21wbigwKSAhPT0gMCAmJiBrLmFuZGxuKHdzIC0gMSkgPT09IDApID8gKHcgKyAxKSA6IDE7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaGlmdDsgaSsrKVxuICAgICAgbmFmLnB1c2goMCk7XG4gICAgay5pdXNocm4oc2hpZnQpO1xuICB9XG5cbiAgcmV0dXJuIG5hZjtcbn1cbnV0aWxzLmdldE5BRiA9IGdldE5BRjtcblxuLy8gUmVwcmVzZW50IGsxLCBrMiBpbiBhIEpvaW50IFNwYXJzZSBGb3JtXG5mdW5jdGlvbiBnZXRKU0YoazEsIGsyKSB7XG4gIHZhciBqc2YgPSBbXG4gICAgW10sXG4gICAgW11cbiAgXTtcblxuICBrMSA9IGsxLmNsb25lKCk7XG4gIGsyID0gazIuY2xvbmUoKTtcbiAgdmFyIGQxID0gMDtcbiAgdmFyIGQyID0gMDtcbiAgd2hpbGUgKGsxLmNtcG4oLWQxKSA+IDAgfHwgazIuY21wbigtZDIpID4gMCkge1xuXG4gICAgLy8gRmlyc3QgcGhhc2VcbiAgICB2YXIgbTE0ID0gKGsxLmFuZGxuKDMpICsgZDEpICYgMztcbiAgICB2YXIgbTI0ID0gKGsyLmFuZGxuKDMpICsgZDIpICYgMztcbiAgICBpZiAobTE0ID09PSAzKVxuICAgICAgbTE0ID0gLTE7XG4gICAgaWYgKG0yNCA9PT0gMylcbiAgICAgIG0yNCA9IC0xO1xuICAgIHZhciB1MTtcbiAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG4gICAgICB1MSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtOCA9IChrMS5hbmRsbig3KSArIGQxKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMjQgPT09IDIpXG4gICAgICAgIHUxID0gLW0xNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTEgPSBtMTQ7XG4gICAgfVxuICAgIGpzZlswXS5wdXNoKHUxKTtcblxuICAgIHZhciB1MjtcbiAgICBpZiAoKG0yNCAmIDEpID09PSAwKSB7XG4gICAgICB1MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtOCA9IChrMi5hbmRsbig3KSArIGQyKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG4gICAgICAgIHUyID0gLW0yNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTIgPSBtMjQ7XG4gICAgfVxuICAgIGpzZlsxXS5wdXNoKHUyKTtcblxuICAgIC8vIFNlY29uZCBwaGFzZVxuICAgIGlmICgyICogZDEgPT09IHUxICsgMSlcbiAgICAgIGQxID0gMSAtIGQxO1xuICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcbiAgICAgIGQyID0gMSAtIGQyO1xuICAgIGsxLml1c2hybigxKTtcbiAgICBrMi5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4ganNmO1xufVxudXRpbHMuZ2V0SlNGID0gZ2V0SlNGO1xuXG5mdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eShvYmosIG5hbWUsIGNvbXB1dGVyKSB7XG4gIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuICBvYmoucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkID8gdGhpc1trZXldIDpcbiAgICAgICAgICAgdGhpc1trZXldID0gY29tcHV0ZXIuY2FsbCh0aGlzKTtcbiAgfTtcbn1cbnV0aWxzLmNhY2hlZFByb3BlcnR5ID0gY2FjaGVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHBhcnNlQnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycgPyB1dGlscy50b0FycmF5KGJ5dGVzLCAnaGV4JykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzO1xufVxudXRpbHMucGFyc2VCeXRlcyA9IHBhcnNlQnl0ZXM7XG5cbmZ1bmN0aW9uIGludEZyb21MRShieXRlcykge1xuICByZXR1cm4gbmV3IEJOKGJ5dGVzLCAnaGV4JywgJ2xlJyk7XG59XG51dGlscy5pbnRGcm9tTEUgPSBpbnRGcm9tTEU7XG5cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAge1xuICAgICAgICBcInJhd1wiOiBcImVsbGlwdGljQGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2VsbGlwdGljLy0vZWxsaXB0aWMtNi4zLjEudGd6XCIsXG4gICAgICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICAgICAgXCJlc2NhcGVkTmFtZVwiOiBcImVsbGlwdGljXCIsXG4gICAgICAgIFwibmFtZVwiOiBcImVsbGlwdGljXCIsXG4gICAgICAgIFwicmF3U3BlY1wiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2VsbGlwdGljLy0vZWxsaXB0aWMtNi4zLjEudGd6XCIsXG4gICAgICAgIFwic3BlY1wiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2VsbGlwdGljLy0vZWxsaXB0aWMtNi4zLjEudGd6XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInJlbW90ZVwiXG4gICAgICB9LFxuICAgICAgXCIvaG9tZS9pbHV2cG9vbDE5L0Rlc2t0b3AveGJ0L3lvdXJzLWNoYW5uZWxzL25vZGVfbW9kdWxlcy95b3Vycy1iaXRjb2luXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJlbGxpcHRpY0A2LjMuMVwiLFxuICBcIl9pZFwiOiBcImVsbGlwdGljQDYuMy4xXCIsXG4gIFwiX2luQ2FjaGVcIjogdHJ1ZSxcbiAgXCJfbG9jYXRpb25cIjogXCIveW91cnMtYml0Y29pbi9lbGxpcHRpY1wiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJyYXdcIjogXCJlbGxpcHRpY0BodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lbGxpcHRpYy8tL2VsbGlwdGljLTYuMy4xLnRnelwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcImVzY2FwZWROYW1lXCI6IFwiZWxsaXB0aWNcIixcbiAgICBcIm5hbWVcIjogXCJlbGxpcHRpY1wiLFxuICAgIFwicmF3U3BlY1wiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2VsbGlwdGljLy0vZWxsaXB0aWMtNi4zLjEudGd6XCIsXG4gICAgXCJzcGVjXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvZWxsaXB0aWMvLS9lbGxpcHRpYy02LjMuMS50Z3pcIixcbiAgICBcInR5cGVcIjogXCJyZW1vdGVcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi95b3Vycy1iaXRjb2luXCIsXG4gICAgXCIveW91cnMtYml0Y29pbi9icm93c2VyaWZ5LXNpZ25cIixcbiAgICBcIi95b3Vycy1iaXRjb2luL2NyZWF0ZS1lY2RoXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lbGxpcHRpYy8tL2VsbGlwdGljLTYuMy4xLnRnelwiLFxuICBcIl9zaGFzdW1cIjogXCIxNzc4MWYyMTA5YWIwZWM2ODZiMTQ2YmRjZmY1ZDJlOGM2YWVjZWRhXCIsXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcImVsbGlwdGljQGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2VsbGlwdGljLy0vZWxsaXB0aWMtNi4zLjEudGd6XCIsXG4gIFwiX3doZXJlXCI6IFwiL2hvbWUvaWx1dnBvb2wxOS9EZXNrdG9wL3hidC95b3Vycy1jaGFubmVscy9ub2RlX21vZHVsZXMveW91cnMtYml0Y29pblwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRmVkb3IgSW5kdXRueVwiLFxuICAgIFwiZW1haWxcIjogXCJmZWRvckBpbmR1dG55LmNvbVwiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpYy9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJibi5qc1wiOiBcIl40LjQuMFwiLFxuICAgIFwiYnJvcmFuZFwiOiBcIl4xLjAuMVwiLFxuICAgIFwiaGFzaC5qc1wiOiBcIl4xLjAuMFwiLFxuICAgIFwiaW5oZXJpdHNcIjogXCJeMi4wLjFcIlxuICB9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiRUMgY3J5cHRvZ3JhcGh5XCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyZnNcIjogXCJeMS40LjNcIixcbiAgICBcImNvdmVyYWxsc1wiOiBcIl4yLjExLjNcIixcbiAgICBcImdydW50XCI6IFwiXjAuNC41XCIsXG4gICAgXCJncnVudC1icm93c2VyaWZ5XCI6IFwiXjUuMC4wXCIsXG4gICAgXCJncnVudC1jb250cmliLWNvbm5lY3RcIjogXCJeMS4wLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItY29weVwiOiBcIl4xLjAuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeMS4wLjFcIixcbiAgICBcImdydW50LW1vY2hhLWlzdGFuYnVsXCI6IFwiXjMuMC4xXCIsXG4gICAgXCJncnVudC1zYXVjZWxhYnNcIjogXCJeOC42LjJcIixcbiAgICBcImlzdGFuYnVsXCI6IFwiXjAuNC4yXCIsXG4gICAgXCJqc2NzXCI6IFwiXjIuOS4wXCIsXG4gICAgXCJqc2hpbnRcIjogXCJeMi42LjBcIixcbiAgICBcIm1vY2hhXCI6IFwiXjIuMS4wXCJcbiAgfSxcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJsaWJcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJFQ1wiLFxuICAgIFwiRWxsaXB0aWNcIixcbiAgICBcImN1cnZlXCIsXG4gICAgXCJDcnlwdG9ncmFwaHlcIlxuICBdLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2VsbGlwdGljLmpzXCIsXG4gIFwibmFtZVwiOiBcImVsbGlwdGljXCIsXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG4gIFwicmVhZG1lXCI6IFwiIyBFbGxpcHRpYyBbIVtCdWlsZCBTdGF0dXNdKGh0dHBzOi8vc2VjdXJlLnRyYXZpcy1jaS5vcmcvaW5kdXRueS9lbGxpcHRpYy5wbmcpXShodHRwOi8vdHJhdmlzLWNpLm9yZy9pbmR1dG55L2VsbGlwdGljKSBbIVtDb3ZlcmFnZSBTdGF0dXNdKGh0dHBzOi8vY292ZXJhbGxzLmlvL3JlcG9zL2luZHV0bnkvZWxsaXB0aWMvYmFkZ2Uuc3ZnP2JyYW5jaD1tYXN0ZXImc2VydmljZT1naXRodWIpXShodHRwczovL2NvdmVyYWxscy5pby9naXRodWIvaW5kdXRueS9lbGxpcHRpYz9icmFuY2g9bWFzdGVyKSBbIVtDb2RlIENsaW1hdGVdKGh0dHBzOi8vY29kZWNsaW1hdGUuY29tL2dpdGh1Yi9pbmR1dG55L2VsbGlwdGljL2JhZGdlcy9ncGEuc3ZnKV0oaHR0cHM6Ly9jb2RlY2xpbWF0ZS5jb20vZ2l0aHViL2luZHV0bnkvZWxsaXB0aWMpXFxuXFxuWyFbU2F1Y2VsYWJzIFRlc3QgU3RhdHVzXShodHRwczovL3NhdWNlbGFicy5jb20vYnJvd3Nlci1tYXRyaXgvZ2gtaW5kdXRueS1lbGxpcHRpYy5zdmcpXShodHRwczovL3NhdWNlbGFicy5jb20vdS9naC1pbmR1dG55LWVsbGlwdGljKVxcblxcbkZhc3QgZWxsaXB0aWMtY3VydmUgY3J5cHRvZ3JhcGh5IGluIGEgcGxhaW4gamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbi5cXG5cXG5OT1RFOiBQbGVhc2UgdGFrZSBhIGxvb2sgYXQgaHR0cDovL3NhZmVjdXJ2ZXMuY3IueXAudG8vIGJlZm9yZSBjaG9vc2luZyBhIGN1cnZlXFxuZm9yIHlvdXIgY3J5cHRvZ3JhcGh5IG9wZXJhdGlvbnMuXFxuXFxuIyMgSW5jZW50aXZlXFxuXFxuRUNDIGlzIG11Y2ggc2xvd2VyIHRoYW4gcmVndWxhciBSU0EgY3J5cHRvZ3JhcGh5LCB0aGUgSlMgaW1wbGVtZW50YXRpb25zIGFyZVxcbmV2ZW4gbW9yZSBzbG93ZXIuXFxuXFxuIyMgQmVuY2htYXJrc1xcblxcbmBgYGJhc2hcXG4kIG5vZGUgYmVuY2htYXJrcy9pbmRleC5qc1xcbkJlbmNobWFya2luZzogc2lnblxcbmVsbGlwdGljI3NpZ24geCAyNjIgb3BzL3NlYyDCsTAuNTElICgxNzcgcnVucyBzYW1wbGVkKVxcbmVjY2pzI3NpZ24geCA1NS45MSBvcHMvc2VjIMKxMC45MCUgKDE0NCBydW5zIHNhbXBsZWQpXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuRmFzdGVzdCBpcyBlbGxpcHRpYyNzaWduXFxuPT09PT09PT09PT09PT09PT09PT09PT09XFxuQmVuY2htYXJraW5nOiB2ZXJpZnlcXG5lbGxpcHRpYyN2ZXJpZnkgeCAxMTMgb3BzL3NlYyDCsTAuNTAlICgxNjYgcnVucyBzYW1wbGVkKVxcbmVjY2pzI3ZlcmlmeSB4IDQ4LjU2IG9wcy9zZWMgwrEwLjM2JSAoMTI1IHJ1bnMgc2FtcGxlZClcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5GYXN0ZXN0IGlzIGVsbGlwdGljI3ZlcmlmeVxcbj09PT09PT09PT09PT09PT09PT09PT09PVxcbkJlbmNobWFya2luZzogZ2VuXFxuZWxsaXB0aWMjZ2VuIHggMjk0IG9wcy9zZWMgwrEwLjQzJSAoMTc2IHJ1bnMgc2FtcGxlZClcXG5lY2NqcyNnZW4geCA2Mi4yNSBvcHMvc2VjIMKxMC42MyUgKDEyOSBydW5zIHNhbXBsZWQpXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuRmFzdGVzdCBpcyBlbGxpcHRpYyNnZW5cXG49PT09PT09PT09PT09PT09PT09PT09PT1cXG5CZW5jaG1hcmtpbmc6IGVjZGhcXG5lbGxpcHRpYyNlY2RoIHggMTM2IG9wcy9zZWMgwrEwLjg1JSAoMTU2IHJ1bnMgc2FtcGxlZClcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5GYXN0ZXN0IGlzIGVsbGlwdGljI2VjZGhcXG49PT09PT09PT09PT09PT09PT09PT09PT1cXG5gYGBcXG5cXG4jIyBBUElcXG5cXG4jIyMgRUNEU0FcXG5cXG5gYGBqYXZhc2NyaXB0XFxudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lYztcXG5cXG4vLyBDcmVhdGUgYW5kIGluaXRpYWxpemUgRUMgY29udGV4dFxcbi8vIChiZXR0ZXIgZG8gaXQgb25jZSBhbmQgcmV1c2UgaXQpXFxudmFyIGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKTtcXG5cXG4vLyBHZW5lcmF0ZSBrZXlzXFxudmFyIGtleSA9IGVjLmdlbktleVBhaXIoKTtcXG5cXG4vLyBTaWduIG1lc3NhZ2UgKG11c3QgYmUgYW4gYXJyYXksIG9yIGl0J2xsIGJlIHRyZWF0ZWQgYXMgYSBoZXggc2VxdWVuY2UpXFxudmFyIG1zZyA9IFsgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAgXTtcXG52YXIgc2lnbmF0dXJlID0ga2V5LnNpZ24obXNnKTtcXG5cXG4vLyBFeHBvcnQgREVSIGVuY29kZWQgc2lnbmF0dXJlIGluIEFycmF5XFxudmFyIGRlclNpZ24gPSBzaWduYXR1cmUudG9ERVIoKTtcXG5cXG4vLyBWZXJpZnkgc2lnbmF0dXJlXFxuY29uc29sZS5sb2coa2V5LnZlcmlmeShtc2csIGRlclNpZ24pKTtcXG5cXG4vLyBDSEVDSyBXSVRIIE5PIFBSSVZBVEUgS0VZXFxuXFxuLy8gUHVibGljIGtleSBhcyAnMDQgKyB4ICsgeSdcXG52YXIgcHViID0gJzA0YmIxZmEzLi4uJztcXG5cXG4vLyBTaWduYXR1cmUgTVVTVCBiZSBlaXRoZXI6XFxuLy8gMSkgaGV4LXN0cmluZyBvZiBERVItZW5jb2RlZCBzaWduYXR1cmU7IG9yXFxuLy8gMikgREVSLWVuY29kZWQgc2lnbmF0dXJlIGFzIGJ1ZmZlcjsgb3JcXG4vLyAzKSBvYmplY3Qgd2l0aCB0d28gaGV4LXN0cmluZyBwcm9wZXJ0aWVzIChyIGFuZCBzKVxcblxcbnZhciBzaWduYXR1cmUgPSAnYjEwMmFjLi4uJzsgLy8gY2FzZSAxXFxudmFyIHNpZ25hdHVyZSA9IG5ldyBCdWZmZXIoJy4uLicpOyAvLyBjYXNlIDJcXG52YXIgc2lnbmF0dXJlID0geyByOiAnYjFmYy4uLicsIHM6ICc5YzQyLi4uJyB9OyAvLyBjYXNlIDNcXG5cXG4vLyBJbXBvcnQgcHVibGljIGtleVxcbnZhciBrZXkgPSBlYy5rZXlGcm9tUHVibGljKHB1YiwgJ2hleCcpO1xcblxcbi8vIFZlcmlmeSBzaWduYXR1cmVcXG5jb25zb2xlLmxvZyhrZXkudmVyaWZ5KG1zZywgc2lnbmF0dXJlKSk7XFxuYGBgXFxuXFxuIyMjIEVkRFNBXFxuXFxuYGBgamF2YXNjcmlwdFxcbnZhciBFZERTQSA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWRkc2E7XFxuXFxuLy8gQ3JlYXRlIGFuZCBpbml0aWFsaXplIEVkRFNBIGNvbnRleHRcXG4vLyAoYmV0dGVyIGRvIGl0IG9uY2UgYW5kIHJldXNlIGl0KVxcbnZhciBlYyA9IG5ldyBFZERTQSgnZWQyNTUxOScpO1xcblxcbi8vIENyZWF0ZSBrZXkgcGFpciBmcm9tIHNlY3JldFxcbnZhciBrZXkgPSBlYy5rZXlGcm9tU2VjcmV0KCc2OTNlM2MuLi4nKTsgLy8gaGV4IHN0cmluZywgYXJyYXkgb3IgQnVmZmVyXFxuXFxuLy8gU2lnbiBtZXNzYWdlIChtdXN0IGJlIGFuIGFycmF5LCBvciBpdCdsbCBiZSB0cmVhdGVkIGFzIGEgaGV4IHNlcXVlbmNlKVxcbnZhciBtc2cgPSBbIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwIF07XFxudmFyIHNpZ25hdHVyZSA9IGtleS5zaWduKG1zZykudG9IZXgoKTtcXG5cXG4vLyBWZXJpZnkgc2lnbmF0dXJlXFxuY29uc29sZS5sb2coa2V5LnZlcmlmeShtc2csIHNpZ25hdHVyZSkpO1xcblxcbi8vIENIRUNLIFdJVEggTk8gUFJJVkFURSBLRVlcXG5cXG4vLyBJbXBvcnQgcHVibGljIGtleVxcbnZhciBwdWIgPSAnMGExYWY2MzguLi4nO1xcbnZhciBrZXkgPSBlYy5rZXlGcm9tUHVibGljKHB1YiwgJ2hleCcpO1xcblxcbi8vIFZlcmlmeSBzaWduYXR1cmVcXG52YXIgc2lnbmF0dXJlID0gJzcwYmVkMS4uLic7XFxuY29uc29sZS5sb2coa2V5LnZlcmlmeShtc2csIHNpZ25hdHVyZSkpO1xcbmBgYFxcblxcbiMjIyBFQ0RIXFxuXFxuYGBgamF2YXNjcmlwdFxcbi8vIEdlbmVyYXRlIGtleXNcXG52YXIga2V5MSA9IGVjLmdlbktleVBhaXIoKTtcXG52YXIga2V5MiA9IGVjLmdlbktleVBhaXIoKTtcXG5cXG52YXIgc2hhcmVkMSA9IGtleTEuZGVyaXZlKGtleTIuZ2V0UHVibGljKCkpO1xcbnZhciBzaGFyZWQyID0ga2V5Mi5kZXJpdmUoa2V5MS5nZXRQdWJsaWMoKSk7XFxuXFxuY29uc29sZS5sb2coJ0JvdGggc2hhcmVkIHNlY3JldHMgYXJlIEJOIGluc3RhbmNlcycpO1xcbmNvbnNvbGUubG9nKHNoYXJlZDEudG9TdHJpbmcoMTYpKTtcXG5jb25zb2xlLmxvZyhzaGFyZWQyLnRvU3RyaW5nKDE2KSk7XFxuYGBgXFxuXFxuTk9URTogYC5kZXJpdmUoKWAgcmV0dXJucyBhIFtCTl1bMV0gaW5zdGFuY2UuXFxuXFxuIyMgU3VwcG9ydGVkIGN1cnZlc1xcblxcbkVsbGlwdGljLmpzIHN1cHBvcnQgZm9sbG93aW5nIGN1cnZlIHR5cGVzOlxcblxcbiogU2hvcnQgV2VpZXJzdHJhc3NcXG4qIE1vbnRnb21lcnlcXG4qIEVkd2FyZHNcXG4qIFR3aXN0ZWQgRWR3YXJkc1xcblxcbkZvbGxvd2luZyBjdXJ2ZSAncHJlc2V0cycgYXJlIGVtYmVkZGVkIGludG8gdGhlIGxpYnJhcnk6XFxuXFxuKiBgc2VjcDI1NmsxYFxcbiogYHAxOTJgXFxuKiBgcDIyNGBcXG4qIGBwMjU2YFxcbiogYHAzODRgXFxuKiBgcDUyMWBcXG4qIGBjdXJ2ZTI1NTE5YFxcbiogYGVkMjU1MTlgXFxuXFxuTk9URTogVGhhdCBgY3VydmUyNTUxOWAgY291bGQgbm90IGJlIHVzZWQgZm9yIEVDRFNBLCB1c2UgYGVkMjU1MTlgIGluc3RlYWQuXFxuXFxuIyMjIEltcGxlbWVudGF0aW9uIGRldGFpbHNcXG5cXG5FQ0RTQSBpcyB1c2luZyBkZXRlcm1pbmlzdGljIGBrYCB2YWx1ZSBnZW5lcmF0aW9uIGFzIHBlciBbUkZDNjk3OV1bMF0uIE1vc3Qgb2ZcXG50aGUgY3VydmUgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIG9uIG5vbi1hZmZpbmUgY29vcmRpbmF0ZXMgKGVpdGhlciBwcm9qZWN0aXZlXFxub3IgZXh0ZW5kZWQpLCB2YXJpb3VzIHdpbmRvd2luZyB0ZWNobmlxdWVzIGFyZSB1c2VkIGZvciBkaWZmZXJlbnQgY2FzZXMuXFxuXFxuQWxsIG9wZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCBpbiByZWR1Y3Rpb24gY29udGV4dCB1c2luZyBbYm4uanNdWzFdLCBoYXNoaW5nIGlzXFxucHJvdmlkZWQgYnkgW2hhc2guanNdWzJdXFxuXFxuIyMjIFJlbGF0ZWQgcHJvamVjdHNcXG5cXG4qIFtlY2NyeXB0b11bM106IGlzb21vcnBoaWMgaW1wbGVtZW50YXRpb24gb2YgRUNEU0EsIEVDREggYW5kIEVDSUVTIGZvciBib3RoXFxuICBicm93c2VyaWZ5IGFuZCBub2RlICh1c2VzIGBlbGxpcHRpY2AgZm9yIGJyb3dzZXIgYW5kIFtzZWNwMjU2azEtbm9kZV1bNF0gZm9yXFxuICBub2RlKVxcblxcbiMjIyMgTElDRU5TRVxcblxcblRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxcblxcbkNvcHlyaWdodCBGZWRvciBJbmR1dG55LCAyMDE0LlxcblxcblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcblxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbnBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbmZvbGxvd2luZyBjb25kaXRpb25zOlxcblxcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuXFxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG5PUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbk5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbkRBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbk9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG5VU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcblswXTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjk3OVxcblsxXTogaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanNcXG5bMl06IGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2hhc2guanNcXG5bM106IGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjaGFuL2VjY3J5cHRvXFxuWzRdOiBodHRwczovL2dpdGh1Yi5jb20vd2FuZGVyZXIvc2VjcDI1NmsxLW5vZGVcXG5cIixcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcIlJFQURNRS5tZFwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImpzY3NcIjogXCJqc2NzIGJlbmNobWFya3MvKi5qcyBsaWIvKi5qcyBsaWIvKiovKi5qcyBsaWIvKiovKiovKi5qcyB0ZXN0L2luZGV4LmpzXCIsXG4gICAgXCJqc2hpbnRcIjogXCJqc2NzIGJlbmNobWFya3MvKi5qcyBsaWIvKi5qcyBsaWIvKiovKi5qcyBsaWIvKiovKiovKi5qcyB0ZXN0L2luZGV4LmpzXCIsXG4gICAgXCJsaW50XCI6IFwibnBtIHJ1biBqc2NzICYmIG5wbSBydW4ganNoaW50XCIsXG4gICAgXCJ0ZXN0XCI6IFwibnBtIHJ1biBsaW50ICYmIG5wbSBydW4gdW5pdFwiLFxuICAgIFwidW5pdFwiOiBcImlzdGFuYnVsIHRlc3QgX21vY2hhIC0tcmVwb3J0ZXI9c3BlYyB0ZXN0L2luZGV4LmpzXCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwiZ3J1bnQgZGlzdCAmJiBnaXQgYWRkIGRpc3QvXCJcbiAgfSxcbiAgXCJ2ZXJzaW9uXCI6IFwiNi4zLjFcIlxufVxuIiwidmFyIGhhc2ggPSBleHBvcnRzO1xuXG5oYXNoLnV0aWxzID0gcmVxdWlyZSgnLi9oYXNoL3V0aWxzJyk7XG5oYXNoLmNvbW1vbiA9IHJlcXVpcmUoJy4vaGFzaC9jb21tb24nKTtcbmhhc2guc2hhID0gcmVxdWlyZSgnLi9oYXNoL3NoYScpO1xuaGFzaC5yaXBlbWQgPSByZXF1aXJlKCcuL2hhc2gvcmlwZW1kJyk7XG5oYXNoLmhtYWMgPSByZXF1aXJlKCcuL2hhc2gvaG1hYycpO1xuXG4vLyBQcm94eSBoYXNoIGZ1bmN0aW9ucyB0byB0aGUgbWFpbiBvYmplY3Rcbmhhc2guc2hhMSA9IGhhc2guc2hhLnNoYTE7XG5oYXNoLnNoYTI1NiA9IGhhc2guc2hhLnNoYTI1Njtcbmhhc2guc2hhMjI0ID0gaGFzaC5zaGEuc2hhMjI0O1xuaGFzaC5zaGEzODQgPSBoYXNoLnNoYS5zaGEzODQ7XG5oYXNoLnNoYTUxMiA9IGhhc2guc2hhLnNoYTUxMjtcbmhhc2gucmlwZW1kMTYwID0gaGFzaC5yaXBlbWQucmlwZW1kMTYwO1xuIiwidmFyIGhhc2ggPSByZXF1aXJlKCcuLi9oYXNoJyk7XG52YXIgdXRpbHMgPSBoYXNoLnV0aWxzO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gQmxvY2tIYXNoKCkge1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7XG4gIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcbiAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcbiAgdGhpcy5wYWRMZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aCAvIDg7XG4gIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cbiAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuICB0aGlzLl9kZWx0YTMyID0gdGhpcy5ibG9ja1NpemUgLyAzMjtcbn1cbmV4cG9ydHMuQmxvY2tIYXNoID0gQmxvY2tIYXNoO1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICAvLyBDb252ZXJ0IG1lc3NhZ2UgdG8gYXJyYXksIHBhZCBpdCwgYW5kIGpvaW4gaW50byAzMmJpdCBibG9ja3NcbiAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG4gIGlmICghdGhpcy5wZW5kaW5nKVxuICAgIHRoaXMucGVuZGluZyA9IG1zZztcbiAgZWxzZVxuICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQobXNnKTtcbiAgdGhpcy5wZW5kaW5nVG90YWwgKz0gbXNnLmxlbmd0aDtcblxuICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG4gIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID49IHRoaXMuX2RlbHRhOCkge1xuICAgIG1zZyA9IHRoaXMucGVuZGluZztcblxuICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuICAgIHZhciByID0gbXNnLmxlbmd0aCAlIHRoaXMuX2RlbHRhODtcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblxuICAgIG1zZyA9IHV0aWxzLmpvaW4zMihtc2csIDAsIG1zZy5sZW5ndGggLSByLCB0aGlzLmVuZGlhbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG4gICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG4gIGFzc2VydCh0aGlzLnBlbmRpbmcgPT09IG51bGwpO1xuXG4gIHJldHVybiB0aGlzLl9kaWdlc3QoZW5jKTtcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIHBhZCgpIHtcbiAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG4gIHZhciBrID0gYnl0ZXMgLSAoKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShrICsgdGhpcy5wYWRMZW5ndGgpO1xuICByZXNbMF0gPSAweDgwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGs7IGkrKylcbiAgICByZXNbaV0gPSAwO1xuXG4gIC8vIEFwcGVuZCBsZW5ndGhcbiAgbGVuIDw8PSAzO1xuICBpZiAodGhpcy5lbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuXG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcblxuICAgIGZvciAodmFyIHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcbiAgICAgIHJlc1tpKytdID0gMDtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuIiwidmFyIGhtYWMgPSBleHBvcnRzO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4uL2hhc2gnKTtcbnZhciB1dGlscyA9IGhhc2gudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBIbWFjKGhhc2gsIGtleSwgZW5jKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSlcbiAgICByZXR1cm4gbmV3IEhtYWMoaGFzaCwga2V5LCBlbmMpO1xuICB0aGlzLkhhc2ggPSBoYXNoO1xuICB0aGlzLmJsb2NrU2l6ZSA9IGhhc2guYmxvY2tTaXplIC8gODtcbiAgdGhpcy5vdXRTaXplID0gaGFzaC5vdXRTaXplIC8gODtcbiAgdGhpcy5pbm5lciA9IG51bGw7XG4gIHRoaXMub3V0ZXIgPSBudWxsO1xuXG4gIHRoaXMuX2luaXQodXRpbHMudG9BcnJheShrZXksIGVuYykpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjO1xuXG5IbWFjLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoa2V5KSB7XG4gIC8vIFNob3J0ZW4ga2V5LCBpZiBuZWVkZWRcbiAgaWYgKGtleS5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSlcbiAgICBrZXkgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSkuZGlnZXN0KCk7XG4gIGFzc2VydChrZXkubGVuZ3RoIDw9IHRoaXMuYmxvY2tTaXplKTtcblxuICAvLyBBZGQgcGFkZGluZyB0byBrZXlcbiAgZm9yICh2YXIgaSA9IGtleS5sZW5ndGg7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgIGtleS5wdXNoKDApO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDM2O1xuICB0aGlzLmlubmVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuXG4gIC8vIDB4MzYgXiAweDVjID0gMHg2YVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcbiAgICBrZXlbaV0gXj0gMHg2YTtcbiAgdGhpcy5vdXRlciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcbn07XG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICB0aGlzLmlubmVyLnVwZGF0ZShtc2csIGVuYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuSG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLm91dGVyLnVwZGF0ZSh0aGlzLmlubmVyLmRpZ2VzdCgpKTtcbiAgcmV0dXJuIHRoaXMub3V0ZXIuZGlnZXN0KGVuYyk7XG59O1xuIiwidmFyIGhhc2ggPSByZXF1aXJlKCcuLi9oYXNoJyk7XG52YXIgdXRpbHMgPSBoYXNoLnV0aWxzO1xuXG52YXIgcm90bDMyID0gdXRpbHMucm90bDMyO1xudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfMyA9IHV0aWxzLnN1bTMyXzM7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgQmxvY2tIYXNoID0gaGFzaC5jb21tb24uQmxvY2tIYXNoO1xuXG5mdW5jdGlvbiBSSVBFTUQxNjAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSSVBFTUQxNjApKVxuICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5oID0gWyAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuZW5kaWFuID0gJ2xpdHRsZSc7XG59XG51dGlscy5pbmhlcml0cyhSSVBFTUQxNjAsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnJpcGVtZDE2MCA9IFJJUEVNRDE2MDtcblxuUklQRU1EMTYwLmJsb2NrU2l6ZSA9IDUxMjtcblJJUEVNRDE2MC5vdXRTaXplID0gMTYwO1xuUklQRU1EMTYwLmhtYWNTdHJlbmd0aCA9IDE5MjtcblJJUEVNRDE2MC5wYWRMZW5ndGggPSA2NDtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIEEgPSB0aGlzLmhbMF07XG4gIHZhciBCID0gdGhpcy5oWzFdO1xuICB2YXIgQyA9IHRoaXMuaFsyXTtcbiAgdmFyIEQgPSB0aGlzLmhbM107XG4gIHZhciBFID0gdGhpcy5oWzRdO1xuICB2YXIgQWggPSBBO1xuICB2YXIgQmggPSBCO1xuICB2YXIgQ2ggPSBDO1xuICB2YXIgRGggPSBEO1xuICB2YXIgRWggPSBFO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICB2YXIgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEEsIGYoaiwgQiwgQywgRCksIG1zZ1tyW2pdICsgc3RhcnRdLCBLKGopKSxcbiAgICAgICAgc1tqXSksXG4gICAgICBFKTtcbiAgICBBID0gRTtcbiAgICBFID0gRDtcbiAgICBEID0gcm90bDMyKEMsIDEwKTtcbiAgICBDID0gQjtcbiAgICBCID0gVDtcbiAgICBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQWgsIGYoNzkgLSBqLCBCaCwgQ2gsIERoKSwgbXNnW3JoW2pdICsgc3RhcnRdLCBLaChqKSksXG4gICAgICAgIHNoW2pdKSxcbiAgICAgIEVoKTtcbiAgICBBaCA9IEVoO1xuICAgIEVoID0gRGg7XG4gICAgRGggPSByb3RsMzIoQ2gsIDEwKTtcbiAgICBDaCA9IEJoO1xuICAgIEJoID0gVDtcbiAgfVxuICBUID0gc3VtMzJfMyh0aGlzLmhbMV0sIEMsIERoKTtcbiAgdGhpcy5oWzFdID0gc3VtMzJfMyh0aGlzLmhbMl0sIEQsIEVoKTtcbiAgdGhpcy5oWzJdID0gc3VtMzJfMyh0aGlzLmhbM10sIEUsIEFoKTtcbiAgdGhpcy5oWzNdID0gc3VtMzJfMyh0aGlzLmhbNF0sIEEsIEJoKTtcbiAgdGhpcy5oWzRdID0gc3VtMzJfMyh0aGlzLmhbMF0sIEIsIENoKTtcbiAgdGhpcy5oWzBdID0gVDtcbn07XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnbGl0dGxlJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdsaXR0bGUnKTtcbn07XG5cbmZ1bmN0aW9uIGYoaiwgeCwgeSwgeikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4geCBeIHkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAoeCAmIHkpIHwgKCh+eCkgJiB6KTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gKHggfCAofnkpKSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuICh4ICYgeikgfCAoeSAmICh+eikpO1xuICBlbHNlXG4gICAgcmV0dXJuIHggXiAoeSB8ICh+eikpO1xufVxuXG5mdW5jdGlvbiBLKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWE4Mjc5OTk7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmVkOWViYTE7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4OGYxYmJjZGM7XG4gIGVsc2VcbiAgICByZXR1cm4gMHhhOTUzZmQ0ZTtcbn1cblxuZnVuY3Rpb24gS2goaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHg1MGEyOGJlNjtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YzRkZDEyNDtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZDcwM2VmMztcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg3YTZkNzZlOTtcbiAgZWxzZVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xufVxuXG52YXIgciA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXTtcblxudmFyIHJoID0gW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5dO1xuXG52YXIgcyA9IFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcbl07XG5cbnZhciBzaCA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl07XG4iLCJ2YXIgaGFzaCA9IHJlcXVpcmUoJy4uL2hhc2gnKTtcbnZhciB1dGlscyA9IGhhc2gudXRpbHM7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG52YXIgcm90cjMyID0gdXRpbHMucm90cjMyO1xudmFyIHJvdGwzMiA9IHV0aWxzLnJvdGwzMjtcbnZhciBzdW0zMiA9IHV0aWxzLnN1bTMyO1xudmFyIHN1bTMyXzQgPSB1dGlscy5zdW0zMl80O1xudmFyIHN1bTMyXzUgPSB1dGlscy5zdW0zMl81O1xudmFyIHJvdHI2NF9oaSA9IHV0aWxzLnJvdHI2NF9oaTtcbnZhciByb3RyNjRfbG8gPSB1dGlscy5yb3RyNjRfbG87XG52YXIgc2hyNjRfaGkgPSB1dGlscy5zaHI2NF9oaTtcbnZhciBzaHI2NF9sbyA9IHV0aWxzLnNocjY0X2xvO1xudmFyIHN1bTY0ID0gdXRpbHMuc3VtNjQ7XG52YXIgc3VtNjRfaGkgPSB1dGlscy5zdW02NF9oaTtcbnZhciBzdW02NF9sbyA9IHV0aWxzLnN1bTY0X2xvO1xudmFyIHN1bTY0XzRfaGkgPSB1dGlscy5zdW02NF80X2hpO1xudmFyIHN1bTY0XzRfbG8gPSB1dGlscy5zdW02NF80X2xvO1xudmFyIHN1bTY0XzVfaGkgPSB1dGlscy5zdW02NF81X2hpO1xudmFyIHN1bTY0XzVfbG8gPSB1dGlscy5zdW02NF81X2xvO1xudmFyIEJsb2NrSGFzaCA9IGhhc2guY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTI1Nl9LID0gW1xuICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LFxuICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuICAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LFxuICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLFxuICAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LFxuICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dO1xuXG52YXIgc2hhNTEyX0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl07XG5cbnZhciBzaGExX0sgPSBbXG4gIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsXG4gIDB4OEYxQkJDREMsIDB4Q0E2MkMxRDZcbl07XG5cbmZ1bmN0aW9uIFNIQTI1NigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG4gICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLFxuICAgICAgICAgICAgIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTkgXTtcbiAgdGhpcy5rID0gc2hhMjU2X0s7XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg2NCk7XG59XG51dGlscy5pbmhlcml0cyhTSEEyNTYsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnNoYTI1NiA9IFNIQTI1NjtcblxuU0hBMjU2LmJsb2NrU2l6ZSA9IDUxMjtcblNIQTI1Ni5vdXRTaXplID0gMjU2O1xuU0hBMjU2LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTI1Ni5wYWRMZW5ndGggPSA2NDtcblxuU0hBMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gc3VtMzJfNChnMV8yNTYoV1tpIC0gMl0pLCBXW2kgLSA3XSwgZzBfMjU2KFdbaSAtIDE1XSksIFdbaSAtIDE2XSk7XG5cbiAgdmFyIGEgPSB0aGlzLmhbMF07XG4gIHZhciBiID0gdGhpcy5oWzFdO1xuICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgdmFyIGQgPSB0aGlzLmhbM107XG4gIHZhciBlID0gdGhpcy5oWzRdO1xuICB2YXIgZiA9IHRoaXMuaFs1XTtcbiAgdmFyIGcgPSB0aGlzLmhbNl07XG4gIHZhciBoID0gdGhpcy5oWzddO1xuXG4gIGFzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBUMSA9IHN1bTMyXzUoaCwgczFfMjU2KGUpLCBjaDMyKGUsIGYsIGcpLCB0aGlzLmtbaV0sIFdbaV0pO1xuICAgIHZhciBUMiA9IHN1bTMyKHMwXzI1NihhKSwgbWFqMzIoYSwgYiwgYykpO1xuICAgIGggPSBnO1xuICAgIGcgPSBmO1xuICAgIGYgPSBlO1xuICAgIGUgPSBzdW0zMihkLCBUMSk7XG4gICAgZCA9IGM7XG4gICAgYyA9IGI7XG4gICAgYiA9IGE7XG4gICAgYSA9IHN1bTMyKFQxLCBUMik7XG4gIH1cblxuICB0aGlzLmhbMF0gPSBzdW0zMih0aGlzLmhbMF0sIGEpO1xuICB0aGlzLmhbMV0gPSBzdW0zMih0aGlzLmhbMV0sIGIpO1xuICB0aGlzLmhbMl0gPSBzdW0zMih0aGlzLmhbMl0sIGMpO1xuICB0aGlzLmhbM10gPSBzdW0zMih0aGlzLmhbM10sIGQpO1xuICB0aGlzLmhbNF0gPSBzdW0zMih0aGlzLmhbNF0sIGUpO1xuICB0aGlzLmhbNV0gPSBzdW0zMih0aGlzLmhbNV0sIGYpO1xuICB0aGlzLmhbNl0gPSBzdW0zMih0aGlzLmhbNl0sIGcpO1xuICB0aGlzLmhbN10gPSBzdW0zMih0aGlzLmhbN10sIGgpO1xufTtcblxuU0hBMjU2LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gU0hBMjI0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMjI0KSlcbiAgICByZXR1cm4gbmV3IFNIQTIyNCgpO1xuXG4gIFNIQTI1Ni5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksXG4gICAgICAgICAgICAgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMjI0LCBTSEEyNTYpO1xuZXhwb3J0cy5zaGEyMjQgPSBTSEEyMjQ7XG5cblNIQTIyNC5ibG9ja1NpemUgPSA1MTI7XG5TSEEyMjQub3V0U2l6ZSA9IDIyNDtcblNIQTIyNC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEyMjQucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTIyNC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgLy8gSnVzdCB0cnVuY2F0ZSBvdXRwdXRcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIFNIQTUxMigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTUxMikpXG4gICAgcmV0dXJuIG5ldyBTSEE1MTIoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweDZhMDllNjY3LCAweGYzYmNjOTA4LFxuICAgICAgICAgICAgIDB4YmI2N2FlODUsIDB4ODRjYWE3M2IsXG4gICAgICAgICAgICAgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYixcbiAgICAgICAgICAgICAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuICAgICAgICAgICAgIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsXG4gICAgICAgICAgICAgMHg5YjA1Njg4YywgMHgyYjNlNmMxZixcbiAgICAgICAgICAgICAweDFmODNkOWFiLCAweGZiNDFiZDZiLFxuICAgICAgICAgICAgIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzkgXTtcbiAgdGhpcy5rID0gc2hhNTEyX0s7XG4gIHRoaXMuVyA9IG5ldyBBcnJheSgxNjApO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBNTEyLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5zaGE1MTIgPSBTSEE1MTI7XG5cblNIQTUxMi5ibG9ja1NpemUgPSAxMDI0O1xuU0hBNTEyLm91dFNpemUgPSA1MTI7XG5TSEE1MTIuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBNTEyLnBhZExlbmd0aCA9IDEyODtcblxuU0hBNTEyLnByb3RvdHlwZS5fcHJlcGFyZUJsb2NrID0gZnVuY3Rpb24gX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIC8vIDMyIHggMzJiaXQgd29yZHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gZzFfNTEyX2hpKFdbaSAtIDRdLCBXW2kgLSAzXSk7ICAvLyBpIC0gMlxuICAgIHZhciBjMF9sbyA9IGcxXzUxMl9sbyhXW2kgLSA0XSwgV1tpIC0gM10pO1xuICAgIHZhciBjMV9oaSA9IFdbaSAtIDE0XTsgIC8vIGkgLSA3XG4gICAgdmFyIGMxX2xvID0gV1tpIC0gMTNdO1xuICAgIHZhciBjMl9oaSA9IGcwXzUxMl9oaShXW2kgLSAzMF0sIFdbaSAtIDI5XSk7ICAvLyBpIC0gMTVcbiAgICB2YXIgYzJfbG8gPSBnMF81MTJfbG8oV1tpIC0gMzBdLCBXW2kgLSAyOV0pO1xuICAgIHZhciBjM19oaSA9IFdbaSAtIDMyXTsgIC8vIGkgLSAxNlxuICAgIHZhciBjM19sbyA9IFdbaSAtIDMxXTtcblxuICAgIFdbaV0gPSBzdW02NF80X2hpKGMwX2hpLCBjMF9sbyxcbiAgICAgICAgICAgICAgICAgICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgICAgICAgICAgICAgICAgIGMzX2hpLCBjM19sbyk7XG4gICAgV1tpICsgMV0gPSBzdW02NF80X2xvKGMwX2hpLCBjMF9sbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGMzX2hpLCBjM19sbyk7XG4gIH1cbn07XG5cblNIQTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB0aGlzLl9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCk7XG5cbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgdmFyIGFoID0gdGhpcy5oWzBdO1xuICB2YXIgYWwgPSB0aGlzLmhbMV07XG4gIHZhciBiaCA9IHRoaXMuaFsyXTtcbiAgdmFyIGJsID0gdGhpcy5oWzNdO1xuICB2YXIgY2ggPSB0aGlzLmhbNF07XG4gIHZhciBjbCA9IHRoaXMuaFs1XTtcbiAgdmFyIGRoID0gdGhpcy5oWzZdO1xuICB2YXIgZGwgPSB0aGlzLmhbN107XG4gIHZhciBlaCA9IHRoaXMuaFs4XTtcbiAgdmFyIGVsID0gdGhpcy5oWzldO1xuICB2YXIgZmggPSB0aGlzLmhbMTBdO1xuICB2YXIgZmwgPSB0aGlzLmhbMTFdO1xuICB2YXIgZ2ggPSB0aGlzLmhbMTJdO1xuICB2YXIgZ2wgPSB0aGlzLmhbMTNdO1xuICB2YXIgaGggPSB0aGlzLmhbMTRdO1xuICB2YXIgaGwgPSB0aGlzLmhbMTVdO1xuXG4gIGFzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGhoO1xuICAgIHZhciBjMF9sbyA9IGhsO1xuICAgIHZhciBjMV9oaSA9IHMxXzUxMl9oaShlaCwgZWwpO1xuICAgIHZhciBjMV9sbyA9IHMxXzUxMl9sbyhlaCwgZWwpO1xuICAgIHZhciBjMl9oaSA9IGNoNjRfaGkoZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG4gICAgdmFyIGMyX2xvID0gY2g2NF9sbyhlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzNfaGkgPSB0aGlzLmtbaV07XG4gICAgdmFyIGMzX2xvID0gdGhpcy5rW2kgKyAxXTtcbiAgICB2YXIgYzRfaGkgPSBXW2ldO1xuICAgIHZhciBjNF9sbyA9IFdbaSArIDFdO1xuXG4gICAgdmFyIFQxX2hpID0gc3VtNjRfNV9oaShjMF9oaSwgYzBfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjM19oaSwgYzNfbG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjNF9oaSwgYzRfbG8pO1xuICAgIHZhciBUMV9sbyA9IHN1bTY0XzVfbG8oYzBfaGksIGMwX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYzRfaGksIGM0X2xvKTtcblxuICAgIHZhciBjMF9oaSA9IHMwXzUxMl9oaShhaCwgYWwpO1xuICAgIHZhciBjMF9sbyA9IHMwXzUxMl9sbyhhaCwgYWwpO1xuICAgIHZhciBjMV9oaSA9IG1hajY0X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuICAgIHZhciBjMV9sbyA9IG1hajY0X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuXG4gICAgdmFyIFQyX2hpID0gc3VtNjRfaGkoYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuICAgIHZhciBUMl9sbyA9IHN1bTY0X2xvKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcblxuICAgIGhoID0gZ2g7XG4gICAgaGwgPSBnbDtcblxuICAgIGdoID0gZmg7XG4gICAgZ2wgPSBmbDtcblxuICAgIGZoID0gZWg7XG4gICAgZmwgPSBlbDtcblxuICAgIGVoID0gc3VtNjRfaGkoZGgsIGRsLCBUMV9oaSwgVDFfbG8pO1xuICAgIGVsID0gc3VtNjRfbG8oZGwsIGRsLCBUMV9oaSwgVDFfbG8pO1xuXG4gICAgZGggPSBjaDtcbiAgICBkbCA9IGNsO1xuXG4gICAgY2ggPSBiaDtcbiAgICBjbCA9IGJsO1xuXG4gICAgYmggPSBhaDtcbiAgICBibCA9IGFsO1xuXG4gICAgYWggPSBzdW02NF9oaShUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gICAgYWwgPSBzdW02NF9sbyhUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gIH1cblxuICBzdW02NCh0aGlzLmgsIDAsIGFoLCBhbCk7XG4gIHN1bTY0KHRoaXMuaCwgMiwgYmgsIGJsKTtcbiAgc3VtNjQodGhpcy5oLCA0LCBjaCwgY2wpO1xuICBzdW02NCh0aGlzLmgsIDYsIGRoLCBkbCk7XG4gIHN1bTY0KHRoaXMuaCwgOCwgZWgsIGVsKTtcbiAgc3VtNjQodGhpcy5oLCAxMCwgZmgsIGZsKTtcbiAgc3VtNjQodGhpcy5oLCAxMiwgZ2gsIGdsKTtcbiAgc3VtNjQodGhpcy5oLCAxNCwgaGgsIGhsKTtcbn07XG5cblNIQTUxMi5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIFNIQTM4NCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTM4NCkpXG4gICAgcmV0dXJuIG5ldyBTSEEzODQoKTtcblxuICBTSEE1MTIuY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gWyAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LFxuICAgICAgICAgICAgIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsXG4gICAgICAgICAgICAgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyxcbiAgICAgICAgICAgICAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgICAgICAgICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsXG4gICAgICAgICAgICAgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSxcbiAgICAgICAgICAgICAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LFxuICAgICAgICAgICAgIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTM4NCwgU0hBNTEyKTtcbmV4cG9ydHMuc2hhMzg0ID0gU0hBMzg0O1xuXG5TSEEzODQuYmxvY2tTaXplID0gMTAyNDtcblNIQTM4NC5vdXRTaXplID0gMzg0O1xuU0hBMzg0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTM4NC5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTM4NC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsXG4gICAgICAgICAgICAgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoODApO1xufVxuXG51dGlscy5pbmhlcml0cyhTSEExLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5zaGExID0gU0hBMTtcblxuU0hBMS5ibG9ja1NpemUgPSA1MTI7XG5TSEExLm91dFNpemUgPSAxNjA7XG5TSEExLmhtYWNTdHJlbmd0aCA9IDgwO1xuU0hBMS5wYWRMZW5ndGggPSA2NDtcblxuU0hBMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuXG4gIGZvcig7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSByb3RsMzIoV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XSwgMSk7XG5cbiAgdmFyIGEgPSB0aGlzLmhbMF07XG4gIHZhciBiID0gdGhpcy5oWzFdO1xuICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgdmFyIGQgPSB0aGlzLmhbM107XG4gIHZhciBlID0gdGhpcy5oWzRdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuXG5mdW5jdGlvbiBjaDMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoKH54KSAmIHopO1xufVxuXG5mdW5jdGlvbiBtYWozMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG59XG5cbmZ1bmN0aW9uIHAzMih4LCB5LCB6KSB7XG4gIHJldHVybiB4IF4geSBeIHo7XG59XG5cbmZ1bmN0aW9uIHMwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgMikgXiByb3RyMzIoeCwgMTMpIF4gcm90cjMyKHgsIDIyKTtcbn1cblxuZnVuY3Rpb24gczFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCA2KSBeIHJvdHIzMih4LCAxMSkgXiByb3RyMzIoeCwgMjUpO1xufVxuXG5mdW5jdGlvbiBnMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDcpIF4gcm90cjMyKHgsIDE4KSBeICh4ID4+PiAzKTtcbn1cblxuZnVuY3Rpb24gZzFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAxNykgXiByb3RyMzIoeCwgMTkpIF4gKHggPj4+IDEwKTtcbn1cblxuZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG4gIGlmIChzID09PSAwKVxuICAgIHJldHVybiBjaDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAyKVxuICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcbn1cblxuZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhoICYgeWgpIF4gKCh+eGgpICYgemgpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGNoNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4bCAmIHlsKSBeICgofnhsKSAmIHpsKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhoICYgeWgpIF4gKHhoICYgemgpIF4gKHloICYgemgpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2xvKHhoLCB4bCwgeWgsIHlsLCB6aCwgemwpIHtcbiAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoeGwgJiB6bCkgXiAoeWwgJiB6bCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczBfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAyOCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDIpOyAgLy8gMzRcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgNyk7ICAvLyAzOVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE0KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTgpO1xuICB2YXIgYzJfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCA5KTsgIC8vIDQxXG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMSk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDgpO1xuICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDcpO1xuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcwXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMSk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDgpO1xuICB2YXIgYzJfbG8gPSBzaHI2NF9sbyh4aCwgeGwsIDcpO1xuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcxXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTkpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyOSk7ICAvLyA2MVxuICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDYpO1xuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGcxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTkpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyOSk7ICAvLyA2MVxuICB2YXIgYzJfbG8gPSBzaHI2NF9sbyh4aCwgeGwsIDYpO1xuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG4iLCJ2YXIgdXRpbHMgPSBleHBvcnRzO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgIGlmICghZW5jKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgaGkgPSBjID4+IDg7XG4gICAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgICBpZiAoaGkpXG4gICAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlcy5wdXNoKGxvKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleCA9IHRvSGV4O1xuXG5mdW5jdGlvbiBodG9ubCh3KSB7XG4gIHZhciByZXMgPSAodyA+Pj4gMjQpIHxcbiAgICAgICAgICAgICgodyA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgICAgICgodyA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICAgICAoKHcgJiAweGZmKSA8PCAyNCk7XG4gIHJldHVybiByZXMgPj4+IDA7XG59XG51dGlscy5odG9ubCA9IGh0b25sO1xuXG5mdW5jdGlvbiB0b0hleDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJylcbiAgICAgIHcgPSBodG9ubCh3KTtcbiAgICByZXMgKz0gemVybzgody50b1N0cmluZygxNikpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleDMyID0gdG9IZXgzMjtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHplcm84KHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSA3KVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNilcbiAgICByZXR1cm4gJzAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuICAgIHJldHVybiAnMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA0KVxuICAgIHJldHVybiAnMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMylcbiAgICByZXR1cm4gJzAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuICAgIHJldHVybiAnMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMDAwMDAwMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG51dGlscy56ZXJvOCA9IHplcm84O1xuXG5mdW5jdGlvbiBqb2luMzIobXNnLCBzdGFydCwgZW5kLCBlbmRpYW4pIHtcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICBhc3NlcnQobGVuICUgNCA9PT0gMCk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuIC8gNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gc3RhcnQ7IGkgPCByZXMubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKVxuICAgICAgdyA9IChtc2dba10gPDwgMjQpIHwgKG1zZ1trICsgMV0gPDwgMTYpIHwgKG1zZ1trICsgMl0gPDwgOCkgfCBtc2dbayArIDNdO1xuICAgIGVsc2VcbiAgICAgIHcgPSAobXNnW2sgKyAzXSA8PCAyNCkgfCAobXNnW2sgKyAyXSA8PCAxNikgfCAobXNnW2sgKyAxXSA8PCA4KSB8IG1zZ1trXTtcbiAgICByZXNbaV0gPSB3ID4+PiAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy5qb2luMzIgPSBqb2luMzI7XG5cbmZ1bmN0aW9uIHNwbGl0MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShtc2cubGVuZ3RoICogNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIG0gPSBtc2dbaV07XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICAgIHJlc1trXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDNdID0gbSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trICsgM10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2tdID0gbSAmIDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy5zcGxpdDMyID0gc3BsaXQzMjtcblxuZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcbiAgcmV0dXJuICh3ID4+PiBiKSB8ICh3IDw8ICgzMiAtIGIpKTtcbn1cbnV0aWxzLnJvdHIzMiA9IHJvdHIzMjtcblxuZnVuY3Rpb24gcm90bDMyKHcsIGIpIHtcbiAgcmV0dXJuICh3IDw8IGIpIHwgKHcgPj4+ICgzMiAtIGIpKTtcbn1cbnV0aWxzLnJvdGwzMiA9IHJvdGwzMjtcblxuZnVuY3Rpb24gc3VtMzIoYSwgYikge1xuICByZXR1cm4gKGEgKyBiKSA+Pj4gMDtcbn1cbnV0aWxzLnN1bTMyID0gc3VtMzI7XG5cbmZ1bmN0aW9uIHN1bTMyXzMoYSwgYiwgYykge1xuICByZXR1cm4gKGEgKyBiICsgYykgPj4+IDA7XG59XG51dGlscy5zdW0zMl8zID0gc3VtMzJfMztcblxuZnVuY3Rpb24gc3VtMzJfNChhLCBiLCBjLCBkKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCkgPj4+IDA7XG59XG51dGlscy5zdW0zMl80ID0gc3VtMzJfNDtcblxuZnVuY3Rpb24gc3VtMzJfNShhLCBiLCBjLCBkLCBlKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCArIGUpID4+PiAwO1xufVxudXRpbHMuc3VtMzJfNSA9IHN1bTMyXzU7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cbnV0aWxzLmFzc2VydCA9IGFzc2VydDtcblxudXRpbHMuaW5oZXJpdHMgPSBpbmhlcml0cztcblxuZnVuY3Rpb24gc3VtNjQoYnVmLCBwb3MsIGFoLCBhbCkge1xuICB2YXIgYmggPSBidWZbcG9zXTtcbiAgdmFyIGJsID0gYnVmW3BvcyArIDFdO1xuXG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICBidWZbcG9zXSA9IGhpID4+PiAwO1xuICBidWZbcG9zICsgMV0gPSBsbztcbn1cbmV4cG9ydHMuc3VtNjQgPSBzdW02NDtcblxuZnVuY3Rpb24gc3VtNjRfaGkoYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0X2hpID0gc3VtNjRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0X2xvKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IGFsICsgYmw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0X2xvID0gc3VtNjRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0XzRfaGkgPSBzdW02NF80X2hpO1xuXG5mdW5jdGlvbiBzdW02NF80X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufTtcbmV4cG9ydHMuc3VtNjRfNF9sbyA9IHN1bTY0XzRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzVfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZWwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGVsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBlaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59O1xuZXhwb3J0cy5zdW02NF81X2hpID0gc3VtNjRfNV9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNV9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbCArIGVsO1xuXG4gIHJldHVybiBsbyA+Pj4gMDtcbn07XG5leHBvcnRzLnN1bTY0XzVfbG8gPSBzdW02NF81X2xvO1xuXG5mdW5jdGlvbiByb3RyNjRfaGkoYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWwgPDwgKDMyIC0gbnVtKSkgfCAoYWggPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufTtcbmV4cG9ydHMucm90cjY0X2hpID0gcm90cjY0X2hpO1xuXG5mdW5jdGlvbiByb3RyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufTtcbmV4cG9ydHMucm90cjY0X2xvID0gcm90cjY0X2xvO1xuXG5mdW5jdGlvbiBzaHI2NF9oaShhaCwgYWwsIG51bSkge1xuICByZXR1cm4gYWggPj4+IG51bTtcbn07XG5leHBvcnRzLnNocjY0X2hpID0gc2hyNjRfaGk7XG5cbmZ1bmN0aW9uIHNocjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn07XG5leHBvcnRzLnNocjY0X2xvID0gc2hyNjRfbG87XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8qKlxuICogSW5qZWN0ZXJcbiAqID09PT09PT09XG4gKlxuICogVGhpcyBpcyBhIGRlcGVuZGVuY3kgaW5qZWN0b3Igc3BlY2lmaWNhbGx5IGRlc2lnbmVkIGZvciB1c2Ugd2l0aCBZb3Vyc1xuICogQml0Y29pbi4gSW4gb3JkZXIgdG8gYWxsb3cgaW5qZWN0aW5nIGRlcGVuZGVuY2llcywgWW91cnMgQml0Y29pbiBjbGFzc2VzXG4gKiBwcm92aWRlIGFuIFwiaW5qZWN0XCIgbWV0aG9kIHRoYXQgbWFrZXMgYSBuZXcgY2xhc3Mgd2l0aCBpbmplY3RlZFxuICogZGVwZW5kZW5jaWVzLiBIb3dldmVyLCB0aGF0IG1ldGhvZCBieSBpdHNlbGYgcHJlc2VudHMgYSBwcm9ibGVtLCBiZWNhdXNlIGl0XG4gKiBjcmVhdGVzIGEgbmV3IGNsYXNzIGV2ZXJ5IHRpbWUgaXQgaXMgdXNlZCwgbGVhdmluZyB0aGUgYnVyZGVuIG9mIGNhY2hpbmcgdGhlXG4gKiBjbGFzc2VzIHRvIHRoZSB1c2VyLiBUaHVzIHRoZSBpbmplY3RvciBhbGxvd3MgdXMgdG8gZWFzaWx5IHdyYXAgYW4gaW5qZWN0XG4gKiBtZXRob2QgdGhhdCBrZWVwcyBhIGNhY2hlIG9mIHRoZSBjcmVhdGVkIGNsYXNzZXMsIGxvd2luZyBtZW1vcnkgYnVyZGVuLCBhbmRcbiAqIGFsbG93aW5nIHRoZSBpbnN0YW5jZW9mIG9wZXJhdG9yIHRvIHdvcmsgY29ycmVjdGx5LlxuICovXG4ndXNlIHN0cmljdCdcbmxldCBjbGFzc21hcHMgPSBuZXcgTWFwKClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmplY3RvciAoaW5qZWN0LCBkZXBlbmRlbmNpZXMpIHtcbiAgaWYgKGNsYXNzbWFwcy5nZXQoaW5qZWN0KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xhc3NtYXBzLnNldChpbmplY3QsIG5ldyBNYXAoKSlcbiAgfVxuXG4gIGxldCBjbGFzc21hcCA9IGNsYXNzbWFwcy5nZXQoaW5qZWN0KVxuICBsZXQgbWVtaW5qZWN0ID0gZnVuY3Rpb24gKGRlcHMpIHtcbiAgICBsZXQgQ2xhc3MgPSBjbGFzc21hcC5nZXQoZGVwcylcbiAgICBpZiAoQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIENsYXNzXG4gICAgfVxuXG4gICAgQ2xhc3MgPSBpbmplY3QoT2JqZWN0LmFzc2lnbih7fSwgZGVwZW5kZW5jaWVzLCBkZXBzKSlcbiAgICBjbGFzc21hcC5zZXQoZGVwcywgQ2xhc3MpXG5cbiAgICAvLyBUaGUgXCJpbmplY3RcIiBhbmQgXCJpbmplY3RlZFwiIHByb3BlcnRpZXMgYXJlIG5vbi1lbnVtZXJhYmxlIHNvIHRoZXkgZG9uJ3RcbiAgICAvLyBydWluIGFueSBjb2RlIHRoYXQgbWF5IGVudW1lcmF0ZSBwcm9wZXJ0aWVzIG9mIHlvdXIgY2xhc3Nlcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MsICdpbmplY3QnLCB7XG4gICAgICB2YWx1ZTogbWVtaW5qZWN0LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcywgJ2luamVjdGVkJywge1xuICAgICAgdmFsdWU6IGRlcHMsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIENsYXNzXG4gIH1cblxuICByZXR1cm4gbWVtaW5qZWN0XG59XG4iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gb2xkQnJvd3NlciAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3NlclxcbnVzZSBjaHJvbWUsIEZpcmVGb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnKVxufVxuXG52YXIgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG9cblxuaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQnl0ZXNcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gb2xkQnJvd3NlclxufVxuXG5mdW5jdGlvbiByYW5kb21CeXRlcyAoc2l6ZSwgY2IpIHtcbiAgLy8gcGhhbnRvbWpzIG5lZWRzIHRvIHRocm93XG4gIGlmIChzaXplID4gNjU1MzYpIHRocm93IG5ldyBFcnJvcigncmVxdWVzdGVkIHRvbyBtYW55IHJhbmRvbSBieXRlcycpXG4gIC8vIGluIGNhc2UgYnJvd3NlcmlmeSAgaXNuJ3QgdXNpbmcgdGhlIFVpbnQ4QXJyYXkgdmVyc2lvblxuICB2YXIgcmF3Qnl0ZXMgPSBuZXcgZ2xvYmFsLlVpbnQ4QXJyYXkoc2l6ZSlcblxuICAvLyBUaGlzIHdpbGwgbm90IHdvcmsgaW4gb2xkZXIgYnJvd3NlcnMuXG4gIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgaWYgKHNpemUgPiAwKSB7ICAvLyBnZXRSYW5kb21WYWx1ZXMgZmFpbHMgb24gSUUgaWYgc2l6ZSA9PSAwXG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYXdCeXRlcylcbiAgfVxuICAvLyBwaGFudG9tanMgZG9lc24ndCBsaWtlIGEgYnVmZmVyIGJlaW5nIHBhc3NlZCBoZXJlXG4gIHZhciBieXRlcyA9IG5ldyBCdWZmZXIocmF3Qnl0ZXMuYnVmZmVyKVxuXG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYihudWxsLCBieXRlcylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG4iXX0=
